<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第四阶段考试</title>
      <link href="/2022/07/11/di-si-jie-duan-kao-shi/"/>
      <url>/2022/07/11/di-si-jie-duan-kao-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="大作业：开发博客系统"><a href="#大作业：开发博客系统" class="headerlink" title="大作业：开发博客系统"></a>大作业：开发博客系统</h2><blockquote><p>请基于你掌握的所有技能，实现 day27  博客系统的所有功能。</p></blockquote><p>根据如下的业务需求设计相应的表结构，内部需涵盖如下功能。</p><ul><li>注册</li><li>登录</li><li>发布博客</li><li>查看博客列表，显示博客标题、创建时间、阅读数量、评论数量、赞数量等。（支持分页查看）</li><li>博客详细，显示博文详细、评论 等。<ul><li>发表评论</li><li>赞 or 踩</li><li>阅读数量 + 1</li></ul></li></ul><p>可参考如下图片来设计相应的表结构。</p><h2 id="一、开发规范"><a href="#一、开发规范" class="headerlink" title="一、开发规范"></a>一、开发规范</h2><pre class="language-none"><code class="language-none">blog├── app.py        文件，程序的主文件（尽量精简）├── config.py     文件，配置文件（放相关配置信息，代码中读取配置信息，如果想要修改配置，即可以在此修改，不用再去代码中逐一修改了）├── src           包，业务处理的代码└── utils         包，公共功能</code></pre><h2 id="二、编写主程序"><a href="#二、编写主程序" class="headerlink" title="二、编写主程序"></a>二、编写主程序</h2><p><code>src -&gt; handler.py</code></p><pre class="language-python" data-language="python"><code class="language-python">class Handler(object):    # 导航列表    NAV &#x3D; []    def login(self):        print(&#39;登录程序&#39;)    def register(self):        print(&#39;注册程序&#39;)    def publish_blog(self):        print(&#39;发布博客程序&#39;)    def blog_list(self):        print(&#39;查看博客列表程序&#39;)    # 主程序    def run(self):        # 导航列表加入首页        Handler.NAV.append(&#39;系统首页&#39;)        # 首页提示信息        mapping &#x3D; &#123;            &#39;1&#39;: &#123;&#39;text&#39;: &#39;登录&#39;, &#39;method&#39;: self.login&#125;,            &#39;2&#39;: &#123;&#39;text&#39;: &#39;注册&#39;, &#39;method&#39;: self.register&#125;,            &#39;3&#39;: &#123;&#39;text&#39;: &#39;发布博客&#39;, &#39;method&#39;: self.publish_blog&#125;,            &#39;4&#39;: &#123;&#39;text&#39;: &#39;查看博客列表&#39;, &#39;method&#39;: self.blog_list&#125;,        &#125;        message &#x3D; &#39;\n&#39;.join([&#39;&#123;&#125;.&#123;&#125;&#39;.format(k, mapping[k][&#39;text&#39;]) for k in mapping])        while True:            print(&#39;&gt;&#39;.join(Handler.NAV).center(50, &#39;*&#39;))  # 打印导航条            print(message)  # 打印首页提示信息            choice &#x3D; input(&#39;请选择序号(Q&#x2F;q退出)： &#39;).strip()            if not choice:  # 输入为空重新输入                print(&#39;输入内容不能为空，请重新输入&#39;)                continue            if choice.upper() &#x3D;&#x3D; &#39;Q&#39;:  # 输入Q&#x2F;q退出                break            text &#x3D; mapping.get(choice)[&#39;text&#39;]            method &#x3D; mapping.get(choice)[&#39;method&#39;]            if not method:  # 序号不存在重新输入                print(&#39;序号不存在，请重新输入&#39;)                continue            Handler.NAV.append(text)            method()handler &#x3D; Handler()handler.run()</code></pre><p><font color="#dd0000"><strong>存在问题：</strong></font></p><ul><li><p>在字典mapping中调用功能和功能名称较为复杂<code>text = mapping.get(choice)[&#39;text&#39;]</code>考虑使用面向对象进行封装<code>context.text</code>简化调用</p></li><li><p>每个maping中的每个功能在执行前都要打印导航条，在退出后要在导航条中删除最后的元素，可以考虑用装饰器实现</p></li></ul><p><code>utils -&gt; context.py</code></p><pre class="language-python" data-language="python"><code class="language-python">class Context(object):    def __init__(self, text, method):        self.text &#x3D; text        self.method &#x3D; method</code></pre><p><code>src -&gt; handler.py</code></p><pre class="language-python" data-language="python"><code class="language-python">from utils.context import Contextclass Handler(object):    # 导航列表    NAV &#x3D; []    def wrapper(self, method):        def inner(*args, **kwargs):            print(&#39;&gt;&#39;.join(Handler.NAV).center(50, &#39;*&#39;))            res &#x3D; method(*args, **kwargs)            Handler.NAV.pop(-1)            return res        return inner    def login(self):        print(&#39;登录程序&#39;)    def register(self):        print(&#39;注册程序&#39;)    def publish_blog(self):        print(&#39;发布博客程序&#39;)    def blog_list(self):        print(&#39;查看博客列表程序&#39;)    # 主程序    def run(self):        # 导航列表加入首页        Handler.NAV.append(&#39;系统首页&#39;)        # 首页提示信息        # mapping &#x3D; &#123;        #     &#39;1&#39;: &#123;&#39;text&#39;: &#39;登录&#39;, &#39;method&#39;: self.login&#125;,        #     &#39;2&#39;: &#123;&#39;text&#39;: &#39;注册&#39;, &#39;method&#39;: self.register&#125;,        #     &#39;3&#39;: &#123;&#39;text&#39;: &#39;发布博客&#39;, &#39;method&#39;: self.publish_blog&#125;,        #     &#39;4&#39;: &#123;&#39;text&#39;: &#39;查看博客列表&#39;, &#39;method&#39;: self.blog_list&#125;,        # &#125;        mapping &#x3D; &#123;            &#39;1&#39;: Context(&#39;登录&#39;, self.wrapper(self.login)),            &#39;2&#39;: Context(&#39;注册&#39;, self.wrapper(self.register)),            &#39;3&#39;: Context(&#39;发布博客&#39;, self.wrapper(self.publish_blog)),            &#39;4&#39;: Context(&#39;查看博客列表&#39;, self.wrapper(self.blog_list)),        &#125;        message &#x3D; &#39;\n&#39;.join([&#39;&#123;&#125;.&#123;&#125;&#39;.format(k, v.text) for k, v in mapping.items()])        while True:            print(&#39;&gt;&#39;.join(Handler.NAV).center(50, &#39;*&#39;))  # 打印导航条            print(message)  # 打印首页提示信息            choice &#x3D; input(&#39;请选择序号(Q&#x2F;q退出)： &#39;).strip()            if not choice:  # 输入为空重新输入                print(&#39;输入内容不能为空，请重新输入&#39;)                continue            if choice.upper() &#x3D;&#x3D; &#39;Q&#39;:  # 输入Q&#x2F;q退出                break            context &#x3D; mapping.get(choice)            if not context:  # 序号不存在重新输入                print(&#39;序号不存在，请重新输入&#39;)                continue            Handler.NAV.append(context.text)            context.method()handler &#x3D; Handler()handler.run()</code></pre><h2 id="三、编写各个功能"><a href="#三、编写各个功能" class="headerlink" title="三、编写各个功能"></a>三、编写各个功能</h2><h3 id="（一）登录功能"><a href="#（一）登录功能" class="headerlink" title="（一）登录功能"></a>（一）登录功能</h3><ul><li><p>在config包的settings模块下完成数据库链接的配置信息</p></li><li><p>在utils包的db模块下编写MySQL工具类：</p><ul><li><p>实例化PooledDB对象，链接数据库</p></li><li><p>支持上下文管理：<code>__enter__</code>,<code>__exit__</code></p></li><li><p><code>exec</code>执行</p></li><li><p><code>fetch_one</code>返回一行结果</p></li><li><p><code>fetch_all</code>返回所有行</p></li></ul></li><li><p>在src包中的account模块下编写账户相关代码：分层将MySQL操作单独编写，思路更清晰</p><ul><li><code>login</code>在数据库中验证用户登录并返回结果</li></ul></li><li><p>在utils包中的context模块下年编写UserDict类：封装实例变量用户ID和昵称，以及属性is_login</p><ul><li><p>self.id：实例变量</p></li><li><p>self.nickname：实例变量</p></li><li><p>self.set_info：通过循环加反射设置实例变量<code>self.id</code>和<code>self.nickname</code></p></li><li><p>self.is_login：实例属性</p></li></ul></li><li><p>在src包中添加handler模块下编写login函数完成登录操作</p></li></ul><p><code>config -&gt; settings.py</code></p><pre class="language-python" data-language="python"><code class="language-python">DB_POOL_CONN &#x3D; &#123;    &quot;maxconnections&quot;: 5,    &quot;mincached&quot;: 2,    &quot;maxcached&quot;: 3,    &quot;blocking&quot;: True,    &quot;setsession&quot;: [],    &quot;ping&quot;: 0,    &quot;host&quot;: &#39;127.0.0.1&#39;,    &quot;port&quot;: 3306,    &quot;user&quot;: &#39;root&#39;,    &quot;password&quot;: &#39;root123&#39;,    &quot;database&quot;: &#39;blog&#39;,    &quot;charset&quot;: &#39;utf8&#39;&#125;</code></pre><p><code>utils -&gt; bd.py</code></p><pre class="language-python" data-language="python"><code class="language-python">import pymysqlfrom dbutils.pooled_db import PooledDBfrom config import settingsPOOL &#x3D; PooledDB(creator&#x3D;pymysql, **settings.DB_POOL_CONN)class Connect(object):    def __init__(self):        conn &#x3D; POOL.connection()        self.conn &#x3D; conn        self.cursor &#x3D; conn.cursor(pymysql.cursors.DictCursor)    def __enter__(self):        return self    def __exit__(self, exc_type, exc_val, exc_tb):        self.cursor.close()        self.conn.close()    def exec(self, sql, *args, **kwargs):        params &#x3D; args or kwargs        # 执行SQL受影响的行数,据此判断exec指令是否成果        row &#x3D; self.cursor.execute(sql, params)        self.conn.commit()        return row    def fetch_one(self, sql, *args, **kwargs):        params &#x3D; args or kwargs        # sql &#x3D; &quot;xxxxx %s %s&quot;        # self.cursor.execute(sql, [1,2])        # sql &#x3D; &quot;xxxxx %(k1)s %(k2)s&quot;        # self.cursor.execute(sql, &#123;&quot;k1&quot;:xxx,&quot;k2&quot;:xxxx&#125;)        self.cursor.execute(sql, params)        result &#x3D; self.cursor.fetchone()        return result    def fetch_all(self, sql, *args, **kwargs):        params &#x3D; args or kwargs        self.cursor.execute(sql, params)        result &#x3D; self.cursor.fetchall()        return result</code></pre><p><code>src -&gt; account.py</code></p><pre class="language-python" data-language="python"><code class="language-python">from utils.db import Connectdef login(username, password):    with Connect() as connect:        sql &#x3D; &quot;select id,nickname from user where username&#x3D;%(username)s and password&#x3D;%(password)s&quot;        result &#x3D; connect.fetch_one(sql, username&#x3D;username, password&#x3D;password)    return result  # &#123;&#39;id&#39;: xxx, &#39;nickname&#39;: xxx&#125;</code></pre><p><code>src -&gt; handler.py</code></p><pre class="language-python" data-language="python"><code class="language-python">class Handler(object):    NAV &#x3D; []  # 导航列表    LOGIN_User_DICT &#x3D; UserDict()  # 记录登录对象    def wrapper(self, method):        def inner(*args, **kwargs):            print(&#39;&gt;&#39;.join(Handler.NAV).center(50, &#39;*&#39;))            res &#x3D; method(*args, **kwargs)            Handler.NAV.pop(-1)            return res        return inner    def login(self):        &quot;&quot;&quot;登录程序&quot;&quot;&quot;        while True:            user &#x3D; input(&#39;请输入用户名(Q&#x2F;q退出)： &#39;).strip()            if user.upper() &#x3D;&#x3D; &#39;Q&#39;:                break            pwd &#x3D; input(&#39;请输入用户密码： &#39;).strip()            user_dict &#x3D; account.login(user, pwd)  # &#123;&#39;id&#39;: xxx, &#39;nickname&#39;: xxx&#125;            if not user_dict:  # 没有用户信息，重新输入                print(&#39;输入用户名或密码错误，请重新输入&#39;)                continue            print(&#39;登录成功&#39;)            Handler.LOGIN_User_DICT.set_info(user_dict)  # 更新登录对象            Handler.NAV.insert(0, Handler.LOGIN_User_DICT.nickname)            return</code></pre><h3 id="（二）注册功能"><a href="#（二）注册功能" class="headerlink" title="（二）注册功能"></a>（二）注册功能</h3><ul><li><p>编写utils包的validator模块，以实现注册时每个注册信息格式正确后注册下一个信息，而不是一个注册信息不正确全部重新注册。</p><ul><li><p><code>email函数</code>传入参数text，根据re.match判断email格式是否正确</p></li><li><p><code>mobile函数</code>传入参数text，根据re.match判断电话号码格式是否正确</p></li><li><p><code>while_input函数</code>一直输入直到输入合法</p></li></ul></li><li><p>在src包的account模块下编写<code>register函数</code>基于MySQL数据库实现用户注册</p></li><li><p>在src包的handler模块下编写登录程序</p><p><code>utils -&gt; validator.py</code></p><pre class="language-python" data-language="python"><code class="language-python">import redef mobile(text):    return re.match(&quot;^1[3-9]\d&#123;9&#125;$&quot;, text)def email(text):    return re.match(&quot;^[a-zA-Z1-9_-]+@[a-zA-Z1-9_-]+\.[a-zA-Z1-9_-]+$&quot;, text)def while_input(text, validator&#x3D;None):    while True:        data &#x3D; input(text).strip()        if not data:  # 输入为空时，重新输入            print(&#39;输入为空，请重新输入&#39;)            continue        # 输入文本不需要校验时直接将输入返回        if not validator:  # while_input(text)            return data        # 输入文本为email或mobile，且输入不合法时        if not validator(data):  # while_input(text, email)            print(&#39;输入格式错误，请重新输入&#39;)            continue        return data</code></pre><p><code>src-&gt; account.py</code></p><pre class="language-python" data-language="python"><code class="language-python">import datetimefrom utils.db import Connectdef login(username, password):    with Connect() as conn:        # sql &#x3D; &quot;select id,nickname from user where username&#x3D;%s and password&#x3D;%s&quot;        # result &#x3D; conn.fetch_one(sql, username, password)        sql &#x3D; &quot;select id,nickname from user where username&#x3D;%(username)s and password&#x3D;%(password)s&quot;        result &#x3D; conn.fetch_one(sql, username&#x3D;username, password&#x3D;password)        return resultdef register(user, pwd, nickname, mobile, email):    with Connect() as conn:        sql &#x3D; &quot;insert into user(username,password,nickname,mobile,email,ctime) values(%s,%s,%s,%s,%s,%s)&quot;        result &#x3D; conn.exec(sql, user, pwd, nickname, mobile, email, datetime.datetime.now())        return result</code></pre><p><code>src -&gt; handler.py</code></p><pre class="language-python" data-language="python"><code class="language-python">from utils.context import Context, UserDictimport accountfrom utils import validatorclass Handler(object):    NAV &#x3D; []  # 导航列表    LOGIN_User_DICT &#x3D; UserDict()  # 记录登录对象    def wrapper(self, method):        def inner(*args, **kwargs):            print(&#39;&gt;&#39;.join(Handler.NAV).center(50, &#39;*&#39;))            res &#x3D; method(*args, **kwargs)            Handler.NAV.pop(-1)            return res        return inner    def login(self):        &quot;&quot;&quot;登录程序&quot;&quot;&quot;        while True:            user &#x3D; input(&#39;请输入用户名(Q&#x2F;q退出)： &#39;).strip()            if user.upper() &#x3D;&#x3D; &#39;Q&#39;:                break            pwd &#x3D; input(&#39;请输入用户密码： &#39;).strip()            user_dict &#x3D; account.login(user, pwd)  # &#123;&#39;id&#39;: xxx, &#39;nickname&#39;: xxx&#125;            if not user_dict:  # 没有用户信息，重新输入                print(&#39;输入用户名或密码错误，请重新输入&#39;)                continue            print(&#39;登录成功&#39;)            Handler.LOGIN_User_DICT.set_info(user_dict)  # 更新登录对象            Handler.NAV.insert(0, Handler.LOGIN_User_DICT.nickname)            return    def register(self):        &quot;&quot;&quot;注册程序&quot;&quot;&quot;        while True:            nickname &#x3D; validator.while_input(&#39;请输入昵称(Q&#x2F;q退出)： &#39;).strip()            if nickname.upper() &#x3D;&#x3D; &quot;Q&quot;:                break            username &#x3D; validator.while_input(&#39;请输入用户名： &#39;).strip()            pwd &#x3D; validator.while_input(&#39;请输入密码： &#39;).strip()            email &#x3D; validator.while_input(&#39;请输入邮箱： &#39;, validator.email).strip()            mobile &#x3D; validator.while_input(&#39;请输入电话号码: &#39;, validator.mobile).strip()            if not account.register(username, nickname, mobile, pwd, email):  # 没有受到影响的行，重新注册                print(&#39;注册失败，请重新注册&#39;)                continue            print(&#39;注册成功&#39;)            return    def publish_blog(self):        print(&#39;发布博客程序&#39;)    def blog_list(self):        print(&#39;查看博客列表程序&#39;)    # 主程序    def run(self):        # 导航列表加入首页        Handler.NAV.append(&#39;系统首页&#39;)        # 首页提示信息        # mapping &#x3D; &#123;        #     &#39;1&#39;: &#123;&#39;text&#39;: &#39;登录&#39;, &#39;method&#39;: self.login&#125;,        #     &#39;2&#39;: &#123;&#39;text&#39;: &#39;注册&#39;, &#39;method&#39;: self.register&#125;,        #     &#39;3&#39;: &#123;&#39;text&#39;: &#39;发布博客&#39;, &#39;method&#39;: self.publish_blog&#125;,        #     &#39;4&#39;: &#123;&#39;text&#39;: &#39;查看博客列表&#39;, &#39;method&#39;: self.blog_list&#125;,        # &#125;        mapping &#x3D; &#123;            &#39;1&#39;: Context(&#39;登录&#39;, self.wrapper(self.login)),            &#39;2&#39;: Context(&#39;注册&#39;, self.wrapper(self.register)),            &#39;3&#39;: Context(&#39;发布博客&#39;, self.wrapper(self.publish_blog)),            &#39;4&#39;: Context(&#39;查看博客列表&#39;, self.wrapper(self.blog_list)),        &#125;        message &#x3D; &#39;\n&#39;.join([&#39;&#123;&#125;.&#123;&#125;&#39;.format(k, v.text) for k, v in mapping.items()])        while True:            print(&#39;&gt;&#39;.join(Handler.NAV).center(50, &#39;*&#39;))  # 打印导航条            print(message)  # 打印首页提示信息            choice &#x3D; input(&#39;请选择序号(Q&#x2F;q退出)： &#39;).strip()            if not choice:  # 输入为空重新输入                print(&#39;输入内容不能为空，请重新输入&#39;)                continue            if choice.upper() &#x3D;&#x3D; &#39;Q&#39;:  # 输入Q&#x2F;q退出                break            context &#x3D; mapping.get(choice)            if not context:  # 序号不存在重新输入                print(&#39;序号不存在，请重新输入&#39;)                continue            Handler.NAV.append(context.text)            context.method()handler &#x3D; Handler()handler.run()</code></pre></li></ul><h3 id="（三）发布博客"><a href="#（三）发布博客" class="headerlink" title="（三）发布博客"></a>（三）发布博客</h3><ul><li><p>编写src包的article模块：传入title，text和user_id实现博客的发布，ctime根据datetime.now()获取</p></li><li><p>在src包下的handler模块中编写publish函数</p><ul><li>判断用户是否登录如果未登录，让用户登录后才能发布</li></ul></li></ul><p><code>src -&gt; article.py</code></p><pre class="language-python" data-language="python"><code class="language-python">from datetime import datetimefrom utils.db import Connectdef publish(title, text, user_id):    try:        with Connect() as connect:            sql &#x3D; &quot;insert into article(title,text,user_id,ctime) values(%s,%s,%s,%s)&quot;            result &#x3D; connect.exec(sql, title, text, user_id, datetime.now())            return result    except Exception as e:  # 异常时没有return 默认返回None        pass</code></pre><p><code>src -&gt; handler.py</code></p><pre class="language-python" data-language="python"><code class="language-python">import timefrom utils.context import Context, UserDictimport account,articlefrom utils import validatorclass Handler(object):    NAV &#x3D; []  # 导航列表    LOGIN_User_DICT &#x3D; UserDict()  # 记录登录对象    def wrapper(self, method):        def inner(*args, **kwargs):            print(&#39;&gt;&#39;.join(Handler.NAV).center(50, &#39;*&#39;))            res &#x3D; method(*args, **kwargs)            Handler.NAV.pop(-1)            return res        return inner    def login(self):        &quot;&quot;&quot;登录程序&quot;&quot;&quot;        while True:            user &#x3D; input(&#39;请输入用户名(Q&#x2F;q退出)： &#39;).strip()            if user.upper() &#x3D;&#x3D; &#39;Q&#39;:                break            pwd &#x3D; input(&#39;请输入用户密码： &#39;).strip()            user_dict &#x3D; account.login(user, pwd)  # &#123;&#39;id&#39;: xxx, &#39;nickname&#39;: xxx&#125;            if not user_dict:  # 没有用户信息，重新输入                print(&#39;输入用户名或密码错误，请重新输入&#39;)                continue            print(&#39;登录成功&#39;)            Handler.LOGIN_User_DICT.set_info(user_dict)  # 更新登录对象            Handler.NAV.insert(0, Handler.LOGIN_User_DICT.nickname)            return    def register(self):        &quot;&quot;&quot;注册程序&quot;&quot;&quot;        while True:            nickname &#x3D; validator.while_input(&#39;请输入昵称(Q&#x2F;q退出)： &#39;).strip()            if nickname.upper() &#x3D;&#x3D; &quot;Q&quot;:                break            username &#x3D; validator.while_input(&#39;请输入用户名： &#39;).strip()            pwd &#x3D; validator.while_input(&#39;请输入密码： &#39;).strip()            email &#x3D; validator.while_input(&#39;请输入邮箱： &#39;, validator.email).strip()            mobile &#x3D; validator.while_input(&#39;请输入电话号码: &#39;, validator.mobile).strip()            if not account.register(username, nickname, mobile, pwd, email):  # 没有受到影响的行，重新注册                print(&#39;注册失败，请重新注册&#39;)                continue            print(&#39;注册成功&#39;)            return    def publish_blog(self):        &quot;&quot;&quot;发布博客程序&quot;&quot;&quot;        # 首先验证是否登录        if not Handler.LOGIN_User_DICT.is_login:            print(&#39;请先登录后在发博客&#39;)            time.sleep(2)  # 间隔两秒后重新发送            return  # 返回空值        # 登录成功后，对title和text合法性进行验证        while True:            title &#x3D; validator.while_input(&#39;请输入文章标题: &#39;).strip()            text &#x3D; validator.while_input(&#39;请输入文章内容： &#39;).strip()            if not article.publish(title, text, Handler.LOGIN_User_DICT.id): # 没有受到影响的行，重新注册                print(&#39;博客发布失败，请重新发布&#39;)                time.sleep(1)  # 间隔一秒后重新发送                continue            print(&#39;博客发布成功&#39;)            return    def blog_list(self):        print(&#39;查看博客列表程序&#39;)    # 主程序    def run(self):        # 导航列表加入首页        Handler.NAV.append(&#39;系统首页&#39;)        # 首页提示信息        # mapping &#x3D; &#123;        #     &#39;1&#39;: &#123;&#39;text&#39;: &#39;登录&#39;, &#39;method&#39;: self.login&#125;,        #     &#39;2&#39;: &#123;&#39;text&#39;: &#39;注册&#39;, &#39;method&#39;: self.register&#125;,        #     &#39;3&#39;: &#123;&#39;text&#39;: &#39;发布博客&#39;, &#39;method&#39;: self.publish_blog&#125;,        #     &#39;4&#39;: &#123;&#39;text&#39;: &#39;查看博客列表&#39;, &#39;method&#39;: self.blog_list&#125;,        # &#125;        mapping &#x3D; &#123;            &#39;1&#39;: Context(&#39;登录&#39;, self.wrapper(self.login)),            &#39;2&#39;: Context(&#39;注册&#39;, self.wrapper(self.register)),            &#39;3&#39;: Context(&#39;发布博客&#39;, self.wrapper(self.publish_blog)),            &#39;4&#39;: Context(&#39;查看博客列表&#39;, self.wrapper(self.blog_list)),        &#125;        message &#x3D; &#39;\n&#39;.join([&#39;&#123;&#125;.&#123;&#125;&#39;.format(k, v.text) for k, v in mapping.items()])        while True:            print(&#39;&gt;&#39;.join(Handler.NAV).center(50, &#39;*&#39;))  # 打印导航条            print(message)  # 打印首页提示信息            choice &#x3D; input(&#39;请选择序号(Q&#x2F;q退出)： &#39;).strip()            if not choice:  # 输入为空重新输入                print(&#39;输入内容不能为空，请重新输入&#39;)                continue            if choice.upper() &#x3D;&#x3D; &#39;Q&#39;:  # 输入Q&#x2F;q退出                break            context &#x3D; mapping.get(choice)            if not context:  # 序号不存在重新输入                print(&#39;序号不存在，请重新输入&#39;)                continue            Handler.NAV.append(context.text)            context.method()handler &#x3D; Handler()handler.run()</code></pre><h3 id="（四）分页、详情、赞踩、评论"><a href="#（四）分页、详情、赞踩、评论" class="headerlink" title="（四）分页、详情、赞踩、评论"></a>（四）分页、详情、赞踩、评论</h3><ul><li><p>首先完成博客列表和分页，在博客列表中支持翻页和查看博客详情</p><ul><li><p>获取博客总数，然后根据博客总数和每页博客数量，确定每页显示的id范围</p><blockquote><p>在src包下的article模块中编写total_count函数，确定limit和offset</p></blockquote></li><li><p>根据limit和offset在MySQL数据库中获取对应id的数据</p><blockquote><p>在src包下的article模块中编写get_article函数，根据用户输入计算limit和offset函数显示博客列表</p></blockquote></li></ul></li><li><p>在博客详情中支持 评论 赞 踩和阅读数加一</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 第四阶段 </tag>
            
            <tag> 考试 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 博客系统开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四阶段重点</title>
      <link href="/2022/07/07/di-si-jie-duan-chong-dian/"/>
      <url>/2022/07/07/di-si-jie-duan-chong-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MySQL入门"><a href="#一、MySQL入门" class="headerlink" title="一、MySQL入门"></a>一、MySQL入门</h2><h3 id="（一）数据库管理"><a href="#（一）数据库管理" class="headerlink" title="（一）数据库管理"></a>（一）数据库管理</h3><ul><li><p>查看所有数据库</p><pre class="language-sql" data-language="sql"><code class="language-sql">show databases;</code></pre></li><li><p>创建数据库</p><pre class="language-sql" data-language="sql"><code class="language-sql">drop database IF EXISTS 数据库名create database 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;-- CHARSET是字符集的意思，使用utf8编码-- COLLATE是校验、核对的意思。指数据库的校验规则,若数据库中有德语、法语或者俄语需求，需使用utf8_unicode_ci，其他情况用utf8_general_ci即可。ci是case insensitive的缩写,意思是大小写不敏感；相对的是cs,即case sensitive,大小写敏感。</code></pre></li><li><p>删除数据库</p><pre class="language-sql" data-language="sql"><code class="language-sql">drop database 数据库名;</code></pre></li><li><p>进入数据库</p><pre class="language-sql" data-language="sql"><code class="language-sql">show databases;</code></pre></li></ul><h3 id="（二）数据表管理"><a href="#（二）数据表管理" class="headerlink" title="（二）数据表管理"></a>（二）数据表管理</h3><ul><li><p>查看数据库下所有表</p><pre class="language-sql" data-language="sql"><code class="language-sql">show  tables；</code></pre></li><li><p>创建表结构</p><pre class="language-sql" data-language="sql"><code class="language-sql">CREATE TABLE &#96;big&#96; (    &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,    &#96;name&#96; varchar(32) DEFAULT NULL,    &#96;email&#96; varchar(64) DEFAULT NULL,    &#96;password&#96; varchar(64) DEFAULT NULL,    &#96;age&#96; int(11) DEFAULT NULL,    PRIMARY KEY (&#96;id&#96;),                       -- 主键索引    UNIQUE KEY &#96;big_unique_email&#96; (&#96;email&#96;),  -- 唯一索引    KEY &#96;ix_name_pwd&#96; (&#96;name&#96;,&#96;password&#96;)     -- 联合索引) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</code></pre></li><li><p>删除表</p><pre class="language-sql" data-language="sql"><code class="language-sql">drop table 表名;</code></pre></li><li><p>清空表</p><pre class="language-sql" data-language="sql"><code class="language-sql">delete from 表名;truncate table 表名;</code></pre></li><li><p>导出数据库的所有表（在命令行运行）</p><pre class="language-sql" data-language="sql"><code class="language-sql"># 结构+数据mysqldump -u root -p 数据库名 &gt; 导出文件绝对路径&#x2F;xxx.sql# 结构mysqldump -u root -p -d 数据库名 &gt; &#x2F;导出文件绝对路径&#x2F;xxx.sql</code></pre></li><li><p>导入数据库的所有表（在命令行运行）</p><pre class="language-sql" data-language="sql"><code class="language-sql">mysql -u root -p  数据库名 &lt; 导出文件绝对路径&#x2F;xxx.sql</code></pre></li><li><p>修改表</p><ul><li><p>增加列</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table 表名 add 列名 类型 not null primary key auto_increment;</code></pre></li><li><p>删除列</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table 表名 drop column 列名;</code></pre></li><li><p>修改列</p><pre class="language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 modify column 列名 类型; -- 修改列类型ALTER TABLE tb CHANGE id id int NOT NULL primary key auto_increment; -- 修改列类型+名称ALTER TABLE 表名 ALTER 列名 SET DEFAULT 1000; -- 修改列默认值ALTER TABLE 表名 add primary key(列名); -- 添加主键ALTER TABLE 表名 drop primary key; -- 删除主键</code></pre></li></ul></li><li><p>查询表各列信息</p><pre class="language-sql" data-language="sql"><code class="language-sql">desc 表名;</code></pre></li><li><p>常见列类型</p><ul><li><p>数字</p><p><code>int[(m)][unsigned][zerofill]</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">int:表示有符号，取值范围：-2147483648 ～ 2147483647int unsigned表示无符号，取值范围：0 ～ 4294967295int(5)zerofill仅用于显示，当不满足5位时，按照左边补0，例如：00002；满足时，正常显示。</code></pre><p><code>tinyint[(m)] [unsigned] [zerofill]</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">有符号，取值范围：-128 ～ 127.无符号，取值范围：0 ～ 255</code></pre><p><code>bigint[(m)][unsigned][zerofill]</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">有符号，取值范围：-9223372036854775808 ～ 9223372036854775807无符号，取值范围：0  ～  18446744073709551615</code></pre><p><code>decimal[(m[,d])] [unsigned] [zerofill]</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。</code></pre><p><code>FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">单精度浮点数，非准确小数值，m是数字总个数，d是小数点后个数。</code></pre><p><code>DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。</code></pre></li><li><p>字符</p><p><code>char(m)</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">定长字符串：m代表字符串的长度，最多可容纳255个字符。定长的体现：即使内容长度小于m，也会占用m长度。</code></pre><p><code>varchar(m)</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">变长字符串，m代表字符串的长度，最多可容纳65535个字节。变长的体现：内容小于m时，会按照真实数据长度存储；如果超出m长度限制（（默认MySQL是严格模式，所以会报错）。</code></pre><p><code>text</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">text数据类型用于保存变长的大字符串，可以组多到65535 (2**16 − 1)个字符。长文本会用text类型。例如：文章、新闻等。</code></pre><p><code>mediumtext</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">maximum length of 16,777,215 (2**24 − 1) characters</code></pre><p><code>longtext</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">maximum length of 4,294,967,295 or 4GB (2**32 − 1)</code></pre></li><li><p>时间</p><p><code>datetime</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59）</code></pre><p><code>timestamp</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">YYYY-MM-DD HH:MM:SS（1970-01-01 00:00:00&#x2F;2037年）对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储，查询时，将其又转化为客户端当前时区进行返回。</code></pre><p><code>date</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">YYYY-MM-DD（1000-01-01&#x2F;9999-12-31）</code></pre><p><code>time</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">HH:MM:SS（&#39;-838:59:59&#39;&#x2F;&#39;838:59:59&#39;）</code></pre></li></ul></li></ul><h3 id="（三）数据行管理"><a href="#（三）数据行管理" class="headerlink" title="（三）数据行管理"></a>（三）数据行管理</h3><ul><li><p>新增数据行</p><pre class="language-sql" data-language="sql"><code class="language-sql">insert into 表名 values(NULL,对应列的值,default); -- 对于自增列和有默认值的列传入NULL和defaultinsert into tb1(name,password) values(&#39;武沛齐&#39;,&#39;123123&#39;),(&#39;alex&#39;,&#39;123&#39;); -- 同时新增多列</code></pre></li><li><p>删除数据行</p><pre class="language-sql" data-language="sql"><code class="language-sql">delete from 表名 where 条件;</code></pre></li><li><p>修改数据行</p><pre class="language-sql" data-language="sql"><code class="language-sql">update 表名 set 列名&#x3D;值 where 条件;</code></pre></li><li><p>查询数据行</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from 表名;select 列名,列名 as 别名,别名 from 表名;</code></pre></li></ul><h2 id="二、SQL必备表关系各授权"><a href="#二、SQL必备表关系各授权" class="headerlink" title="二、SQL必备表关系各授权"></a>二、SQL必备表关系各授权</h2><h3 id="一-SQL必备"><a href="#一-SQL必备" class="headerlink" title="(一)SQL必备"></a>(一)SQL必备</h3><ul><li><p>条件：根据条件搜索结果</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info where age &gt; 30;select * from info where id !&#x3D; 1;select * from info where (name &#x3D; &#39;李杰&#39; or email&#x3D;&quot;pyyu@live.com&quot;)  and age&#x3D;49;select * from info where id not in (1,4,6);select * from info where id in (select id from depart);select * from info where exists (select * from depart where id&#x3D;5);select * from (select * from info where id&gt;2) as T where age &gt; 10;</code></pre></li><li><p>通配符：一般用于模糊搜索</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info where name like &quot;%沛%&quot;; -- 匹配任意字符select * from info where email like &quot;__peiqi_live.co_&quot;;-- 匹配一个字符-- 注意：数量少可以使用通配符，数据量大的搜索一般不使用，搜索效率很低</code></pre></li><li><p>映射：想要获取的列</p><pre class="language-sql" data-language="sql"><code class="language-sql">select         id,        name,        case depart_id when 1 then &quot;第1部门&quot; end v1,        case depart_id when 1 then &quot;第1部门&quot; else &quot;其他&quot; end v2,        case depart_id when 1 then &quot;第1部门&quot; when 2 then &quot;第2部门&quot; else &quot;其他&quot; end v3,        case when age&lt;18 then &quot;少年&quot; end v4,        case when age&lt;18 then &quot;少年&quot; else &quot;油腻男&quot; end v5,        case when age&lt;18 then &quot;少年&quot; when age&lt;30 then &quot;青年&quot; else &quot;油腻男&quot; end v6from info;</code></pre></li><li><p>排序</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info order by age desc; -- 倒序select * from info order by age asc;  -- 顺序select * from info order by age asc,id desc; -- 优先按照age从小到大；如果age相同则按照id从大到小。</code></pre></li><li><p>取部分</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info limit 5; -- 获取前5条数据select * from info limit 3 offset 2; -- 从位置2开始，向后获取前3数据</code></pre></li><li><p>分组</p><pre class="language-sql" data-language="sql"><code class="language-sql">select depart_id,count(id) from info group by depart_id;select depart_id,count(id) from info group by depart_id having count(id) &gt; 2;select --聚合条件放在having后面</code></pre></li><li><p>左右连表</p><pre class="language-sql" data-language="sql"><code class="language-sql">主表 left join 从表 on 主表.x &#x3D; 从表.id select info.id,info.name,info.email,depart.title from info right outer join depart on info.depart_id &#x3D; depart.id;info主表，就以info数据为主，depart为辅。（推荐使用）</code></pre></li><li><p>联合</p><pre class="language-sql" data-language="sql"><code class="language-sql">select id,title from depart unionselect id,name from info; -- 列数需相同-- 自动去重union all  -- 保留所有union all  -- 保留所有</code></pre></li><li><p>SQL执行顺序</p><pre class="language-sql" data-language="sql"><code class="language-sql">join on -- 先连表where -- 再筛选 group by -- 再分组having -- 再筛选聚合条件order by -- 再排序limit -- 最后取部分</code></pre></li></ul><h3 id="二-表关系"><a href="#二-表关系" class="headerlink" title="(二)表关系"></a>(二)表关系</h3><ul><li><p>单表</p><pre class="language-sql" data-language="sql"><code class="language-sql">单独一张表就可以将信息保存</code></pre></li><li><p>一对多</p><pre class="language-sql" data-language="sql"><code class="language-sql">需要两张表来存储信息，且两张表存在 一对多 或 多对一关系</code></pre></li><li><p>多对多</p><pre class="language-sql" data-language="sql"><code class="language-sql">需要三张表来存储信息，两张单表 + 关系表，创造出两个单表之间多对多关系。</code></pre></li><li><p>外键约束</p><pre class="language-sql" data-language="sql"><code class="language-sql">开发中往往还会为他们添加一个 外键约束，保证某一个列的值必须是其他表中的特定列已存在的值constraint 外键名(fk_info_depart) foreign key (depart_id) references depart(id); -- 创建表时创建外键alter table 表名 add constraint 外键名(fk_info_depart) foreign key info(depart_id) references depart(id);  -- 表已创建添加外键alter table 表名 drop foreign key 外键名(fk_info_depart); -- 删除外键</code></pre></li></ul><h2 id="三、索引、函数和存储过程"><a href="#三、索引、函数和存储过程" class="headerlink" title="三、索引、函数和存储过程"></a>三、索引、函数和存储过程</h2><h3 id="（一）索引"><a href="#（一）索引" class="headerlink" title="（一）索引"></a>（一）索引</h3><p>如果有了索引结构的查询效率比表中逐行查询的速度要快很多且数据量越大越明显。但，数据增删改的速度会变慢。</p><ul><li><p>索引原理（B+Tree）</p><ul><li>非聚簇索引（mysiam引擎）：数据 和 索引结构 分开存储</li><li>聚簇索引（innodb引擎）：数据 和 主键索引结构存储在一起企业开发中一般都会使用 innodb 引擎（内部支持事务、行级锁、外键等特点），在MySQL5.5版本之后默认引擎也是innodb。</li></ul></li><li><p>常见索引</p><ul><li><p>主键索引：加速查找、不能为空、不能重复。 + 联合主键索引</p><pre class="language-sql" data-language="sql"><code class="language-sql">create table 表名(    id int not null auto_increment,    name varchar(32) not null,    primary key (列1,列2)          -- 如果有多列，称为联合主键（不常用且myisam引擎支持）);  -- 创建数据表时创建主键索引alter table 表名 add primary key (列名); -- 表已创建插入主键索引alter table 表名 add primary key (列名); -- 删除主键索引</code></pre></li><li><p>唯一索引：加速查找、不能重复。  + 联合唯一索引</p><pre class="language-sql" data-language="sql"><code class="language-sql">create table 表名(    id int not null auto_increment,    name varchar(32) not null,    unique index (列1,列2)          -- 如果有多列，称为联合唯一（不常用且myisam引擎支持）);  -- 创建数据表时创建唯一索引alter table 表名 add unique index (列名); -- 表已创建插入唯一索引alter table 表名 add unique index (列名); -- 删除唯一索引</code></pre></li><li><p>普通索引：加速查找。 + 联合索引</p><pre class="language-sql" data-language="sql"><code class="language-sql">create table 表名(    id int not null auto_increment,    name varchar(32) not null,    index (列1,列2)          -- 如果有多列，称为联合普通索引（不常用且myisam引擎支持）);  -- 创建数据表时创建普通索引alter table 表名 add unique index (列名); -- 表已创建插入普通索引alter table 表名 add unique index (列名); -- 删除普通索引</code></pre></li></ul></li><li><p>操作表：在表中创建索引后，查询时一定要命中索引。</p><ul><li><p>优点：查找速度快、约束（唯一、主键、联合唯一）</p></li><li><p>缺点：插入、删除、更新速度比较慢，因为每次操作都需要调整整个B+Tree的数据结构关系。</p></li><li><p>无法命中索引的情况</p><pre class="language-sql" data-language="sql"><code class="language-sql">类型不一致（表中name为varchar查询时输入int，无法命中索引）select * from big where name &#x3D; 123;-- 未命中select * from big where email &#x3D; 123;-- 未命中 特殊的主键：select * from big where id &#x3D; &quot;123&quot;;-- 命中使用不等于select * from big where name !&#x3D; &quot;武沛齐&quot;;-- 未命中select * from big where email !&#x3D; &quot;wupeiqi@live.com&quot;;  -- 未命中特殊的主键：select * from big where id !&#x3D; 123;-- 命中or，当or条件中有未建立索引的列才失效。select * from big where id &#x3D; 123 or password&#x3D;&quot;xx&quot;;-- 未命中select * from big where name &#x3D; &quot;wupeiqi&quot; or password&#x3D;&quot;xx&quot;;-- 未命中特别的：select * from big where id &#x3D; 10 or password&#x3D;&quot;xx&quot; and name&#x3D;&quot;xx&quot;; -- 命中排序，当根据索引排序时候，选择的映射如果不是索引，则不走索引。select * from big order by name asc;     -- 未命中select * from big order by name desc;    -- 未命中select name from big order by name desc;    -- 命中特别的主键：通配符在最后select * from big order by id desc;  -- 命中like，模糊匹配时。select * from big where name like &quot;%u-12-19999&quot;;-- 未命中select * from big where name like &quot;_u-12-19999&quot;;-- 未命中select * from big where name like &quot;wu-%-10&quot;;-- 未命中特别的：select * from big where name like &quot;wu-1111-%&quot;;-- 命中select * from big where name like &quot;wuw-%&quot;;-- 命中使用函数select * from big where reverse(name) &#x3D; &quot;wupeiqi&quot;;  -- 未命中特别的：select * from big where name &#x3D; reverse(&quot;wupeiqi&quot;);  -- 命中最左前缀，如果是联合索引，要遵循最左前缀原则。如果联合索引为：(name,password)name and password       -- 命中name                 -- 命中password                -- 未命中name or password       -- 未命中</code></pre></li></ul></li><li><p>执行计划:<code>explain + SQL语句</code>能够预判SQL的执行（只能给到一定的参考，不一定完全能预判准确）。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SQL性能指标type;性能从高到低SYSTEM，系统，表仅有一行(&#x3D;系统表)。这是const联接类型的一个特例。CONST，常量，表最多有一个匹配行,因为仅有一行,在这行的列值可被优化器剩余部分认为是常数,const表很快。EQ_REF，连表操作时常见。REF，根据 索引 直接去查找（非键）。INDEX_MERGE，合并索引，使用多个单列索引搜索RANGE，对索引列进行范围查找INDEX，全索引扫描，对索引从头到尾找一遍ALL，全表扫描，数据表从头到尾找一遍。(一般未命中索引，都是会执行权标扫描)</code></pre></li></ul><h2 id="四、Python操作"><a href="#四、Python操作" class="headerlink" title="四、Python操作"></a>四、Python操作</h2><h3 id="（一）事务：innodb引擎中支持事务，myisam不支持"><a href="#（一）事务：innodb引擎中支持事务，myisam不支持" class="headerlink" title="（一）事务：innodb引擎中支持事务，myisam不支持"></a>（一）事务：innodb引擎中支持事务，myisam不支持</h3><p>事务的四大特性（ACID）：</p><ul><li>原子性（Atomicity）：是指事务包含的所有操作不可分割，要么全部成功，要么全部失败回滚。</li><li>一致性（Consistency）：执行的前后数据的完整性保持一致。</li><li>独立性（Isolation）：一个事务执行的过程中,不应该受到其他事务的干扰。</li><li>持久性（Durability）：事务一旦结束,数据就持久到数据库。</li></ul><h3 id="（二）锁"><a href="#（二）锁" class="headerlink" title="（二）锁"></a>（二）锁</h3><p>帮助我们实现开发过程中遇到的同时处理数据的情况。</p><ul><li>表级锁：即A操作表时，其他人对整个表都不能操作，等待A操作完之后，才能继续。</li><li>行级锁：即A操作表时，其他人对指定的行数据不能操作，其他行可以操作，等待A操作完之后，才能继续。</li><li>InnoDB引擎支持行锁和表锁；MYISAM支持表锁，不支持行锁。<ul><li>在innodb引擎中，update、insert、delete的行为内部都会先申请锁（排它锁），申请到之后才执行相关操作，最后再释放锁。</li><li>在innodb引擎中，select则默认不会申请锁。想要让select去申请锁，则需要配合 事务 + 特殊语法来实现。</li><li>for update，排它锁，加锁之后，其他不可以读写。</li><li>lock in share mode ，共享锁，加锁之后，其他可读但不可写。</li></ul></li></ul><h3 id="（三）MySQL工具类"><a href="#（三）MySQL工具类" class="headerlink" title="（三）MySQL工具类"></a>（三）MySQL工具类</h3><ul><li><p>单例</p><pre class="language-python" data-language="python"><code class="language-python"># db.pyimport pymysqlfrom dbutils.pooled_db import PooledDBclass DBHelper(object):    def __init__(self):        # TODO 此处配置，可以去配置文件中读取。        self.pool &#x3D; PooledDB(            creator&#x3D;pymysql,  # 使用链接数据库的模块            maxconnections&#x3D;5,  # 连接池允许的最大连接数，0和None表示不限制连接数            mincached&#x3D;2,  # 初始化时，链接池中至少创建的空闲的链接，0表示不创建            maxcached&#x3D;3,  # 链接池中最多闲置的链接，0和None不限制            blocking&#x3D;True,  # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错            setsession&#x3D;[],  # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]            ping&#x3D;0,            # ping MySQL服务端，检查是否服务可用。# 如：0 &#x3D; None &#x3D; never, 1 &#x3D; default &#x3D; whenever it is requested, 2 &#x3D; when a cursor is created, 4 &#x3D; when a query is executed, 7 &#x3D; always            host&#x3D;&#39;127.0.0.1&#39;,            port&#x3D;3306,            user&#x3D;&#39;root&#39;,            password&#x3D;&#39;root123&#39;,            database&#x3D;&#39;userdb&#39;,            charset&#x3D;&#39;utf8&#39;        )    def get_conn_cursor(self):        conn &#x3D; self.pool.connection()        cursor &#x3D; conn.cursor(pymysql.cursors.DictCursor)        return conn, cursor    def close_conn_cursor(self, *args):        for item in args:            item.close()    def exec(self, sql, **kwargs):        conn, cursor &#x3D; self.get_conn_cursor()        cursor.execute(sql, kwargs)        conn.commit()        self.close_conn_cursor(conn, cursor)    def fetch_one(self, sql, **kwargs):        conn, cursor &#x3D; self.get_conn_cursor()        cursor.execute(sql, kwargs)        result &#x3D; cursor.fetchone()        self.close_conn_cursor(conn, cursor)        return result    def fetch_all(self, sql, **kwargs):        conn, cursor &#x3D; self.get_conn_cursor()        cursor.execute(sql, kwargs)        result &#x3D; cursor.fetchall()        self.close_conn_cursor(conn, cursor)        return resultdb &#x3D; DBHelper()</code></pre><pre class="language-python" data-language="python"><code class="language-python">from db import dbdb.exec(&quot;insert into d1(name) values(%(name)s)&quot;, name&#x3D;&quot;武沛齐666&quot;)ret &#x3D; db.fetch_one(&quot;select * from d1&quot;)print(ret)ret &#x3D; db.fetch_one(&quot;select * from d1 where id&#x3D;%(nid)s&quot;, nid&#x3D;3)print(ret)ret &#x3D; db.fetch_all(&quot;select * from d1&quot;)print(ret)ret &#x3D; db.fetch_all(&quot;select * from d1 where id&gt;%(nid)s&quot;, nid&#x3D;2)print(ret)</code></pre></li><li><p>上下文管理：如果你想要让他也支持 with 上下文管理。</p><pre class="language-python" data-language="python"><code class="language-python">with 获取连接：执行SQL（执行完毕后，自动将连接交还给连接池）</code></pre><pre class="language-python" data-language="python"><code class="language-python"># db_context.pyimport threadingimport pymysqlfrom dbutils.pooled_db import PooledDBPOOL &#x3D; PooledDB(    creator&#x3D;pymysql,  # 使用链接数据库的模块    maxconnections&#x3D;5,  # 连接池允许的最大连接数，0和None表示不限制连接数    mincached&#x3D;2,  # 初始化时，链接池中至少创建的空闲的链接，0表示不创建    maxcached&#x3D;3,  # 链接池中最多闲置的链接，0和None不限制    blocking&#x3D;True,  # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错    setsession&#x3D;[],  # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]    ping&#x3D;0,    host&#x3D;&#39;127.0.0.1&#39;,    port&#x3D;3306,    user&#x3D;&#39;root&#39;,    password&#x3D;&#39;root123&#39;,    database&#x3D;&#39;userdb&#39;,    charset&#x3D;&#39;utf8&#39;)class Connect(object):    def __init__(self):        self.conn &#x3D; conn &#x3D; POOL.connection()        self.cursor &#x3D; conn.cursor(pymysql.cursors.DictCursor)    def __enter__(self):        return self    def __exit__(self, exc_type, exc_val, exc_tb):        self.cursor.close()        self.conn.close()    def exec(self, sql, **kwargs):        self.cursor.execute(sql, kwargs)        self.conn.commit()    def fetch_one(self, sql, **kwargs):        self.cursor.execute(sql, kwargs)        result &#x3D; self.cursor.fetchone()        return result    def fetch_all(self, sql, **kwargs):        self.cursor.execute(sql, kwargs)        result &#x3D; self.cursor.fetchall()        return result</code></pre><pre class="language-python" data-language="python"><code class="language-python">from db_context import Connectwith Connect() as obj:    # print(obj.conn)    # print(obj.cursor)    ret &#x3D; obj.fetch_one(&quot;select * from d1&quot;)    print(ret)    ret &#x3D; obj.fetch_one(&quot;select * from d1 where id&#x3D;%(id)s&quot;, id&#x3D;3)    print(ret)</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 第四阶段 </tag>
            
            <tag> 总结 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python第四模块day2</title>
      <link href="/2022/06/30/python-di-si-mo-kuai-day2/"/>
      <url>/2022/06/30/python-di-si-mo-kuai-day2/</url>
      
        <content type="html"><![CDATA[<h2 id="二十八、索引和函数及存储过程"><a href="#二十八、索引和函数及存储过程" class="headerlink" title="二十八、索引和函数及存储过程"></a>二十八、索引和函数及存储过程</h2><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210531123330918.png" class="" title="image-20210531123330918"><p>课程目标：了解MySQL中索引、函数、存储过程、函数、触发器、视图等知识点。</p><p>课程概要：</p><ul><li>索引</li><li>函数</li><li>存储过程</li><li>视图</li><li>触发器</li></ul><h3 id="1-索引"><a href="#1-索引" class="headerlink" title="1. 索引"></a>1. 索引</h3><p>在数据库中索引最核心的作用是：<strong>加速查找</strong>。  例如：在含有300w条数据的表中查询，无索引需要700秒，而利用索引可能仅需1秒。</p><pre class="language-none"><code class="language-none">mysql&gt; select * from big where password&#x3D;&quot;81f98021-6927-433a-8f0d-0f5ac274f96e&quot;;+----+---------+---------------+--------------------------------------+------+| id | name    | email         | password                             | age  |+----+---------+---------------+--------------------------------------+------+| 11 | wu-13-1 | w-13-1@qq.com | 81f98021-6927-433a-8f0d-0f5ac274f96e |    9 |+----+---------+---------------+--------------------------------------+------+1 row in set (0.70 sec)mysql&gt; select * from big where id&#x3D;11;+----+---------+---------------+--------------------------------------+------+| id | name    | email         | password                             | age  |+----+---------+---------------+--------------------------------------+------+| 11 | wu-13-1 | w-13-1@qq.com | 81f98021-6927-433a-8f0d-0f5ac274f96e |    9 |+----+---------+---------------+--------------------------------------+------+1 row in set (0.00 sec)mysql&gt; select * from big where name&#x3D;&quot;wu-13-1&quot;;+----+---------+---------------+--------------------------------------+------+| id | name    | email         | password                             | age  |+----+---------+---------------+--------------------------------------+------+| 11 | wu-13-1 | w-13-1@qq.com | 81f98021-6927-433a-8f0d-0f5ac274f96e |    9 |+----+---------+---------------+--------------------------------------+------+1 row in set (0.00 sec)</code></pre><p>在开发过程中会为哪些 经常会被搜索的列 创建索引，以提高程序的响应速度。例如：查询手机号、邮箱、用户名等。</p><h4 id="1-1-索引原理"><a href="#1-1-索引原理" class="headerlink" title="1.1 索引原理"></a>1.1 索引原理</h4><p>为什么加上索引之后速度能有这么大的提升呢？ 因为索引的底层是基于B+Tree的数据结构存储的。</p><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526160040895-16565736485922.png" class="" title="image-20210526160040895"><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526155746811-16565736485933.png" class="" title="image-20210526155746811"><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526160519425-16565736485934.png" class="" title="image-20210526160519425"><p>很明显，如果有了索引结构的查询效率比表中逐行<font color="#dd0000"><strong>查询的速度要快很</strong></font>多且数据量越大越明显。但，<font color="#dd0000"><strong>数据增删改的速度会变慢。</strong></font></p><p>B+Tree结构连接：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p><p>数据库的索引是基于上述B+Tree的数据结构实现，但在创建数据库表时，如果指定不同的引擎，底层使用的B+Tree结构的原理有些不同。</p><ul><li><p>myisam引擎，非聚簇索引（数据 和 索引结构 分开存储）</p></li><li><p>innodb引擎，聚簇索引（数据 和 主键索引结构存储在一起）</p></li></ul><h5 id="1-1-1-非聚簇索引（mysiam引擎）"><a href="#1-1-1-非聚簇索引（mysiam引擎）" class="headerlink" title="1.1.1 非聚簇索引（mysiam引擎）"></a>1.1.1 非聚簇索引（mysiam引擎）</h5><pre class="language-sql" data-language="sql"><code class="language-sql">create table 表名(    id int not null auto_increment primary key,     name varchar(32) not null,    age int)engine&#x3D;myisam default charset&#x3D;utf8;</code></pre><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526160040895-16565736485922.png" class="" title="image-20210526160040895"><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526155746811-16565736485933.png" class="" title="image-20210526155746811"><p>![image-20210526155118552](E:&#x2F;python路飞学城&#x2F;模块4&#x2F;day28 索引和函数及存储过程&#x2F;assets&#x2F;image-20210526155118552.png)</p><h5 id="1-1-2-聚簇索引（innodb引擎）"><a href="#1-1-2-聚簇索引（innodb引擎）" class="headerlink" title="1.1.2 聚簇索引（innodb引擎）"></a>1.1.2 聚簇索引（innodb引擎）</h5><pre class="language-sql" data-language="sql"><code class="language-sql">create table 表名(    id int not null auto_increment primary key,     name varchar(32) not null,    age int)engine&#x3D;innodb default charset&#x3D;utf8;</code></pre><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526160040895-16565736485922.png" class="" title="image-20210526160040895"><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526155746811-16565736485933.png" class="" title="image-20210526155746811"><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526160519425-16565736485934.png" class="" title="image-20210526160519425"><p>![image-20210526155250801](E:&#x2F;python路飞学城&#x2F;模块4&#x2F;day28 索引和函数及存储过程&#x2F;assets&#x2F;image-20210526155250801.png)</p><p>在MySQL文件存储中的体现：</p><pre class="language-none"><code class="language-none">root@192 userdb # pwd&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;userdbroot@192 userdb # ls -ltotal 1412928-rw-r-----  1 _mysql  _mysql       8684 May 15 22:51 big.frm，表结构。-rw-r-----  1 _mysql  _mysql  717225984 May 15 22:51 big.ibd，数据和索引结构。-rw-r-----  1 _mysql  _mysql       8588 May 16 11:38 goods.frm-rw-r-----  1 _mysql  _mysql      98304 May 16 11:39 goods.ibd-rw-r-----  1 _mysql  _mysql       8586 May 26 10:57 t2.frm，表结构-rw-r-----  1 _mysql  _mysql          0 May 26 10:57 t2.MYD，数据-rw-r-----  1 _mysql  _mysql       1024 May 26 10:57 t2.MYI，索引结构</code></pre><p>上述 聚簇索引 和 非聚簇索引 底层均利用了B+Tree结构结构，只不过内部数据存储有些不同罢了。</p><p>在企业开发中一般都会使用 innodb 引擎（内部支持事务、行级锁、外键等特点），在MySQL5.5版本之后默认引擎也是innodb。</p><pre class="language-sql" data-language="sql"><code class="language-sql">mysql&gt; show create table users \G;*************************** 1. row ***************************       Table: usersCreate Table: CREATE TABLE &#96;users&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;name&#96; varchar(32) DEFAULT NULL,  &#96;password&#96; varchar(64) DEFAULT NULL,  &#96;ctime&#96; datetime DEFAULT NULL,  &#96;age&#96; int(11) DEFAULT &#39;5&#39;,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;11 DEFAULT CHARSET&#x3D;utf81 row in set (0.00 sec)ERROR:No query specifiedmysql&gt; show index from users \G;*************************** 1. row ***************************        Table: users   Non_unique: 0     Key_name: PRIMARY Seq_in_index: 1  Column_name: id    Collation: A  Cardinality: 3     Sub_part: NULL       Packed: NULL         Null:   Index_type: BTREE   -- 虽然显示BTree，但底层数据结构基于B+Tree。      Comment:Index_comment:1 row in set (0.00 sec)ERROR:No query specifiedmysql&gt;</code></pre><p>innodb引擎，一般创建的索引：聚簇索引。</p><h4 id="1-2-常见索引"><a href="#1-2-常见索引" class="headerlink" title="1.2 常见索引"></a>1.2 常见索引</h4><p>在innodb引擎下，索引底层都是基于B+Tree数据结构存储（聚簇索引）。</p><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526170708409-16565736485937.png" class="" title="image-20210526170708409"><p>在开发过程中常见的索引类型有：</p><ul><li>主键索引：加速查找、不能为空、不能重复。 + 联合主键索引</li><li>唯一索引：加速查找、不能重复。  + 联合唯一索引</li><li>普通索引：加速查找。 + 联合索引</li></ul><h5 id="1-2-1-主键和联合主键索引"><a href="#1-2-1-主键和联合主键索引" class="headerlink" title="1.2.1 主键和联合主键索引"></a>1.2.1 主键和联合主键索引</h5><ul><li>创建表时加入主键索引</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">create table 表名(    id int not null auto_increment primary key,   -- 主键    name varchar(32) not null);create table 表名(    id int not null auto_increment,    name varchar(32) not null,    primary key(id));create table 表名(    id int not null auto_increment,    name varchar(32) not null,    primary key(列1,列2)          -- 如果有多列，称为联合主键（不常用且myisam引擎支持）);</code></pre><ul><li>表已经创建插入主键索引</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">alter table 表名 add primary key(列名);</code></pre><ul><li>删除主键索引</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">alter table 表名 drop primary key;</code></pre><p>注意：删除索引时可能会报错，自增列必须定义为键。</p><pre class="language-sql" data-language="sql"><code class="language-sql">ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a keyalter table 表 change id id int not null; -- 修改表的列去掉自增属性</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create table t7(    id int not null,    name varchar(32) not null,    primary key(id));alter table t6 drop primary key;</code></pre><h5 id="1-2-2-唯一和联合唯一索引"><a href="#1-2-2-唯一和联合唯一索引" class="headerlink" title="1.2.2 唯一和联合唯一索引"></a>1.2.2 唯一和联合唯一索引</h5><ul><li>创建表时加入唯一索引</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">create table 表名(    id int not null auto_increment primary key,    name varchar(32) not null,    email varchar(64) not null,    unique ix_name (name),  -- 唯一索引    unique ix_email (email), -- 唯一索引);create table 表名(    id int not null auto_increment,    name varchar(32) not null,    unique (列1,列2)               -- 如果有多列，称为联合唯一索引（两列加起来不能重复）。);</code></pre><ul><li>表已创建增加唯一索引</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">create unique index 索引名 on 表名(列名);</code></pre><ul><li>删除唯一索引</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">drop unique index 索引名 on 表名;</code></pre><h5 id="1-2-3-索引和联合索引"><a href="#1-2-3-索引和联合索引" class="headerlink" title="1.2.3 索引和联合索引"></a>1.2.3 索引和联合索引</h5><ul><li>创建表时加入普通索引</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">create table 表名(    id int not null auto_increment primary key,    name varchar(32) not null,    email varchar(64) not null,    index ix_email (email),    index ix_name (name),);create table 表名(    id int not null auto_increment primary key,    name varchar(32) not null,    email varchar(64) not null,    index ix_email (name,email)     -- 如果有多列，称为联合索引。);</code></pre><ul><li>表已创建插入普通索引</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">create index 索引名 on 表名(列名);</code></pre><ul><li>删除普通索引</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">drop index 索引名 on 表名;</code></pre><p>在项目开发的设计表结构的环节，大家需要根据业务需求的特点来决定是否创建相应的索引。</p><h5 id="案例：博客系统"><a href="#案例：博客系统" class="headerlink" title="案例：博客系统"></a>案例：博客系统</h5><p>![image-20210531164453161](E:&#x2F;python路飞学城&#x2F;模块4&#x2F;day28 索引和函数及存储过程&#x2F;assets&#x2F;image-20210531164453161.png)</p><ul><li>每张表id列都创建 自增 + 主键。</li><li>用户表<ul><li>用户名 + 密码 创建联合普通索引。</li><li>手机号，创建唯一索引。</li><li>邮箱，创建唯一索引。</li></ul></li><li>推荐表<ul><li>user_id和article_id创建联合唯一索引。</li></ul></li></ul><h4 id="1-3-操作表"><a href="#1-3-操作表" class="headerlink" title="1.3 操作表"></a>1.3 操作表</h4><p>在表中创建索引后，<font color="#dd0000"><strong>查询时一定要命中索引。</strong></font></p><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526170700985-16565736485939.png" class="" title="image-20210526170700985"><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526155746811-16565736485933.png" class="" title="image-20210526155746811"><p>在数据库的表中创建索引之后优缺点如下：</p><ul><li>优点：查找速度快、约束（唯一、主键、联合唯一）</li><li>缺点：插入、删除、更新速度比较慢，因为每次操作都需要调整整个B+Tree的数据结构关系。</li></ul><p>所以，在表中不要无节制的去创建索引啊。。。</p><p>在开发中，我们会对表中经常被搜索的列创建索引，从而提高程序的响应速度。</p><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526170718219-165657364859310.png" class="" title="image-20210526170718219"><pre class="language-sql" data-language="sql"><code class="language-sql">CREATE TABLE &#96;big&#96; (    &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,    &#96;name&#96; varchar(32) DEFAULT NULL,    &#96;email&#96; varchar(64) DEFAULT NULL,    &#96;password&#96; varchar(64) DEFAULT NULL,    &#96;age&#96; int(11) DEFAULT NULL,    PRIMARY KEY (&#96;id&#96;),                       -- 主键索引    UNIQUE KEY &#96;big_unique_email&#96; (&#96;email&#96;),  -- 唯一索引    KEY &#96;ix_name_pwd&#96; (&#96;name&#96;,&#96;password&#96;)     -- 联合索引) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</code></pre><p>一般情况下，我们针对只要通过索引列去搜搜都可以 <code>命中</code> 索引（通过索引结构加速查找）。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from big where id &#x3D; 5;select * from big where id &gt; 5;select * from big where email &#x3D; &quot;wupeiqi@live.com&quot;;select * from big where name &#x3D; &quot;武沛齐&quot;;select * from big where name &#x3D; &quot;kelly&quot; and password&#x3D;&quot;ffsijfs&quot;;...</code></pre><p><font color="#dd0000"><strong>但是，还是会有一些特殊的情况，让我们无法命中索引（即使创建了索引），这也是需要大家在开发中要注意的。【翻看笔记】：未命中索引的情况</strong></font></p><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210526170718219-165657364859310.png" class="" title="image-20210526170718219"><ul><li><p>类型不一致（表中name为varchar查询时输入int，无法命中索引）</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from big where name &#x3D; 123;-- 未命中select * from big where email &#x3D; 123;-- 未命中特殊的主键：select * from big where id &#x3D; &quot;123&quot;;-- 命中</code></pre></li><li><p>使用不等于</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from big where name !&#x3D; &quot;武沛齐&quot;;-- 未命中select * from big where email !&#x3D; &quot;wupeiqi@live.com&quot;;  -- 未命中特殊的主键：select * from big where id !&#x3D; 123;-- 命中</code></pre></li><li><p>or，当or条件中有未建立索引的列才失效。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from big where id &#x3D; 123 or password&#x3D;&quot;xx&quot;;-- 未命中select * from big where name &#x3D; &quot;wupeiqi&quot; or password&#x3D;&quot;xx&quot;;-- 未命中特别的：select * from big where id &#x3D; 10 or password&#x3D;&quot;xx&quot; and name&#x3D;&quot;xx&quot;; -- 命中</code></pre></li><li><p>排序，当根据索引排序时候，选择的映射如果不是索引，则不走索引。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from big order by name asc;     -- 未命中select * from big order by name desc;    -- 未命中select name from big order by name desc;    -- 命中特别的主键：通配符在最后select * from big order by id desc;  -- 命中</code></pre></li><li><p>like，模糊匹配时。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from big where name like &quot;%u-12-19999&quot;;-- 未命中select * from big where name like &quot;_u-12-19999&quot;;-- 未命中select * from big where name like &quot;wu-%-10&quot;;-- 未命中特别的：select * from big where name like &quot;wu-1111-%&quot;;-- 命中select * from big where name like &quot;wuw-%&quot;;-- 命中</code></pre></li><li><p>使用函数</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from big where reverse(name) &#x3D; &quot;wupeiqi&quot;;  -- 未命中特别的：select * from big where name &#x3D; reverse(&quot;wupeiqi&quot;);  -- 命中</code></pre></li><li><p>最左前缀，如果是联合索引，要遵循最左前缀原则。</p><pre class="language-sql" data-language="sql"><code class="language-sql">如果联合索引为：(name,password)    name and password       -- 命中    name                 -- 命中    password                -- 未命中    name or password       -- 未命中</code></pre></li></ul><p>常见的无法命中索引的情况就是上述的示例。</p><p>对于大家来说会现在的最大的问题是，记不住，哪怎么办呢？接下来看执行计划。</p><h4 id="1-4-执行计划"><a href="#1-4-执行计划" class="headerlink" title="1.4 执行计划"></a>1.4 执行计划</h4><p>MySQL中提供了执行计划，让你能够预判SQL的执行（只能给到一定的参考，不一定完全能预判准确）。</p><pre class="language-none"><code class="language-none">explain + SQL语句;</code></pre><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210527074105599-165657364859311.png" class="" title="image-20210527074105599"><p>其中比较重要的是 type，他他SQL性能比较重要的标志，性能从低到高依次：<code>all &lt; index &lt; range &lt; index_merge &lt; ref_or_null &lt; ref &lt; eq_ref &lt; system/const</code> </p><ul><li><p>ALL，全表扫描，数据表从头到尾找一遍。(一般未命中索引，都是会执行权标扫描)</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from big;特别的：如果有limit，则找到之后就不在继续向下扫描.select * from big limit 1;</code></pre></li><li><p>INDEX，全索引扫描，对索引从头到尾找一遍</p><pre class="language-sql" data-language="sql"><code class="language-sql">explain select id from big;explain select name from big;</code></pre></li><li><p>RANGE，对索引列进行范围查找</p><pre class="language-sql" data-language="sql"><code class="language-sql">explain select * from big where id &gt; 10;explain select * from big where id in (11,22,33);explain select * from big where id between 10 and 20;explain select * from big where name &gt; &quot;wupeiqi&quot; ;</code></pre></li><li><p>INDEX_MERGE，合并索引，使用多个单列索引搜索</p><pre class="language-sql" data-language="sql"><code class="language-sql">explain select * from big where id &#x3D; 10 or name&#x3D;&quot;武沛齐&quot;;</code></pre></li><li><p>REF，根据 索引 直接去查找（非键）。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select *  from big where name &#x3D; &#39;武沛齐&#39;;</code></pre></li><li><p>EQ_REF，连表操作时常见。</p><pre class="language-sql" data-language="sql"><code class="language-sql">explain select big.name,users.id from big left join users on big.age &#x3D; users.id;</code></pre></li><li><p>CONST，常量，表最多有一个匹配行,因为仅有一行,在这行的列值可被优化器剩余部分认为是常数,const表很快。</p><pre class="language-sql" data-language="sql"><code class="language-sql">explain select * from big where id&#x3D;11;-- 主键explain select * from big where email&#x3D;&quot;w-11-0@qq.com&quot;;-- 唯一索引</code></pre></li><li><p>SYSTEM，系统，表仅有一行(&#x3D;系统表)。这是const联接类型的一个特例。</p><pre class="language-sql" data-language="sql"><code class="language-sql">explain select * from (select * from big where id&#x3D;1 limit 1) as A;</code></pre></li></ul><p>其他列：</p><pre class="language-none"><code class="language-none">id，查询顺序标识z，查询类型    SIMPLE          简单查询    PRIMARY         最外层查询    SUBQUERY        映射为子查询    DERIVED         子查询    UNION           联合    UNION RESULT    使用联合的结果    ...    table，正在访问的表名partitions，涉及的分区（MySQL支持将数据划分到不同的idb文件中，详单与数据的拆分）。 一个特别大的文件拆分成多个小文件（分区）。possible_keys，查询涉及到的字段上若存在索引，则该索引将被列出，即：可能使用的索引。key，显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。例如：有索引但未命中，则possible_keys显示、key则显示NULL。key_len，表示索引字段的最大可能长度。(类型字节长度 + 变长2 + 可空1)，例如：key_len&#x3D;195，类型varchar(64)，195&#x3D;64*3+2+1ref，连表时显示的关联信息。例如：A和B连表，显示连表的字段信息。rows，估计读取的数据行数（只是预估值）explain select * from big where password &#x3D;&quot;025dfdeb-d803-425d-9834-445758885d1c&quot;;explain select * from big where password &#x3D;&quot;025dfdeb-d803-425d-9834-445758885d1c&quot; limit 1;filtered，返回结果的行占需要读到的行的百分比。explain select * from big where id&#x3D;1;  -- 100，只读了一个1行，返回结果也是1行。explain select * from big where password&#x3D;&quot;27d8ba90-edd0-4a2f-9aaf-99c9d607c3b3&quot;;  -- 10，读取了10行，返回了1行。注意：密码27d8ba90-edd0-4a2f-9aaf-99c9d607c3b3在第10行extra，该列包含MySQL解决查询的详细信息。    “Using index”    此值表示mysql将使用覆盖索引，以避免访问表。不要把覆盖索引和index访问类型弄混了。    “Using where”    这意味着mysql服务器将在存储引擎检索行后再进行过滤，许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where子句的查询都会显示“Using where”。有时“Using where”的出现就是一个暗示：查询可受益于不同的索引。    “Using temporary”    这意味着mysql在对查询结果排序时会使用一个临时表。    “Using filesort”    这意味着mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。mysql有两种文件排序算法，这两种排序方式都可以在内存或者磁盘上完成，explain不会告诉你mysql将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。    “Range checked for each record(index map: N)”    这个意味着没有好用的索引，新的索引将在联接的每一行上重新估算，N是显示在possible_keys列中索引的位图，并且是冗余的。</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上述索引相关的内容讲的比较多，大家在开发过程中重点应该掌握的是：</p><ul><li>根据情况创建合适的索引（加速查找）。</li><li>有索引，则查询时要命中索引。</li></ul><h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h3><p>MySQL中提供了很多函数，为我们的SQL操作提供便利，例如：</p><pre class="language-none"><code class="language-none">mysql&gt; select * from d1;+----+-----------+| id | name      |+----+-----------+|  1 | 武沛齐    ||  3 | xxx       ||  4 | pyyu      |+----+-----------+3 rows in set (0.00 sec)mysql&gt; select count(id), max(id),min(id),avg(id) from d1;+-----------+---------+---------+---------+| count(id) | max(id) | min(id) | avg(id) |+-----------+---------+---------+---------+|         3 |       4 |       1 |  2.6667 |+-----------+---------+---------+---------+1 row in set (0.00 sec)mysql&gt;mysql&gt;mysql&gt; select id,reverse(name) from d1;+----+---------------+| id | reverse(name) |+----+---------------+|  1 | 齐沛武        ||  3 | xxx           ||  4 | uyyp          |+----+---------------+3 rows in set (0.00 sec)mysql&gt; select id, reverse(name),concat(name,name), NOW(), DATE_FORMAT( NOW(),&#39;%Y-%m-%d %H:%i:%s&#39;)  from d1;+----+---------------+--------------------+---------------------+-----------------------------------------+| id | reverse(name) | concat(name,name)  | NOW()               | DATE_FORMAT( NOW(),&#39;%Y-%m-%d %H:%i:%s&#39;) |+----+---------------+--------------------+---------------------+-----------------------------------------+|  1 | 齐沛武        | 武沛齐武沛齐       | 2021-05-27 09:18:07 | 2021-05-27 09:18:07                     ||  3 | xxx           | xxxxxx             | 2021-05-27 09:18:07 | 2021-05-27 09:18:07                     ||  4 | uyyp          | pyyupyyu           | 2021-05-27 09:18:07 | 2021-05-27 09:18:07                     |+----+---------------+--------------------+---------------------+-----------------------------------------+3 rows in set (0.00 sec)mysql&gt; select concat(&quot;alex&quot;,&quot;sb&quot;);+---------------------+| concat(&quot;alex&quot;,&quot;sb&quot;) |+---------------------+| alexsb              |+---------------------+1 row in set (0.00 sec)mysql&gt; select sleep(1);+----------+| sleep(1) |+----------+|        0 |+----------+1 row in set (1.00 sec)</code></pre><p>部分函数列表：</p><pre class="language-none"><code class="language-none">CHAR_LENGTH(str)    返回值为字符串str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。    对于一个包含五个二字节字符集, LENGTH()返回值为 10, 而CHAR_LENGTH()的返回值为5。CONCAT(str1,str2,...)    字符串拼接    如有任何一个参数为NULL ，则返回值为 NULL。CONCAT_WS(separator,str1,str2,...)    字符串拼接（自定义连接符）    CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。CONV(N,from_base,to_base)    进制转换    例如：        SELECT CONV(&#39;a&#39;,16,2); 表示将 a 由16进制转换为2进制字符串表示FORMAT(X,D)    将数字X 的格式写为&#39;#,###,###.##&#39;,以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若  D 为 0, 则返回结果不带有小数点，或不含小数部分。    例如：        SELECT FORMAT(12332.1,4); 结果为： &#39;12,332.1000&#39;INSERT(str,pos,len,newstr)    在str的指定位置插入字符串        pos：要替换位置其实位置        len：替换的长度        newstr：新字符串    特别的：        如果pos超过原字符串长度，则返回原字符串        如果len超过原字符串长度，则由新字符串完全替换INSTR(str,substr)    返回字符串 str 中子字符串的第一个出现位置。LEFT(str,len)    返回字符串str 从开始的len位置的子序列字符。LOWER(str)    变小写UPPER(str)    变大写LTRIM(str)    返回字符串 str ，其引导空格字符被删除。RTRIM(str)    返回字符串 str ，结尾空格字符被删去。SUBSTRING(str,pos,len)    获取字符串子序列LOCATE(substr,str,pos)    获取子序列索引位置REPEAT(str,count)    返回一个由重复的字符串str 组成的字符串，字符串str的数目等于count 。    若 count &lt;&#x3D; 0,则返回一个空字符串。    若str 或 count 为 NULL，则返回 NULL 。REPLACE(str,from_str,to_str)    返回字符串str 以及所有被字符串to_str替代的字符串from_str 。REVERSE(str)    返回字符串 str ，顺序和字符顺序相反。RIGHT(str,len)    从字符串str 开始，返回从后边开始len个字符组成的子序列SPACE(N)    返回一个由N空格组成的字符串。SUBSTRING(str,pos) , SUBSTRING(str FROM pos) SUBSTRING(str,pos,len) , SUBSTRING(str FROM pos FOR len)    不带有len 参数的格式从字符串str返回一个子字符串，起始于位置 pos。带有len参数的格式从字符串str返回一个长度同len字符相同的子字符串，起始于位置 pos。 使用 FROM的格式为标准 SQL 语法。也可能对pos使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。    mysql&gt; SELECT SUBSTRING(&#39;Quadratically&#39;,5);        -&gt; &#39;ratically&#39;    mysql&gt; SELECT SUBSTRING(&#39;foobarbar&#39; FROM 4);        -&gt; &#39;barbar&#39;    mysql&gt; SELECT SUBSTRING(&#39;Quadratically&#39;,5,6);        -&gt; &#39;ratica&#39;    mysql&gt; SELECT SUBSTRING(&#39;Sakila&#39;, -3);        -&gt; &#39;ila&#39;    mysql&gt; SELECT SUBSTRING(&#39;Sakila&#39;, -5, 3);        -&gt; &#39;aki&#39;    mysql&gt; SELECT SUBSTRING(&#39;Sakila&#39; FROM -4 FOR 2);        -&gt; &#39;ki&#39;TRIM([&#123;BOTH | LEADING | TRAILING&#125; [remstr] FROM] str) TRIM(remstr FROM] str)    返回字符串 str ， 其中所有remstr 前缀和&#x2F;或后缀都已被删除。若分类符BOTH、LEADIN或TRAILING中没有一个是给定的,则假设为BOTH 。 remstr 为可选项，在未指定情况下，可删除空格。    mysql&gt; SELECT TRIM(&#39;  bar   &#39;);            -&gt; &#39;bar&#39;    mysql&gt; SELECT TRIM(LEADING &#39;x&#39; FROM &#39;xxxbarxxx&#39;);            -&gt; &#39;barxxx&#39;    mysql&gt; SELECT TRIM(BOTH &#39;x&#39; FROM &#39;xxxbarxxx&#39;);            -&gt; &#39;bar&#39;    mysql&gt; SELECT TRIM(TRAILING &#39;xyz&#39; FROM &#39;barxxyz&#39;);            -&gt; &#39;barx&#39;   </code></pre><p>更多函数：<a href="https://dev.mysql.com/doc/refman/5.7/en/functions.html">https://dev.mysql.com/doc/refman/5.7/en/functions.html</a></p><p>当然，MySQL中也支持让你去自定义函数。</p><ul><li><p>创建函数</p><pre class="language-sql" data-language="sql"><code class="language-sql">delimiter $$create function f1(    i1 int,    i2 int)returns intBEGIN    declare num int;    declare maxId int;    select max(id) from big into maxId;        set num &#x3D; i1 + i2 + maxId;    return(num);END $$delimiter ;</code></pre></li><li><p>执行函数</p><pre class="language-sql" data-language="sql"><code class="language-sql">select f1(11,22);select f1(11,id),name from d1;</code></pre></li><li><p>删除函数</p><pre class="language-sql" data-language="sql"><code class="language-sql">drop function f1;</code></pre></li></ul><h3 id="3-存储过程"><a href="#3-存储过程" class="headerlink" title="3. 存储过程"></a>3. 存储过程</h3><p>存储过程，是一个存储在MySQL中的SQL语句集合，当主动去调用存储过程时，其中内部的SQL语句会按照逻辑执行。</p><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210531174813902-165657364859312.png" class=""><ul><li><p>创建存储过程</p><pre class="language-sql" data-language="sql"><code class="language-sql">delimiter $$create procedure p1()BEGIN    select * from d1;END $$delimiter ;</code></pre></li><li><p>执行存储过程</p><pre class="language-sql" data-language="sql"><code class="language-sql">call p1();</code></pre><pre class="language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import pymysqlconn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, db&#x3D;&#39;userdb&#39;)cursor &#x3D; conn.cursor(cursor&#x3D;pymysql.cursors.DictCursor)# 执行存储过程cursor.callproc(&#39;p1&#39;)result &#x3D; cursor.fetchall()cursor.close()conn.close()print(result)</code></pre></li><li><p>删除存储过程</p><pre class="language-sql" data-language="sql"><code class="language-sql">drop procedure proc_name;</code></pre></li></ul><h4 id="3-1-参数类型"><a href="#3-1-参数类型" class="headerlink" title="3.1 参数类型"></a>3.1 参数类型</h4><p>存储过程的参数可以有如下三种：</p><ul><li>in，仅用于传入参数用</li><li>x from db_context import Connect​with Connect() as obj:    # print(obj.conn)    # print(obj.cursor)    ret &#x3D; obj.fetch_one(“select * from d1”)    print(ret)​    ret &#x3D; obj.fetch_one(“select * from d1 where id&#x3D;%(id)s”, id&#x3D;3)    print(ret)python</li><li>inout，既可以传入又可以当作返回值</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">delimiter $$create procedure p2(    in i1 int,    in i2 int,    inout i3 int,    out r1 int)BEGIN    DECLARE temp1 int;    DECLARE temp2 int default 0;        set temp1 &#x3D; 1;    set r1 &#x3D; i1 + i2 + temp1 + temp2;        set i3 &#x3D; i3 + 100;end $$delimiter ;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">set @t1 &#x3D;4;set @t2 &#x3D; 0;CALL p2 (1, 2 ,@t1, @t2);SELECT @t1,@t2;</code></pre><pre class="language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import pymysqlconn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, db&#x3D;&#39;userdb&#39;)cursor &#x3D; conn.cursor(cursor&#x3D;pymysql.cursors.DictCursor)# 执行存储过程cursor.callproc(&#39;p2&#39;,args&#x3D;(1, 22, 3, 4))# 获取执行完存储的参数cursor.execute(&quot;select @_p2_0,@_p2_1,@_p2_2,@_p2_3&quot;)result &#x3D; cursor.fetchall()# &#123;&quot;@_p2_0&quot;:1, &quot;@_p2_1&quot;:22,&quot;@_p2_2&quot;:103,&quot;@_p2_3&quot;:23,&#125;cursor.close()conn.close()print(result)</code></pre><h4 id="3-2-返回值-amp-结果集"><a href="#3-2-返回值-amp-结果集" class="headerlink" title="3.2 返回值 &amp; 结果集"></a>3.2 返回值 &amp; 结果集</h4><pre class="language-sql" data-language="sql"><code class="language-sql">delimiter $$create procedure p3(    in n1 int,    inout n2 int,    out n3 int)begin    set n2 &#x3D; n1 + 100;    set n3 &#x3D; n2 + n1 + 100;    select * from d1;end $$delimiter ;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">set @t1 &#x3D;4;set @t2 &#x3D; 0;CALL p3 (1,@t1, @t2);SELECT @t1,@t2;</code></pre><pre class="language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import pymysqlconn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, db&#x3D;&#39;userdb&#39;)cursor &#x3D; conn.cursor(cursor&#x3D;pymysql.cursors.DictCursor)# 执行存储过程cursor.callproc(&#39;p3&#39;,args&#x3D;(22, 3, 4))table &#x3D; cursor.fetchall() # 得到执行存储过中的结果集# 获取执行完存储的参数cursor.execute(&quot;select @_p3_0,@_p3_1,@_p3_2&quot;)rets &#x3D; cursor.fetchall()cursor.close()conn.close()print(table)print(rets)</code></pre><h4 id="3-3-事务-amp-异常"><a href="#3-3-事务-amp-异常" class="headerlink" title="3.3 事务 &amp; 异常"></a>3.3 事务 &amp; 异常</h4><p>事务，成功都成功，失败都失败。</p><pre class="language-sql" data-language="sql"><code class="language-sql">delimiter $$create PROCEDURE p4(    OUT p_return_code tinyint)BEGIN   DECLARE exit handler for sqlexception   BEGIN     -- ERROR     set p_return_code &#x3D; 1;     rollback;   END;    DECLARE exit handler for sqlwarning   BEGIN     -- WARNING     set p_return_code &#x3D; 2;     rollback;   END;    START TRANSACTION;  -- 开启事务    delete from d1;    insert into tb(name)values(&#39;seven&#39;);  COMMIT;  -- 提交事务   -- SUCCESS   set p_return_code &#x3D; 0;    END $$delimiter ; </code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">set @ret &#x3D;100;CALL p4(@ret);SELECT @ret;</code></pre><pre class="language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import pymysqlconn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, db&#x3D;&#39;userdb&#39;)cursor &#x3D; conn.cursor(cursor&#x3D;pymysql.cursors.DictCursor)# 执行存储过程cursor.callproc(&#39;p4&#39;,args&#x3D;(100))# 获取执行完存储的参数cursor.execute(&quot;select @_p4_0&quot;)rets &#x3D; cursor.fetchall()cursor.close()conn.close()print(table)print(rets)</code></pre><h4 id="3-4-游标"><a href="#3-4-游标" class="headerlink" title="3.4 游标"></a>3.4 游标</h4><pre class="language-sql" data-language="sql"><code class="language-sql">delimiter $$create procedure p5()begin     declare sid int;    declare sname varchar(50);     declare done int default false;    declare my_cursor CURSOR FOR select id,name from d1;        DECLARE CONTINUE HANDLER FOR NOT FOUND SET done &#x3D; TRUE;        open my_cursor;        xxoo: LOOP            fetch my_cursor into sid,sname;            IF done then                 leave xxoo;            END IF;            insert into t1(name) values(sname);        end loop xxoo;    close my_cursor;end $$delimiter ; </code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">call p5();</code></pre><h3 id="4-视图"><a href="#4-视图" class="headerlink" title="4.视图"></a>4.视图</h3><p>视图其实是一个虚拟表（非真实存在），其本质是<font color="#dd0000"><strong>【根据SQL语句获取动态的数据集，并为其命名】</strong></font>，用户使用时只需使用【名称】即可获取结果集，并可以将其当作表来使用。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECT    *FROM    (SELECT nid,name FROM tb1 WHERE nid &gt; 2) AS AWHERE    A.name &gt; &#39;alex&#39;;</code></pre><ul><li><p>创建视图</p><pre class="language-sql" data-language="sql"><code class="language-sql">create view v1 as select id,name from d1 where id &gt; 1;</code></pre></li><li><p>使用视图</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from v1;-- select * from (select id,name from d1 where id &gt; 1) as v1;</code></pre></li><li><p>删除视图</p><pre class="language-sql" data-language="sql"><code class="language-sql">drop view v1;</code></pre></li><li><p>修改视图</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter view v1 as SQL语句</code></pre></li></ul><p>注意：基于视图只能查询，针对视图不能执行 增加、修改、删除。 如果源表发生变化，视图表也会发生变化。</p><h3 id="5-触发器"><a href="#5-触发器" class="headerlink" title="5.触发器"></a>5.触发器</h3><p>![](E:&#x2F;python路飞学城&#x2F;模块4&#x2F;day28 索引和函数及存储过程&#x2F;assets&#x2F;image-20210531181738177.png)</p><p>对某个表进行【增&#x2F;删&#x2F;改】操作的前后如果希望触发某个特定的行为时，可以使用触发器。</p><pre class="language-sql" data-language="sql"><code class="language-sql"># 插入前CREATE TRIGGER tri_before_insert_tb1 BEFORE INSERT ON tb1 FOR EACH ROWBEGIN    ...END# 插入后CREATE TRIGGER tri_after_insert_tb1 AFTER INSERT ON tb1 FOR EACH ROWBEGIN    ...END# 删除前CREATE TRIGGER tri_before_delete_tb1 BEFORE DELETE ON tb1 FOR EACH ROWBEGIN    ...END# 删除后CREATE TRIGGER tri_after_delete_tb1 AFTER DELETE ON tb1 FOR EACH ROWBEGIN    ...END# 更新前CREATE TRIGGER tri_before_update_tb1 BEFORE UPDATE ON tb1 FOR EACH ROWBEGIN    ...END# 更新后CREATE TRIGGER tri_after_update_tb1 AFTER UPDATE ON tb1 FOR EACH ROWBEGIN    ...END</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">DROP TRIGGER tri_after_insert_tb1;</code></pre><p>示例：</p><ul><li><p>在 t1 表中插入数据之前，先在 t2 表中插入一行数据。</p><pre class="language-sql" data-language="sql"><code class="language-sql">delimiter $$CREATE TRIGGER tri_before_insert_t1 BEFORE INSERT ON t1 FOR EACH ROWBEGIN-- NEW.id  NEW.name  NEW.email-- INSERT INTO t2 (name) VALUES();IF NEW.name &#x3D; &#39;alex&#39; THEN        INSERT INTO t2 (name) VALUES(NEW.id);    END IF;END $$delimiter ;</code></pre><pre class="language-none"><code class="language-none">insert into t1(id,name,email)values(1,&quot;alex&quot;,&quot;xxx@qq.com&quot;)</code></pre></li><li><p>在t1表中删除数据之后，再在t2表中插入一行数据。</p><pre class="language-sql" data-language="sql"><code class="language-sql">delimiter $$CREATE TRIGGER tri_after_insert_t1 AFTER DELETE ON t1 FOR EACH ROWBEGINIF OLD.name &#x3D; &#39;alex&#39; THEN    INSERT INTO t2 (name) VALUES(OLD.id);END IF;END $$delimiter ;</code></pre></li></ul><p>特别的：NEW表示新数据，OLD表示原来的数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于Python开发人员，其实在开发过程中触发器、视图、存储过程用的很少（以前搞C#经常写存储过程），最常用的其实就是正确的使用索引以及常见的函数。</p><ul><li>索引，加速查找 &amp; 约束。<ul><li>innodb和myisam的区别，聚簇索引 和 非聚簇索引。</li><li>常见的索引：主键、唯一、普通。</li><li>命中索引</li><li>执行计划</li></ul></li><li>函数，提供了一些常见操作 &amp; 配合SQL语句，执行后返回结果。</li><li>存储过程，一个SQL语句的集合，可以出发复杂的情况，最终可以返回结果 + 数据集。</li><li>视图，一个虚拟的表。</li><li>触发器，在表中数据行执行前后自定义一些操作。</li></ul><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol><li><p>根据你掌握的索引知识重新设计 day27  博客系统的表结构，让查询数据库的速度可以变得更快。</p><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210531164453161-165658068792114.png" class="" title="image-20210531164453161"><ul><li><p>创建数据库day28</p><pre class="language-sql" data-language="sql"><code class="language-sql">drop database IF EXISTS day28; -- 要是数据库day28已存在先删除create database day28 default charset utf8 collate utf8_general_ci;use day28;</code></pre></li><li><p>创建数据表</p><ul><li>为所有表的id列创建主索引</li><li>为user表的用户名（username）和密码(password)创建联合普通索引</li><li>为user表的电话号码(mobil)和邮箱(email)创建唯一索引</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">CREATE TABLE &#96;user&#96;(&#96;id&#96; int NOT NULL AUTO_INCREMENT,    &#96;username&#96; varchar(16) NOT NULL,    &#96;nickname&#96; varchar(16) NOT NULL,&#96;mobile&#96; char(11) NOT NULL,    &#96;password&#96; varchar(64) NOT NULL,    &#96;email&#96; varchar(64) NOT NULL,    &#96;ctime&#96; datetime NOT NULL,    PRIMARY KEY (&#96;id&#96;),                               -- 主键索引    UNIQUE KEY &#96;big_unique_email&#96; (&#96;email&#96;),          -- 唯一索引    UNIQUE KEY &#96;big_unique_mobile&#96; (&#96;mobile&#96;),        -- 唯一索引    KEY &#96;ix_username_pwd&#96; (&#96;username&#96;,&#96;password&#96;)     -- 联合索引)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;CREATE TABLE &#96;article&#96;(&#96;id&#96; int NOT NULL AUTO_INCREMENT,    &#96;title&#96; varchar(255) NOT NULL,    &#96;text&#96; text NOT NULL,&#96;read_count&#96; int DEFAULT 0,&#96;comment_count&#96; int DEFAULT 0,&#96;up_count&#96; int DEFAULT 0,&#96;down_count&#96; int DEFAULT 0,    &#96;user_id&#96; int NOT NULL,    &#96;ctime&#96; datetime NOT NULL,    PRIMARY KEY (&#96;id&#96;),                           -- 主键索引    UNIQUE KEY &#96;big_unique_user_id&#96; (&#96;user_id&#96;),  -- 唯一索引    constraint fk_article_user foreign key (user_id) references user(id))default charset&#x3D;utf8;CREATE TABLE &#96;comment&#96;(    &#96;id&#96; int NOT NULL AUTO_INCREMENT,    &#96;content&#96; varchar(255) NOT NULL,    &#96;user_id&#96; int NOT NULL,&#96;article_id&#96; int NOT NULL,    &#96;ctime&#96; datetime NOT NULL,    PRIMARY KEY (&#96;id&#96;),   -- 主键索引    constraint fk_comment_user foreign key (user_id) references user(id),    constraint fk_comment_article foreign key (article_id) references article(id))default charset&#x3D;utf8;CREATE TABLE &#96;up_down&#96;(    &#96;id&#96; int NOT NULL AUTO_INCREMENT,    &#96;choice&#96; tinyint NOT NULL,    &#96;user_id&#96; int NOT NULL,&#96;article_id&#96; int NOT NULL,    &#96;ctime&#96; datetime NOT NULL,    PRIMARY KEY (&#96;id&#96;),                           -- 主键索引    constraint fk_up_down_user foreign key (user_id) references user(id),    constraint fk_up_down_article foreign key (article_id) references article(id))default charset&#x3D;utf8;</code></pre></li></ul></li><li><p>了解 函数、存储过程、触发器、视图。</p><ul><li><p>函数，提供了一些常见操作 &amp; 配合SQL语句，执行后返回结果。</p></li><li><p>存储过程，一个SQL语句的集合，可以触发复杂的情况，最终可以返回结果 + 数据集。</p></li><li><p>视图，一个虚拟的表。</p></li><li><p>触发器，在表中数据行执行前后自定义一些操作。</p></li></ul></li></ol><h2 id="二十九、Python操作MySQL和实战"><a href="#二十九、Python操作MySQL和实战" class="headerlink" title="二十九、Python操作MySQL和实战"></a>二十九、Python操作MySQL和实战</h2><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210531185255250.png" class="" title="image-20210531185255250"><p>课程目标：掌握事务和锁以及Python操作MySQL的各种开发必备知识。</p><p>课程概要：</p><ul><li>事务</li><li>锁</li><li>数据库连接池</li><li>SQL工具类</li><li>其他</li></ul><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h3><p><font color="#dd0000"><strong>innodb引擎中支持事务，myisam不支持。</strong></font></p><pre class="language-sql" data-language="sql"><code class="language-sql">CREATE TABLE &#96;users&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,  &#96;name&#96; varchar(32) DEFAULT NULL,  &#96;amount&#96; int(11) DEFAULT NULL) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</code></pre><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210527145549634.png" class="" title="image-20210527145549634"><p>例如：李杰 给 武沛齐 转账 100，那就会涉及2个步骤。</p><ul><li>李杰账户 减100</li><li>武沛齐账户 加 100</li></ul><p>这两个步骤必须同时完成才算完成，并且如果第一个完成、第二步失败，还是回滚到初始状态。</p><p>事务，就是来解决这种情况的。  大白话：要成功都成功；要失败都失败。</p><p>事务的具有四大特性（ACID）：</p><ul><li><p><font color="#dd0000"><strong>原子性（Atomicity）</strong></font></p><pre class="language-none"><code class="language-none">原子性是指事务包含的所有操作不可分割，要么全部成功，要么全部失败回滚。</code></pre></li><li><p><font color="#dd0000"><strong>一致性（Consistency）</strong></font></p><pre class="language-none"><code class="language-none">执行的前后数据的完整性保持一致。</code></pre></li><li><p><font color="#dd0000"><strong>隔离性（Isolation）</strong></font></p><pre class="language-none"><code class="language-none">一个事务执行的过程中,不应该受到其他事务的干扰。</code></pre></li><li><p><font color="#dd0000"><strong>持久性（Durability）</strong></font></p><pre class="language-none"><code class="language-none">事务一旦结束,数据就持久到数据库</code></pre></li></ul><h4 id="1-1-MySQL客户端"><a href="#1-1-MySQL客户端" class="headerlink" title="1.1 MySQL客户端"></a>1.1 MySQL客户端</h4><pre class="language-sql" data-language="sql"><code class="language-sql">mysql&gt; select * from users;+----+---------+---------+| id | name    | amount  |+----+---------+---------+|  1 | wupeiqi |    5    ||  2 |  alex   |    6    |+----+---------+---------+3 rows in set (0.00 sec)mysql&gt; begin;  -- 开启事务 start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; update users set amount&#x3D;amount-2 where id&#x3D;1;   -- 执行操作Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; update users set amount&#x3D;amount+2 where id&#x3D;2;   -- 执行操作Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; commit;  -- 提交事务  rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from users;+----+---------+---------+| id | name    | amount  |+----+---------+---------+|  1 | wupeiqi |    3    ||  2 |  ale x  |    8    |+----+---------+---------+3 rows in set (0.00 sec)</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">mysql&gt; select * from users;+----+---------+---------+| id | name    | amount  |+----+---------+---------+|  1 | wupeiqi |    3    ||  2 |  ale x  |    8    |+----+---------+---------+3 rows in set (0.00 sec)mysql&gt; begin; -- 开启事务Query OK, 0 rows affected (0.00 sec)mysql&gt; update users set amount&#x3D;amount-2 where id&#x3D;1; -- 执行操作（此时数据库中的值已修改）Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; rollback; -- 事务回滚（回到原来的状态）Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from users;+----+---------+---------+| id | name    | amount  |+----+---------+---------+|  1 | wupeiqi |    3    ||  2 |  ale x  |    8    |+----+---------+---------+3 rows in set (0.00 sec)</code></pre><h4 id="1-2-Python代码"><a href="#1-2-Python代码" class="headerlink" title="1.2 Python代码"></a>1.2 Python代码</h4><pre class="language-sql" data-language="sql"><code class="language-sql">import pymysqlconn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, charset&#x3D;&quot;utf8&quot;, db&#x3D;&#39;userdb&#39;)cursor &#x3D; conn.cursor()# 开启事务conn.begin()try:    cursor.execute(&quot;update users set amount&#x3D;1 where id&#x3D;1&quot;)    int(&#39;asdf&#39;)    cursor.execute(&quot;update tran set amount&#x3D;2 where id&#x3D;2&quot;)except Exception as e:    # 回滚    print(&quot;回滚&quot;)    conn.rollback()else:    # 提交    print(&quot;提交&quot;)    conn.commit()cursor.close()conn.close()</code></pre><h3 id="2-锁"><a href="#2-锁" class="headerlink" title="2. 锁"></a>2. 锁</h3><p>在用MySQL时，不知你是否会疑问：同时有很多做更新、插入、删除动作，MySQL如何保证数据不出错呢？</p><p>MySQL中自带了锁的功能，可以帮助我们实现开发过程中遇到的同时处理数据的情况。对于数据库中的锁，从锁的范围来讲有：</p><ul><li>表级锁，即A操作表时，其他人对整个表都不能操作，等待A操作完之后，才能继续。</li><li>行级锁，即A操作表时，其他人对指定的行数据不能操作，其他行可以操作，等待A操作完之后，才能继续。</li></ul><pre class="language-none"><code class="language-none">MYISAM支持表锁，不支持行锁；InnoDB引擎支持行锁和表锁。即：在MYISAM下如果要加锁，无论怎么加都会是表锁。    在InnoDB引擎支持下如果是基于索引查询的数据则是行级锁，否则就是表锁。</code></pre><p>所以，一般情况下我们会选择使用innodb引擎，并且在 搜索 时也会使用索引（命中索引）。</p><p>接下来的操作就基于innodb引擎来操作：</p><pre class="language-sql" data-language="sql"><code class="language-sql">CREATE TABLE &#96;L1&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;name&#96; varchar(255) DEFAULT NULL,  &#96;count&#96; int(11) DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB  DEFAULT CHARSET&#x3D;utf8;</code></pre><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210528134811202.png" class="" title="image-20210528134811202"><p>在innodb引擎中，update、insert、delete的行为内部都会先申请锁（排它锁），申请到之后才执行相关操作，最后再释放锁。</p><pre class="language-none"><code class="language-none">所以，当多个人同时像数据库执行：insert、update、delete等操作时，内部加锁后会排队逐一执行。</code></pre><p>而select则默认不会申请锁。</p><pre class="language-none"><code class="language-none">select * from xxx;</code></pre><p>如果，你想要让select去申请锁，则需要配合 事务 + 特殊语法来实现。</p><ul><li><p>​</p><pre class="language-sql" data-language="sql"><code class="language-sql">begin; select * from L1 where name&#x3D;&quot;武沛齐&quot; for update;    -- name列不是索引（表锁）commit;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">begin; -- 或者 start transaction;select * from L1 where id&#x3D;1 for update;  -- id列是索引（行锁）commit;</code></pre></li><li><p><code>lock in share mode</code> ，共享锁，加锁之后，其他可读但不可写。</p><pre class="language-sql" data-language="sql"><code class="language-sql">begin; select * from L1 where name&#x3D;&quot;武沛齐&quot; lock in share mode;    -- 假设name列不是索引（表锁）commit;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">begin; -- 或者 start transaction;select * from L1 where id&#x3D;1 lock in share mode;           -- id列是索引（行锁）commit;</code></pre></li></ul><h4 id="2-1-排它锁"><a href="#2-1-排它锁" class="headerlink" title="2.1 排它锁"></a>2.1 排它锁</h4><p>排它锁（ <code>for update</code>），加锁之后，其他事务不可以读写。</p><p>应用场景：总共100件商品，每次购买一件需要让商品个数减1 。</p><pre class="language-sql" data-language="sql"><code class="language-sql">A: 访问页面查看商品剩余 100B: 访问页面查看商品剩余 100此时 A、B 同时下单，那么他们同时执行SQL：update goods set count&#x3D;count-1 where id&#x3D;3由于Innodb引擎内部会加锁，所以他们两个即使同一时刻执行，内部也会排序逐步执行。但是，当商品剩余 1个时，就需要注意了。A: 访问页面查看商品剩余 1B: 访问页面查看商品剩余 1此时 A、B 同时下单，那么他们同时执行SQL：update goods set count&#x3D;count-1 where id&#x3D;3这样剩余数量就会出现 -1，很显然这是不正确的，所以应该怎么办呢？这种情况下，可以利用 排它锁，在更新之前先查询剩余数量，只有数量 &gt;0 才可以购买，所以，下单时应该执行：begin; -- start transaction;select count from goods where id&#x3D;3 for update;-- 获取个数进行判断if 个数&gt;0:update goods set count&#x3D;count-1 where id&#x3D;3;else:-- 已售罄commit;</code></pre><p>基于Python代码示例：</p><pre class="language-python" data-language="python"><code class="language-python">import pymysqlimport threadingdef task():    conn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, charset&#x3D;&quot;utf8&quot;, db&#x3D;&#39;userdb&#39;)    cursor &#x3D; conn.cursor(pymysql.cursors.DictCursor)        # cursor &#x3D; conn.cursor()  # fetchone:(1,10) 只返回查询结果id&#x3D;1，age&#x3D;10      # fetchall:((1,10),(2,12)) 只返回查询结果id&#x3D;1，age&#x3D;10;id&#x3D;2,age&#x3D;12    # 开启事务    conn.begin()    cursor.execute(&quot;select id,age from tran where id&#x3D;2 for update&quot;)    # fetchall      ( &#123;&quot;id&quot;:1,&quot;age&quot;:10&#125;,&#123;&quot;id&quot;:2,&quot;age&quot;:10&#125;, )     # &#123;&quot;id&quot;:1,&quot;age&quot;:10&#125;       result &#x3D; cursor.fetchone()    current_age &#x3D; result[&#39;age&#39;]        if current_age &gt; 0:        cursor.execute(&quot;update tran set age&#x3D;age-1 where id&#x3D;2&quot;)    else:        print(&quot;已售罄&quot;)    conn.commit()    cursor.close()    conn.close()def run():    for i in range(5):        t &#x3D; threading.Thread(target&#x3D;task)        t.start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    run()</code></pre><h4 id="2-2-共享锁"><a href="#2-2-共享锁" class="headerlink" title="2.2 共享锁"></a>2.2 共享锁</h4><p>共享锁（ <code>lock in share mode</code>），可以读，但不允许写。</p><p>加锁之后，后续其他事物可以可以进行读，但不允许写（update、delete、insert），因为写的默认也会加锁。</p><p><strong>Locking Read Examples</strong></p><p>Suppose that you want to insert a new row into a table <code>child</code>, and make sure that the child row has a parent row in table <code>parent</code>. Your application code can ensure referential integrity throughout this sequence of operations.</p><p>First, use a consistent read to query the table <code>PARENT</code> and verify that the parent row exists. Can you safely insert the child row to table <code>CHILD</code>? No, because some other session could delete the parent row in the moment between your <code>SELECT</code> and your <code>INSERT</code>, without you being aware of it.</p><p>To avoid this potential issue, perform the <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"><code>SELECT</code></a> using <code>LOCK IN SHARE MODE</code>:</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECT * FROM parent WHERE NAME &#x3D; &#39;Jones&#39; LOCK IN SHARE MODE;</code></pre><p>After the <code>LOCK IN SHARE MODE</code> query returns the parent <code>&#39;Jones&#39;</code>, you can safely add the child record to the <code>CHILD</code> table and commit the transaction. Any transaction that tries to acquire an exclusive lock in the applicable row in the <code>PARENT</code> table waits until you are finished, that is, until the data in all tables is in a consistent state.</p><h3 id="3-数据库连接池"><a href="#3-数据库连接池" class="headerlink" title="3. 数据库连接池"></a>3. 数据库连接池</h3><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210531211656410.png" class="" title="image-20210531211656410"><p>在操作数据库时需要使用数据库连接池。</p><pre class="language-none"><code class="language-none">pip3.9 install pymysqlpip3.9 install dbutils</code></pre><pre class="language-python" data-language="python"><code class="language-python">import threadingimport pymysqlfrom dbutils.pooled_db import PooledDBMYSQL_DB_POOL &#x3D; PooledDB(    creator&#x3D;pymysql,  # 使用链接数据库的模块    maxconnections&#x3D;5,  # 连接池允许的最大连接数，0和None表示不限制连接数    mincached&#x3D;2,  # 初始化时，链接池中至少创建的空闲的链接，0表示不创建    maxcached&#x3D;3,  # 链接池中最多闲置的链接，0和None不限制    blocking&#x3D;True,  # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错    setsession&#x3D;[],  # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]    ping&#x3D;0,    # ping MySQL服务端，检查是否服务可用。    # 如：0 &#x3D; None &#x3D; never, 1 &#x3D; default &#x3D; whenever it is requested,     # 2 &#x3D; when a cursor is created, 4 &#x3D; when a query is executed, 7 &#x3D; always    host&#x3D;&#39;127.0.0.1&#39;,    port&#x3D;3306,    user&#x3D;&#39;root&#39;,    password&#x3D;&#39;root123&#39;,    database&#x3D;&#39;userdb&#39;,    charset&#x3D;&#39;utf8&#39;)def task():    # 去连接池获取一个连接，如果不使用MYSQL_DB_POOL类则直接关闭连接    conn &#x3D; MYSQL_DB_POOL.connection()    cursor &#x3D; conn.cursor(pymysql.cursors.DictCursor)        cursor.execute(&#39;select sleep(2)&#39;)    result &#x3D; cursor.fetchall()    print(result)    cursor.close()    # 将连接交还给给连接池，如果不使用MYSQL_DB_POOL类则直接关闭连接    conn.close()# 创建10个进程去对数据库进行操作def run():    for i in range(10):        t &#x3D; threading.Thread(target&#x3D;task)        t.start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    run()</code></pre><h3 id="4-SQL工具类"><a href="#4-SQL工具类" class="headerlink" title="4. SQL工具类"></a>4. SQL工具类</h3><p>基于数据库连接池开发一个公共的SQL操作类，方便以后操作数据库。</p><h4 id="4-1-单例和方法"><a href="#4-1-单例和方法" class="headerlink" title="4.1 单例和方法"></a>4.1 单例和方法</h4><pre class="language-sql" data-language="sql"><code class="language-sql"># db.pyimport pymysqlfrom dbutils.pooled_db import PooledDBclass DBHelper(object):    def __init__(self):        # TODO 此处配置，可以去配置文件中读取。        self.pool &#x3D; PooledDB(            creator&#x3D;pymysql,  # 使用链接数据库的模块            maxconnections&#x3D;5,  # 连接池允许的最大连接数，0和None表示不限制连接数            mincached&#x3D;2,  # 初始化时，链接池中至少创建的空闲的链接，0表示不创建            maxcached&#x3D;3,  # 链接池中最多闲置的链接，0和None不限制            blocking&#x3D;True,  # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错            setsession&#x3D;[],  # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]            ping&#x3D;0,            # ping MySQL服务端，检查是否服务可用。# 如：0 &#x3D; None &#x3D; never, 1 &#x3D; default &#x3D; whenever it is requested, 2 &#x3D; when a cursor is created, 4 &#x3D; when a query is executed, 7 &#x3D; always            host&#x3D;&#39;127.0.0.1&#39;,            port&#x3D;3306,            user&#x3D;&#39;root&#39;,            password&#x3D;&#39;root123&#39;,            database&#x3D;&#39;userdb&#39;,            charset&#x3D;&#39;utf8&#39;        )    def get_conn_cursor(self):        conn &#x3D; self.pool.connection()        cursor &#x3D; conn.cursor(pymysql.cursors.DictCursor)        return conn, cursor    def close_conn_cursor(self, *args):        for item in args:            item.close()    def exec(self, sql, **kwargs):        conn, cursor &#x3D; self.get_conn_cursor()        cursor.execute(sql, kwargs)        conn.commit()        self.close_conn_cursor(conn, cursor)    def fetch_one(self, sql, **kwargs):        conn, cursor &#x3D; self.get_conn_cursor()        cursor.execute(sql, kwargs)        result &#x3D; cursor.fetchone()        self.close_conn_cursor(conn, cursor)        return result    def fetch_all(self, sql, **kwargs):        conn, cursor &#x3D; self.get_conn_cursor()        cursor.execute(sql, kwargs)        result &#x3D; cursor.fetchall()        self.close_conn_cursor(conn, cursor)        return resultdb &#x3D; DBHelper()</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">from db import dbdb.exec(&quot;insert into d1(name) values(%(name)s)&quot;, name&#x3D;&quot;武沛齐666&quot;)ret &#x3D; db.fetch_one(&quot;select * from d1&quot;)print(ret)ret &#x3D; db.fetch_one(&quot;select * from d1 where id&#x3D;%(nid)s&quot;, nid&#x3D;3)print(ret)ret &#x3D; db.fetch_all(&quot;select * from d1&quot;)print(ret)ret &#x3D; db.fetch_all(&quot;select * from d1 where id&gt;%(nid)s&quot;, nid&#x3D;2)print(ret)</code></pre><h4 id="4-2-上下文管理"><a href="#4-2-上下文管理" class="headerlink" title="4.2 上下文管理"></a>4.2 上下文管理</h4><p>如果你想要让他也支持 with 上下文管理。</p><pre class="language-none"><code class="language-none">with 获取连接：执行SQL（执行完毕后，自动将连接交还给连接池）</code></pre><pre class="language-python" data-language="python"><code class="language-python"># db_context.pyimport threadingimport pymysqlfrom dbutils.pooled_db import PooledDBPOOL &#x3D; PooledDB(    creator&#x3D;pymysql,  # 使用链接数据库的模块    maxconnections&#x3D;5,  # 连接池允许的最大连接数，0和None表示不限制连接数    mincached&#x3D;2,  # 初始化时，链接池中至少创建的空闲的链接，0表示不创建    maxcached&#x3D;3,  # 链接池中最多闲置的链接，0和None不限制    blocking&#x3D;True,  # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错    setsession&#x3D;[],  # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]    ping&#x3D;0,    host&#x3D;&#39;127.0.0.1&#39;,    port&#x3D;3306,    user&#x3D;&#39;root&#39;,    password&#x3D;&#39;root123&#39;,    database&#x3D;&#39;userdb&#39;,    charset&#x3D;&#39;utf8&#39;)class Connect(object):    def __init__(self):        self.conn &#x3D; conn &#x3D; POOL.connection()        self.cursor &#x3D; conn.cursor(pymysql.cursors.DictCursor)    def __enter__(self):        return self    def __exit__(self, exc_type, exc_val, exc_tb):        self.cursor.close()        self.conn.close()    def exec(self, sql, **kwargs):        self.cursor.execute(sql, kwargs)        self.conn.commit()    def fetch_one(self, sql, **kwargs):        self.cursor.execute(sql, kwargs)        result &#x3D; self.cursor.fetchone()        return result    def fetch_all(self, sql, **kwargs):        self.cursor.execute(sql, kwargs)        result &#x3D; self.cursor.fetchall()        return result</code></pre><pre class="language-python" data-language="python"><code class="language-python">from db_context import Connectwith Connect() as obj:    # print(obj.conn)    # print(obj.cursor)    ret &#x3D; obj.fetch_one(&quot;select * from d1&quot;)    print(ret)    ret &#x3D; obj.fetch_one(&quot;select * from d1 where id&#x3D;%(id)s&quot;, id&#x3D;3)    print(ret)</code></pre><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h3><p>navicat，是一个桌面应用，让我们可以更加方便的管理MySQL数据库。</p><ul><li>mac系统：<a href="https://www.macdo.cn/17030.html">https://www.macdo.cn/17030.html</a></li><li>win系统：<ul><li>链接: <a href="https://pan.baidu.com/s/13cjbrBquz9vjVqKgWoCQ1w">https://pan.baidu.com/s/13cjbrBquz9vjVqKgWoCQ1w</a>  密码: qstp</li><li>链接: <a href="https://pan.baidu.com/s/1JULIIwQA5s0qN98KP8UXHA">https://pan.baidu.com/s/1JULIIwQA5s0qN98KP8UXHA</a>  密码: p18f</li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>本节内容比较重要，也是开发中经常会使用到的技能。</p><ul><li>事务，解决批量操作同时成功或失败的问题。</li><li>锁，解决并发处理的问题。</li><li>数据库连接池，解决多个人请求连接数据库的问题。</li><li>SQL工具类，解决连接数据库代码重复的问题。</li><li>navicat工具</li></ul><h3 id="大作业：开发博客系统"><a href="#大作业：开发博客系统" class="headerlink" title="大作业：开发博客系统"></a>大作业：开发博客系统</h3><blockquote><p>请基于你掌握的所有技能，实现 day27  博客系统的所有功能。</p></blockquote><p>根据如下的业务需求设计相应的表结构，内部需涵盖如下功能。</p><ul><li>注册</li><li>登录</li><li>发布博客</li><li>查看博客列表，显示博客标题、创建时间、阅读数量、评论数量、赞数量等。（支持分页查看）</li><li>博客详细，显示博文详细、评论 等。<ul><li>发表评论</li><li>赞 or 踩</li><li>阅读数量 + 1</li></ul></li></ul><p>可参考如下图片来设计相应的表结构。</p><h4 id="1-注册和登录"><a href="#1-注册和登录" class="headerlink" title="1. 注册和登录"></a>1. 注册和登录</h4><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210520204812764.png" class="" title="image-20210520204812764"><h4 id="2-文章列表"><a href="#2-文章列表" class="headerlink" title="2. 文章列表"></a>2. 文章列表</h4><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210520204735867-16572013289091.png" class="" title="image-20210520204735867"><h4 id="3-文章详细"><a href="#3-文章详细" class="headerlink" title="3. 文章详细"></a>3. 文章详细</h4><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210520205148509.png" class="" title="image-20210520205148509"><h4 id="4-评论-amp-阅读-amp-赞-amp-踩"><a href="#4-评论-amp-阅读-amp-赞-amp-踩" class="headerlink" title="4. 评论 &amp; 阅读 &amp; 赞 &amp; 踩"></a>4. 评论 &amp; 阅读 &amp; 赞 &amp; 踩</h4><img src="/2022/06/30/python-di-si-mo-kuai-day2/image-20210520205332907.png" class="" title="image-20210520205332907"><p>注意：假设都是一级评论（不能回复评论）。</p>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 第四阶段 </tag>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块四day1</title>
      <link href="/2022/06/24/python-mo-kuai-si-day1/"/>
      <url>/2022/06/24/python-mo-kuai-si-day1/</url>
      
        <content type="html"><![CDATA[<p>从今天开始，我们将进入系列课程的 第四模块 的学习，这个模块就是给大家讲解MySQL数据库。</p><p>以前，在开发程序时，我们会把很多的数据和信息存储到某个文件夹中的文件中，例如：user.txt 、db.xlsx 等。</p><p>现在，有那么一个叫：数据库管理系统（DBMS，Database Management System）的软件，可以帮助我们实现对文件夹中的文件进行操作，而我们只要学习DBMS能识别的指令， 就能控制它去帮助我们实现的文件和文件夹的处理。例如：</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210507211911641.png" class="" title="image-20210507211911641"><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210508090834860.png" class="" title="image-20210508090834860"><p>数据库管理系统（DBMS）专注于帮助开发者解决数据存储的问题，这样开发者就可以把主要精力放在实现业务功能上了。</p><p>业内有很多的的数据库管理系统产品，例如：</p><ul><li><strong>MySQL</strong>，原来是sun公司，后来被甲骨文收购。现在互联网企业几乎都在使用。【免费 + 收费】</li><li>Oracle，甲骨文。收费，一般国企、事业单位居多。【收费】</li><li>Microsoft SQL Server，微软。【收费】</li><li>DB2，IBM。【免费 + 收费】</li><li>SQLite，D. Richard Hipp个人开发。【免费】</li><li>Access， 微软。【收费】</li><li>PostgreSQL，加州大学伯克利分校。【免费】</li><li>等众多..</li></ul><p>由于各大公司都是使用MySQL，所以我们课程主要给大家讲解MySQL数据库。</p><p>在项目开发中想要基于MySQL来进行数据存储，大致应该怎么做呢？</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210508102020237.png" class="" title="image-20210508102020237"><p>本系列的MySQL模块会分为5部分来讲解：</p><ul><li>MySQL入门，安装和快速应用Python实现数据库的操作。</li><li>必备SQL和授权，学习更多必备的指令让数据库实现更多业务场景。</li><li><font color="#dd0000"><strong>SQL强化和实践，强化练习必备”指令“（项目开发写的最多）。</strong></font></li><li>索引和函数以及存储过程，掌握常见性能提升手段以及那些应用不是很频繁却又需了解的知识点。</li><li>Python操作MySQL和应用，侧重点在于Python开发，让大家了解Python开发中必备的实战应用，例如：锁、事务、数据库连接池等。</li></ul><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210528190629407.png" class="" title="image-20210528190629407"><h2 id="二十五、MySQL入门"><a href="#二十五、MySQL入门" class="headerlink" title="二十五、MySQL入门"></a>二十五、MySQL入门</h2><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210528192555988.png" class="" title="image-20210528192555988"><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210508102020237.png" class="" title="image-20210508102020237"><p>课程目标：学习安装和快速应用Python实现数据库的操作。</p><p>课程概要：</p><ul><li>安装 &amp; 配置 &amp; 启动<ul><li>win</li><li>mac</li></ul></li><li>数据库 管理（类比文件夹）</li><li>表 管理        （类比文件夹下的Excel文件）</li><li>数据行 管理（类比Excel文件中的数据行）</li><li>Python操作MySQL及相关安全的问题</li></ul><h3 id="1-安装-amp-配置-amp-启动"><a href="#1-安装-amp-配置-amp-启动" class="headerlink" title="1. 安装 &amp; 配置 &amp; 启动"></a>1. 安装 &amp; 配置 &amp; 启动</h3><p>MySQL现在的版本主要分为：</p><ul><li>5.x 版本，现在互联网企业中的主流版本，包括：头条、美图、百度、腾讯等互联网公司主流的版本。</li><li>8.x 版本，新增了一些了窗口函数、持久化配置、隐藏索引等其他功能。</li></ul><p>所以，我们课程会以常用大版本中最新的版本为例来讲解，即：5.7.31 （依然有很多企业在用5.6.x，但新项目基本上都是5.7.x了）。</p><h4 id="1-1-win系统"><a href="#1-1-win系统" class="headerlink" title="1.1 win系统"></a>1.1 win系统</h4><h5 id="第1步：下载安装"><a href="#第1步：下载安装" class="headerlink" title="第1步：下载安装"></a>第1步：下载安装</h5><p><a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210508103751068.png" class="" title="image-20210508103751068"><p>注意：下载5.7.31版本</p><h5 id="第2步：解压至任意文件夹"><a href="#第2步：解压至任意文件夹" class="headerlink" title="第2步：解压至任意文件夹"></a>第2步：解压至任意文件夹</h5><p>建议解压至软件安装目录，例如：</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210508105417186.png" class="" title="image-20210508105417186"><h5 id="第3步：创建配置文件"><a href="#第3步：创建配置文件" class="headerlink" title="第3步：创建配置文件"></a>第3步：创建配置文件</h5><p>在MySQL的安装目录下创建 <code>my.ini</code> 的文件，作为MySQL的配置文件。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210508120708175.png" class="" title="image-20210508120708175"><p>其实，MySQL的配置文件可以放在很多的目录，下图是配置文件的优先级（注意要使用管理员权限打开命令行窗口）：</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510150530193.png" class="" title="image-20210510150530193"><p>强烈，建议大家还是把配置文件放在MySQL安装目录下，这样以后电脑上想要安装多个版本的MySQL时，配置文件可以相互独立不影响。</p><p>注意：如果你电脑的上述其他目录存在MySQL配置文件，建议删除，否则可能会影响MySQL的启动。</p><h5 id="第4步：初始化"><a href="#第4步：初始化" class="headerlink" title="第4步：初始化"></a>第4步：初始化</h5><pre class="language-none"><code class="language-none">&gt;&gt;&gt; &quot;C:\Program Files\mysql-5.7.31-winx64\bin\mysqld.exe&quot;  --initialize-insecure</code></pre><p>初始化命令在执行时，会自动读取配置文件并执行初始化，此过程主要会做两件事：</p><ul><li>自动创建data目录，以后我们的数据都会存放在这个目录。</li><li>同时创建建必备一些的数据，例如默认账户 root （无密码），用于登录MySQL并通过指令操作MySQL。</li></ul><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510151829891.png" class="" title="image-20210510151829891"><p>在windowns安装过程中如果有报错 （ msvcr120.dll不存在 ），请下载并安装下面的两个补丁：</p><ul><li><p>vcredist：<a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=40784">https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=40784</a>  （主要）</p><img src="Python模块四day1/image-20210508115414183.png" alt="image-20210508115414183" style="zoom:33%;" /></li><li><p>dirctx：<a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=35">https://www.microsoft.com/zh-CN/download/details.aspx?id=35</a></p><img src="Python模块四day1/image-20210508115521913.png" alt="image-20210508115521913" style="zoom: 33%;" /></li></ul><h5 id="第5步：启动"><a href="#第5步：启动" class="headerlink" title="第5步：启动"></a>第5步：启动</h5><p>启动MySQL常见的有两种方式：</p><ul><li><p>临时启动</p><pre class="language-bash" data-language="bash"><code class="language-bash">&gt;&gt;&gt; &quot;C:\Program Files\mysql-5.7.31-winx64\bin\mysqld.exe&quot;</code></pre><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510152448745.png" class="" title="image-20210510152448745"><p>注意：此时程序会挂起，内部就是可以接收客户端发来的MySQL指令，关闭窗口或Ctrl+c 就可以停止运行。</p><p>这种启动方式每次开机或想要开启都需要手动执行一遍命令比较麻烦。</p></li><li><p>制作windows服务，基于windows服务管理。</p><pre class="language-bash" data-language="bash"><code class="language-bash">&gt;&gt;&gt;&quot;C:\Program Files\mysql-5.7.31-winx64\bin\mysqld.exe&quot; --install mysql57</code></pre><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510152702489.png" class=""><p>创建好服务之后，可以通过命令 启动和关闭服务，例如：</p><pre class="language-bash" data-language="bash"><code class="language-bash">&gt;&gt;&gt; net start mysql57&gt;&gt;&gt; net stop mysql57</code></pre><p>也可以在window的服务管理中点击按钮启动和关闭服务。例如：</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210529225011045.png" class=""><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210529225043126.png" class=""><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510152740268.png" class=""><p>以后不再想要使用window服务了，也可以将制作的这个MySQL服务删除。</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt;&quot;C:\Program Files\mysql-5.7.31-winx64\bin\mysqld.exe&quot; --remove mysql57</code></pre><img src="Python模块四day1/image-20210510152809233.png" style="zoom:25%;" /></li></ul><h5 id="第6步：测试连接MySQL"><a href="#第6步：测试连接MySQL" class="headerlink" title="第6步：测试连接MySQL"></a>第6步：测试连接MySQL</h5><p>安装并启动MySQL之后，就可以连接MySQL来测试是否已正确安装并启动成功。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510153336093.png" class="" title="image-20210510153336093"><p>以后在开发时，肯定是要用Python代码来连接MySQL并且进行数据操作（后面讲）。</p><p>在安装MySQL时，其实也自动安装了一个工具（客户端），让我们快速实现连接MySQL并发送指令。</p><blockquote><p>“C:\Program Files\mysql-5.7.31-winx64\bin\mysql.exe” -h 127.0.0.1 -P 3306 -u root -p</p></blockquote><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510154446628.png" class=""><p>注意：</p><ul><li><p><code>mysql57</code>服务开启时，才能连接数据库</p></li><li><p>如果把bin目录加入环境变量，每次在运行命令时，就不用再重新输入绝对路径了。</p></li></ul><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210529225251803.png" class=""><p>上述过程如果操作完成之后，证明你的安装和启动过程就搞定了。</p><h4 id="1-2-mac系统"><a href="#1-2-mac系统" class="headerlink" title="1.2 mac系统"></a>1.2 mac系统</h4><p>mac系统和win不同，MySQL为他提供了非常方便的一站式安装程序，只要点击、next就可以安装、初始化完成。</p><h5 id="第1步：安装和初始化"><a href="#第1步：安装和初始化" class="headerlink" title="第1步：安装和初始化"></a>第1步：安装和初始化</h5><p><a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p><img src="Python模块四day1/image-20210508103830229.png" alt="image-20210508103830229"  /><img src="Python模块四day1/image-20210508165414794.png" alt="image-20210508165414794" style="zoom:50%;" /><img src="Python模块四day1/image-20210508171059416.png" alt="image-20210508171059416" style="zoom:50%;" /><p>这个基于dmg文件的安装过程，其实包含了：</p><ul><li>安装，默认安装在了 <code>/usr/local/mysql-5.7.31-macos10.14-x86_64/</code>目录。</li><li>初始化，在安装目录下创建data目录用于存放数据； 初始化模块数据库以及账户相关等，例如： 账cd</li></ul><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510103342842.png" class="" title="image-20210510103342842"><h5 id="第2步：创建配置文件"><a href="#第2步：创建配置文件" class="headerlink" title="第2步：创建配置文件"></a>第2步：创建配置文件</h5><p>建议在MySQL安装目录下创建 <code>etc/my.cnf</code> 作为MySQL的配置文件。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510161700478.png" class=""><p>MySQL的配置文件按照优先级，会在以下目录中寻找：</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510161845843.png" class=""><p>为了避免多个版本共存时，配置文件混乱的问题，建议大家还是把配置文件放在当前MySQL的安装目录下。</p><h5 id="第3步：启动"><a href="#第3步：启动" class="headerlink" title="第3步：启动"></a>第3步：启动</h5><p>在Mac系统中启动MySQL常见的有2种方式：</p><ul><li><p>安装目录中自带 <code>mysql.server</code> 脚本（建议）</p><pre class="language-python" data-language="python"><code class="language-python">sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server start# 输入电脑密码sudo mysql.server start# 输入电脑密码</code></pre><pre class="language-none"><code class="language-none">sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server stop</code></pre><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510162854578.png" class=""><p>为了避免每次执行命令都需要些路径，可以将路径 <code>/usr/local/mysql/support-files</code>加入到环境变量中。</p></li></ul><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510165107737.png" class=""><p>  操作完成之后，再在终端执行下命令：<code>source ~/.zprofile</code> 让设置的环境变量立即生效。</p><p>  注意：mac系统的版本如果比较老，会显示空白的 <code>zprofile</code> 文件，此就要去打开   <code>bash_profile</code> 文件。</p><p>  这样设置好之后，以后就可以使用下面的命令去启动和关闭MySQL了。</p>  <pre class="language-none"><code class="language-none">sudo mysql.server startsudo mysql.server stop</code></pre><ul><li>系统偏好设置（不推荐）</li></ul><img src="Python模块四day1/image-20210510104009559.png" alt="image-20210510104009559" style="zoom: 33%;" /><p>第一种<code>mysql.server</code>脚本的形式，内部是使用 <code>mysqld_safe</code>运行，可以守护我们的MySQL进程，如意外挂掉可自动重启。</p><h5 id="第4步：测试连接MySQL"><a href="#第4步：测试连接MySQL" class="headerlink" title="第4步：测试连接MySQL"></a>第4步：测试连接MySQL</h5><p>安装并启动MySQL之后，就可以连接MySQL来测试是否已正确安装并启动成功。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510153336093.png" class="" title="image-20210510153336093"><p>以后在开发时，肯定是要用Python代码来连接MySQL并且进行数据操作（后面讲）。</p><p>在安装MySQL时，其实也自动安装了一个工具（客户端），让我们快速实现连接MySQL并发送指令。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510171029083.png" class=""><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510171004699.png" class=""><p>注意：<code>/usr/local/mysql/bin</code>也可以加入到环境变量。</p><p>至此，在Mac系统中关于MySQL的安装和配置就完成了。</p><h4 id="1-3-关于配置文件"><a href="#1-3-关于配置文件" class="headerlink" title="1.3 关于配置文件"></a>1.3 关于配置文件</h4><p>上述的过程中，我们在配置文件中只添加了很少的配置。</p><p>其实，配置项有很多，而哪些配置项都有默认值，如果我们不配置，MySQL则自动使用默认值。</p><h4 id="1-4-关于密码"><a href="#1-4-关于密码" class="headerlink" title="1.4 关于密码"></a>1.4 关于密码</h4><h5 id="1-设置和修改root密码"><a href="#1-设置和修改root密码" class="headerlink" title="1. 设置和修改root密码"></a>1. 设置和修改root密码</h5><p>在windows系统中模块默认 root 账户是没有密码的，如果想要为账户设定密码，可以在利用root账户登录成功之后，执行：</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210530001548192.png" class=""><h5 id="2-忘记root密码"><a href="#2-忘记root密码" class="headerlink" title="2. 忘记root密码"></a>2. 忘记root密码</h5><p>如果你忘记了MySQL账户的密码。</p><ul><li><p>修改配置文件，在 [mysqld] 节点下添加 <code>skip-grant-tables=1</code></p><pre class="language-none"><code class="language-none">[mysqld]...skip-grant-tables&#x3D;1...</code></pre></li><li><p>重启MySQL，再次登录时，不需要密码直接可以进去了</p><ul><li><p>windows重启</p><pre class="language-none"><code class="language-none">net stop mysql57net start mysql57</code></pre></li><li><p>mac重启</p><pre class="language-none"><code class="language-none">sudo mysql.server restart</code></pre></li></ul><p>重启后，无序密码就可以进入。</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; mysql -u root -p</code></pre></li><li><p>进入数据库后执行修改密码命令</p><pre class="language-none"><code class="language-none">use mysql;update user set authentication_string &#x3D; password(&#39;新密码&#39;),password_last_changed&#x3D;now() where user&#x3D;&#39;root&#39;;</code></pre></li><li><p>退出并再次修改配置文件，删除 [mysqld] 节点下的 <code>skip-grant-tables=1</code></p><pre class="language-none"><code class="language-none">[mysqld]...# skip-grant-tables&#x3D;1...</code></pre></li><li><p>再次重启，以后就可以使用新密码登录了。</p></li></ul><h3 id="2-数据库-管理"><a href="#2-数据库-管理" class="headerlink" title="2. 数据库 管理"></a>2. 数据库 管理</h3><p>安装上数据库之后，就需要开始学习指令了，通过指令让MySQL去做出一些文件操作。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210507211911641.png" class=""><p>如果将数据库管理系统与之前的文件管理做类比的话：</p><table><thead><tr><th>数据库管理系统</th><th>文件管理</th></tr></thead><tbody><tr><td>数据库</td><td>文件夹</td></tr><tr><td>数据表</td><td>文件夹下的excel文件</td></tr></tbody></table><p>接下来，我们先学习 数据库（文件夹）相关操作的指令。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510153336093.png" class=""><h4 id="2-1-内置客户端操作"><a href="#2-1-内置客户端操作" class="headerlink" title="2.1 内置客户端操作"></a>2.1 内置客户端操作</h4><p>当连接上MySQL之后，执行如下指令（一般称为SQL语句），就可以对MySQL的数据进行操作。</p><ul><li><p>查看当前所有的数据库：  <code>show databases;</code></p></li><li><p>创建数据库：<code>create database 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</code> </p><pre class="language-none"><code class="language-none">create database day25db;create database day25db DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</code></pre></li><li><p>删除数据库：<code>drop database 数据库名</code>;</p></li><li><p>进入数据（进入文件）：<code>use 数据库;</code></p></li></ul><p>示例：<font color="#dd0000"> <strong>【mysql数据库操作】：不用记住，用到时回来翻看</strong></font></p><pre class="language-bash" data-language="bash"><code class="language-bash"># 1.登录MySQLwupeiqi@wupeiqideMBP ~ % &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.7.31 MySQL Community Server (GPL)Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and&#x2F;or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.# 2.查看当前数据库mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.00 sec)# 3. 创建数据库:  create database 数据库名 default charset 编码 collate 排序规则;mysql&gt; create database db1 default charset utf8 collate utf8_general_ci;Query OK, 1 row affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || db1                || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.01 sec)# 4. 删除数据库mysql&gt; drop database db1;Query OK, 0 rows affected (0.00 sec)# 5. 查看当前数据库mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.00 sec)# 6. 进入数据库mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changed# 7. 进入mysql数据库（文件夹），查看此数据库下的所有表。mysql&gt; show tables;+---------------------------+| Tables_in_mysql           |+---------------------------+| columns_priv              || db                        || engine_cost               || event                     || func                      || general_log               || gtid_executed             || help_category             || help_keyword              || help_relation             || help_topic                || innodb_index_stats        || innodb_table_stats        || ndb_binlog_index          || plugin                    || proc                      || procs_priv                || proxies_priv              || server_cost               || servers                   || slave_master_info         || slave_relay_log_info      || slave_worker_info         || slow_log                  || tables_priv               || time_zone                 || time_zone_leap_second     || time_zone_name            || time_zone_transition      || time_zone_transition_type || user                      |+---------------------------+31 rows in set (0.00 sec)# 8. 退出mysql&gt;exit;</code></pre><h4 id="2-2-Python代码操作"><a href="#2-2-Python代码操作" class="headerlink" title="2.2 Python代码操作"></a>2.2 Python代码操作</h4><p>无论通过何种方式去连接MySQL，本质上发送的 <strong>指令</strong> 都是相同的，只是连接的方式和操作形式不同而已。</p><p>当连接上MySQL之后，执行如下指令，就可以对MySQL的数据进行操作。（同上述过程）</p><ul><li>查看当前所有的数据库  <code>show databases;</code></li><li>创建数据库：<code>create database 数据库名 default charset utf8 collate utf8_general_ci;</code> </li><li>删除数据库：<code>drop database 数据库名</code>;</li><li>进入数据（进入文件）：<code>use 数据库;</code></li></ul><p>想要使用Python操作MySQL需要安装第三方模块：</p><pre class="language-none"><code class="language-none">pip3 install pymysql</code></pre><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510153336093.png" class="" title="image-20210510153336093"><p>安装完成后，就可以编写代码：</p><pre class="language-python" data-language="python"><code class="language-python">import pymysql# 连接MySQL（socket）conn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, charset&#x3D;&quot;utf8&quot;)cursor &#x3D; conn.cursor()# 1. 查看数据库# 发送指令cursor.execute(&quot;show databases&quot;)# 获取指令的结果result &#x3D; cursor.fetchall()print(result) # ((&#39;information_schema&#39;,), (&#39;mysql&#39;,), (&#39;performance_schema&#39;,), (&#39;sys&#39;,))# 2. 创建数据库（新增、删除、修改）# 发送指令cursor.execute(&quot;create database db3 default charset utf8 collate utf8_general_ci&quot;)conn.commit()# 3. 查看数据库# 发送指令cursor.execute(&quot;show databases&quot;)# 获取指令的结果result &#x3D; cursor.fetchall()print(result) # ((&#39;information_schema&#39;,), (&#39;db3&#39;,), (&#39;mysql&#39;,), (&#39;performance_schema&#39;,), (&#39;sys&#39;,))# 4. 删除数据库# 发送指令cursor.execute(&quot;drop database db3&quot;)conn.commit()# 3. 查看数据库# 发送指令cursor.execute(&quot;show databases&quot;)# 获取指令的结果result &#x3D; cursor.fetchall()print(result) # ((&#39;information_schema&#39;,), (&#39;mysql&#39;,), (&#39;performance_schema&#39;,), (&#39;sys&#39;,))# 5. 进入数据库，查看表# 发送指令cursor.execute(&quot;use mysql&quot;)cursor.execute(&quot;show tables&quot;)result &#x3D; cursor.fetchall()print(result) # ((&#39;columns_priv&#39;,), (&#39;db&#39;,), (&#39;engine_cost&#39;,), (&#39;event&#39;,), (&#39;func&#39;,), (&#39;general_log&#39;,),....# 关闭连接cursor.close()conn.close()</code></pre><p><font color="#dd0000"> <strong>注意：用Python连接mysql时</strong></font></p><ul><li>做查询操作：加上<code>cursor.fetchall()</code>、<code>cursor.fetxx()</code>以接受返回值</li><li>做增删改操作：加上<code>conn.commit()</code>以确定操作</li></ul><h3 id="3-数据表-管理"><a href="#3-数据表-管理" class="headerlink" title="3. 数据表 管理"></a>3. 数据表 管理</h3><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210507211911641.png" class="" title="image-20210507211911641"><p>如果将数据库管理系统与之前的文件管理做类比的话：</p><table><thead><tr><th>数据库管理系统</th><th>文件管理</th></tr></thead><tbody><tr><td>数据库</td><td>文件夹</td></tr><tr><td>数据表</td><td>文件夹下的文件</td></tr></tbody></table><p>接下来，我们先学习 数据表（文件夹中的文件）相关操作的指令。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210510153336093.png" class="" title="image-20210510153336093"><p>其实在数据库中创建数据库 和 创建Excel非常类似，需要指定： <code>表名</code>、<code>列名称</code>、<code>类类型（整型、字符串或其他)</code>。</p><h4 id="3-1-内置客户端操作"><a href="#3-1-内置客户端操作" class="headerlink" title="3.1 内置客户端操作"></a>3.1 内置客户端操作</h4><p>数据表常见操作的指令：<font color="#dd0000"> <strong>【mysql数据表操作】：不用记住，用到时回来翻看</strong></font></p><ul><li><p>进入数据库 <code>use 数据库;</code>，查看当前所有表：<code>show tables;</code></p></li><li><p>创建表结构</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210511102323966.png" class="" title="image-20210511102323966"><pre class="language-sql" data-language="sql"><code class="language-sql">create table 表名(    列名  类型,    列名  类型,    列名  类型)default charset&#x3D;utf8;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create table tb1(id int,    name varchar(16))default charset&#x3D;utf8;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create table tb2(id int,    name varchar(16) not null,   -- 不允许为空    email varchar(32) null,      -- 允许为空（默认）    age int)default charset&#x3D;utf8;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create table tb3(id int,    name varchar(16) not null,   -- 不允许为空    email varchar(32) null,      -- 允许为空（默认）    age int default 3            -- 插入数据时，如果不给age列设置值，默认值：3)default charset&#x3D;utf8;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create table tb4(id int primary key, -- 主键（不允许为空、不能重复）    name varchar(16) not null,   -- 不允许为空    email varchar(32) null,      -- 允许为空（默认）    age int default 3            -- 插入数据时，如果不给age列设置值，默认值：3)default charset&#x3D;utf8;</code></pre><p>主键一般用于表示当前这条数据的ID编号（类似于人的身份证），需要我们自己来维护一个不重复的值，比较繁琐。所以，在数据库中一般会将主键和自增结合。</p><pre class="language-sql" data-language="sql"><code class="language-sql">create table tb5(id int not null auto_increment primary key,-- 不允许为空 &amp; 主键 &amp; 自增    name varchar(16) not null,   -- 不允许为空    email varchar(32) null,      -- 允许为空（默认）    age int default 3            -- 插入数据时，如果不给age列设置值，默认值：3)default charset&#x3D;utf8;</code></pre><p><font color="#dd0000"> <strong>注意：一个表中只能有一个自增列【自增列，一般都是主键】。</strong></font></p></li><li><p>删除表 <code>drop table 表名;</code></p></li><li><p>清空表 <code>delete from 表名;</code> 或 <code>truncate table 表名;</code>（速度快、无法回滚撤销等）</p></li><li><p>修改表</p><ul><li><p>添加列 </p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table 表名 add 列名 类型;alter table 表名 add 列名 类型 DEFAULT 默认值;alter table 表名 add 列名 类型 not null default 默认值;alter table 表名 add 列名 类型 not null primary key auto_increment;</code></pre></li><li><p>删除列</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table 表名 drop column 列名;</code></pre></li><li><p>修改列 类型</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table 表名 modify column 列名 类型;</code></pre></li><li><p>修改列 类型 + 名称</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table 表名 change 原列名 新列名 新类型;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">alter table  tb change id nid int not null;alter table  tb change id id int not null default 5;alter table  tb change id id int not null primary key auto_increment;alter table  tb change id id int; -- 允许为空，删除默认值，删除自增。</code></pre></li><li><p>修改列 默认值</p><pre class="language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 ALTER 列名 SET DEFAULT 1000;</code></pre></li><li><p>删除列 默认值</p><pre class="language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 ALTER 列名 DROP DEFAULT;</code></pre></li><li><p>添加主键</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table 表名 add primary key(列名);</code></pre></li><li><p>删除主键</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table 表名 drop primary key;</code></pre></li></ul></li><li><p>查询表各列信息</p><pre class="language-sql" data-language="sql"><code class="language-sql">desc 表名;</code></pre></li><li><p>常见列类型</p><pre class="language-sql" data-language="sql"><code class="language-sql">create table 表(id int,    name varchar(16))default charset&#x3D;utf8;</code></pre><ul><li><p><code>int[(m)][unsigned][zerofill]</code></p><pre class="language-none"><code class="language-none">int表示有符号，取值范围：-2147483648 ～ 2147483647int unsigned表示无符号，取值范围：0 ～ 4294967295int(5)zerofill仅用于显示，当不满足5位时，按照左边补0，例如：00002；满足时，正常显示。</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">mysql&gt; create table L1(id int, uid int unsigned, zid int(5) zerofill) default charset&#x3D;utf8;Query OK, 0 rows affected (0.03 sec)mysql&gt; insert into L1(id,uid,zid) values(1,2,3);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into L1(id,uid,zid) values(2147483641,4294967294,300000);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from L1;+------------+------------+--------+| id         | uid        | zid    |+------------+------------+--------+|          1 |          2 |  00003 || 2147483641 | 4294967294 | 300000 |+------------+------------+--------+2 rows in set (0.00 sec)mysql&gt; insert into L1(id,uid,zid) values(214748364100,4294967294,300000);ERROR 1264 (22003): Out of range value for column &#39;id&#39; at row 1mysql&gt;</code></pre></li><li><p><code>tinyint[(m)] [unsigned] [zerofill]</code></p><pre class="language-none"><code class="language-none">有符号，取值范围：-128 ～ 127.无符号，取值范围：0 ～ 255</code></pre></li><li><p><code>bigint[(m)][unsigned][zerofill]</code></p><pre class="language-none"><code class="language-none">有符号，取值范围：-9223372036854775808 ～ 9223372036854775807无符号，取值范围：0  ～  18446744073709551615</code></pre></li><li><p><code>decimal[(m[,d])] [unsigned] [zerofill]</code></p><pre class="language-none"><code class="language-none">准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。例如：create table L2(id int not null primary key auto_increment,salary decimal(8,2))default charset&#x3D;utf8;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">mysql&gt; create table L2(id int not null primary key auto_increment,salary decimal(8,2))default charset&#x3D;utf8;Query OK, 0 rows affected (0.03 sec)mysql&gt; insert into L2(salary) values(1.28);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into L2(salary) values(5.289);Query OK, 1 row affected, 1 warning (0.00 sec)mysql&gt; insert into L2(salary) values(5.282);Query OK, 1 row affected, 1 warning (0.00 sec)mysql&gt; insert into L2(salary) values(512132.28);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into L2(salary) values(512132.283);Query OK, 1 row affected, 1 warning (0.00 sec)mysql&gt; select * from L2;+----+-----------+| id | salary    |+----+-----------+|  1 |      1.28 ||  2 |      5.29 ||  3 |      5.28 ||  4 | 512132.28 ||  5 | 512132.28 |+----+-----------+5 rows in set (0.00 sec)mysql&gt; insert into L2(salary) values(5121321.283);ERROR 1264 (22003): Out of range value for column &#39;salary&#39; at row 1mysql&gt;</code></pre></li><li><p><code>FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]</code></p><pre class="language-none"><code class="language-none">单精度浮点数，非准确小数值，m是数字总个数，d是小数点后个数。</code></pre></li><li><p><code>DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]</code></p><pre class="language-none"><code class="language-none">双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。</code></pre></li><li><p><code>char(m)</code></p><pre class="language-none"><code class="language-none">定长字符串，m代表字符串的长度，最多可容纳255个字符。定长的体现：即使内容长度小于m，也会占用m长度。例如：char(5)，数据是：yes，底层也会占用5个字符；如果超出m长度限制（默认MySQL是严格模式，所以会报错）。    如果在配置文件中加入如下配置，        sql-mode&#x3D;&quot;NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;    保存并重启，此时MySQL则是非严格模式，此时超过长度则自动截断（不报错）。。注意：默认底层存储是固定的长度（不够则用空格补齐），但是查询数据时，会自动将空白去除。 如果想要保留空白，在sql-mode中加入 PAD_CHAR_TO_FULL_LENGTH 即可。查看模式sql-mode，执行命令：show variables  like &#39;sql_mode&#39;;一般适用于：固定长度的内容。create table L3(    id int not null primary key auto_increment,    name varchar(5),    depart char(3))default charset&#x3D;utf8;insert into L3(name,depart) values(&quot;alexsb&quot;,&quot;sbalex&quot;);</code></pre></li><li><p><code>varchar(m)</code></p><pre class="language-none"><code class="language-none">变长字符串，m代表字符串的长度，最多可容纳65535个字节。变长的体现：内容小于m时，会按照真实数据长度存储；如果超出m长度限制（（默认MySQL是严格模式，所以会报错）。    如果在配置文件中加入如下配置，        sql-mode&#x3D;&quot;NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;    保存并重启，此时MySQL则是非严格模式，此时超过长度则自动截断（不报错）。例如：create table L3(    id int not null primary key auto_increment,    name varchar(5),    depart char(3))default charset&#x3D;utf8;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">mysql&gt; create table L3(id int not null primary key auto_increment,name varchar(5),depart char(3))default charset&#x3D;utf8;Query OK, 0 rows affected (0.03 sec)-- 插入多行mysql&gt; insert into L3(name,depart) values(&quot;wu&quot;,&quot;WU&quot;),(&quot;wupei&quot;,&quot;ALS&quot;);Query OK, 2 rows affected (0.00 sec)Records: 2  Duplicates: 0  Warnings: 0mysql&gt; select * from L3;+----+-------+--------+| id | name  | depart |+----+-------+--------+|  1 | wu    | WU     ||  2 | wupei | ALS    |+----+-------+--------+2 rows in set (0.00 sec)-- 非严格模式下，不会报错。mysql&gt; insert into L3(name,depart) values(&quot;wupeiqi&quot;,&quot;ALS&quot;);ERROR 1406 (22001): Data too long for column &#39;name&#39; at row 1mysql&gt; insert into L3(name,depart) values(&quot;wupei&quot;,&quot;ALSB&quot;);ERROR 1406 (22001): Data too long for column &#39;depart&#39; at row 1mysql&gt;-- 如果 sql-mode 中加入了 PAD_CHAR_TO_FULL_LENGTH ，则查询时char时空白会保留。mysql&gt; select name,length(name),depart,length(depart) from L3;+-------+--------------+--------+----------------+| name  | length(name) | depart | length(depart) |+-------+--------------+--------+----------------+| wu    |            2 | WU     |              3 || wupei |            5 | ALS    |              3 |+-------+--------------+--------+----------------+4 rows in set (0.00 sec)mysql&gt;</code></pre></li><li><p><code>text</code></p><pre class="language-none"><code class="language-none">text数据类型用于保存变长的大字符串，可以组多到65535 (2**16 − 1)个字符。一般情况下，长文本会用text类型。例如：文章、新闻等。</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create table L4(id int not null primary key auto_increment,    title varchar(128),content text)default charset&#x3D;utf8;</code></pre></li><li><p><code>mediumtext</code></p><pre class="language-none"><code class="language-none">A TEXT column with a maximum length of 16,777,215 (2**24 − 1) characters.</code></pre></li><li><p><code>longtext</code></p><pre class="language-none"><code class="language-none">A TEXT column with a maximum length of 4,294,967,295 or 4GB (2**32 − 1)</code></pre></li><li><p><code>datetime</code></p><pre class="language-none"><code class="language-none">YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59）</code></pre></li><li><p><code>timestamp</code></p><pre class="language-none"><code class="language-none">YYYY-MM-DD HH:MM:SS（1970-01-01 00:00:00&#x2F;2037年）</code></pre><pre class="language-none"><code class="language-none">对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储，查询时，将其又转化为客户端当前时区进行返回。对于DATETIME，不做任何改变，原样输入和输出。</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">mysql&gt; create table L5(    -&gt; id int not null primary key auto_increment,    -&gt; dt datetime,    -&gt; tt timestamp    -&gt; )default charset&#x3D;utf8;Query OK, 0 rows affected (0.03 sec)mysql&gt; insert into L5(dt,tt) values(&quot;2025-11-11 11:11:44&quot;, &quot;2025-11-11 11:11:44&quot;);mysql&gt; select * from L5;+----+---------------------+---------------------+| id | dt                  | tt                  |+----+---------------------+---------------------+|  1 | 2025-11-11 11:11:44 | 2025-11-11 11:11:44 |+----+---------------------+---------------------+1 row in set (0.00 sec)mysql&gt; show variables like &#39;%time_zone%&#39;;+------------------+--------+| Variable_name    | Value  |+------------------+--------+| system_time_zone | CST    | | time_zone        | SYSTEM |+------------------+--------+2 rows in set (0.00 sec)-- “CST”指的是MySQL所在主机的系统时间，是中国标准时间的缩写，China Standard Time UT+8:00mysql&gt; set time_zone&#x3D;&#39;+0:00&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like &#39;%time_zone%&#39;;+------------------+--------+| Variable_name    | Value  |+------------------+--------+| system_time_zone | CST    || time_zone        | +00:00 |+------------------+--------+2 rows in set (0.01 sec)mysql&gt; select * from L5;+----+---------------------+---------------------+| id | dt                  | tt                  |+----+---------------------+---------------------+|  1 | 2025-11-11 11:11:44 | 2025-11-11 03:11:44 |+----+---------------------+---------------------+1 row in set (0.00 sec)</code></pre></li><li><p><code>date</code></p><pre class="language-none"><code class="language-none">YYYY-MM-DD（1000-01-01&#x2F;9999-12-31）</code></pre></li><li><p><code>time</code></p><pre class="language-none"><code class="language-none">HH:MM:SS（&#39;-838:59:59&#39;&#x2F;&#39;838:59:59&#39;）</code></pre></li></ul><p>MySQL还有很多其他的数据类型，例如：<em>set、enum、TinyBlob、Blob、MediumBlob、LongBlob 等</em>，详细见官方文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/data-types.html">https://dev.mysql.com/doc/refman/5.7/en/data-types.html</a></p></li></ul><p>上述就是关于数据表的一些基本操作。</p><h4 id="3-2-MySQL代码操作"><a href="#3-2-MySQL代码操作" class="headerlink" title="3.2 MySQL代码操作"></a>3.2 MySQL代码操作</h4><p>基于Python去连接MySQL之后，想要进行数据表的管理的话，发送的指令其实都是相同的，例如：</p><pre class="language-sql" data-language="sql"><code class="language-sql">import pymysql# 连接MySQLconn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, charset&#x3D;&quot;utf8&quot;)cursor &#x3D; conn.cursor()# 1. 创建数据库&quot;&quot;&quot;cursor.execute(&quot;create database db4 default charset utf8 collate utf8_general_ci&quot;)conn.commit()&quot;&quot;&quot;# 2. 进入数据库、查看数据表&quot;&quot;&quot;cursor.execute(&quot;use db4&quot;)cursor.execute(&quot;show tables&quot;)result &#x3D; cursor.fetchall()print(result)&quot;&quot;&quot;# 3. 进入数据库创建表cursor.execute(&quot;use db4&quot;)sql &#x3D; &quot;&quot;&quot;create table L4(    id int not null primary key auto_increment,    title varchar(128),    content text,    ctime datetime)default charset&#x3D;utf8;&quot;&quot;&quot;cursor.execute(sql)conn.commit()# 4. 查看数据库中的表&quot;&quot;&quot;cursor.execute(&quot;show tables&quot;)result &#x3D; cursor.fetchall()print(result)&quot;&quot;&quot;# 5. 其他 drop table... 略过# 关闭连接cursor.close()conn.close()</code></pre><h3 id="4-数据行"><a href="#4-数据行" class="headerlink" title="4.数据行"></a>4.数据行</h3><p>当数据库和数据表创建完成之后，就需要对数据表中的内容进行：增、删、改、查了。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210511102323966.png" class="" title="image-20210511102323966"><h4 id="4-1-内置客户端操作"><a href="#4-1-内置客户端操作" class="headerlink" title="4.1 内置客户端操作"></a>4.1 内置客户端操作</h4><p>数据行操作的相关SQL语句（指令）如下：</p><ul><li><p>新<strong>增</strong>数据</p><pre class="language-none"><code class="language-none">insert into 表名 (列名,列名,列名) values(对应列的值,对应列的值,对应列的值);insert into 表名 values(NULL,对应列的值,default);  -- 对于自增列和有默认值的列传入NULL和default</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">insert into tb1(name,password) values(&#39;武沛齐&#39;,&#39;123123&#39;);insert into tb1(name,password) values(&#39;武沛齐&#39;,&#39;123123&#39;),(&#39;alex&#39;,&#39;123&#39;); -- 新增多行数据insert into tb1 values(&#39;武沛齐&#39;,&#39;123123&#39;),(&#39;alex&#39;,&#39;123&#39;); -- 如果表中只有2列insert into class values(NULL,&#39;三年二班&#39;),(NULL,&#39;一年三班&#39;),(NULL,&#39;三年一班&#39;)</code></pre></li><li><p><strong>删</strong>除数据</p><pre class="language-sql" data-language="sql"><code class="language-sql">delete from 表名;delete from 表名 where 条件;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">delete from tb1;delete from tb1 where name&#x3D;&quot;wupeiqi&quot;;delete from tb1 where name&#x3D;&quot;wupeiqi&quot; and password&#x3D;&quot;123&quot;;delete from tb1 where id&gt;9;</code></pre></li><li><p>修<strong>改</strong>数据</p><pre class="language-sql" data-language="sql"><code class="language-sql">update 表名 set 列名&#x3D;值;update 表名 set 列名&#x3D;值 where 条件;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">update tb1 set name&#x3D;&quot;wupeiqi&quot;;update tb1 set name&#x3D;&quot;wupeiqi&quot; where id&#x3D;1;update tb1 set age&#x3D;age+1;  -- 整型update tb1 set age&#x3D;age+1 where id&#x3D;2;update L3 set name&#x3D;concat(name,&quot;db&quot;);update L3 set name&#x3D;concat(name,&quot;123&quot;)  where id&#x3D;2;  -- concat一个函数，可以拼接字符串</code></pre></li><li><p><strong>查</strong>询数据</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from 表名;select 列名,列名,列名 from 表名;select 列名,列名 as 别名,列名 from 表名;select * from 表名 where 条件;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select * from tb1;select id,name,age from tb1;select id,name as N,age, from tb1;select id,name as N,age, 111 from tb1;select * from tb1 where id &#x3D; 1;select * from tb1 where id &gt; 1;select * from tb1 where id !&#x3D; 1;select * from tb1 where name&#x3D;&quot;wupeiqi&quot; and password&#x3D;&quot;123&quot;;</code></pre></li></ul><h4 id="4-2-Python代码操作"><a href="#4-2-Python代码操作" class="headerlink" title="4.2 Python代码操作"></a>4.2 Python代码操作</h4><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210511102323966.png" class="" title="image-20210511102323966"><pre class="language-python" data-language="python"><code class="language-python">import pymysql# 连接MySQL，自动执行 use userdb; -- 进入数据库conn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, charset&#x3D;&quot;utf8&quot;, db&#x3D;&#39;userdb&#39;)cursor &#x3D; conn.cursor()# 1.新增（需commit）&quot;&quot;&quot;cursor.execute(&quot;insert into tb1(name,password) values(&#39;武沛齐&#39;,&#39;123123&#39;)&quot;)conn.commit()&quot;&quot;&quot;# 2.删除（需commit）&quot;&quot;&quot;cursor.execute(&quot;delete from tb1 where id&#x3D;1&quot;)conn.commit()&quot;&quot;&quot;# 3.修改（需commit)&quot;&quot;&quot;cursor.execute(&quot;update tb1 set name&#x3D;&#39;xx&#39; where id&#x3D;1&quot;)conn.commit()&quot;&quot;&quot;# 4.查询&quot;&quot;&quot;cursor.execute(&quot;select * from tb where id&gt;10&quot;)data &#x3D; cursor.fetchone() # cursor.fetchall()print(data)&quot;&quot;&quot;# 关闭连接cursor.close()conn.close()</code></pre><p>其实在真正做项目开发时，流程如下：</p><ul><li>第一步：根据项目的功能来设计相应的 数据库 &amp; 表结构（不会经常变动，在项目设计之初就确定好了）。</li><li>第二步：操作表结构中的数据，已达到实现业务逻辑的目的。</li></ul><p><strong>例如：实现一个 用户管理系统。</strong></p><p>先使用MySQL自带的客户端创建相关 数据库和表结构（相当于先创建好Excel结构）。</p><ul><li>第一步：登录mysql</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">mysql -u root -pEnter password: root123</code></pre><ul><li>第二步：创建并进入数据库<code>usersdb</code></li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">create database usersdb default charset utf8 collate utf8_general_ci;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">use usersdb;</code></pre><ul><li>第三步：创建数据表table</li></ul><p></p><pre class="language-sql" data-language="sql"><code class="language-sql">create table users(id int not null primary key auto_increment,    name varchar(32),password varchar(64))default charset&#x3D;utf8;</code></pre><p><font color="#dd0000"> <strong>注意：前三步一般在终端完成</strong></font></p><ul><li>第四步：再在程序中执行编写相应的功能实现 注册、登录 等功能。</li></ul><pre class="language-python" data-language="python"><code class="language-python">import pymysqldef register():    print(&quot;用户注册&quot;)    user &#x3D; input(&quot;请输入用户名：&quot;) # alex    password &#x3D; input(&quot;请输入密码：&quot;) # sb    # 连接指定数据    conn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, charset&#x3D;&quot;utf8&quot;, db&#x3D;&quot;usersdb&quot;)    cursor &#x3D; conn.cursor()    # 执行SQL语句（有SQL注入风险，稍后讲解）    # sql &#x3D; &#39;insert into users(name,password)values(&quot;alex&quot;,&quot;sb&quot;)&#39;    sql &#x3D; &#39;insert into users(name,password) values(&quot;&#123;&#125;&quot;,&quot;&#123;&#125;&quot;)&#39;.format(user, password)        cursor.execute(sql)    conn.commit()    # 关闭数据库连接    cursor.close()    conn.close()    print(&quot;注册成功，用户名：&#123;&#125;,密码:&#123;&#125;&quot;.format(user, password))def login():    print(&quot;用户登录&quot;)    user &#x3D; input(&quot;请输入用户名：&quot;)    password &#x3D; input(&quot;请输入密码：&quot;)    # 连接指定数据    conn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, charset&#x3D;&quot;utf8&quot;, db&#x3D;&quot;usersdb&quot;)    cursor &#x3D; conn.cursor()    # 执行SQL语句（有SQL注入风险，稍后讲解）    # sql &#x3D; select * from users where name&#x3D;&#39;wupeiqi&#39; and password&#x3D;&#39;123&#39;    sql &#x3D; &quot;select * from users where name&#x3D;&#39;&#123;&#125;&#39; and password&#x3D;&#39;&#123;&#125;&#39;&quot;.format(user, password)    cursor.execute(sql)        result &#x3D; cursor.fetchone() # 去向mysql获取第一个结果并返回    # cursor.fetchone()返回结果由以下两种情况    # None    # 返回匹配结果的整个列的元组 (id, name, password)如：(1,wupeiqi,123)            # 关闭数据库连接    cursor.close()    conn.close()    if result:        print(&quot;登录成功&quot;, result)    else:        print(&quot;登录失败&quot;)def run():    choice &#x3D; input(&quot;1.注册；2.登录&quot;)    if choice &#x3D;&#x3D; &#39;1&#39;:        register()    elif choice &#x3D;&#x3D; &#39;2&#39;:        login()    else:        print(&quot;输入错误&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    run()</code></pre><p>So，你会发现， 在项目开发时，数据库 &amp; 数据表 的操作其实就做那么一次，最最常写的还是 对数据行 的操作。</p><h3 id="5-关于SQL注入"><a href="#5-关于SQL注入" class="headerlink" title="5.关于SQL注入"></a>5.关于SQL注入</h3><p>假如，你开发了一个用户认证的系统，应该用户登录成功后才能正确的返回相应的用户结果。 </p><pre class="language-python" data-language="python"><code class="language-python">import pymysql# 输入用户名和密码user &#x3D; input(&quot;请输入用户名：&quot;) # &#39; or 1&#x3D;1 -- pwd &#x3D; input(&quot;请输入密码：&quot;) # 123conn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, charset&#x3D;&quot;utf8&quot;,db&#x3D;&#39;usersdb&#39;)cursor &#x3D; conn.cursor()# 基于字符串格式化来 拼接SQL语句# sql &#x3D; &quot;select * from users where name&#x3D;&#39;alex&#39; and password&#x3D;&#39;123&#39;&quot;# sql &#x3D; &quot;select * from users where name&#x3D;&#39;&#39; or 1&#x3D;1 -- &#39; and password&#x3D;&#39;123&#39;&quot;sql &#x3D; &quot;select * from users where name&#x3D;&#39;&#123;&#125;&#39; and password&#x3D;&#39;&#123;&#125;&#39;&quot;.format(user, pwd)cursor.execute(sql)result &#x3D; cursor.fetchone()print(result) # None，不是Nonecursor.close()conn.close()</code></pre><p>如果用户在输入user时，输入了：   <code>&#39; or 1=1 --  </code>    ，这样即使用户输入的密码不存在，也会可以通过验证。</p><p><strong>为什么呢？</strong></p><p>因为在SQL拼接时，拼接后的结果是：</p><pre class="language-none"><code class="language-none">select * from users where name&#x3D;&#39;&#39; or 1&#x3D;1 -- &#39; and password&#x3D;&#39;123&#39;</code></pre><p>注意：在MySQL中 <code>--</code> 表示注释。</p><p><strong>那么，在Python开发中 如何来避免SQL注入呢？</strong></p><p>切记，SQL语句不要在使用python的字符串格式化，而是使用pymysql的execute方法。</p><pre class="language-python" data-language="python"><code class="language-python">import pymysql# 输入用户名和密码user &#x3D; input(&quot;请输入用户名：&quot;)pwd &#x3D; input(&quot;请输入密码：&quot;)conn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, charset&#x3D;&quot;utf8&quot;, db&#x3D;&#39;userdb&#39;)cursor &#x3D; conn.cursor()cursor.execute(&quot;select * from users where name&#x3D;%s and password&#x3D;%s&quot;, [user, pwd])# 或# cursor.execute(&quot;select * from users where name&#x3D;%(n1)s and password&#x3D;%(n2)s&quot;, &#123;&quot;n1&quot;: user, &#39;n2&#39;: pwd&#125;)result &#x3D; cursor.fetchone()print(result)cursor.close()conn.close()</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210508102020237.png" class="" title="image-20210508102020237"><p>除了 【第5步 用户授权】以外，现在使用的是默认root账户（拥有最大权限），上述所有的过程已讲解完毕。</p><p>本节内容大家需要掌握：</p><ul><li>安装和启动MySQL</li><li>SQL语句：<ul><li>数据库操作</li><li>表操作</li><li>数据行操作</li></ul></li><li>基于Python操作MySQL</li><li>注意SQL注入的问题</li></ul><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol><li><p>根据要求 创建表 结构并编写相应的SQL语句（基于MySQL自带客户端操作）</p><table><thead><tr><th>列名</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>不为空 &amp; 自增 &amp; 主键</td></tr><tr><td>name</td><td>varchar(32)</td><td>不为空</td></tr><tr><td>password</td><td>varchar(64)</td><td>不为空</td></tr><tr><td>gender</td><td>char(1)</td><td>不为空，支持：男、女</td></tr><tr><td>email</td><td>varchar(64)</td><td>可以为空</td></tr><tr><td>amount</td><td>decimal(10,2)</td><td>不为空 &amp; 默认值为 0</td></tr><tr><td>ctime</td><td>datetime</td><td>新增时的时间<br />提示：可基于datetime模块实现</td></tr></tbody></table><ul><li><p>根据上述表的要求创建相应的数据和表结构（注意编码）。</p></li><li><p>任意插入5条数据。</p></li><li><p>将 <code>id&lt;3</code>的所有人的性别改为  男。</p></li><li><p>查询余额 <code>amount&gt;1000</code>的所有用户。</p></li><li><p>让每个人的余额在自己原的基础上 +1000 。</p></li><li><p>删除性别为男的所有数据。</p></li><li><p>通过Python代码实现上述除了第一个以外的操作。</p><pre class="language-none"><code class="language-none">插入5条数据时，ctime那一列不要自己写“2021-11-11.。。” 而是使用datatime模块生成当前时间。</code></pre></li></ul><p>终端：</p><pre class="language-sql" data-language="sql"><code class="language-sql"># 创建并打开day25数据库create database day25 default charset utf8 collate utf8_general_ci;use day25# 创建task1数据表create table task1(id int not null primary key auto_increment,    name varchar(32) not null,password varchar(64) not null,    gender char(1) not null,    email varchar(64),    amount decimal(10,2) not null default 0,    ctime datetime)default charset&#x3D;utf8;desc task1; -- 查看数据表是否创建正确# 插入数据insert into task1 values(1,&#39;小赵&#39;,&#39;111&#39;,&#39;男&#39;,&#39;111@qq.com&#39;,&#39;12000.445&#39;,&#39;2022-6-26 09:37:50&#39;),(2,&#39;小孙&#39;,&#39;222&#39;,&#39;女&#39;,&#39;222@qq.com&#39;,&#39;15000.6788&#39;,&#39;2022-6-26 09:40:23&#39;),(3,&#39;小李&#39;,&#39;333&#39;,&#39;女&#39;,&#39;333@qq.com&#39;,&#39;899.93&#39;,&#39;2022-6-26 09:45:23&#39;),(4,&#39;小李&#39;,&#39;444&#39;,&#39;男&#39;,&#39;444@qq.com&#39;,&#39;444.445&#39;,&#39;2022-6-26 09:35:50&#39;),(5,&#39;小周&#39;,&#39;555&#39;,&#39;男&#39;,&#39;555@qq.com&#39;,&#39;1200.459&#39;,&#39;2022-6-26 09:37:50&#39;); select * from task1; -- 查看数据行是否插入正确# 将 id&lt;3的所有人的性别改为  男。update task1 set gender&#x3D;&#39;男&#39; where id&lt;3;select * from task1; -- 查看数据行是否修改正确# 查询余额 amount&gt;1000的所有用户select * from task1 where amount&gt;1000; -- 看满足要求的数据的所有列select amount from task1 where amount&gt;1000;  -- 只看满足要求的数据的amount列select * from task1; -- 查看数据行是否查询正确# 让每个人的余额在自己原的基础上 +1000 。update task1 set amount&#x3D;amount+1000;select * from task1; -- 查看数据行是否修改正确# 删除性别为男的所有数据。delete from task1 where gender&#x3D;&#39;男&#39;;select * from task1; -- 查看数据行是否删除正确</code></pre></li><li><p>编写脚本实现将 csv 文件的内容录入到 MySQL 数据库中。<br>要求：自己创建一个自增列作为主键（不要用csv文件中的第一列作为主键）。</p><pre class="language-none"><code class="language-none">1715046,河北大学取消考试学生紧急离校,老师:回不了家的到老师家过年,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715046-15562045_adpkg-ad_hd.mp41715020,重庆两口子因琐事吵架，男子怒将自家车推进涪江,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715020-15561817_adpkg-ad_hd.mp41715031,成都九峰山因雪景引游客暴增，致垃圾遍地野猴觅食,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715031-15561980_adpkg-ad_hd.mp41715014,女子子宫摘除32年后CT报告称未见异常，医生：贴的模版忘删了,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715014-15561686_adpkg-ad_hd.mp41715025,监控画面曝光！甘肃天水一公交车与救护车相撞后坠桥,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715025-15561875_adpkg-ad_hd.mp41715010,男子称退伍后发现被贷款100万：征信逾期数十次，非自己签名,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715010-15561845_adpkg-ad_hd.mp41715007,东北老交警零下43度执勤落下老寒腿:穿2斤重棉裤,已习以为常,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715007-15561958_adpkg-ad_hd.mp41715011,女教师公寓熟睡被同事弟弟连砍数刀：全身刀疤，不敢告诉父母,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715011-15561664_adpkg-ad_hd.mp41714970,网曝江西一村庄现两千平违建，房主回应：建给村里当文化中心,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714970-15561752_adpkg-ad_hd.mp41715006,河南一新建足球场内惊现坟墓，官方：会尽快迁坟,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715006-15561679_adpkg-ad_hd.mp41715009,老师收到毕业24年学生送的定制台历：他高考失利，我开导过,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715009-15561658_adpkg-ad_hd.mp41715000,尚德机构回应未兑现宝马奖励：名单仍在确认中，会负责到底,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715000-15561545_adpkg-ad_hd.mp41714993,沈阳重点管控区日常产90吨生活垃圾，重点疫点垃圾由专人运走,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714993-15561434_adpkg-ad_hd.mp41714995,消费者称遭移动外呼10088套路换套餐，客服致歉：口径有问题,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714995-1427-174135_adpkg-ad_hd.mp41714979,泪流满面！武警相隔两千公里与妻子隔屏举行婚礼,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714979-15561542_adpkg-ad_hd.mp41714992,村民结婚两男子拄拐上门要钱：给少了不走，反问&quot;咋拿得出手&quot;,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714992-15561429_adpkg-ad_hd.mp41714457,36年嫌疑人：儿女被骂“杀人犯的孩子”，不想把骂名带进棺材,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714457-1491-170515_adpkg-ad_hd.mp41714981,男子偷手机被发现挣脱失主逃跑，执勤辅警狂追八百米擒获,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714981-99-172939_adpkg-ad_hd.mp41714977,八旬老太捡拾垃圾成瘾，堆满楼道院子漫进邻居家,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714977-15561306_adpkg-ad_hd.mp41714972,昆明一楼盘消防喷淋离地仅2米1，业主吐槽：直接当喷头用,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714972-15561247_adpkg-ad_hd.mp41714973,居民家浓烟弥漫邻居敲门不应，民警赶来一看是屋主在熏腊肉,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714973-15561249_adpkg-ad_hd.mp41714966,石家庄有超市停业，学校紧急放假，学生：下午考试被临时取消,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714966-15561248_adpkg-ad_hd.mp41714902,杭州地铁7号线施工大揭秘：940天完成近40公里地铁线,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714902-15561394_adpkg-ad_hd.mp41714928,沈阳已设置重点管控区域，大连志愿者挨家挨户配送生活物资,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714928-15561018_adpkg-ad_hd.mp41714950,女孩考第一溺亡双胞胎姐姐不吃不喝，家属诉求：给予心理疏导,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714950-15561100_adpkg-ad_hd.mp41714924,70万1针特效药降价，2岁患儿母亲哽咽：会拼全力救孩子,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714924-58-162201_adpkg-ad_hd.mp41714930,贵州大叔嫁女陪嫁28万现金和一套房：儿子结婚只花了十几万,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714930-15561017_adpkg-ad_hd.mp41714927,张家口云顶滑雪场通报一滑雪者摔倒身亡：警方已介入,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714927-15560963_adpkg-ad_hd.mp41714926,邢台全面进入战时状态，小区进出需要健康码,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714926-15560829_adpkg-ad_hd.mp41714918,石家庄多个小区采取封闭管理：发现阳性检测者，全员核酸检测,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714918-15560835_adpkg-ad_hd.mp41714693,兰大女生当兵2年后重返校园：学会自律，珍惜在校时光,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714693-15560791_adpkg-ad_hd.mp41714920,猴哥尝到投喂甜头赖老太家不走，逗鸡毁菜气到村民报警,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714920-15560793_adpkg-ad_hd.mp41714916,沈阳确诊出车司机搭载的抚顺3名乘客全部找到，核酸均为阴性,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714916-15560758_adpkg-ad_hd.mp41714894,轿车被48米建筑垃圾围堵三个月，车主无法用车叫苦不迭,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714894-15560731_adpkg-ad_hd.mp41714861,考第一被质疑后溺亡女孩同学：她自尊心强，曾说被怀疑作弊,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714861-15560701_adpkg-ad_hd.mp41714886,东北汉子冲进火场救人被熏成黑脸：差几秒，我就倒在里面了,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714886-15560659_adpkg-ad_hd.mp41714908,探访石家庄疫情高风险地区：部分村庄封村，外村人一律不让进,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714908-15560638_adpkg-ad_hd.mp41714906,“北京时间”产生于西安，科学家解读选址考量因素,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714906-15560549_adpkg-ad_hd.mp41714907,16人聚餐吃了800元无人结账，老板询问反遭怼：多大点事儿,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714907-15560637_adpkg-ad_hd.mp41714892,重庆一地铁站出口建在坡顶，居民：期待未来的变化,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714892-15560550_adpkg-ad_hd.mp41714900,河北南宫一小区发现高度疑似密接人员，小区全面封闭只进不出,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714900-15560548_adpkg-ad_hd.mp41714901,杭州运河边8平米小书摊开了13年，店主兼职拉货补贴,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714901-15560544_adpkg-ad_hd.mp41714877,河南商丘鹦鹉卖家被追刑责，养殖户：不敢卖不敢放，放也犯法,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714877-15560499_adpkg-ad_hd.mp41714895,石家庄小果庄村1天增加8例确诊病例，为全国唯一高风险地区,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714895-15560459_adpkg-ad_hd.mp41714801,48岁女教师重新高考学法律：直接进入老年生活是种损失,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714801-15560352_adpkg-ad_hd.mp41714873,不认失散聋哑儿夫妻已接走儿子，养父：两验DNA，归属没说清,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714873-15560356_adpkg-ad_hd.mp41714846,7岁男童煤气中毒脑死亡，父母含泪为其捐器官救同龄人,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714846-15560326_adpkg-ad_hd.mp41714875,连夜出发！衡水110名护士紧急集结支援中风险地区,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714875-15560268_adpkg-ad_hd.mp41713843,打满全场丨院感专家李素英回忆援鄂：90后00后医护最让我感动,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210104&#x2F;cont-1713843-15559433_adpkg-ad_hd.mp41714869,河北新增14例确诊30例无症状，石家庄一村庄调整为高风险地区,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714869-15560218_adpkg-ad_hd.mp41714862,应急部披露襄汾饭店坍塌致29死细节：8次违规扩建，监管不严,https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1714862-15560157_adpkg-ad_hd.mp4</code></pre></li></ol><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;使用python自动将db中的csv格式数据录入mysql：&quot;&quot;&quot;import pymysqlimport re# 创建连接：连接MySQL，自动执行 use userdb; -- 使用创建好的day25数据库conn &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;root123&#39;, charset&#x3D;&quot;utf8&quot;, db&#x3D;&#39;day25&#39;)cursor &#x3D; conn.cursor()  # 创建游标# 创建数据表sql &#x3D; &quot;&quot;&quot;create table input_csv(id int not null primary key auto_increment,  vedio_id int(7) unsigned not null,  title text not null,url varchar(200) not null)default charset&#x3D;utf8;&quot;&quot;&quot;cursor.execute(sql)conn.commit()# 查看数据表是否创建正确cursor.execute(&quot;desc input_csv&quot;)data &#x3D; cursor.fetchall()print(data)file_obj &#x3D; open(&#39;db.csv&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;)conn.commit()for line in file_obj:    line &#x3D; line.strip()    file_id &#x3D; re.match(&#39;^\d&#123;7&#125;&#39;, line).group()    file_title &#x3D; &#39;&#39;.join(re.findall(&#39;([\u0391-\uFFE5]+)&#39;, line))    file_url &#x3D; re.findall(&#39;https.+&#39;, line)[0]    # print(file_id, file_title, file_url)    # 拼接sql字符串    sql &#x3D; &#39;insert into input_csv values(NULL, &quot;&#123;&#125;&quot;,&quot;&#123;&#125;&quot;, &quot;&#123;&#125;&quot;)&#39;.format(file_id, file_title, file_url)    cursor.execute(sql)    conn.commit()file_obj.close()</code></pre><h2 id="二十六、必备SQL和表关系及授权"><a href="#二十六、必备SQL和表关系及授权" class="headerlink" title="二十六、必备SQL和表关系及授权"></a>二十六、必备SQL和表关系及授权</h2><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210530161018798.png" class=""><p>课程目标：掌握开发中最常见的SQL语句和表关系及授权相关知识点。</p><p>课程概要：</p><ul><li><p>必备SQL（8个必备）</p></li><li><p>表关系</p></li><li><p>授权</p></li></ul><h3 id="1-必备SQL语句"><a href="#1-必备SQL语句" class="headerlink" title="1. 必备SQL语句"></a>1. 必备SQL语句</h3><p>上一节讲解了最基础SQL语句：增删改查，其实在日常的开发中还有很多必备的SQL语句。这一部分的SQL语句都是围绕着对 <font color="#dd0000"> <strong>表中的数据进行操作的。</strong></font></p><p>提示：今天的所有操作我都只会在 MySQL自带的客户端工具上进行操作。</p><p>例如：现在创建如下两张表。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210517184555990.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">create database day26 default charset utf8 collate utf8_general_ci;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create table depart(id int not null auto_increment primary key,    title varchar(16) not null)default charset&#x3D;utf8;create table info(id int not null auto_increment primary key,    name varchar(16) not null,    email varchar(32) not null,    age int,    depart_id int)default charset&#x3D;utf8;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">insert into depart(title) values(&quot;开发&quot;),(&quot;运营&quot;),(&quot;销售&quot;);insert into info(name,email,age,depart_id) values(&quot;武沛齐&quot;,&quot;wupeiqi@live.com&quot;,19,1);insert into info(name,email,age,depart_id) values(&quot;于超&quot;,&quot;pyyu@live.com&quot;,49,1);insert into info(name,email,age,depart_id) values(&quot;alex&quot;,&quot;alex@live.com&quot;,9,2);insert into info(name,email,age,depart_id) values(&quot;tony&quot;,&quot;tony@live.com&quot;,29,1);insert into info(name,email,age,depart_id) values(&quot;kelly&quot;,&quot;kelly@live.com&quot;,99,3);insert into info(name,email,age,depart_id) values(&quot;james&quot;,&quot;james@live.com&quot;,49,1);insert into info(name,email,age,depart_id) values(&quot;李杰&quot;,&quot;lijie@live.com&quot;,49,1);</code></pre><h4 id="1-1-条件"><a href="#1-1-条件" class="headerlink" title="1.1 条件"></a>1.1 条件</h4><p>根据条件搜索结果。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210517184600205.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info where age &gt; 30;select * from info where id &gt; 1;select * from info where id &#x3D; 1;select * from info where id &gt;&#x3D; 1;select * from info where id !&#x3D; 1;select * from info where id between 2 and 4;   -- id大于等于2、且小于等于4select * from info where name &#x3D; &#39;武沛齐&#39; and age &#x3D; 19;select * from info where name &#x3D; &#39;alex&#39; or age &#x3D; 49;select * from info where (name &#x3D; &#39;李杰&#39; or email&#x3D;&quot;pyyu@live.com&quot;)  and age&#x3D;49;select * from info where id in (1,4,6);select * from info where id not in (1,4,6);select * from info where id in (select id from depart);# select * from info where id in (1,2,3);# exists：select * from depart where id&#x3D;5，去查数据是否存在，如果存在，如果不存在。select * from info where exists (select * from depart where id&#x3D;5);select * from info where not exists (select * from depart where id&#x3D;5);select * from (select * from info where id&gt;2) as T where age &gt; 10;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info where info.id &gt; 10;  -- 建议使用这种方法select * from info where id &gt; 10;</code></pre><h4 id="1-2-通配符"><a href="#1-2-通配符" class="headerlink" title="1.2 通配符"></a>1.2 通配符</h4><p>一般用于模糊搜索。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210517184600205.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info where name like &quot;%沛%&quot;;select * from info where name like &quot;%沛&quot;;select * from info where email like &quot;%@live.com&quot;;select * from info where name like &quot;武%齐&quot;;select * from info where name like &quot;k%y&quot;;select * from info where email like &quot;wupeiqi%&quot;;select * from info where email like &quot;_@live.com&quot;;select * from info where email like &quot;_upeiqi@live.com&quot;;select * from info where email like &quot;__peiqi@live.com&quot;;select * from info where email like &quot;__peiqi_live.co_&quot;;</code></pre><p> <font color="#dd0000"> <strong>注意： 。</strong></font></p><h4 id="1-3-映射"><a href="#1-3-映射" class="headerlink" title="1.3 映射"></a>1.3 映射</h4><p>想要获取的列。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210517184600205.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info;select id, namefrom info;select id, name as NM from info;select id, name as NM, 123  from info;注意：少些select * ,按自己需求的列查询。select id,name,666 as num,( select max(id) from depart ) as mid, -- max&#x2F;min&#x2F;sum-- 等价于-- 3 as mid 此处的3为动态查询出来的( select min(id) from depart) as nid, -- max&#x2F;min&#x2F;sumagefrom info;</code></pre><p>注意：<code>( ) as nid</code> 括号中只能放一行数据</p><pre class="language-sql" data-language="sql"><code class="language-sql">select id,name,( select title from depart where depart.id&#x3D;info.depart_id) as x1from info;# 注意：效率很低select id,name,( select title from depart where depart.id&#x3D;info.depart_id) as x1,( select title from depart where depart.id&#x3D;info.id) as x2from info;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select id,name,case depart_id when 1 then &quot;第1部门&quot; end v1from info;select id,name,case depart_id when 1 then &quot;第1部门&quot; else &quot;其他&quot; end v2from info;select id,name,case depart_id when 1 then &quot;第1部门&quot; end v1,case depart_id when 1 then &quot;第1部门&quot; else &quot;其他&quot; end v2,case depart_id when 1 then &quot;第1部门&quot; when 2 then &quot;第2部门&quot; else &quot;其他&quot; end v3,case when age&lt;18 then &quot;少年&quot; end v4,case when age&lt;18 then &quot;少年&quot; else &quot;油腻男&quot; end v5,case when age&lt;18 then &quot;少年&quot; when age&lt;30 then &quot;青年&quot; else &quot;油腻男&quot; end v6from info;</code></pre><h4 id="1-4-排序"><a href="#1-4-排序" class="headerlink" title="1.4 排序"></a>1.4 排序</h4><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210517184600205.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info order by age desc; -- 倒序select * from info order by age asc;  -- 顺序select * from info order by id desc;select * from info order by id asc;select * from info order by age asc,id desc; -- 优先按照age从小到大；如果age相同则按照id从大到小。select * from info where id&gt;10 order by age asc,id desc;select * from info where id&gt;6 or name like &quot;%y&quot; order by age asc,id desc;</code></pre><h4 id="1-5-取部分"><a href="#1-5-取部分" class="headerlink" title="1.5 取部分"></a>1.5 取部分</h4><p>一般要用于获取部分数据。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210517184600205.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info limit 5;   -- 获取前5条数据select * from info order by id desc limit 3;-- 先排序，再获取前3条数据select * from info where id &gt; 4 order by id desc limit 3;-- 先排序，再获取前3条数据select * from info limit 3 offset 2;-- 从位置2开始，向后获取前3数据</code></pre><p>数据库表中：1000条数据。</p><ul><li>第一页：<code>select * from info limit 10 offset 0;</code></li><li>第二页：<code>select * from info limit 10 offset 10;</code></li><li>第三页：<code>select * from info limit 10 offset 20;</code></li><li>第四页：<code>select * from info limit 10 offset 30;</code></li><li>…</li></ul><h4 id="1-6-分组"><a href="#1-6-分组" class="headerlink" title="1.6 分组"></a>1.6 分组</h4><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210517184600205.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">select age,max(id),min(id),count(id),sum(id),avg(id) from info group by age;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select age,count(1) from info group by age;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select depart_id,count(id) from info group by depart_id;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select depart_id,count(id) from info group by depart_id having count(id) &gt; 2;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select count(id) from info;select max(id) from info;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select age,max(id),min(id),sum(id),count(id) from info group by age;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select age,name from info group by age;  -- 不建议select * from info where id in (select max(id) from info group by age);</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select age,count(id) from info group by age having count(id) &gt; 2;select age,count(id) from info where id &gt; 4 group by age having count(id) &gt; 2;  -- 聚合条件放在having后面</code></pre><pre class="language-none"><code class="language-none">到目前为止SQL执行顺序：    where：筛选    group by：分组    having ：对分组后的聚合条件进行搜索    order by：排序    limit：截取</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select age,count(id) from info where id &gt; 2 group by age having count(id) &gt; 1 order by age desc limit 1;- 要查询的表info- 条件 id&gt;2- 根据age分组- 对分组后的数据再根据聚合条件过滤 count(id)&gt;1- 根据age从大到小排序- 获取第1条</code></pre><h4 id="1-7-左右连表"><a href="#1-7-左右连表" class="headerlink" title="1.7 左右连表"></a>1.7 左右连表</h4><p>多个表可以连接起来进行查询。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210517184600205.png" class=""><p>展示用户信息&amp;部门名称：</p><pre class="language-none"><code class="language-none">主表 left outer join 从表 on 主表.x &#x3D; 从表.id </code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info left outer join depart on info.depart_id &#x3D; depart.id;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select info.id,info.name,info.email,depart.title from info left outer join depart on info.depart_id &#x3D; depart.id;</code></pre><pre class="language-none"><code class="language-none">从表 right outer join 主表 on 主表.x &#x3D; 从表.id</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select info.id,info.name,info.email,depart.title from info right outer join depart on info.depart_id &#x3D; depart.id;</code></pre><p>为了更加直接的查看效果，我们分别在 depart 表 和 info 中额外插入一条数据。</p><pre class="language-sql" data-language="sql"><code class="language-sql">insert into depart(title) values(&quot;运维&quot;);</code></pre><p>此时从表存在和主表无关联的数据，这样一来主从表就有区别：</p><ul><li><p>info主表，就以info数据为主，depart为辅。（推荐使用）</p><pre class="language-sql" data-language="sql"><code class="language-sql">select info.id,info.name,info.email,depart.title from info left outer join depart on info.depart_id &#x3D; depart.id;</code></pre></li><li><p>depart主表，，就以depart数据为主，info为辅。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select info.id,info.name,info.email,depart.title from info right outer join depart on info.depart_id &#x3D; depart.id;</code></pre></li></ul><pre class="language-none"><code class="language-none">select * from info left outer join depart on ....select * from depart left outer join info on ....</code></pre><p>简写：<code>select * from depart left join info on ....</code></p><pre class="language-sql" data-language="sql"><code class="language-sql">-- 内连接:    表  inner join 表  on 条件select * from info inner join depart on info.depart_id&#x3D;depart.id;+----+-----------+------------------+------+-----------+----+--------+| id | name      | email            | age  | depart_id | id | title  |+----+-----------+------------------+------+-----------+----+--------+|  1 | 武沛齐    | wupeiqi@live.com |   19 |         1 |  1 | 开发   ||  2 | 于超      | pyyu@live.com    |   49 |         1 |  1 | 开发   ||  3 | alex      | alex@live.com    |    9 |         2 |  2 | 运营   ||  4 | tony      | tony@live.com    |   29 |         1 |  1 | 开发   ||  5 | kelly     | kelly@live.com   |   99 |         3 |  3 | 销售   ||  6 | james     | james@live.com   |   49 |         1 |  1 | 开发   ||  7 | 李杰      | lijie@live.com   |   49 |         1 |  1 | 开发   |+----+-----------+------------------+------+-----------+----+--------+</code></pre><pre class="language-none"><code class="language-none">到目前为止SQL执行顺序：    join     on     where     group by    having     order by    limit </code></pre><p>写在最后：多张表也可以连接。</p><h4 id="1-8-联合"><a href="#1-8-联合" class="headerlink" title="1.8 联合"></a>1.8 联合</h4><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210519093004885.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">select id,title from depart unionselect id,name from info;select id,title from depart unionselect email,name from info;-- 列数需相同</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select id from depart unionselect id from info;-- 自动去重</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select id from depart union allselect id from info;-- 保留所有</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>到目前为止，你已经掌握了如下相关指令（SQL语句）：</p><ul><li>数据库</li><li>数据表</li><li>数据行<ul><li>增加</li><li>删除</li><li>修改</li><li>查询（各种变着花样的查询）</li></ul></li></ul><h3 id="2-表关系"><a href="#2-表关系" class="headerlink" title="2.表关系"></a>2.表关系</h3><p>在开发项目时，需要根据业务需求去创建很多的表结构，以此来实现业务逻辑，一般表结构有三类：</p><ul><li>单表，单独一张表就可以将信息保存。<img src="/2022/06/24/python-mo-kuai-si-day1/image-20210519112309521.png" class=""></li><li>一对多，需要两张表来存储信息，且两张表存在 <code>一对多</code> 或 <code>多对一</code>关系。<img src="/2022/06/24/python-mo-kuai-si-day1/image-20210519112430244.png" class=""></li><li>多对多，需要三张表来存储信息，两张单表 + 关系表，创造出两个单表之间<code>多对多关系</code>。<img src="/2022/06/24/python-mo-kuai-si-day1/image-20210519113228664.png" class=""></li></ul><p>在上述的表：一对多的 <code>info.depart_id</code>字段、多对多的 <code>boy_girl.boy_id</code> 、<code>girl_id</code> 直接用整型存储就可以，因为他们只要存储关联表的主键ID即可。</p><p>在开发中往往还会为他们添加一个 <strong>外键约束</strong>，保证某一个列的值必须是其他表中的特定列已存在的值，例如：<code>info.depart_id</code>的值必须是 <code>depart.id</code>中已存在的值。</p><p><strong>一对多示例：</strong></p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210520171902550.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">create table depart(id int not null auto_increment primary key,    title varchar(16) not null)default charset&#x3D;utf8;create table info(id int not null auto_increment primary key,    name varchar(16) not null,    email varchar(32) not null,    age int,    depart_id int not null,    constraint fk_info_depart foreign key (depart_id) references depart(id))default charset&#x3D;utf8;</code></pre><p>如果表结构已创建好了，额外想要增加外键：</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table info add constraint fk_info_depart foreign key info(depart_id) references depart(id);</code></pre><p>删除外键：</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table info drop foreign key fk_info_depart;</code></pre><p><strong>多对多示例：</strong></p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210520171843289.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">create table boy(id int not null auto_increment primary key,    name varchar(16) not null)default charset&#x3D;utf8;create table girl(id int not null auto_increment primary key,    name varchar(16) not null)default charset&#x3D;utf8;create table boy_girl(id int not null auto_increment primary key,    boy_id int not null,    girl_id int not null,    constraint fk_boy_girl_boy foreign key boy_girl(boy_id) references boy(id),    constraint fk_boy_girl_girl foreign key boy_girl(girl_id) references girl(id))default charset&#x3D;utf8;</code></pre><p>如果表结构已创建好了，额外想要增加外键：</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table boy_girl add constraint fk_boy_girl_boy foreign key boy_girl(boy_id) references boy(id);alter table boy_girl add constraint fk_boy_girl_girl foreign key boy_girl(girl_id) references girl(id);</code></pre><p>删除外键：</p><pre class="language-sql" data-language="sql"><code class="language-sql">alter table info drop foreign key fk_boy_girl_boy;alter table info drop foreign key fk_boy_girl_girl;</code></pre><p> <font color="#dd0000"> <strong>在以后项目开发时，设计表结构及其关系的是一个非常重要的技能。一般项目开始开发的步骤：</strong></font></p><ul><li>需求调研</li><li>设计数据库表结构（根据需求）</li><li>项目开发（写代码）</li></ul><p>大量的工作应该放在前2个步骤，前期的设计完成之后，后续的功能代码开发就比较简单了。</p><h4 id="案例：简易版路飞学城"><a href="#案例：简易版路飞学城" class="headerlink" title="案例：简易版路飞学城"></a>案例：简易版路飞学城</h4><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210530200222433.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">create database luffy default charset utf8 collate utf8_general_ci;use luffy;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create table info(id int not null auto_increment primary key,    username varchar(16) not null,    mobile char(11) not null,    password varchar(64) not null)default charset&#x3D;utf8;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create table course(id int not null auto_increment primary key,    title varchar(16) not null)default charset&#x3D;utf8;create table module(id int not null auto_increment primary key,    title varchar(16) not null,    course_id int not null,    constraint fk_module_course foreign key (course_id) references course(id))default charset&#x3D;utf8;create table day(id int not null auto_increment primary key,    title varchar(16) not null,module_id int not null,    constraint fk_day_module foreign key (module_id) references module(id))default charset&#x3D;utf8;create table video(id int not null auto_increment primary key,    title varchar(16) not null,day_id int not null,    constraint fk_video_day foreign key (day_id) references day(id))default charset&#x3D;utf8;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create table module_record(id int not null auto_increment primary key,    user_id int not null,    module_id int not null,    constraint fk_user_id foreign key module_record(user_id) references info(id),    constraint fk_module_id foreign key module_record(module_id) references module(id))default charset&#x3D;utf8;</code></pre><h3 id="3-授权"><a href="#3-授权" class="headerlink" title="3. 授权"></a>3. 授权</h3><p>之前我们无论是基于Python代码 or 自带客户端 去连接MySQL时，均使用的是 <strong>root</strong> 账户，拥有对MySQL数据库操作的所有权限。</p><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210520173921204.png" class=""><p>如果有多个程序的数据库都放在同一个MySQL中，如果程序都用root账户就存在风险了。</p><p><strong>这种情况怎么办呢？</strong></p><blockquote><p>在MySQL中支持创建账户，并给账户分配权限，例如：只拥有数据库A操作的权限、只拥有数据库B中某些表的权限、只拥有数据库B中某些表的读权限等。</p></blockquote><h4 id="3-1-用户管理"><a href="#3-1-用户管理" class="headerlink" title="3.1 用户管理"></a>3.1 用户管理</h4><p>在MySQL的默认数据库 <code>mysql</code> 中的 <code>user</code> 表中存储着所有的账户信息（含账户、权限等）。</p><pre class="language-none"><code class="language-none">mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || day26              || mysql              || performance_schema || sys                |+--------------------+10 rows in set (0.00 sec)mysql&gt; select user,authentication_string,host from  mysql.user;+----------------------------------+-------------------------------------------+-------------------------------+| user                             | authentication_string                     | host                          |+----------------------------------+-------------------------------------------+-------------------------------+| root                             | *FAAFFE644E901CFAFAEC7562415E5FAEC243B8B2 | localhost                     || mysql.session                    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | localhost                     || mysql.sys                        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | localhost                     |+----------------------------------+-------------------------------------------+-------------------------------+3 rows in set (0.00 sec)</code></pre><ul><li><p>创建和删除用户</p><pre class="language-none"><code class="language-none">create user &#39;用户名&#39;@&#39;连接者的IP地址&#39; identified by &#39;密码&#39;;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create user wupeiqi1@127.0.0.1 identified by &#39;root123&#39;;drop user wupeiqi1@127.0.0.1;create user wupeiqi2@&#39;127.0.0.%&#39; identified by &#39;root123&#39;;drop user wupeiqi2@&#39;127.0.0.%&#39;;create user wupeiqi3@&#39;%&#39; identified by &#39;root123&#39;;drop user wupeiqi3@&#39;%&#39;;create user &#39;wupeiqi4&#39;@&#39;%&#39; identified by &#39;root123&#39;;drop user &#39;wupeiqi4&#39;@&#39;%&#39;;</code></pre></li><li><p>修改用户</p><pre class="language-none"><code class="language-none">rename user &#39;用户名&#39;@&#39;IP地址&#39; to &#39;新用户名&#39;@&#39;IP地址&#39;;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">rename user wupeiqi1@127.0.0.1 to wupeiqi1@localhost;rename user &#39;wupeiqi1&#39;@&#39;127.0.0.1&#39; to &#39;wupeiqi1&#39;@&#39;localhost&#39;;</code></pre></li><li><p>修改密码</p><pre class="language-none"><code class="language-none">set password for &#39;用户名&#39;@&#39;IP地址&#39; &#x3D; Password(&#39;新密码&#39;)</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">set password for &#39;wupeiqi4&#39;@&#39;%&#39; &#x3D; Password(&#39;123123&#39;);</code></pre></li></ul><h4 id="3-2-授权管理"><a href="#3-2-授权管理" class="headerlink" title="3.2 授权管理"></a>3.2 授权管理</h4><p>创建好用户之后，就可以为用户进行授权了。</p><ul><li><p>授权</p><pre class="language-none"><code class="language-none">grant 权限 on 数据库.表 to   &#39;用户&#39;@&#39;IP地址&#39;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">grant all privileges on *.* TO &#39;wupeiqi&#39;@&#39;localhost&#39;;         -- 用户wupeiqi拥有所有数据库的所有权限grant all privileges on day26.* TO &#39;wupeiqi&#39;@&#39;localhost&#39;;     -- 用户wupeiqi拥有数据库day26的所有权限grant all privileges on day26.info TO &#39;wupeiqi&#39;@&#39;localhost&#39;;  -- 用户wupeiqi拥有数据库day26中info表的所有权限grant select on day26.info TO &#39;wupeiqi&#39;@&#39;localhost&#39;;          -- 用户wupeiqi拥有数据库day26中info表的查询权限grant select,insert on day26.* TO &#39;wupeiqi&#39;@&#39;localhost&#39;;      -- 用户wupeiqi拥有数据库day26所有表的查询和插入权限grant all privileges on day26db.* to &#39;wupeiqi4&#39;@&#39;%&#39;;# 注意：flush privileges;  -- 将数据读取到内存中，从而立即生效。</code></pre><ul><li><p>对于权限</p><pre class="language-none"><code class="language-none">all privileges  除grant外的所有权限select          仅查权限select,insert   查和插入权限...usage                   无访问权限alter                   使用alter tablealter routine           使用alter procedure和drop procedurecreate                  使用create tablecreate routine          使用create procedurecreate temporary tables 使用create temporary tablescreate user             使用create user、drop user、rename user和revoke  all privilegescreate view             使用create viewdelete                  使用deletedrop                    使用drop tableexecute                 使用call和存储过程file                    使用select into outfile 和 load data infilegrant option            使用grant 和 revokeindex                   使用indexinsert                  使用insertlock tables             使用lock tableprocess                 使用show full processlistselect                  使用selectshow databases          使用show databasesshow view               使用show viewupdate                  使用updatereload                  使用flushshutdown                使用mysqladmin shutdown(关闭MySQL)super                   􏱂􏰈使用change master、kill、logs、purge、master和set global。还允许mysqladmin􏵗􏵘􏲊􏲋调试登陆replication client      服务器位置的访问replication slave       由复制从属使用</code></pre></li><li><p>对于数据库和表</p><pre class="language-none"><code class="language-none">数据库名.*            数据库中的所有数据库名.表名          指定数据库中的某张表数据库名.存储过程名     指定数据库中的存储过程*.*                  所有数据库</code></pre></li></ul></li><li><p>查看授权</p><pre class="language-none"><code class="language-none">show grants for &#39;用户&#39;@&#39;IP地址&#39;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">show grants for &#39;wupeiqi&#39;@&#39;localhost&#39;;show grants for &#39;wupeiqi4&#39;@&#39;%&#39;;</code></pre></li><li><p>取消授权</p><pre class="language-none"><code class="language-none">revoke 权限 on 数据库.表 from &#39;用户&#39;@&#39;IP地址&#39;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">revoke ALL PRIVILEGES on day26.* from &#39;wupeiqi&#39;@&#39;localhost&#39;;revoke ALL PRIVILEGES on day26db.* from &#39;wupeiqi4&#39;@&#39;%&#39;;# 注意：flush privileges;   -- 将数据读取到内存中，从而立即生效。</code></pre></li></ul><p>一般情况下，在很多的 正规 公司，数据库都是由 DBA 来统一进行管理，DBA为每个项目的数据库创建用户，并赋予相关的权限。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>本节主要讲解的三大部分的知识点：</p><ul><li>常见SQL语句，项目开发中使用最频繁的知识点。</li><li>表关系，项目开发前，项目表结构设计时必备知识点。<ul><li>单表</li><li>一对多</li><li>多对多</li></ul></li><li>授权，在MySQL中创建用户并赋予相关权限。</li></ul><h4 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h4><p>本节讲解 SQL语句、表结构 是以后项目开发中最最最常见知识点，为了让大家能有更多的联系和实践，单独为了大家设置了1天的时间作为本节课程的练习，详见 day27 。</p><h2 id="二十七、SQL强化和实践"><a href="#二十七、SQL强化和实践" class="headerlink" title="二十七、SQL强化和实践"></a>二十七、SQL强化和实践</h2><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210531085557128.png" class="" title="image-20210531085557128"><p>课程目标：练习常见的SQL语句和表结构的设计。</p><p>课程概要：</p><ul><li>SQL强化</li><li>表结构设计（博客系统）</li></ul><h3 id="1-SQL强化"><a href="#1-SQL强化" class="headerlink" title="1. SQL强化"></a>1. SQL强化</h3><h4 id="1-1-题目"><a href="#1-1-题目" class="headerlink" title="1.1.题目"></a>1.1.题目</h4><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210531123055185.png" class="" title="image-20210531123055185"><ol><li>根据上图创建  数据库 &amp; 表结构 并 录入数据（可以自行创造数据）。</li><li>创建用户 luffy 并赋予此数据库的所有权限。</li><li>查询姓“波”的老师的个数。</li><li>查询姓“山”的学生名单。</li><li>查询男生、女生的人数。</li><li>查询同名同姓学生名单，并统计同名人数。</li><li>查询 “三年二班” 的所有学生。</li><li>查询 每个 班级的 班级名称、班级人数。</li><li>查询成绩小于60分的同学的学号、姓名、成绩、课程名称。</li><li>查询选修了 “生物课” 的所有学生ID、学生姓名、成绩。</li><li>查询选修了 “生物课” 且分数低于70的的所有学生ID、学生姓名、成绩。</li><li>查询所有同学的学号、姓名、选课数、总成绩。</li><li>查询各科被选修的学生数。</li><li>查询各科成绩的总分、最高分、最低分，显示：课程ID、课程名称、总分、最高分、最低分。</li><li>查询各科成绩的平均分，显示：课程ID、课程名称、平均分。</li><li>查询各科成绩的平均分，显示：课程ID、课程名称、平均分（按平均分从大到小排序）。</li><li>查询各科成绩的平均分和及格率，显示：课程ID、课程名称、平均分、及格率。</li><li>查询平均成绩大于等于60的所有学生的学号、平均成绩；。</li><li>查询平均成绩大于85的所有学生的学号、平均成绩、姓名。</li><li>查询 “三年二班”  每个学生的 学号、姓名、总成绩、平均成绩。</li><li>查询各个班级的班级名称、总成绩、平均成绩、及格率（按平均成绩从大到小排序）。</li><li>查询学过 “波多” 老师课的同学的学号、姓名。</li><li>查询没学过 “波多” 老师课的同学的学号、姓名。</li><li>查询选修 “波多” 老师所授课程的学生中，成绩最高的学生姓名及其成绩（不考虑并列）。</li><li>查询选修 “波多” 老师所授课程的学生中，成绩最高的学生姓名及其成绩（考虑并列）。</li><li>查询只选修了一门课程的全部学生的学号、姓名。</li><li>查询至少选修两门课程的学生学号、学生姓名、选修课程数量。</li><li><font color="#dd0000"> <strong>查询两门及以上不及格的同学的学号、学生姓名、选修课程数量。</strong></font></li><li><font color="#dd0000"><strong>查询选修了所有课程的学生的学号、姓名。</strong></font></li><li><font color="#dd0000"> <strong>查询两门及以上不及格的同学的学号、学生姓名、选修课程数量。查询未选修所有课程的学生的学号、姓名。</strong></font></li><li><font color="#dd0000"> <strong>查询所有学生都选修了的课程的课程号、课程名。</strong></font></li><li>查询选修 “生物” 和 “物理” 课程的所有学生学号、姓名。</li><li>查询至少有一门课与学号为“1”的学生所选的课程相同的其他学生学号 和 姓名 。</li><li>查询与学号为 “2” 的同学选修的课程完全相同的其他 学生学号 和 姓名 。</li><li>查询“生物”课程比“物理”课程成绩高的所有学生的学号；</li><li>查询每门课程成绩最好的前3名 (不考虑成绩并列情况) 。</li><li>查询每门课程成绩最好的前3名 (考虑成绩并列情况) 。</li><li>创建一个表 <code>sc</code>，然后将 score 表中所有数据插入到 sc 表中。</li><li>向 sc 表中插入一些记录，这些记录要求符合以下条件：<ul><li>学生ID为：没上过课程ID为 “2” 课程的学生的 学号；</li><li>课程ID为：2</li><li>成绩为：80</li></ul></li><li>向 sc 表中插入一些记录，这些记录要求符合以下条件：<ul><li>学生ID为：没上过课程ID为 “2” 课程的学生的 学号。</li><li>课程ID为：2。</li><li>成绩为：课程ID为3的最高分。</li></ul></li></ol><h4 id="1-2-答案"><a href="#1-2-答案" class="headerlink" title="1.2.答案"></a>1.2.答案</h4><ol><li><p>根据上图创建  数据库 &amp; 表结构 并 录入数据（可以自行创造数据）</p><pre class="language-sql" data-language="sql"><code class="language-sql">create database day27db default charset utf8 collate utf8_general_ci;use day27db;drop database day27db;drop database IF EXISTS day27db;</code></pre><p>利用导入数据库命令：</p><ul><li><p>导入</p><pre class="language-none"><code class="language-none">mysql -u root -p  day27db &lt; 导入文件绝对路径</code></pre></li><li><p>导出</p><pre class="language-none"><code class="language-none"># 结构+数据mysqldump -u root -p  day27db &gt; 导出文件绝对路径# 结构mysqldump -u root -p -d day27db &gt; &#x2F;Users&#x2F;wupeiqi&#x2F;day27db3.sql</code></pre></li><li><p>day27db.sql文件</p></li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">create table class(cid int not null auto_increment primary key,    caption varchar(16) not null)default charset&#x3D;utf8;INSERT INTO class3 VALUES (&#39;1&#39;, &#39;三年二班&#39;), (&#39;2&#39;, &#39;三年三班&#39;), (&#39;3&#39;, &#39;一年二班&#39;), (&#39;4&#39;, &#39;二年九班&#39;);create table student( sid int not null auto_increment primary key,    gender char(1) not null,    class_id int not null,    sname varchar(16) not null,    constraint fk_student_class foreign key (class_id) references class(cid))default charset&#x3D;utf8;INSERT INTO student VALUES (&#39;1&#39;, &#39;男&#39;, &#39;1&#39;, &#39;理解&#39;), (&#39;2&#39;, &#39;女&#39;, &#39;1&#39;, &#39;钢蛋&#39;), (&#39;3&#39;, &#39;男&#39;, &#39;1&#39;, &#39;张三&#39;), (&#39;4&#39;, &#39;男&#39;, &#39;1&#39;, &#39;张一&#39;), (&#39;5&#39;, &#39;女&#39;, &#39;1&#39;, &#39;张二&#39;), (&#39;6&#39;, &#39;男&#39;, &#39;1&#39;, &#39;张四&#39;), (&#39;7&#39;, &#39;女&#39;, &#39;2&#39;, &#39;铁锤&#39;), (&#39;8&#39;, &#39;男&#39;, &#39;2&#39;, &#39;李三&#39;), (&#39;9&#39;, &#39;男&#39;, &#39;2&#39;, &#39;李一&#39;), (&#39;10&#39;, &#39;女&#39;, &#39;2&#39;, &#39;李二&#39;), (&#39;11&#39;, &#39;男&#39;, &#39;2&#39;, &#39;李四&#39;), (&#39;12&#39;, &#39;女&#39;, &#39;3&#39;, &#39;如花&#39;), (&#39;13&#39;, &#39;男&#39;, &#39;3&#39;, &#39;刘三&#39;), (&#39;14&#39;, &#39;男&#39;, &#39;3&#39;, &#39;刘一&#39;), (&#39;15&#39;, &#39;女&#39;, &#39;3&#39;, &#39;刘二&#39;), (&#39;16&#39;, &#39;男&#39;, &#39;3&#39;, &#39;刘四&#39;);create table teacher( tid int not null auto_increment primary key,    tname varchar(16) not null)default charset&#x3D;utf8;INSERT INTO &#96;teacher&#96; VALUES (&#39;1&#39;, &#39;张磊老师&#39;), (&#39;2&#39;, &#39;李平老师&#39;), (&#39;3&#39;, &#39;刘海燕老师&#39;), (&#39;4&#39;, &#39;朱云海老师&#39;), (&#39;5&#39;, &#39;李杰老师&#39;);create table course(   cid int not null auto_increment primary key,    cname varchar(16) not null,    teacher_id int not null,    constraint fk_course_teacher foreign key (teacher_id) references teacher(tid))default charset&#x3D;utf8;INSERT INTO &#96;course&#96; VALUES (&#39;1&#39;, &#39;生物&#39;, &#39;1&#39;), (&#39;2&#39;, &#39;物理&#39;, &#39;2&#39;), (&#39;3&#39;, &#39;体育&#39;, &#39;3&#39;), (&#39;4&#39;, &#39;美术&#39;, &#39;2&#39;);CREATE TABLE &#96;score&#96; (  &#96;sid&#96; int NOT NULL AUTO_INCREMENT PRIMARY KEY,  &#96;student_id&#96; int NOT NULL,  &#96;course_id&#96; int NOT NULL,  &#96;num&#96; int NOT NULL,  CONSTRAINT &#96;fk_score_course&#96; FOREIGN KEY (&#96;course_id&#96;) REFERENCES &#96;course&#96; (&#96;cid&#96;),  CONSTRAINT &#96;fk_score_student&#96; FOREIGN KEY (&#96;student_id&#96;) REFERENCES &#96;student&#96; (&#96;sid&#96;)) DEFAULT CHARSET&#x3D;utf8;INSERT INTO &#96;score&#96; VALUES (&#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;10&#39;), (&#39;2&#39;, &#39;1&#39;, &#39;2&#39;, &#39;9&#39;), (&#39;5&#39;, &#39;1&#39;, &#39;4&#39;, &#39;66&#39;), (&#39;6&#39;, &#39;2&#39;, &#39;1&#39;, &#39;8&#39;), (&#39;8&#39;, &#39;2&#39;, &#39;3&#39;, &#39;68&#39;), (&#39;9&#39;, &#39;2&#39;, &#39;4&#39;, &#39;99&#39;), (&#39;10&#39;, &#39;3&#39;, &#39;1&#39;, &#39;77&#39;), (&#39;11&#39;, &#39;3&#39;, &#39;2&#39;, &#39;66&#39;), (&#39;12&#39;, &#39;3&#39;, &#39;3&#39;, &#39;87&#39;), (&#39;13&#39;, &#39;3&#39;, &#39;4&#39;, &#39;99&#39;), (&#39;14&#39;, &#39;4&#39;, &#39;1&#39;, &#39;79&#39;), (&#39;15&#39;, &#39;4&#39;, &#39;2&#39;, &#39;11&#39;), (&#39;16&#39;, &#39;4&#39;, &#39;3&#39;, &#39;67&#39;), (&#39;17&#39;, &#39;4&#39;, &#39;4&#39;, &#39;100&#39;), (&#39;18&#39;, &#39;5&#39;, &#39;1&#39;, &#39;79&#39;), (&#39;19&#39;, &#39;5&#39;, &#39;2&#39;, &#39;11&#39;), (&#39;20&#39;, &#39;5&#39;, &#39;3&#39;, &#39;67&#39;), (&#39;21&#39;, &#39;5&#39;, &#39;4&#39;, &#39;100&#39;), (&#39;22&#39;, &#39;6&#39;, &#39;1&#39;, &#39;9&#39;), (&#39;23&#39;, &#39;6&#39;, &#39;2&#39;, &#39;100&#39;), (&#39;24&#39;, &#39;6&#39;, &#39;3&#39;, &#39;67&#39;), (&#39;25&#39;, &#39;6&#39;, &#39;4&#39;, &#39;100&#39;), (&#39;26&#39;, &#39;7&#39;, &#39;1&#39;, &#39;9&#39;), (&#39;27&#39;, &#39;7&#39;, &#39;2&#39;, &#39;100&#39;), (&#39;28&#39;, &#39;7&#39;, &#39;3&#39;, &#39;67&#39;), (&#39;29&#39;, &#39;7&#39;, &#39;4&#39;, &#39;88&#39;), (&#39;30&#39;, &#39;8&#39;, &#39;1&#39;, &#39;9&#39;), (&#39;31&#39;, &#39;8&#39;, &#39;2&#39;, &#39;100&#39;), (&#39;32&#39;, &#39;8&#39;, &#39;3&#39;, &#39;67&#39;), (&#39;33&#39;, &#39;8&#39;, &#39;4&#39;, &#39;88&#39;), (&#39;34&#39;, &#39;9&#39;, &#39;1&#39;, &#39;91&#39;), (&#39;35&#39;, &#39;9&#39;, &#39;2&#39;, &#39;88&#39;), (&#39;36&#39;, &#39;9&#39;, &#39;3&#39;, &#39;67&#39;), (&#39;37&#39;, &#39;9&#39;, &#39;4&#39;, &#39;22&#39;), (&#39;38&#39;, &#39;10&#39;, &#39;1&#39;, &#39;90&#39;), (&#39;39&#39;, &#39;10&#39;, &#39;2&#39;, &#39;77&#39;), (&#39;40&#39;, &#39;10&#39;, &#39;3&#39;, &#39;43&#39;), (&#39;41&#39;, &#39;10&#39;, &#39;4&#39;, &#39;87&#39;), (&#39;42&#39;, &#39;11&#39;, &#39;1&#39;, &#39;90&#39;), (&#39;43&#39;, &#39;11&#39;, &#39;2&#39;, &#39;77&#39;), (&#39;44&#39;, &#39;11&#39;, &#39;3&#39;, &#39;43&#39;), (&#39;45&#39;, &#39;11&#39;, &#39;4&#39;, &#39;87&#39;), (&#39;46&#39;, &#39;12&#39;, &#39;1&#39;, &#39;90&#39;), (&#39;47&#39;, &#39;12&#39;, &#39;2&#39;, &#39;77&#39;), (&#39;48&#39;, &#39;12&#39;, &#39;3&#39;, &#39;43&#39;), (&#39;49&#39;, &#39;12&#39;, &#39;4&#39;, &#39;87&#39;), (&#39;52&#39;, &#39;13&#39;, &#39;3&#39;, &#39;87&#39;);</code></pre></li><li><p>创建用户 luffy 并赋予此数据库的所有权限。</p><pre class="language-sql" data-language="sql"><code class="language-sql">create user &#39;luffy&#39;@&#39;%&#39; identified by &#39;root123&#39;;grant all privileges on day27db.* TO &#39;luffy&#39;@&#39;%&#39;;flush privileges;</code></pre></li><li><p>查询姓“李”的老师的个数。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from teacher where tname like &quot;李%&quot;;</code></pre></li><li><p>查询姓“张”的学生名单。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from student where sname like &quot;张%&quot;;</code></pre></li><li><p>查询男生、女生的人数。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select gender,count(1) from student group by gender;</code></pre></li><li><p>查询同名同姓学生名单，并统计同名人数。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select sname,count(1) from student group by sname;select sname,count(1) from student group by sname having count(1) &gt; 1;</code></pre></li><li><p>查询 “三年二班” 的所有学生。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from student left join class on student.class_id &#x3D; class.cid where class.caption&#x3D;&quot;三年二班&quot;;</code></pre></li><li><p>查询 每个 班级的 班级名称、班级人数。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select class_id,count(1) from student group by class_id;select class.caption,count(1) from student left join class on student.class_id &#x3D; class.cid group by class.caption;</code></pre></li><li><p>查询成绩小于60分的同学的学号、姓名、成绩、课程名称。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from score where num &lt;60;select student.sid,student.sname,score.num,course.cname from score left join student on score.student_id&#x3D;student.sid left join course on score.course_id &#x3D;course.cid where num &lt;60;</code></pre></li><li><p>查询选修了 “生物课” 的所有学生ID、学生姓名、成绩。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from score left join course on score.course_id &#x3D;course.cid where course.cname&#x3D;&quot;生物&quot;;select student.sid,student.sname,score.num from score left join course on score.course_id &#x3D;course.cid left join student on score.student_id&#x3D;student.sid where course.cname&#x3D;&quot;生物&quot;;</code></pre></li><li><p>查询选修了 “生物课” 且分数低于60的的所有学生ID、学生姓名、成绩。</p><pre class="language-sql" data-language="sql"><code class="language-sql">selectstudent.sid,student.sname,score.num from score left join course on score.course_id &#x3D;course.cid left join student on score.student_id&#x3D;student.sid where course.cname&#x3D;&quot;生物&quot; and score.num &lt; 60;</code></pre></li><li><p>查询所有同学的学号、姓名、选课数、总成绩。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select student_id,count(1),sum(num) from score group by student_id;select student_id,student.sname,count(1),sum(num) from score left join student on score.student_id&#x3D;student.sid group by student_id;</code></pre></li><li><p>查询各科被选修的学生数。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select course_id,count(1) from score group by course_id;select course_id,course.cname,count(1) from score left join course on score.course_id &#x3D;course.cid group by course_id;</code></pre></li><li><p>查询各科成绩的总分、最高分、最低分，显示：课程ID、课程名称、总分、最高分、最低分。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select course_id,course.cname,sum(num), max(num), min(num) from score left join course on score.course_id &#x3D;course.cid group by course_id;</code></pre></li><li><p>查询各科成绩的平均分，显示：课程ID、课程名称、平均分。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select course_id,course.cname,avg(num) from score left join course on score.course_id &#x3D;course.cid group by course_id;</code></pre></li><li><p>查询各科成绩的平均分，显示：课程ID、课程名称、平均分（按平均分从大到小排序）。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select course_id,course.cname,avg(num) from score left join course on score.course_id &#x3D;course.cid group by course_id order by avg(num) desc;select course_id,course.cname,avg(num) as A from score left join course on score.course_id &#x3D;course.cid group by course_id order by A desc;</code></pre></li><li><p>查询各科成绩的平均分和及格率，显示：课程ID、课程名称、平均分、及格率。</p><pre class="language-none"><code class="language-none">10&#x2F;20 &#x3D; 及格率select course_id,count(1) from score group by course_id;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select sid,course_id,num,case when score.num &gt;&#x3D; 60 then 1 else 0 end &quot;是否及格&quot; from score;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select sid,course_id,num,case when score.num &gt; 60 then 1 else 0 end &quot;是否及格&quot; from score;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select course_id,course.cname,avg(num),count(1) as total,sum(case when score.num &gt; 60 then 1 else 0 end) from score left join course on score.course_id &#x3D;course.cid group by course_id;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select course_id,course.cname,avg(num),sum(case when score.num &gt; 60 then 1 else 0 end)&#x2F;count(1) *100 as percent from score left join course on score.course_id &#x3D;course.cid group by course_id;</code></pre></li><li><p>查询平均成绩大于60的所有学生的学号、平均成绩；</p><pre class="language-sql" data-language="sql"><code class="language-sql">select student_id,avg(num) from score group by student_id having avg(num) &gt; 60;</code></pre></li><li><p>查询平均成绩大于85的所有学生的学号、平均成绩、姓名。</p><pre class="language-sql" data-language="sql"><code class="language-sql">select student_id,avg(num) from score group by student_id having avg(num) &gt; 85;select student_id,avg(num),student.sname from score left join student on score.student_id&#x3D;student.sid   group by student_id having avg(num) &gt; 85;</code></pre></li><li><p>查询 “三年二班”  每个学生的 学号、姓名、总成绩、平均成绩。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECT* FROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sidLEFT JOIN class ON class.cid &#x3D; student.class_id;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">SELECT* FROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sidLEFT JOIN class ON class.cid &#x3D; student.class_id WHEREclass.caption &#x3D; &quot;三年二班&quot;;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent_id,sname,sum( num ),avg( num ) FROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sidLEFT JOIN class ON class.cid &#x3D; student.class_id WHEREclass.caption &#x3D; &quot;三年二班&quot; GROUP BYstudent_id</code></pre></li><li><p>查询各个班级的班级名称、总成绩、平均成绩、及格率（按平均成绩从大到小排序）。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTclass.cid,class.caption,sum( num ),avg( num ) as av,sum( CASE WHEN score.num &gt; 60 THEN 1 ELSE 0 END ) &#x2F; count( 1 ) * 100 as JGFROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sidLEFT JOIN class ON class.cid &#x3D; student.class_id GROUP BYclass.cidORDER BYav desc</code></pre></li><li><p>查询学过 “波多” 老师课的同学的学号、姓名。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent.sid,student.snameFROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sidLEFT JOIN course ON score.course_id &#x3D; course.cidLEFT JOIN teacher ON course.teacher_id &#x3D; teacher.tidWHEREteacher.tname &#x3D; &quot;波多&quot; </code></pre></li><li><p>查询没学过 “波多” 老师课的同学的学号、姓名。</p><pre class="language-sql" data-language="sql"><code class="language-sql"># 错误的思路SELECTstudent.sid,student.snameFROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sidLEFT JOIN course ON score.course_id &#x3D; course.cidLEFT JOIN teacher ON course.teacher_id &#x3D; teacher.tidWHEREteacher.tname !&#x3D; &quot;波多&quot; </code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select * from student where sid not in(    SELECT        student.sid    FROM        score        LEFT JOIN student ON score.student_id &#x3D; student.sid        LEFT JOIN course ON score.course_id &#x3D; course.cid        LEFT JOIN teacher ON course.teacher_id &#x3D; teacher.tid    WHERE        teacher.tname &#x3D; &quot;波多&quot; )</code></pre></li><li><p>查询选修 “苍空” 老师所授课程的学生中，成绩最高的学生姓名及其成绩（不考虑并列）。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent.sid,student.sname FROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sidLEFT JOIN course ON score.course_id &#x3D; course.cidLEFT JOIN teacher ON course.teacher_id &#x3D; teacher.tid WHEREteacher.tname &#x3D; &quot;苍空&quot; ORDER BYscore.num DESC LIMIT 1</code></pre></li><li><p>查询选修 “苍空” 老师所授课程的学生中，成绩最高的学生姓名及其成绩（考虑并列）。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent.sid,student.sname FROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sidLEFT JOIN course ON score.course_id &#x3D; course.cidLEFT JOIN teacher ON course.teacher_id &#x3D; teacher.tid WHEREteacher.tname &#x3D; &quot;苍空&quot; AND score.num &#x3D; (        SELECT            max( num )         FROM            score            LEFT JOIN course ON score.course_id &#x3D; course.cid            LEFT JOIN teacher ON course.teacher_id &#x3D; teacher.tid         WHERE        teacher.tname &#x3D; &quot;苍空&quot; )</code></pre></li><li><p>查询只选修了一门课程的全部学生的学号、姓名。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent.sid,student.sname FROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sid GROUP BYstudent_id HAVINGcount( 1 ) &#x3D;1</code></pre></li><li><p>查询至少选修两门课程的学生学号、学生姓名、选修课程数量。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent.sid,student.sname ,count(1)FROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sid GROUP BYstudent_id HAVINGcount( 1 ) &gt;&#x3D; 2</code></pre></li><li><p>查询两门及以上不及格的同学的学号、学生姓名、选修课程数量。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent.sid,student.sname ,count(1)FROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sid where num &lt; 60GROUP BYstudent_id HAVINGcount( 1 ) &gt;&#x3D; 2</code></pre></li><li><p>查询选修了所有课程的学生的学号、姓名。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent.sid,student.snameFROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sid GROUP BYstudent_id HAVINGcount( 1 ) &#x3D; ( SELECT count( 1 ) FROM course )</code></pre></li><li><p>查询未选修所有课程的学生的学号、姓名。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent.sid,student.snameFROMscoreLEFT JOIN student ON score.student_id &#x3D; student.sid GROUP BYstudent_id HAVINGcount( 1 ) !&#x3D; ( SELECT count( 1 ) FROM course )</code></pre></li><li><p>查询所有学生都选修了的课程的课程号、课程名。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTcourse.cid,course.cnameFROMscoreLEFT JOIN course ON score.course_id &#x3D; course.cidGROUP BYcourse_id HAVINGcount( 1 ) &#x3D; ( SELECT count( 1 ) FROM student )</code></pre></li><li><p>查询选修 “生物” 和 “物理” 课程的所有学生学号、姓名。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent.sid,student.snameFROMscoreLEFT JOIN course ON score.course_id &#x3D; course.cidLEFT JOIN student ON score.student_id &#x3D; student.sidWHEREcourse.cname in (&quot;生物&quot;,&quot;物理&quot;)GROUP BYstudent_idhaving count(1) &#x3D; 2;</code></pre></li><li><p>查询至少有一门课与学号为“1”的学生所选的课程相同的其他学生学号 和 姓名 。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent.sid,student.snameFROMscoreLEFT JOIN course ON score.course_id &#x3D; course.cidLEFT JOIN student ON score.student_id &#x3D; student.sidWHEREscore.course_id in ( select course_id from score where student_id&#x3D;1)  -- （）中为学生1选的课程and score.student_id !&#x3D; 1GROUP BYstudent_idHAVINGcount(1) &gt; 1</code></pre></li><li><p>查询与学号为 “2” 的同学选修的课程完全相同的其他 学生学号 和 姓名 。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent.sid,student.snameFROMscoreLEFT JOIN course ON score.course_id &#x3D; course.cidLEFT JOIN student ON score.student_id &#x3D; student.sidWHEREscore.course_id in ( select course_id from score where student_id&#x3D;2)and score.student_id in (    select student_id from score where student_id!&#x3D;2 group by student having count(1) &#x3D; select count(1) from score where student_id&#x3D;2    )GROUP BYstudent_idHAVINGcount(1) &#x3D; ( select count(1) from score where student_id&#x3D;2 )# 如果id&#x3D;2学生他的课程数量和其他人的课程数量是一样。select student_id from score where student_id!&#x3D;2 group by student having count(1) &#x3D; select count(1) from score where student_id&#x3D;2select student_id from score where student_id!&#x3D;2 group by student_id having count(1) &#x3D; select count(1) from score where student_id&#x3D;2</code></pre></li><li><p>查询“生物”课程比“物理”课程成绩高的所有学生的学号；</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECT* FROMscoreLEFT JOIN course ON score.course_id &#x3D; course.cidwhere cname in (&quot;生物&quot;,&quot;物理&quot;);</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">SELECT*,case cname WHEN &quot;生物&quot; then num else -1 end sw,case cname WHEN &quot;物理&quot; then num else -1 end wlFROMscoreLEFT JOIN course ON score.course_id &#x3D; course.cidwhere cname in (&quot;生物&quot;,&quot;物理&quot;);</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent_id,max(case cname WHEN &quot;生物&quot; then num else -1 end) as sw,max(case cname WHEN &quot;物理&quot; then num else -1 end) as wlFROMscoreLEFT JOIN course ON score.course_id &#x3D; course.cidwhere cname in (&quot;生物&quot;,&quot;物理&quot;)GROUP BYstudent_id;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTstudent_id,max( CASE cname WHEN &quot;生物&quot; THEN num ELSE 0 END ) AS sw,max( CASE cname WHEN &quot;物理&quot; THEN num ELSE 0 END ) AS wl FROMscoreLEFT JOIN course ON score.course_id &#x3D; course.cid WHEREcname IN ( &quot;生物&quot;, &quot;物理&quot; ) GROUP BYstudent_id HAVINGsw &gt; wl;</code></pre></li><li><p>查询每门课程成绩最好的前3名 (不考虑成绩并列情况) 。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTcid,cname,( select student.sname from score left join student on student.sid &#x3D; score.student_id where course_id &#x3D; course.cid order by num desc limit 1 offset 0) as &quot;第1名&quot;,( select student.sname from score left join student on student.sid &#x3D; score.student_id where course_id &#x3D; course.cid order by num desc limit 1 offset 1) as &quot;第2名&quot;,( select student.sname from score left join student on student.sid &#x3D; score.student_id where course_id &#x3D; course.cid order by num desc limit 1 offset 2) as &quot;第3名&quot;FROMcourse;</code></pre></li><li><p>查询每门课程成绩最好的前3名 (考虑成绩并列情况) 。</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTcid,cname,( select num from score  where course_id &#x3D; course.cid GROUP BY num order by num desc limit 1 offset 0) as &quot;最高分&quot;,( select num from score  where course_id &#x3D; course.cid GROUP BY num order by num desc limit 1 offset 1) as &quot;第二高分&quot;,( select num from score  where course_id &#x3D; course.cid GROUP BY num order by num desc limit 1 offset 2) as &quot;第三高分&quot;FROMcourse;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">select * from score left join (SELECTcid,cname,( select num from score  where course_id &#x3D; course.cid GROUP BY num order by num desc limit 1 offset 0) as &quot;最高分&quot;,( select num from score  where course_id &#x3D; course.cid GROUP BY num order by num desc limit 1 offset 1) as &quot;第二高分&quot;,( select num from score  where course_id &#x3D; course.cid GROUP BY num order by num desc limit 1 offset 2) as thirdFROMcourse ) as C on score.course_id &#x3D; C.cid WHEREscore.num &gt;&#x3D; C.third</code></pre></li><li><p>创建一个表 <code>sc</code>，然后将 score 表中所有数据插入到 sc 表中。</p><pre class="language-sql" data-language="sql"><code class="language-sql">CREATE TABLE &#96;sc&#96; (  &#96;sid&#96; int NOT NULL AUTO_INCREMENT PRIMARY KEY,  &#96;student_id&#96; int NOT NULL,  &#96;course_id&#96; int NOT NULL,  &#96;num&#96; int NOT NULL,  CONSTRAINT &#96;fk_sc_course&#96; FOREIGN KEY (&#96;course_id&#96;) REFERENCES &#96;course&#96; (&#96;cid&#96;),  CONSTRAINT &#96;fk_sc_student&#96; FOREIGN KEY (&#96;student_id&#96;) REFERENCES &#96;student&#96; (&#96;sid&#96;)) DEFAULT CHARSET&#x3D;utf8;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">INSERT INTO sc SELECT * from score;</code></pre></li><li><p>向 sc 表中插入一些记录，这些记录要求符合以下条件：</p><ul><li>学生ID为：没上过课程ID为 “2” 课程的学生的 学号；</li><li>课程ID为：2</li><li>成绩为：80</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">-- 上过select student_id from score where course_id &#x3D;2;-- 没上过SELECTsidFROMstudent WHEREsid NOT IN ( SELECT student_id FROM score WHERE course_id &#x3D; 2 )-- 构造数据SELECTsid,2,80FROMstudent WHEREsid NOT IN ( SELECT student_id FROM score WHERE course_id &#x3D; 2 );</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">INSERT INTO sc ( student_id, course_id, num ) SELECTsid,2,80 FROMstudent WHEREsid NOT IN ( SELECT student_id FROM score WHERE course_id &#x3D; 2 )</code></pre></li><li><p>向 sc 表中插入一些记录，这些记录要求符合以下条件：</p><ul><li>学生ID为：没上过课程ID为 “2” 课程的学生的 学号。</li><li>课程ID为：2。</li><li>成绩为：课程ID为3的最高分。</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql">SELECTsid,2,(select max(num) from score where course_id&#x3D;3) as numFROMstudent WHEREsid NOT IN ( SELECT student_id FROM score WHERE course_id &#x3D; 2 );</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">INSERT INTO sc ( student_id, course_id, num ) SELECTsid,2,(select max(num) from score where course_id&#x3D;3) as numFROMstudent WHEREsid NOT IN ( SELECT student_id FROM score WHERE course_id &#x3D; 2 )</code></pre></li></ol><h3 id="2-设计表结构"><a href="#2-设计表结构" class="headerlink" title="2. 设计表结构"></a>2. 设计表结构</h3><p>根据如下的业务需求设计相应的表结构，内部需涵盖如下功能。</p><ul><li>注册</li><li>登录</li><li>发布博客</li><li>查看博客列表，显示博客标题、创建时间、阅读数量、评论数量、赞数量等。</li><li>博客详细，显示博文详细、评论 等。<ul><li>发表评论</li><li>赞 or 踩</li><li>阅读数量 + 1</li></ul></li></ul><p>参考如下图片请根据如下功能来设计相应的表结构。</p><p>注意：只需要设计表结构，不需要用python代码实现具体的功能（再学一点知识点后再更好的去实现）。</p><h4 id="2-1-注册和登录"><a href="#2-1-注册和登录" class="headerlink" title="2.1 注册和登录"></a>2.1 注册和登录</h4><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210520204812764-16564929449182.png" class=""><h4 id="2-2-文章列表"><a href="#2-2-文章列表" class="headerlink" title="2.2 文章列表"></a>2.2 文章列表</h4><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210520204735867-16564929449186.png" class=""><h4 id="2-3-文章详细"><a href="#2-3-文章详细" class="headerlink" title="2.3 文章详细"></a>2.3 文章详细</h4><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210520205148509-16564929449183.png" class=""><h4 id="2-4-评论-amp-阅读-amp-赞-amp-踩"><a href="#2-4-评论-amp-阅读-amp-赞-amp-踩" class="headerlink" title="2.4 评论 &amp; 阅读 &amp; 赞 &amp; 踩"></a>2.4 评论 &amp; 阅读 &amp; 赞 &amp; 踩</h4><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210520205332907-16564929449184.png" class=""><p>注意：假设都是一级评论（不能回复评论）。</p><h4 id="2-5答案：表结构设计"><a href="#2-5答案：表结构设计" class="headerlink" title="2.5答案：表结构设计"></a>2.5答案：表结构设计</h4><img src="/2022/06/24/python-mo-kuai-si-day1/image-20210531083345193.png" class=""><pre class="language-sql" data-language="sql"><code class="language-sql">drop database blog;drop database IF EXISTS blog;create database blog default charset utf8 collate utf8_general_ci;use blog;</code></pre><pre class="language-sql" data-language="sql"><code class="language-sql">create table user(id int not null auto_increment primary key,    username varchar(16) not null,    nickname varchar(16) not null,mobile char(11) not null,    password varchar(64) not null,    email varchar(64) not null,    ctime datetime not null)default charset&#x3D;utf8;create table article(id int not null auto_increment primary key,    title varchar(255) not null,    text text not null,read_count int default 0,comment_count int default 0,up_count int default 0,down_count int default 0,    user_id int not null,    ctime datetime not null,    constraint fk_article_user foreign key (user_id) references user(id))default charset&#x3D;utf8;create table comment(    id int not null auto_increment primary key,    content varchar(255) not null,    user_id int not null,article_id int not null,    ctime datetime not null,    constraint fk_comment_user foreign key (user_id) references user(id),    constraint fk_comment_article foreign key (article_id) references article(id))default charset&#x3D;utf8;create table up_down(    id int not null auto_increment primary key,    choice tinyint not null,    user_id int not null,article_id int not null,    ctime datetime not null,    constraint fk_up_down_user foreign key (user_id) references user(id),    constraint fk_up_down_article foreign key (article_id) references article(id))default charset&#x3D;utf8;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 第四阶段 </tag>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三阶段重点</title>
      <link href="/2022/06/24/di-san-jie-duan-chong-dian/"/>
      <url>/2022/06/24/di-san-jie-duan-chong-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、面向对象基础"><a href="#一、面向对象基础" class="headerlink" title="一、面向对象基础"></a>一、面向对象基础</h2><h3 id="（一）面向对象的三大特性"><a href="#（一）面向对象的三大特性" class="headerlink" title="（一）面向对象的三大特性"></a>（一）面向对象的三大特性</h3><ul><li><p>封装性：将方法封装到类中 或 将数据封装到对象中，便于以后使用。</p></li><li><p>继承性：将类中的公共的方法提取到基类中去实现。</p></li><li><p>多态性：Python默认支持多态（这种方式称之为鸭子类型），最简单的基础下面的这段代码即可。</p></li></ul><h2 id="二、面向对象进阶"><a href="#二、面向对象进阶" class="headerlink" title="二、面向对象进阶"></a>二、面向对象进阶</h2><h3 id="（一）面向对象中的成员"><a href="#（一）面向对象中的成员" class="headerlink" title="（一）面向对象中的成员"></a>（一）面向对象中的成员</h3><ul><li>变量：<ul><li>类变量：属于类，可以被所有对象共享，一般用于给对象提供公共数据（类似于全局变量）。</li><li>实例变量：属于对象，每个对象中各自维护自己的数据。</li></ul></li><li>方法：<ul><li>绑定方法：默认有一个self参数，由对象进行调用（此时self就等于调用方法的这个对象）【对象&amp;类均可调用】</li><li>类方法：默认有一个cls参数，用类或对象都可以调用（此时cls就等于调用方法的这个类）【对象&amp;类均可调用】</li><li>静态方法：无默认参数，用类和对象都可以调用。【对象&amp;类均可调用】</li></ul></li><li>属性：属性其实是由绑定方法 + 特殊装饰器（<code>@property</code>） 组合创造出来的，<strong>让我们以后在调用方法时可以不加括号</strong></li></ul><h3 id="（二）特殊成员"><a href="#（二）特殊成员" class="headerlink" title="（二）特殊成员"></a>（二）特殊成员</h3><h4 id="1、-new-初始化方法"><a href="#1、-new-初始化方法" class="headerlink" title="1、__new__初始化方法"></a>1、<code>__new__</code>初始化方法</h4><p>在构造方法前创建空对象并返回</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __new__(cls, *args, **kwargs):        print(&quot;第一步：先创建空对象并返回&quot;)        return object.__new__(cls)obj &#x3D; Foo(&quot;武沛齐&quot;)  # 第一步：先创建空对象并返回</code></pre><h4 id="2、-init-构造方法"><a href="#2、-init-构造方法" class="headerlink" title="2、__init__构造方法"></a>2、<code>__init__</code>构造方法</h4><p>对对象进行初始化操作</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name):        print(&quot;第二步：初始化对象，在空对象中创建数据&quot;)        self.name &#x3D; name    def __new__(cls, *args, **kwargs):        print(&quot;第一步：先创建空对象并返回&quot;)        return object.__new__(cls)obj &#x3D; Foo(&quot;武沛齐&quot;)&gt;&gt;&gt;第一步：先创建空对象并返回&gt;&gt;&gt;第二步：初始化对象，在空对象中创建数据</code></pre><h4 id="3、-call"><a href="#3、-call" class="headerlink" title="3、__call__"></a>3、<code>__call__</code></h4><p>使对象可以被执行&#x2F;可以被加括号<code>()</code></p><ul><li>不定义<code>__call__</code>方法执行<code>对象()</code>会报错：’Foo’ object is not callable</li></ul><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __call__(self, *args, **kwargs):        print(&quot;执行call方法&quot;)obj &#x3D; Foo()obj()  # 执行call方法</code></pre><h4 id="4、-str"><a href="#4、-str" class="headerlink" title="4、__str__"></a>4、<code>__str__</code></h4><p>在对象被print打印的时候，直接返回<code>__str__</code>方法的返回值，方法需要返回一个字符串，当做这个对象的描写。</p><ul><li>不定义<code>__str__</code>：执行<code>print(obj)</code>返回一个对象<code>&lt;__main__.Foo object at 0x000001DA77C8CD00&gt;</code></li></ul><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __str__(self):        return &quot;哈哈哈哈&quot;obj &#x3D; Foo()print(obj)</code></pre><h4 id="5、-dict"><a href="#5、-dict" class="headerlink" title="5、__dict__"></a>5、<code>__dict__</code></h4><p>获取类或对象的变量和功能</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name, age):        self.name &#x3D; name        self.age &#x3D; ageobj &#x3D; Foo(&quot;武沛齐&quot;, 19)print(Foo.__dict__)  # &#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;__init__&#39;: &lt;function Foo.__init__ at 0x000002BB3FC8B4C0&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Foo&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Foo&#39; objects&gt;, &#39;__doc__&#39;: None&#125;print(obj.__dict__)  # &#123;&#39;name&#39;: &#39;武沛齐&#39;, &#39;age&#39;: 19&#125;</code></pre><h4 id="6、-getitem-、-setitem-、-delitem"><a href="#6、-getitem-、-setitem-、-delitem" class="headerlink" title="6、__getitem__、__setitem__、__delitem__"></a>6、<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code></h4><p>使对象可以通过<code>[]</code>进行获取、设置和删除元素的操作</p><ul><li>不定义<code>__getitem__</code>执行<code>obj[&quot;x1&quot;]</code>报错：’Foo’ object is not subscriptable</li><li>不定义<code>__setitem__</code>执行<code>obj[&#39;x2&#39;] = 123</code>报错：’Foo’ object does not support item assignment</li><li>不定义<code>__delitem__</code>执行<code>del obj[&#39;x3&#39;]</code>报错：’Foo’ object does not support item deletion</li></ul><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __getitem__(self, item):        pass    def __setitem__(self, key, value):        pass    def __delitem__(self, key):        passobj &#x3D; Foo()obj[&quot;x1&quot;]  # 不定义__getitem__报错：&#39;Foo&#39; object is not subscriptableobj[&#39;x2&#39;] &#x3D; 123  # 不定义__setitem__报错：&#39;Foo&#39; object does not support item assignmentdel obj[&#39;x3&#39;]  # 不定义__delitem__报错：&#39;Foo&#39; object does not support item deletion</code></pre><h4 id="7、-enter-、-exit"><a href="#7、-enter-、-exit" class="headerlink" title="7、__enter__、__exit__"></a>7、<code>__enter__</code>、<code>__exit__</code></h4><p>使对象可以使用with关键字</p><ul><li>不定义<code>__enter__</code>和<code>__exit__</code>使用with关键字报错：AttributeError</li></ul><h4 id="【面试题】：补充代码，实现如下功能"><a href="#【面试题】：补充代码，实现如下功能" class="headerlink" title="【面试题】：补充代码，实现如下功能"></a><font color="#dd0000"><strong>【面试题】：补充代码，实现如下功能</strong></font></h4><pre class="language-python" data-language="python"><code class="language-python"># （补充代码，实现如下功能）class Context:        def do_something(self):        print(&#39;内部执行&#39;)with Context() as ctx:    print(&#39;内部执行&#39;)    ctx.do_something()</code></pre><p>答案：</p><pre class="language-python" data-language="python"><code class="language-python">class Context:    def __enter__(self):        return self    def do_something(self):        print(&#39;内部执行&#39;)    def __exit__(self, exc_type, exc_val, exc_tb):        passwith Context() as ctx:    print(&#39;内部执行&#39;)    ctx.do_something()</code></pre><h4 id="8、-add"><a href="#8、-add" class="headerlink" title="8、__add__"></a>8、<code>__add__</code></h4><p>使对象可以使用<code>+</code>号</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name):        self.name &#x3D; name    def __add__(self, other):        return &quot;&#123;&#125;-&#123;&#125;&quot;.format(self.name, other.name)v1 &#x3D; Foo(&quot;alex&quot;)v2 &#x3D; Foo(&quot;sb&quot;)# 对象+值，内部会去执行 对象.__add__方法，并将+后面的值当做参数传递过去。v3 &#x3D; v1 + v2print(v3)</code></pre><h4 id="9、-iter-、-next"><a href="#9、-iter-、-next" class="headerlink" title="9、__iter__、__next__"></a>9、<code>__iter__</code>、<code>__next__</code></h4><ul><li><p>迭代器：</p><ul><li>类中定义了<code>__iter__</code>和<code>__next__</code>两个方法</li><li><code>__iter__ </code>方法需要返回对象本身，即：<code>self</code></li><li><code>__next__ </code>方法，返回下一个数据，如果没有数据了，则需要抛出一个<code>StopIteration</code>的异常</li></ul></li><li><p>生成器：如果按照迭代器的规定来看，其实生成器类也是一种特殊的迭代器类（生成器也是一种特殊的迭代器）。</p></li><li><p>可迭代对象</p><ul><li>如果一个类中有<code>__iter__</code>方法且返回一个迭代器对象 ；则我们称以这个类创建的对象为可迭代对象。</li></ul></li><li><p>示例代码</p></li></ul><pre class="language-python" data-language="python"><code class="language-python"># 创建 迭代器类型 ：class IT(object):        def __init__(self):            self.counter &#x3D; 0        def __iter__(self):            return self        def __next__(self):            self.counter +&#x3D; 1            if self.counter &#x3D;&#x3D; 3:                raise StopIteration()            return self.counter# 根据类实例化创建一个迭代器对象：    obj1 &#x3D; IT()        # v1 &#x3D; obj1.__next__()    # v2 &#x3D; obj1.__next__()    # v3 &#x3D; obj1.__next__() # 抛出异常        v1 &#x3D; next(obj1) # obj1.__next__()    print(v1)    v2 &#x3D; next(obj1)    print(v2)    v3 &#x3D; next(obj1)    print(v3)    obj2 &#x3D; IT()for item in obj2:  # 首先会执行迭代器对象的__iter__方法并获取返回值，一直去反复的执行 next(对象) print(item)        # 迭代器对象支持通过next取值，如果取值结束则自动抛出StopIteration。# for循环内部在循环时，先执行__iter__方法，获取一个迭代器对象，然后不断执行的next取值（有异常StopIteration则终止循环）。</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 创建生成器函数    def func():        yield 1        yield 2    # 创建生成器对象（内部是根据生成器类generator创建的对象），生成器类的内部也声明了：__iter__、__next__ 方法。    obj1 &#x3D; func()        v1 &#x3D; next(obj1)    print(v1)    v2 &#x3D; next(obj1)    print(v2)    v3 &#x3D; next(obj1)    print(v3)    obj2 &#x3D; func()    for item in obj2:        print(item)如果按照迭代器的规定来看，其实生成器类也是一种特殊的迭代器类（生成器也是一种特殊的迭代器）。</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 如果一个类中有__iter__方法且返回一个迭代器对象 ；则我们称以这个类创建的对象为可迭代对象。class Foo(object):        def __iter__(self):        return 迭代器对象(生成器对象)    obj &#x3D; Foo() # obj是 可迭代对象。# 可迭代对象是可以使用for来进行循环，在循环的内部其实是先执行 __iter__ 方法，获取其迭代器对象，然后再在内部执行这个迭代器对象的next功能，逐步取值。for item in obj:    pass</code></pre><h2 id="三、面向对象高级和应用"><a href="#三、面向对象高级和应用" class="headerlink" title="三、面向对象高级和应用"></a>三、面向对象高级和应用</h2><h3 id="（一）mro和c3算法"><a href="#（一）mro和c3算法" class="headerlink" title="（一）mro和c3算法"></a>（一）mro和c3算法</h3><ul><li><p>mro：获取类的继承关系</p><pre class="language-python" data-language="python"><code class="language-python">class C(object):    passclass B(object):    passclass A(B, C):    passprint( A.mro() )   # [&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code></pre></li><li><p>c3算法：<font color="#dd0000"><strong>从左到右，深度优先，大小钻石，留住顶端</strong></font></p></li></ul><h3 id="（二）内置函数补充"><a href="#（二）内置函数补充" class="headerlink" title="（二）内置函数补充"></a>（二）内置函数补充</h3><ul><li><p><code>staticmethod</code></p></li><li><p><code>classmethod</code></p></li><li><p><code>property</code></p></li><li><p><code>callable</code></p></li><li><p><code>isinstance</code></p></li><li><p><code>issubclass</code></p></li><li><p><code>super</code></p></li><li><p>反射相关：</p><ul><li><p><code>getattr</code></p></li><li><p><code>setattr</code></p></li><li><p><code>hasattr</code></p></li><li><p><code>delattr</code></p></li></ul></li></ul><h3 id="（三）字符串操作"><a href="#（三）字符串操作" class="headerlink" title="（三）字符串操作"></a>（三）字符串操作</h3><ol><li>根据字符串的形式导入模块 <code>import_module</code></li><li>根据字符串的形式操作成员 <code>反射-getattr,setattr,hasattr,delattr</code></li></ol><h2 id="四、网络编程基础"><a href="#四、网络编程基础" class="headerlink" title="四、网络编程基础"></a>四、网络编程基础</h2><h4 id="（一）二层交换机-amp-路由器-amp-三层交换机-的作用"><a href="#（一）二层交换机-amp-路由器-amp-三层交换机-的作用" class="headerlink" title="（一）二层交换机 &amp; 路由器 &amp; 三层交换机 的作用"></a>（一）二层交换机 &amp; 路由器 &amp; 三层交换机 的作用</h4><ul><li><p>二层交换机：构建局域网，并且实现局域网内数据的转发</p></li><li><p>路由器：实现跨局域网通信</p></li><li><p>三层交换机：具备二层交换机和路由器的功能</p></li></ul><h4 id="（二）简述常见词：IP、子网掩码、DHCP、公网IP、端口、域名的作用。"><a href="#（二）简述常见词：IP、子网掩码、DHCP、公网IP、端口、域名的作用。" class="headerlink" title="（二）简述常见词：IP、子网掩码、DHCP、公网IP、端口、域名的作用。"></a>（二）简述常见词：IP、子网掩码、DHCP、公网IP、端口、域名的作用。</h4><ul><li><p>IP：本质上是一组32位2进制，通过<code>.</code>划分为4个8位的二进制</p></li><li><p>子网掩码：用于指定IP的网络地址和主机地址</p></li><li><p>DHCP：网络设备中的一个服务，用于给接入网络的设备自动设置IP、子网掩码和网关</p></li><li><p>公网IP：一般企业拉专线是会给固定的公网IP，只有具有公网IP才能被互联网上其它电脑访问</p></li><li><p>端口：IP用于表示某台具体电脑，端口表示该电脑上某个具体程序。（0-65535）</p></li><li><p>域名：与IP构造对应关系，方便用户记忆</p></li></ul><h4 id="（三）B-x2F-S架构和C-x2F-S架构"><a href="#（三）B-x2F-S架构和C-x2F-S架构" class="headerlink" title="（三）B&#x2F;S架构和C&#x2F;S架构"></a>（三）B&#x2F;S架构和C&#x2F;S架构</h4><ul><li><p>B&#x2F;S架构，是Browser和Server的简称。开发这种架构的程序意味着你开发服务端即可，客户端用用户电脑上的浏览器来代替。</p></li><li><p>C&#x2F;S架构，是Client和Server的简称。开发这种架构的程序意味着你即需要开发客户端也需要开发服务端。</p></li></ul><h2 id="五、网络编程进阶"><a href="#五、网络编程进阶" class="headerlink" title="五、网络编程进阶"></a>五、网络编程进阶</h2><h3 id="（一）OSI-7层模型"><a href="#（一）OSI-7层模型" class="headerlink" title="（一）OSI 7层模型"></a>（一）OSI 7层模型</h3><ul><li><p>应用层：规定数据的格式。</p><pre class="language-python" data-language="python"><code class="language-python">&quot;GET &#x2F;s?wd&#x3D;你好 HTTP&#x2F;1.1\r\nHost:www.baidu.com\r\n\r\n&quot;</code></pre></li><li><p>表示层：对应用层数据的编码、压缩（解压缩）、分块、加密（解密）等任务。</p><pre class="language-python" data-language="python"><code class="language-python">&quot;GET &#x2F;s?wd&#x3D;你好 HTTP&#x2F;1.1\r\nHost:www.baidu.com\r\n\r\n你好&quot;.encode(&#39;utf-8&#39;)</code></pre></li><li><p>会话层：负责与目标建立、中断连接。</p><pre class="language-none"><code class="language-none">在发送数据之前，需要会先发送 “连接” 的请求，与远程建立连接后，再发送数据。当然，发送完毕之后，也涉及中断连接的操作。</code></pre></li><li><p>传输层：建立端口到端口的通信，其实就确定双方的端口信息。</p><pre class="language-none"><code class="language-none">数据：&quot;GET &#x2F;s?wd&#x3D;你好 HTTP&#x2F;1.1\r\nHost:www.baidu.com\r\n\r\n你好&quot;.encode(&#39;utf-8&#39;)端口：- 目标：80- 本地：6784</code></pre></li><li><p>网络层：标记目标IP信息（IP协议层）</p><pre class="language-none"><code class="language-none">数据：&quot;GET &#x2F;s?wd&#x3D;你好 HTTP&#x2F;1.1\r\nHost:www.baidu.com\r\n\r\n你好&quot;.encode(&#39;utf-8&#39;)端口：- 目标：80- 本地：6784IP：- 目标IP：110.242.68.3（百度）- 本地IP：192.168.10.1</code></pre></li><li><p>数据链路层：对数据进行分组并设置源和目标mac地址</p><pre class="language-none"><code class="language-none">数据：&quot;POST &#x2F;s?wd&#x3D;你好 HTTP&#x2F;1.1\r\nHost:www.baidu.com\r\n\r\n你好&quot;.encode(&#39;utf-8&#39;)端口：- 目标：80- 本地：6784IP：- 目标IP：110.242.68.3（百度）- 本地IP：192.168.10.1MAC：- 目标MAC：FF-FF-FF-FF-FF-FF - 本机MAC：11-9d-d8-1a-dd-cd</code></pre></li><li><p>物理层：将二进制数据在物理媒体上传输。</p><pre class="language-none"><code class="language-none">通过网线将二进制数据发送出去</code></pre></li></ul><h3 id="（二）UDP和TCP协议"><a href="#（二）UDP和TCP协议" class="headerlink" title="（二）UDP和TCP协议"></a>（二）UDP和TCP协议</h3><p>协议，其实就是规定 连接、收发数据的一些规定。</p><ul><li><p>UDP（User Data Protocol）用户数据报协议， 是⼀个⽆连接的简单的⾯向数据报的传输层协议。 UDP不提供可靠性， 它只是把应⽤程序传给IP层的数据报发送出去， 但是并不能保证它们能到达⽬的地。 由于UDP在传输数据报前不⽤在客户和服务器之间建⽴⼀个连接， 且没有超时重发等机制， 故⽽传输速度很快。</p><pre class="language-none"><code class="language-none">常见的有：语音通话、视频通话、实时游戏画面 等。</code></pre></li><li><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接，然后再进行收发数据。</p><pre class="language-none"><code class="language-none">常见有：网站、手机APP数据获取等。</code></pre></li></ul><h3 id="（三）TCP三次握手和四次挥手"><a href="#（三）TCP三次握手和四次挥手" class="headerlink" title="（三）TCP三次握手和四次挥手"></a>（三）TCP三次握手和四次挥手</h3><pre class="language-none"><code class="language-none">    客户端                                                服务端  1.  SYN-SENT    --&gt; &lt;seq&#x3D;100&gt;&lt;CTL&#x3D;SYN&gt;               --&gt; SYN-RECEIVED  2.  ESTABLISHED &lt;-- &lt;seq&#x3D;300&gt;&lt;ack&#x3D;101&gt;&lt;CTL&#x3D;SYN,ACK&gt;  &lt;-- SYN-RECEIVED  3.  ESTABLISHED --&gt; &lt;seq&#x3D;101&gt;&lt;ack&#x3D;301&gt;&lt;CTL&#x3D;ACK&gt;       --&gt; ESTABLISHED      At this point, both the client and server have received an acknowledgment of the connection. The steps 1, 2 establish the connection parameter (sequence number) for one direction and it is acknowledged. The steps 2, 3 establish the connection parameter (sequence number) for the other direction and it is acknowledged. With these, a full-duplex communication is established.</code></pre><pre class="language-none"><code class="language-none">     TCP A                                                TCP B  1.  FIN-WAIT-1  --&gt; &lt;seq&#x3D;100&gt;&lt;ack&#x3D;300&gt;&lt;CTL&#x3D;FIN,ACK&gt;  --&gt; CLOSE-WAIT  2.  FIN-WAIT-2  &lt;-- &lt;seq&#x3D;300&gt;&lt;ack&#x3D;101&gt;&lt;CTL&#x3D;ACK&gt;      &lt;-- CLOSE-WAIT  3.  TIME-WAIT   &lt;-- &lt;seq&#x3D;300&gt;&lt;ack&#x3D;101&gt;&lt;CTL&#x3D;FIN,ACK&gt;  &lt;-- LAST-ACK  4.  TIME-WAIT   --&gt; &lt;seq&#x3D;101&gt;&lt;ack&#x3D;301&gt;&lt;CTL&#x3D;ACK&gt;      --&gt; CLOSED</code></pre><h3 id="（四）粘包"><a href="#（四）粘包" class="headerlink" title="（四）粘包"></a>（四）粘包</h3><p>两台电脑在进行收发数据时，其实不是直接将数据传输给对方。</p><ul><li>对于发送者，执行 <code>sendall/send</code> 发送消息时，是将数据先发送至自己网卡的 写缓冲区 ，再由缓冲区将数据发送给到对方网卡的读缓冲区。</li><li>对于接受者，执行 <code>recv</code> 接收消息时，是从自己网卡的读缓冲区获取数据。</li></ul><p>所以，如果发送者连续快速的发送了2条信息，接收者在读取时会认为这是1条信息，即：<strong>2个数据包粘在了一起。</strong></p><blockquote><blockquote><p>每次发送的消息时，都将消息划分为 头部（固定字节长度） 和 数据 两部分。例如：头部，用4个字节表示后面数据的长度。</p></blockquote><ul><li>发送数据，先发送数据的长度，再发送数据（或拼接起来再发送）。</li><li>接收数据，先读4个字节就可以知道自己这个数据包中的数据长度，再根据长度读取到数据。</li></ul><p>对于头部需要一个数字并固定为4个字节，这个功能可以借助python的struct包来实现：</p><img src="/2022/06/24/di-san-jie-duan-chong-dian/image-20210215090446549.png" class=""></blockquote>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 第三阶段 </tag>
            
            <tag> 面向对象&amp;网络编程 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nc转tif脚本</title>
      <link href="/2022/06/22/nc-zhuan-tif-jiao-ben/"/>
      <url>/2022/06/22/nc-zhuan-tif-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前置工作"><a href="#一、前置工作" class="headerlink" title="一、前置工作"></a>一、前置工作</h2><ul><li><p>安装<code>numpy</code></p><pre class="language-none"><code class="language-none">pip install numpy</code></pre></li><li><p>安装<code>netCDF4</code></p><pre class="language-none"><code class="language-none">pip install netCDF</code></pre></li><li><p>安装<code>osgeo</code></p><p>直接用<code>pip</code>安装<code>osgeo</code>包会报错，手动安装GDAL包</p><p><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">GDAL安装包下载地址</a></p></li></ul><img src="nc转tif脚本/image-20220623101808209.png" alt="image-20220623101808209" style="zoom:50%;" /><p>注意根据电脑下载对应版本</p><pre class="language-none"><code class="language-none">pip install C:\Users\Geng\Documents\WeChat Files\wxid_rh9270rkkf7z22\FileStorage\MsgAttach\5a9a159f4743700fac722dbd14c562d1\File\2022-06\GDAL-3.4.3-cp310-cp310-win_amd64.whl</code></pre><p>注意：<code>install</code>后为<code>GDAL</code>包的绝对路径</p><h2 id="二、数据源"><a href="#二、数据源" class="headerlink" title="二、数据源"></a>二、数据源</h2><ul><li>此处以<a href="http://www.geodata.cn/">国家地球系统科学数据中心</a>,月平均气温数据为例</li></ul><img src="nc转tif脚本/image-20220623102910567.png" alt="image-20220623102910567" style="zoom:50%;" /><ul><li>选择2022年的气温数据（如果选择年份为多个年份如1952-1954）同样可以使用本脚本</li></ul><img src="nc转tif脚本/image-20220623103101088.png" alt="image-20220623103101088" style="zoom:50%;" /><h2 id="三、查看数据"><a href="#三、查看数据" class="headerlink" title="三、查看数据"></a>三、查看数据</h2><p>通过对数据的查看确定数据的维度等信息其中<font color="#dd0000"><strong>变量名称</strong></font>最为重要后续要使用</p><pre class="language-python" data-language="python"><code class="language-python">import netCDF4 as nc# 了解nc数据情况data &#x3D; r&#39;C:\Users\Geng\Desktop\nc\tmp_2020.nc&#39;nc_data_object &#x3D; nc.Dataset(data)print(&#39;这是整体数据描述&#39;.center(80, &quot;*&quot;))print(nc_data_object)# 查看nc文件包含的变量,注意最后一个变量此处文tmpvariables &#x3D; nc_data_object.variablesfor variable in variables.keys():    print(&#39;变量&#123;&#125;&#39;.format(variable).center(80, &quot;*&quot;))    print(variables[variable])# 单独查看nc文件中存储的变量信息variable &#x3D; nc_data_object.variables[&#39;tmp&#39;]print(&#39;这是变量的信息此处为温度信息tmp&#39;.center(80, &quot;*&quot;))print(variable)</code></pre><h2 id="四、数据输出"><a href="#四、数据输出" class="headerlink" title="四、数据输出"></a>四、数据输出</h2><p>将2022年每个月温度数据信息进行输出，单位为0.1℃</p><h2 id="五、操作过程"><a href="#五、操作过程" class="headerlink" title="五、操作过程"></a>五、操作过程</h2><ul><li><p>修改变量信息<code>tmp</code>为该nc数据中存储的变量，通过<code>nc_data_obj.variables</code>查看</p></li><li><p>修改<code>Input_folder</code>路径到.nc文件上级目录</p></li><li><p>修改<code>Output_folder</code>路径到指定文件夹</p></li></ul><h2 id="六、Python2源码"><a href="#六、Python2源码" class="headerlink" title="六、Python2源码"></a>六、Python2源码</h2><pre class="language-python" data-language="python"><code class="language-python">import numpy as npimport netCDF4 as ncfrom osgeo import gdal,osrimport glob# 单个nc数据降雨量数据读取为多个tif文件def NC_to_tiffs(data, Output_folder):    nc_data_obj &#x3D; nc.Dataset(data)    Lon &#x3D; nc_data_obj.variables[&#39;lon&#39;][:]    Lat &#x3D; nc_data_obj.variables[&#39;lat&#39;][:]    pre_arr &#x3D; np.asarray(nc_data_obj.variables[&#39;tmp&#39;])  # 根据数据存储变量信息进行更改    # 影像的左上角和右下角坐标    LonMin, LatMax, LonMax, LatMin &#x3D; [Lon.min(), Lat.max(), Lon.max(), Lat.min()]    # 分辨率计算    N_Lat &#x3D; len(Lat)    N_Lon &#x3D; len(Lon)    Lon_Res &#x3D; (LonMax - LonMin) &#x2F; (float(N_Lon) - 1)    Lat_Res &#x3D; (LatMax - LatMin) &#x2F; (float(N_Lat) - 1)    for i in range(len(pre_arr[:])):        # 创建.tif文件        driver &#x3D; gdal.GetDriverByName(&#39;GTiff&#39;)        out_tif_name &#x3D; Output_folder + &#39;\\&#39; + data.split(&#39;\\&#39;)[-1].split(&#39;.&#39;)[0] + &#39;_&#39; + str(i + 1) + &#39;.tif&#39;        out_tif &#x3D; driver.Create(out_tif_name, N_Lon, N_Lat, 1, gdal.GDT_Float32)        # 设置影像的显示范围        # -Lat_Res一定要是-的        geotransform &#x3D; (LonMin, Lon_Res, 0, LatMax, 0, -Lat_Res)        out_tif.SetGeoTransform(geotransform)        # 获取地理坐标系统信息，用于选取需要的地理坐标系统        srs &#x3D; osr.SpatialReference()        srs.ImportFromEPSG(4326)  # 定义输出的坐标系为&quot;WGS 84&quot;，AUTHORITY[&quot;EPSG&quot;,&quot;4326&quot;]        out_tif.SetProjection(srs.ExportToWkt())  # 给新建图层赋予投影信息        # 数据写出        out_tif.GetRasterBand(1).WriteArray(pre_arr[i])  # 将数据写入内存，此时没有写入硬盘        out_tif.FlushCache()  # 将数据写入硬盘        out_tif &#x3D; None  # 注意必须关闭tif文件if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    Input_folder &#x3D; r&#39;F:\tmp_2000_2002&#39;    Output_folder &#x3D; r&#39;F:\tmp_2000_2002\out&#39;    # 读取所有nc数据    data_list &#x3D; glob.glob(Input_folder + &#39;\\*.nc&#39;)    for i in range(len(data_list)):        data &#x3D; data_list[i]        NC_to_tiffs(data,Output_folder)        print(data + &#39;-----转tif成功&#39;)    print(&#39;----转换结束----&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入职相关</title>
      <link href="/2022/06/18/ru-zhi-xiang-guan/"/>
      <url>/2022/06/18/ru-zhi-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、劳动合同"><a href="#一、劳动合同" class="headerlink" title="一、劳动合同"></a>一、劳动合同</h2><h3 id="（一）签合同与发工资单位要一致"><a href="#（一）签合同与发工资单位要一致" class="headerlink" title="（一）签合同与发工资单位要一致"></a>（一）签合同与发工资单位要一致</h3><p>部分老板名下有多家公司，会有签合同的公司和你实际工作的公司不一致的情况，甚至发工资的单位也不一样，<strong>在未来有劳动纠纷时个人取证困难。</strong></p><h3 id="（二）工作岗位和地点约定清楚"><a href="#（二）工作岗位和地点约定清楚" class="headerlink" title="（二）工作岗位和地点约定清楚"></a>（二）工作岗位和地点约定清楚</h3><p>在劳动合同中要注明工作岗位的名称，防止未来公司随便以调岗、调工作地的名义，让你被迫主动离职（主动离职不会对你进行赔偿）。</p><h3 id="（三）不要签阴阳合同"><a href="#（三）不要签阴阳合同" class="headerlink" title="（三）不要签阴阳合同"></a>（三）不要签阴阳合同</h3><p>为了应付上级部门检查签一份规范的合同，再签一份不规范的实际合同，<strong>在未来有劳动纠纷时对个人不利，索赔困难。</strong></p><h3 id="（四）保存劳动合同"><a href="#（四）保存劳动合同" class="headerlink" title="（四）保存劳动合同"></a>（四）保存劳动合同</h3><p>签完劳动合同后，公司一份备份，个人也要留一份</p><h3 id="（五）合同期限"><a href="#（五）合同期限" class="headerlink" title="（五）合同期限"></a>（五）合同期限</h3><table><thead><tr><th align="center">劳动合同</th><th align="center">试用期</th></tr></thead><tbody><tr><td align="center">三个月~一年</td><td align="center">不得超过一个月</td></tr><tr><td align="center">一年~三年</td><td align="center">不得超过两个月</td></tr><tr><td align="center">三年以上~无固定</td><td align="center">不得超过六个月</td></tr></tbody></table><h3 id="（六）签劳动合同的时间"><a href="#（六）签劳动合同的时间" class="headerlink" title="（六）签劳动合同的时间"></a>（六）签劳动合同的时间</h3><p>员工入职之日起，一个月内要签署劳动合同，<strong>试用期</strong>也包含在劳动合同内，若公司以各种理由拒绝签订合同，劳动者可以向公司索赔，需向劳动者每月支付两倍的工资。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python模块三day2</title>
      <link href="/2022/06/17/python-mo-kuai-san-day2/"/>
      <url>/2022/06/17/python-mo-kuai-san-day2/</url>
      
        <content type="html"><![CDATA[<h2 id="二十一、网络编程：理解即可"><a href="#二十一、网络编程：理解即可" class="headerlink" title="二十一、网络编程：理解即可"></a>二十一、网络编程：理解即可</h2><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210220091551058.png" class="" title="image-20210220091551058"><p>课程目标：掌握网络相关的基础知识并可以基于Python开发程序（基于网络进行数据传输）。</p><p>课程概要：</p><ul><li>网络必备基础</li><li>网络编程（Python代码）</li><li>B&#x2F;S和C&#x2F;S架构</li></ul><h3 id="1-必备基础"><a href="#1-必备基础" class="headerlink" title="1.必备基础"></a>1.必备基础</h3><p>你必须了解的网络相关设备和基础概念。</p><h4 id="1-1-网络架构"><a href="#1-1-网络架构" class="headerlink" title="1.1 网络架构"></a>1.1 网络架构</h4><p>假设 <strong>alex</strong> 上了一个野鸡大学买了一台电脑，电脑里存了1部小电影，整宿整宿的在宿舍反复的看。</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210204184431053-3881170.png" class="" title="image-20210204184431053"><p><strong>alex</strong> 如何想要和室友 <strong>于超</strong> 进行收发数据，可以通过一根网线来进行连接，并进行数据的传输。</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210204185417337-3881170.png" class="" title="image-20210204185417337"><h5 id="1-1-1-交换机"><a href="#1-1-1-交换机" class="headerlink" title="1.1.1 交换机"></a>1.1.1 交换机</h5><p>其他2位室友如何也想和他们的电脑相互连接然后进行资源的共享，此时就需要一个设备 【二层交换机】组件一个局域网。</p><pre class="language-python" data-language="python"><code class="language-python">当电脑接入交换机之后，我们需要为每台电脑分配一个IP，例如：    - 电脑1：192.168.10.1    - 电脑2：192.168.10.2    - 电脑3：192.168.10.3    - 电脑4：192.168.10.4</code></pre><pre class="language-none"><code class="language-none">局域网内容个电脑之间是基于ARP协议来进行通信，例如：A电脑向 IP为192.168.10.3的另一个电脑发送消息。第一步：A封装数据包，此时只知道目标IP不知道目标mac地址（未知mac地址时默认会设置为FF）。第二步：将数据包发送到交换机，交换机通过广播的形式将数据发送给所有电脑。第三步：目标电脑接收到数据包后，监测自己是否是目标IP。- 是，收到数据并回复。- 不是，则丢弃包。为防止每次发送消息都是广播形式，每台电脑的内部都为维护了一个ARP表，接受到数据时（无论是否自己的）都会记录自己了解的IP和MAC的对应关系，例如：    Internet地址       物理地址    192.168.10.1            14-9d-da-2a-dd-0a    192.168.10.3            14-9d-da-2a-dd-0c    ...    以便于下次在发送消息时，就知道了目标的mac地址，直接让交换机转发给指定的电脑（单播）。同时，当有消息发送经过二层交换机时他的内容也会维护记录了交换机接口和连接的电脑的mac地址的对应关系，例如：    接口（网卡）               mac地址      接口1              14-9d-da-2a-dd-0A      接口2              14-9d-da-2a-dd-0B      接口3              14-9d-da-2a-dd-0C      ...这样一来，交换机在进行数据转发时，效率就更高了。注意：每台电脑出厂时在网卡中都设置了唯一的mac地址（不重复），网卡集成在主板上，如果更换了主板则mac地址也会变更。</code></pre><img src="Python模块三day2/image-20210221142111266.png" alt="image-20210221142111266" style="zoom:33%;" /><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210205143317465-3881170.png" class="" title="image-20210205143317465"><pre class="language-none"><code class="language-none">头部信息：源ip地址 源mac地址 目标ip地址数据：你好</code></pre><pre class="language-none"><code class="language-none">头部信息：源ip地址 源mac地址 目标ip地址 目标mac地址数据：收到</code></pre><h5 id="1-1-2-路由器"><a href="#1-1-2-路由器" class="headerlink" title="1.1.2 路由器"></a>1.1.2 路由器</h5><p>多个宿舍之间想想要组建一个相互可以通信网络，此时需要【二层交换机】和【企业路由器】配合组建稍微大一点的局域网（同时也可缓解广播风暴）。</p><pre class="language-none"><code class="language-none">划分好网络结构之后，其实会给各宿舍的电脑分配IP和网关，例如：   宿舍A：- 电脑1：192.168.10.1  网关：192.168.10.254- 电脑2：192.168.10.2  网关：192.168.10.254- 电脑3：192.168.10.3  网关：192.168.10.254- 电脑4：192.168.10.4  网关：192.168.10.254   宿舍B- 电脑1：192.168.20.1  网关：192.168.20.254- 电脑2：192.168.20.2  网关：192.168.20.254- 电脑3：192.168.20.3  网关：192.168.20.254- 电脑4：192.168.20.4  网关：192.168.20.254然后再在路由器中配置路由表（包含网段和路由器上的接口的对应关系），例如： 接口             IP     eth0     192.168.10.254（192.168.10网段）     eth1     192.168.20.254（192.168.20网段）    想与外部网络通信，需要配置网关，网关就是路由表中配置的指向此网段的IP。其实就类似于贸易出口都需要经过海关。</code></pre><pre class="language-python" data-language="python"><code class="language-python">数据通信的过程结合了APR协议和IP协议，例如：宿舍A的电脑1向宿舍B的电脑3发送消息（目标IP：192.168.20.3）。简化过程：- 宿舍A的电脑1，通过广播或单播将数据发送到网管（路由器）    - 路由器接收到数据之后，再通过对应的接口把数据通过广播的形式发送到宿舍B。注意：各自局域网内通过学习并记录相关mac地址后，就可以不再使用广播形式，而是使用单播来发送消息了。</code></pre><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210204205902286-3890545.png" class="" title="image-20210204205902286"><img src="Python模块三day2/image-20210221145506980.png" alt="image-20210221145506980" style="zoom:33%;" /><h5 id="1-1-3-三层交换机"><a href="#1-1-3-三层交换机" class="headerlink" title="1.1.3 三层交换机"></a>1.1.3 三层交换机</h5><p>三层交换机集成了 交换机 &amp; 路由器的功能（大部分路由器功能），上述的三个设备其实可以用一个三层交换机就可以搞定。</p><pre class="language-python" data-language="python"><code class="language-python">按照下图，在三层交换机上分别做如下几件事：1. 划分两个vlan，模拟出来路由器的两个接口。2. 将交换机的接口划分给指定的vlan，例如：接口1、2、3划分给一个vlan，相当于交换机连接上了路由器。    接口4、5、6划分给一个vlan，相当于交换机连接上了路由器。3. 电脑连接上交换机。4. 进行相应的配置。宿舍A（左边）电脑配置：    - 电脑1：192.168.10.1  网关：192.168.10.254对应交换机接口：1- 电脑2：192.168.10.2  网关：192.168.10.254对应交换机接口：2- 电脑3：192.168.10.3  网关：192.168.10.254对应交换机接口：3宿舍B（右边）电脑配置：- 电脑1：192.168.20.1  网关：192.168.20.254对应交换机接口：4- 电脑2：192.168.20.2  网关：192.168.20.254对应交换机接口：5- 电脑3：192.168.20.3  网关：192.168.20.254对应交换机接口：6    交换机中的路由配置：      接口               IP         左vlan     192.168.10.254（192.168.10网段）         右vlan     192.168.20.254（192.168.20网段）        通过上述的配置之后，就可以实现宿舍A和宿舍B的网络通信了。</code></pre><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210206092454106-3881170.png" class="" title="image-20210206092454106"><h5 id="1-1-4-小型企业基础网络架构"><a href="#1-1-4-小型企业基础网络架构" class="headerlink" title="1.1.4 小型企业基础网络架构"></a>1.1.4 小型企业基础网络架构</h5><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210206225844012.png" class="" title="image-20210206225844012"><h5 id="1-1-5-家庭网络架构"><a href="#1-1-5-家庭网络架构" class="headerlink" title="1.1.5 家庭网络架构"></a>1.1.5 家庭网络架构</h5><p>家用路由器集成了是交换机和路由的功能（性能差、价格便宜）。</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210206231121896.png" class="" title="image-20210206231121896"><h5 id="1-1-6-互联网"><a href="#1-1-6-互联网" class="headerlink" title="1.1.6 互联网"></a>1.1.6 互联网<img src="/2022/06/17/python-mo-kuai-san-day2/image-20210206231602247.png" class="" title="image-20210206231602247"></h5><h4 id="1-2-网络核心词汇"><a href="#1-2-网络核心词汇" class="headerlink" title="1.2 网络核心词汇"></a>1.2 网络核心词汇</h4><h6 id="1-2-1-子网掩码和IP"><a href="#1-2-1-子网掩码和IP" class="headerlink" title="1.2.1 子网掩码和IP"></a>1.2.1 子网掩码和IP</h6><p>之前说过，接入网络设备后，需要一个IP来代指次电脑，例如：192.168.10.1 。</p><p>IP其是一个32位的二进制，为了便于记忆就将它分为4组，每组8位，由小数点分开，例如：</p><pre class="language-none"><code class="language-none">二进制表示：00000000.10010111.11111111.00001111十进制表示：251.151.255.150~255192.178.11.211192.178.11.311</code></pre><p>在网络中的每台电脑都会有一个IP与之绑定，这样通过IP就可以找到相应的电脑。</p><p>一个IP地址可以划分为两个部分，即：网络地址 + 主机地址。</p><ul><li><p>问题1：如何确定网络地址和主机地址呢？</p><pre class="language-none"><code class="language-none">通过子网掩码就可以确定IP的网络地址和主机地址。示例1：    IP：192.168.1.199      11000000.10101000.00000001.11000111子网掩码：255.255.255.0     11111111.11111111.11111111.00000000此时，网络地址就是前24位 + 主机地址是后8位。你可能见过有些IP这样写 192.168.1.199&#x2F;24，意思也是前24位是网络地址。示例2：    IP：192.168.99.254     11000000.10101000.01100011.11111110子网掩码：255.255.240.0     11111111.11111111.11111100.00000000此时，网络地址就是前22位 + 主机地址是后10位。你可能见过有些IP这样写 192.168.99.254&#x2F;22，意思也是前22位是网络地址。</code></pre></li><li><p>问题2：划分 网络地址 + 主机地址 的意义是什么？</p><pre class="language-none"><code class="language-none">网络地址相同的IP，也称为属于同一个网段。在局域网内只有同一个网段的IP才能相互通信，不同网段IP想要通信需要借助路由的转发才能通信。当了解子网掩码之后，其实就可以确定某个网段可以容纳的主机个数，例如：【IP: 192.168.10.2  掩码：255.255.255.0】 和 【192.168.10.251 掩码：255.255.255.0】 数据同一个网段。示例网段的主机范围：11000000.10101000.00001010. 00000001  ~  11000000.10101000.00001010.  11111110                 --------------------------              --------------------------                          网络地址                                   网络地址           192.168.10.1                 ~           192.168.10.254                           【IP: 192.168.8.1  掩码：255.255.240.0】 和 【192.168.11.254 掩码：255.255.240.0】 数据同一个网段。子网掩码：255.255.240.0示例网段的主机范围：11000000.10101000.000010 00.00000001  ~  11000000.10101000.000010 11.11111110                 11111111.11111111.111111 00.00000000                 ------------------------                 ------------------------                          网络地址                                   网络地址           192.168.8.1                 ~           192.168.11.254           【IP: 192.168.96.1  掩码：255.255.240.0】 和 【192.168.99.254  掩码：255.255.240.0】 数据同一个网段。示例网段的主机范围：11000000.10101000.011000 00.00000001  ~  11000000.10101000.011000 11.11111110                          ------------------------                 ------------------------                          网络地址                                   网络地址           192.168.96.1                 ~           192.168.99.254    </code></pre><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210207001644433.png" class="" title="image-20210207001644433"><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210207135331788.png" class="" title="image-20210207135331788"></li></ul><h6 id="1-2-2-DHCP"><a href="#1-2-2-DHCP" class="headerlink" title="1.2.2 DHCP"></a>1.2.2 DHCP</h6><p>在一个局域网内想要给某台电脑分配IP有两种方式：</p><ul><li><p>手动设置，打开指定菜单栏在里面输入相应的IP信息。</p></li><li><p>自动获取</p><pre class="language-python" data-language="python"><code class="language-python">- 在电脑端，IP地址获取方式设置为自动。- 在路由器或三层交换机，开启DHCP服务，并设置IP地址池。（家用路由器上也是基于DHCP服务自动分配的IP）这样，电脑只要连接只该网络，DHCP服务就会为它自动分配IP、子网掩码、网关。</code></pre></li></ul><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210207143152690.png" class="" title="image-20210207143152690"><img src="Python模块三day2/image-20210207143340596.png" alt="image-20210207143340596" style="zoom:33%;" /><h6 id="1-2-3-内网和公网IP"><a href="#1-2-3-内网和公网IP" class="headerlink" title="1.2.3 内网和公网IP"></a>1.2.3 内网和公网IP</h6><pre class="language-none"><code class="language-none">一般情况下，内网IP都用这些（潜规则）：- 10.0.0.0 到 10.255.255.255- 172.16.0.0 到172.31.255.255- 192.168.0.0 到192.168.255.255</code></pre><p>之前我们自己在一个局域网内为电脑分配的IP都称为<code>内网IP</code>，基于内网IP可以在一个局域网内进行相互通信（也需要相关的配置）。</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210207211646642.png" class="" title="image-20210207211646642"><p>如果想要通过互联网进行通信，就必须借助公网IP。例如，右边家庭电脑想访问左边某公司服务器上的部署的网站：</p><ul><li>第一步：左边公司，去运营商申请公网的固定IP（办理专线宽带时运营商会分配至少1个固定的IP地址），其实运营商就是将你拉的这个专线和固定IP创建绑定关系。（假设公网IP：123.206.15.88）</li><li>第二步：配置公网IP与指定服务器的转发规则。</li><li>第二步：右边家庭，如果想要访问某个公司服务器上的网网站，只需要执行指定IP：123.206.15.88，运营商就会根据IP找到与之关联的公司专线，并通过公司路由器、防火墙等设备找到指定的服务器。</li></ul><p>按理说，每个从运营商接入网的用户都可以有一个外网IP，但由于全球用户太多而IP根本就不够分配，所以，运营商网络会进行划分，让多个家庭宽带用户共用一个公网IP（动态，可能每次上网公网IP都不一样）。</p><p>让家庭用户想要通过网络访问访问其他IP时，先发给运营商由运营商向外转发到其他IP。</p><p>注意：外部用户想要访问家庭宽带的IP时，运营商不会把请求转发到我们的电脑。</p><img src="Python模块三day2/image-20210221173632272.png" alt="image-20210221173632272" style="zoom:50%;" /><p>所以，以后如果你想开发一个网站供全球的用户访问，那你就需要做以下几件事：</p><ul><li>拉专线，申请固定公网IP</li><li>买一台服务器（就是性能好的电脑）</li><li>公网IP绑定至此服务器</li><li>将写好的代码放在服务器上并运行起来</li></ul><p>这样就可以搞定了…</p><p><strong>扩展</strong>：IPv4和IPv6</p><pre class="language-python" data-language="python"><code class="language-python">IPv4，长度为 32 位（4 个字节）， 格式：A.B.C.DIPv6，长度为 128 位（16 个字节），用&quot;:&quot;分成8段，格式：XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX（每个X是一个16进制数）。</code></pre><h6 id="1-2-4-云服务器"><a href="#1-2-4-云服务器" class="headerlink" title="1.2.4 云服务器"></a>1.2.4 云服务器</h6><p>大家可能之前听说过：阿里云、腾讯云、亚马逊aws等之类的平台都在搞云服务器，那是个啥？</p><img src="Python模块三day2/image-20210207214828047.png" alt="image-20210207214828047" style="zoom:50%;" /><p>简单的说：他们造了一个机房（网吧），买了很多很多的服务器（高性能电脑），然后将他们放在机房，然后通电+通网，主要对外去租赁这些服务器资源，让用户不必再自己  拉专线+配置网络+买服务器。</p><p>假设，你想要在腾讯云租一台服务器，就可以根据自己的需求去选择配置，腾讯云会根据配置在他的物理机上虚拟出一个服务器，并进行相应的环境初始化并绑定公网固定IP，这样你就可以快速拥有一台可以被大家访问的服务器了。</p><p>注意：一台性能非常高的物理机虚拟出很多虚拟机，类似于你在自己电脑上通过vmware、parallel等搞出多个虚拟机。</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210207215523168.png" class="" title="image-20210207215523168"><h6 id="1-2-5-端口"><a href="#1-2-5-端口" class="headerlink" title="1.2.5 端口"></a>1.2.5 端口</h6><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210207221334711.png" class="" title="image-20210207221334711"><p>假设，你在腾讯租了一台云服务器（外网IP:123.206.15.88），然后又开发了 2 个网站运行在服务器上。</p><p>那么问题来了，用户在自己的电脑或手机上如何来分别访问同一台服务器上两个程序呢？</p><p>其实，在计算机中有一个 <code>端口</code> 的概念，每个程序想要通过网络进行通讯都必须要指定一个端口，例如：</p><ul><li>网站A：使用8001端口，那么用户在自己电脑上或手机上访问时指定 IP和端口 即可，如： <code>123.206.15.88:8001</code> </li><li>网站B：使用8002端口，那么用户在自己电脑上或手机上访问时指定 IP和端口 即可，如： <code>123.206.15.88:8002</code></li></ul><p>注意：端口的取值范围：0 ~ 65535，很多端口在计算机的内部已被使用，我们平时自定义时尽量选择5000之后的端口。</p><p>示例：访问百度</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210207230929229.png" class="" title="image-20210207230929229"><p>提示：如果在浏览器上只写IP不写端口，则默认是80端口。</p><h6 id="1-2-6-域名"><a href="#1-2-6-域名" class="headerlink" title="1.2.6 域名"></a>1.2.6 域名</h6><p>假设你创业开发了一个网站，用户很难记住你的公网IP：<code>123.206.15.88:80</code>   &#96;&#96;123.206.15.88&#96;。</p><p>所以，域名就诞生了，让域名和IP创建对应关系，用户只需要记住域名就可以了，例如：</p><pre class="language-none"><code class="language-none">www.baidu.com   --&gt;  110.242.68.3www.taobao.com  --&gt; 121.18.239.232...</code></pre><p>注意：域名只是和IP创建了对应关系，与端口无关 <code>www.baidu.com:80</code>。</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210207221334711.png" class="" title="image-20210207221334711"><p>在用户在自己的电脑或手机上输入域名去访问时，其实要执行两个步骤：</p><ul><li>根据域名寻找IP。（寻找IP）</li><li>获得IP之后，再通过IP再去访问指定服务器。</li></ul><p>在电脑上属如域名后，寻找IP的过程如下：</p><ul><li><p>第一步：在自己电脑的DNS缓存记录中寻找 域名对应的IP，如果未命中，则执行下一步。</p></li><li><p>第二步：在自己电脑的hosts文件中寻找，如果未命中，则执行下一步。</p><pre class="language-none"><code class="language-none">- mac系统：&#x2F;etc&#x2F;hosts 文件中- win系统：C:\Windows\System32\drivers\etc\hosts 文件中</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 内容示例127.0.0.1localhost255.255.255.255broadcasthost127.0.0.1 kubernetes.docker.internal192.168.1.55 www.pythonav.com</code></pre></li><li><p>第三步：在自己电脑上找到DNS配置的地址（本地域名服务器），去这个地址寻找域名对应的IP，如果未命中，则执行下一步。</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210207233253951.png" class="" title="image-20210207233253951"><pre class="language-python" data-language="python"><code class="language-python">常见的DNS服务器地址：114.114.114.114（114 DNS）    223.5.5.5（阿里 AliDNS）    8.8.8.8（Google DNS，随着Google在中国的没落和国内官方的限制，已经不是太好用了）    ...    各大运营商也有相应的DNS服务器...    如果你选择的是自动获得DNS，那么就会使用本地运营商的DNS服务器了。</code></pre></li><li><p>第四步：去根域名服务器中询问（全球共13台根域名服务器，距离中国最近的一台是在日本）</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210208102929953.png" class="" title="image-20210208102929953"></li></ul><p><span style="color:red;"><strong>问题来了</strong></span></p><p>了解域名是怎么回事之后？现在你如果想要让自己的网站通过域名来访问，应该怎么办呢？【目前了解即可】</p><ul><li><p>租一个域名</p><pre class="language-none"><code class="language-none">ICANN，域名的总管理者（美国一个非营利机构），它仅制定域名政策，注册业务它会授权给一些顶级注册商。顶级注册商，可以对外销售域名，但要受国家 互联网络信息中心的管理。例如：中国万网(阿里云收购），中国新网，新网互联，商务中国，中国频道等。代理注册商，顶级注册上可以再招一些代理帮助他们卖域名。</code></pre><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210208110607388.png" class="" title="image-20210208110607388"></li><li><p>备案</p><pre class="language-none"><code class="language-none">现在国内注册域名后，需要进行备案（提交一些网站、个人或企业 等信息）后才能使用。注册成功后，可按照引导备案：https:&#x2F;&#x2F;beian.aliyun.com&#x2F;注意：国外的域名无需备案就能使用。</code></pre></li><li><p>域名解析</p><pre class="language-none"><code class="language-none">让域名和IP创建关联关系，并将关系同步到相关：本地域名服务器 和 根域名服务器（含顶级和二级域名服务器）。</code></pre><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210208110829796.png" class="" title="image-20210208110829796"><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210208110938038.png" class="" title="image-20210208110938038"></li></ul><h3 id="2-网络编程"><a href="#2-网络编程" class="headerlink" title="2. 网络编程"></a>2. 网络编程</h3><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210207221334711.png" class="" title="image-20210207221334711"><p>Python中内置了一个socket模块，可以快速实现网络之间进行传输数据。例如：</p><ul><li><p>服务端，放在左边云服务器中（有固定IP）</p><pre class="language-python" data-language="python"><code class="language-python">import socket# 1.监听本机的IP和端口sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.bind((&#39;123.206.15.88&#39;, 8001)) # IP,端口sock.listen(5) # 支持排队等待5人while True:    # 2.等待，有人来连接（阻塞）    conn, addr &#x3D; sock.accept() # 等待客户端来连接（阻塞）    # 3.等待，连接者发送消息（阻塞）    client_data &#x3D; conn.recv(1024) # 等待接收客户端发来数据    print(client_data) # 字节    # print(client_data.decode(&#39;utf-8&#39;))     # 4.给连接者回复消息    conn.sendall(&quot;hello world&quot;.encode(&#39;utf-8&#39;))    # 5.关闭连接    conn.close()# 6.停止服务端程序sock.close()</code></pre></li><li><p>客户端，放在右边用户电脑上</p><pre class="language-python" data-language="python"><code class="language-python">import socket# 1. 向指定IP发送连接请求client &#x3D; socket.socket()client.connect((&#39;123.206.15.88&#39;, 8001)) # 向服务端发起连接（阻塞）10s# 2. 连接成功之后，发送消息client.sendall(&#39;hello&#39;.encode(&#39;utf-8&#39;))# 3. 等待，消息的回复（阻塞）reply &#x3D; client.recv(1024)print(reply)# 4. 关闭连接client.close()</code></pre></li></ul><p>上述示例需要借助于互联网，你至少需要租一台云服务器才能通信。</p><p>为了节省学习成本，大家可以在自己电脑上模拟【服务端】和【客户端】，等以后项目开发完毕后，再租服务器并部署到服务器上。</p><p>注意：在自己本地运行上述代码时，要监听和连接时的IP地址。</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210208164809572.png" class="" title="image-20210208164809572"><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210221190543727.png" class="" title="image-20210221190543727"><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210221190426551.png" class="" title="image-20210221190426551"><p>当然，你也可以把在自己的局域网内找两台电脑，A作为服务端，B作为客户端，这样两者也可以通信。</p><pre class="language-python" data-language="python"><code class="language-python">服务端的代码需修改：监听的IP修改为A的IP地址。客户端的代码需修改：连接的IP修改为A的IP地址（客户端要去找到服务端，并与服务端创建连接）。</code></pre><p>注意事项：</p><ul><li><p>本机：</p><pre class="language-none"><code class="language-none">服务端IP：127.0.0.1  &#x2F; 192.168.28.92（局域网IP）</code></pre></li><li><p>局域网：</p><pre class="language-python" data-language="python"><code class="language-python">服务端IP：192.168.28.92（局域网IP）    </code></pre></li><li><p>互联网</p><pre class="language-python" data-language="python"><code class="language-python">服务端IP：123.206.15.88（外网IP）</code></pre></li></ul><h4 id="案例：智障客服"><a href="#案例：智障客服" class="headerlink" title="案例：智障客服"></a>案例：智障客服</h4><ul><li><p>服务端</p><pre class="language-python" data-language="python"><code class="language-python">import socket# 1.监听本机的IP和端口sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.bind((&#39;127.0.0.1&#39;, 8001))  # 127.0.0.1 或 查看自己局域网本地IP地址sock.listen(5)while True:    # 2.等待，有人来连接（阻塞）    conn, addr &#x3D; sock.accept()    print(&quot;有人来连接了...&quot;)    # 3.连接成功后立即发送    conn.sendall(&quot;欢迎使用xx系统，请输入您想要办理的业务！&quot;.encode(&quot;utf-8&quot;))    while True:        # 3.等待接受信息        data &#x3D; conn.recv(1024)        if not data:            break        data_string &#x3D; data.decode(&quot;utf-8&quot;)        # 4.回复消息        conn.sendall(&quot;你说啥？&quot;.encode(&quot;utf-8&quot;))    print(&quot;断开连接了&quot;)    # 5.关闭与此人的连接    conn.close()# 6.停止服务端程序sock.close()</code></pre></li><li><p>客户端</p><pre class="language-python" data-language="python"><code class="language-python">import socket# 1. 向指定IP发送连接请求client &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)client.connect((&#39;127.0.0.1&#39;, 8001))# 2.连接成功后，获取系统登录信息message &#x3D; client.recv(1024)print(message.decode(&quot;utf-8&quot;))while True:    content &#x3D; input(&quot;请输入(q&#x2F;Q退出)：&quot;)    if content.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    client.sendall(content.encode(&quot;utf-8&quot;))    # 3. 等待，消息的回复    reply &#x3D; client.recv(1024)    print(reply.decode(&quot;utf-8&quot;))# 关闭连接，关闭连接时会向服务端发送空数据。client.close()</code></pre></li></ul><h4 id="案例：文件上传"><a href="#案例：文件上传" class="headerlink" title="案例：文件上传"></a>案例：文件上传</h4><ul><li><p>服务端</p><pre class="language-python" data-language="python"><code class="language-python">import socketsock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.bind((&#39;127.0.0.1&#39;, 8001))  # 127.0.0.1 或 查看自己局域网本地IP地址sock.listen(5)conn, addr &#x3D; sock.accept()# 接收文件大小data &#x3D; conn.recv(1024)total_file_size &#x3D; int(data.decode(&#39;utf-8&#39;))# 接收文件内容file_object &#x3D; open(&#39;xxx.png&#39;, mode&#x3D;&#39;wb&#39;)recv_size &#x3D; 0while True:    # 每次最多接收1024字节    data &#x3D; conn.recv(1024)    file_object.write(data)    file_object.flush()    recv_size +&#x3D; len(data)    # 上传完成    if recv_size &#x3D;&#x3D; total_file_size:        break# 接收完毕，关闭连接conn.close()sock.close()</code></pre></li><li><p>客户端</p><pre class="language-python" data-language="python"><code class="language-python">import timeimport osimport socketclient &#x3D; socket.socket()client.connect((&#39;127.0.0.1&#39;, 8001))file_path &#x3D; input(&quot;请输入要上传的文件：&quot;)# 先发送文件大小file_size &#x3D; os.stat(file_path).st_sizeclient.sendall(str(file_size).encode(&#39;utf-8&#39;))print(&quot;准备...&quot;)time.sleep(2)print(&quot;开始上传..&quot;)file_object &#x3D; open(file_path, mode&#x3D;&#39;rb&#39;)read_size &#x3D; 0while True:    chunk &#x3D; file_object.read(1024) # 每次读取1024字节    client.sendall(chunk)    read_size +&#x3D; len(chunk)    if read_size &#x3D;&#x3D; file_size:        breakclient.close()</code></pre></li></ul><h3 id="3-B-x2F-S和C-x2F-S架构"><a href="#3-B-x2F-S和C-x2F-S架构" class="headerlink" title="3. B&#x2F;S和C&#x2F;S架构"></a>3. B&#x2F;S和C&#x2F;S架构</h3><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210207221334711.png" class="" title="image-20210207221334711"><p>平时在开发或与人沟通时，经常会有人提到b&#x2F;s和c&#x2F;s架构，他们是啥意思呢？</p><ul><li><p>C&#x2F;S架构，是Client和Server的简称。开发这种架构的程序意味着你即需要开发客户端也需要开发服务端。</p><pre class="language-python" data-language="python"><code class="language-python">例如：你电脑的上QQ、百度网盘、钉钉、QQ音乐 等安装在电脑上的软件。服务端：互联网公司会开发一个程序放在他们的服务器上，用于给客户端提供数据支持。客户端：大家在电脑安装的相关程序，内部会连接服务端进行收发数据并提供 交互和展示的功能。</code></pre></li><li><p>B&#x2F;S架构，是Browser和Server的简称。开发这种架构的程序意味着你开发服务端即可，客户端用用户电脑上的浏览器来代替。</p><pre class="language-none"><code class="language-none">例如：淘宝、京东等网站。服务端：互联网公司开发一个网站，放在他们的服务器上。客户端：不需要开发，用现成的浏览器即可。</code></pre></li></ul><p>简而言之，B&#x2F;S架构就是开发网站；C&#x2F;S架构就是开发安装在电脑的软件。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>了解常见设备和网络架构。</li><li>掌握常见网络词汇的意思。</li><li>了解B&#x2F;S和C&#x2F;S架构的区别。</li><li>基于Python的socket模块实现网络编程。</li></ol><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol><li><p>简述 二层交换机 &amp; 路由器 &amp; 三层交换机 的作用。</p><p>答：</p><ul><li>二层交换机：构建局域网，并且实现局域网内数据的转发</li><li>路由器：实现跨局域网通信</li><li>三层交换机：具备二层交换机和局域网的功能</li></ul></li><li><p>简述常见词：IP、子网掩码、DHCP、公网IP、端口、域名的作用。</p><ul><li>IP：本质上是一组32位2进制，通过<code>.</code>划分为4个8位的二进制</li><li>子网掩码：用于指定IP的网络地址和主机地址</li><li>DHCP：网络设备中的一个服务，用于给接入网络的设备自动设置IP、子网掩码和网关</li><li>公网IP：一般企业拉专线是会给固定的公网IP，只有具有公网IP才能被互联网上其它电脑访问</li><li>端口：IP用于表示某台具体电脑，端口表示该电脑上某个具体程序。（0-65535）</li><li>域名：与IP构造对应关系，方便用户记忆</li></ul></li><li><p>实现远程用户认证系统。</p><pre class="language-python" data-language="python"><code class="language-python">客户端：1. 运行程序，连接服务端并获取服务端发送的欢迎使用xx系统信息。    2. 输入用户名和密码，并将用户名和密码发送到服务端去校验。    3. 登录失败，重试（Q退出）。    4. 登录成功，进入系统，提示登录成功服务端：1. 客户端连接上服务端，返回 欢迎使用xx系统信息。    2. 等待客户端发送用户名和密码进行校验（用户名和密码在文件中）    3. 登录失败，返回错误信息。    4. 登录成功，返回成功提示的内容。</code></pre><p>答：</p><p>服务器</p><pre class="language-python" data-language="python"><code class="language-python">import socket# 1.监听本机的IP和端口sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.bind((&#39;127.0.0.1&#39;, 8001)) # IP,端口sock.listen(5) # 支持排队等待5人# 2.等待，有人来连接（阻塞）conn, addr &#x3D; sock.accept()  # 等待客户端来连接（阻塞）# 3.给客户端发送消息conn.sendall(&#39;欢迎使用xx系统&#39;.encode(&#39;utf-8&#39;))while True:    # 3.等待，客户端发送消息（阻塞）    data &#x3D; conn.recv(1024) # 等待接收客户端发来数据    if data.decode(&#39;utf-8&#39;).upper() &#x3D;&#x3D; &#39;Q&#39;:        break    log_user, log_psd &#x3D; data.decode(&#39;utf-8&#39;).split(&#39;;&#39;)    with open(&#39;db&#39;, mode&#x3D;&#39;rb&#39;) as file:        for line in file:            line_str &#x3D; line.strip().decode(&#39;utf-8&#39;)            user, psd &#x3D; line_str.split(&#39;;&#39;)            if log_user &#x3D;&#x3D; user and log_psd &#x3D;&#x3D; psd:                msg &#x3D; &#39;登录成功&#39;                conn.sendall(msg.encode(&#39;utf-8&#39;))                break        else:            msg &#x3D; &#39;登录失败&#39;            conn.sendall(msg.encode(&#39;utf-8&#39;))# 6.停止服务端程序sock.close()</code></pre><p>客户端</p><pre class="language-python" data-language="python"><code class="language-python">import socket# 1. 向指定IP发送连接请求client &#x3D; socket.socket()client.connect((&#39;127.0.0.1&#39;, 8001)) # 向服务端发起连接（阻塞）10s# 2. 等待，消息的回复（阻塞）reply &#x3D; client.recv(1024)print(reply.decode(&#39;utf-8&#39;))# 3.给服务器发送消息while True:    user &#x3D; input(&#39;请输入用户名(输入Q&#x2F;q退出)： &#39;)    if user.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    psd &#x3D; input(&#39;请输入密码： &#39;)    data &#x3D; &quot;;&quot;.join([user, psd])    client.sendall(data.encode(&#39;utf-8&#39;))    # 3.等待，服务器发送消息（阻塞）    res &#x3D; client.recv(1024)    print(res.decode(&#39;utf-8&#39;))# 4. 关闭连接client.close()</code></pre></li></ol><h2 id="二十二、网络编程（下）"><a href="#二十二、网络编程（下）" class="headerlink" title="二十二、网络编程（下）"></a>二十二、网络编程（下）</h2><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210222072456318.png" class="" title="image-20210222072456318"><p>课程目标：学会网络编程开发的必备知识点。</p><p>今日概要：</p><ul><li>OSI7 层模型——理论，理解即可</li><li>TCP和UDP</li><li>粘包</li><li>阻塞和非阻塞——理论，理解即可</li><li>IO多路复用——理论，理解即可</li></ul><h3 id="1-OSI-7层模型"><a href="#1-OSI-7层模型" class="headerlink" title="1. OSI 7层模型"></a>1. OSI 7层模型</h3><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210222072652918.png" class="" title="image-20210222072652918"><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210209113923860.png" class="" title="image-20210209113923860"><p>OSI的7层模型对于大家来说可能不太好理解，所以我们通过一个案例来讲解：</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210209101325856.png" class="" title="image-20210209101325856"><p>假设，你在浏览器上输入了一些关键字，内部通过DNS找到对应的IP后，再发送数据时内部会做如下的事：</p><ul><li><p>应用层：规定数据的格式。</p><pre class="language-python" data-language="python"><code class="language-python">&quot;GET &#x2F;s?wd&#x3D;你好 HTTP&#x2F;1.1\r\nHost:www.baidu.com\r\n\r\n&quot;</code></pre></li><li><p>表示层：对应用层数据的编码、压缩（解压缩）、分块、加密（解密）等任务。</p><pre class="language-python" data-language="python"><code class="language-python">&quot;GET &#x2F;s?wd&#x3D;你好 HTTP&#x2F;1.1\r\nHost:www.baidu.com\r\n\r\n你好&quot;.encode(&#39;utf-8&#39;)</code></pre></li><li><p>会话层：负责与目标建立、中断连接。</p><pre class="language-none"><code class="language-none">在发送数据之前，需要会先发送 “连接” 的请求，与远程建立连接后，再发送数据。当然，发送完毕之后，也涉及中断连接的操作。</code></pre></li><li><p>传输层：建立端口到端口的通信，其实就确定双方的端口信息。</p><pre class="language-none"><code class="language-none">数据：&quot;GET &#x2F;s?wd&#x3D;你好 HTTP&#x2F;1.1\r\nHost:www.baidu.com\r\n\r\n你好&quot;.encode(&#39;utf-8&#39;)端口：- 目标：80- 本地：6784</code></pre></li><li><p>网络层：标记目标IP信息（IP协议层）</p><pre class="language-none"><code class="language-none">数据：&quot;GET &#x2F;s?wd&#x3D;你好 HTTP&#x2F;1.1\r\nHost:www.baidu.com\r\n\r\n你好&quot;.encode(&#39;utf-8&#39;)端口：- 目标：80- 本地：6784IP：- 目标IP：110.242.68.3（百度）- 本地IP：192.168.10.1</code></pre></li><li><p>数据链路层：对数据进行分组并设置源和目标mac地址</p><pre class="language-none"><code class="language-none">数据：&quot;POST &#x2F;s?wd&#x3D;你好 HTTP&#x2F;1.1\r\nHost:www.baidu.com\r\n\r\n你好&quot;.encode(&#39;utf-8&#39;)端口：- 目标：80- 本地：6784IP：- 目标IP：110.242.68.3（百度）- 本地IP：192.168.10.1MAC：- 目标MAC：FF-FF-FF-FF-FF-FF - 本机MAC：11-9d-d8-1a-dd-cd</code></pre></li><li><p>物理层：将二进制数据在物理媒体上传输。</p><pre class="language-none"><code class="language-none">通过网线将二进制数据发送出去</code></pre></li></ul><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210209113923860.png" class="" title="image-20210209113923860"><p>每一层各司其职，最终保证数据呈现在到用户手中。</p><p>简单的可以理解为发快递：将数据外面套了7个箱子，最终用户收到箱子时需要打开7个箱子才能拿到数据。而在运输的过程中有些箱子是会被拆开并替换的，例如：</p><pre class="language-none"><code class="language-none">最终运送目标：上海 ~ 北京（中途可能需要中转站），在中转站会会打开箱子查看信息，在进行转发。- 对于二级中转站（二层交换机）：拆开数据链路层的箱子，查看mac地址信息。- 对于三级中转站（路由器或三层交换机）：拆开网络层的箱子，查看IP信息。</code></pre><p>在开发过程中其实只能体现：应用层、表示层、会话层、传输层，其他层的处理都是在网络设备中自动完成的。</p><pre class="language-python" data-language="python"><code class="language-python">import socketclient &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)client.connect((&#39;110.242.68.3&#39;, 80)) # 向服务端发送了数据包key &#x3D; &quot;你好&quot;# 应用层content &#x3D; &quot;GET &#x2F;s?wd&#x3D;&#123;&#125; http1.1\r\nHost:www.baidu.com\r\n\r\n&quot;.format(key)# 表示层content &#x3D; content.encode(&quot;utf-8&quot;)client.sendall(content)result &#x3D; client.recv(8196)print(result.decode(&#39;utf-8&#39;))# 会话层 &amp; 传输层client.close()</code></pre><h3 id="2-UDP和TCP协议"><a href="#2-UDP和TCP协议" class="headerlink" title="2. UDP和TCP协议"></a>2. UDP和TCP协议</h3><p>协议，其实就是规定 连接、收发数据的一些规定。</p><p>在OSI的 传输层 除了定义端口信息以外，常见的还可以指定UDP或TCP的协议，协议不同连接和传输数据的细节也会不同。</p><ul><li><p>UDP（User Data Protocol）用户数据报协议， 是⼀个⽆连接的简单的⾯向数据报的传输层协议。 UDP不提供可靠性， 它只是把应⽤程序传给IP层的数据报发送出去， 但是并不能保证它们能到达⽬的地。 由于UDP在传输数据报前不⽤在客户和服务器之间建⽴⼀个连接， 且没有超时重发等机制， 故⽽传输速度很快。</p><pre class="language-none"><code class="language-none">常见的有：语音通话、视频通话、实时游戏画面 等。</code></pre></li><li><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接，然后再进行收发数据。</p><pre class="language-none"><code class="language-none">常见有：网站、手机APP数据获取等。</code></pre></li></ul><h4 id="2-1-UDP和TCP-示例代码"><a href="#2-1-UDP和TCP-示例代码" class="headerlink" title="2.1 UDP和TCP 示例代码"></a>2.1 UDP和TCP 示例代码</h4><p>UDP示例如下：</p><ul><li><p>服务端</p><pre class="language-python" data-language="python"><code class="language-python">import socketserver &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  #UDP参数为socket.SOCK_DGRAMserver.bind((&#39;127.0.0.1&#39;, 8002))while True:    data, (host, port) &#x3D; server.recvfrom(1024) # 阻塞    print(data, host, port)    server.sendto(&quot;好的&quot;.encode(&#39;utf-8&#39;), (host, port))</code></pre></li><li><p>客户端</p><pre class="language-python" data-language="python"><code class="language-python">import socketclient &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)while True:    text &#x3D; input(&quot;请输入要发送的内容：&quot;)    if text.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    client.sendto(text.encode(&#39;utf-8&#39;), (&#39;127.0.0.1&#39;, 8002))    data, (host, port) &#x3D; client.recvfrom(1024)    print(data.decode(&#39;utf-8&#39;))client.close()</code></pre></li></ul><p>TCP示例如下：</p><ul><li><p>服务端</p><pre class="language-python" data-language="python"><code class="language-python">import socket# 1.监听本机的IP和端口sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # TCP参数为SOCK_STREAMsock.bind((&#39;127.0.0.1&#39;, 8001))sock.listen(5)while True:    # 2.等待，有人来连接（阻塞）    conn, addr &#x3D; sock.accept()    # 3.等待，连接者发送消息（阻塞）    client_data &#x3D; conn.recv(1024)    print(client_data)    # 4.给连接者回复消息    conn.sendall(b&quot;hello world&quot;)    # 5.关闭连接    conn.close()# 6.停止服务端程序sock.close()</code></pre></li><li><p>客户端</p><pre class="language-python" data-language="python"><code class="language-python">import socket# 1. 向指定IP发送连接请求client &#x3D; socket.socket()client.connect((&#39;127.0.0.1&#39;, 8001))# 2. 连接成功之后，发送消息client.sendall(b&#39;hello&#39;)# 3. 等待，消息的回复（阻塞）reply &#x3D; client.recv(1024)print(reply)# 4. 关闭连接client.close()</code></pre></li></ul><h4 id="2-2-TCP三次握手和四次挥手"><a href="#2-2-TCP三次握手和四次挥手" class="headerlink" title="2.2 TCP三次握手和四次挥手"></a>2.2 TCP三次握手和四次挥手</h4><p>这是一个常见的面试题。</p><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210222072652918.png" class="" title="image-20210222072652918"><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210209113923860.png" class="" title="image-20210209113923860"><pre class="language-none"><code class="language-none"> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          Source Port          |       Destination Port        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                        Sequence Number                        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Acknowledgment Number                      |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|  Data |           |U|A|P|R|S|F|                               || Offset| Reserved  |R|C|S|S|Y|I|            Window             ||       |           |G|K|H|T|N|N|                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|           Checksum            |         Urgent Pointer        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Options                    |    Padding    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                             data                              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>网络中的双方想要基于TCP连接进行通信，必须要经过：</p><ul><li><p>创建连接，客户端和服务端要进行三次握手。</p><pre class="language-python" data-language="python"><code class="language-python"># 服务端import socketsock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.bind((&#39;127.0.0.1&#39;, 8001))sock.listen(5)while True:    conn, addr &#x3D; sock.accept() # 等待客户端连接    ...</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 客户端import socketclient &#x3D; socket.socket()client.connect((&#39;127.0.0.1&#39;, 8001)) # 发起连接</code></pre><pre class="language-none"><code class="language-none">      客户端                                                服务端  1.  SYN-SENT    --&gt; &lt;seq&#x3D;100&gt;&lt;CTL&#x3D;SYN&gt;               --&gt; SYN-RECEIVED  2.  ESTABLISHED &lt;-- &lt;seq&#x3D;300&gt;&lt;ack&#x3D;101&gt;&lt;CTL&#x3D;SYN,ACK&gt;  &lt;-- SYN-RECEIVED  3.  ESTABLISHED --&gt; &lt;seq&#x3D;101&gt;&lt;ack&#x3D;301&gt;&lt;CTL&#x3D;ACK&gt;       --&gt; ESTABLISHED      At this point, both the client and server have received an acknowledgment of the connection. The steps 1, 2 establish the connection parameter (sequence number) for one direction and it is acknowledged. The steps 2, 3 establish the connection parameter (sequence number) for the other direction and it is acknowledged. With these, a full-duplex communication is established.</code></pre></li><li><p>传输数据</p><pre class="language-none"><code class="language-none">在收发数据的过程中，只有有数据的传送就会有应答（ack），如果没有ack，那么内部会尝试重复发送。</code></pre></li><li><p>关闭连接，客户端和服务端要进行4次挥手。</p><pre class="language-python" data-language="python"><code class="language-python">import socketsock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.bind((&#39;127.0.0.1&#39;, 8001))sock.listen(5)while True:    conn, addr &#x3D; sock.accept()...    conn.close() # 关闭连接sock.close()</code></pre><pre class="language-python" data-language="python"><code class="language-python">import socketclient &#x3D; socket.socket()client.connect((&#39;127.0.0.1&#39;, 8001))...client.close() # 关闭连接</code></pre><pre class="language-none"><code class="language-none">     TCP A                                                TCP B  1.  FIN-WAIT-1  --&gt; &lt;seq&#x3D;100&gt;&lt;ack&#x3D;300&gt;&lt;CTL&#x3D;FIN,ACK&gt;  --&gt; CLOSE-WAIT  2.  FIN-WAIT-2  &lt;-- &lt;seq&#x3D;300&gt;&lt;ack&#x3D;101&gt;&lt;CTL&#x3D;ACK&gt;      &lt;-- CLOSE-WAIT  3.  TIME-WAIT   &lt;-- &lt;seq&#x3D;300&gt;&lt;ack&#x3D;101&gt;&lt;CTL&#x3D;FIN,ACK&gt;  &lt;-- LAST-ACK  4.  TIME-WAIT   --&gt; &lt;seq&#x3D;101&gt;&lt;ack&#x3D;301&gt;&lt;CTL&#x3D;ACK&gt;      --&gt; CLOSED</code></pre></li></ul><h3 id="3-粘包"><a href="#3-粘包" class="headerlink" title="3. 粘包"></a>3. 粘包</h3><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210222072652918.png" class="" title="image-20210222072652918"><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210215074546610.png" class="" title="image-20210215074546610"><p>两台电脑在进行收发数据时，其实不是直接将数据传输给对方。</p><ul><li>对于发送者，执行 <code>sendall/send</code> 发送消息时，是将数据先发送至自己网卡的 写缓冲区 ，再由缓冲区将数据发送给到对方网卡的读缓冲区。</li><li>对于接受者，执行 <code>recv</code> 接收消息时，是从自己网卡的读缓冲区获取数据。</li></ul><p>所以，如果发送者连续快速的发送了2条信息，接收者在读取时会认为这是1条信息，即：<span style='color:red;'><strong>2个数据包粘在了一起。</strong></span>例如：</p><pre class="language-python" data-language="python"><code class="language-python"># socket客户端（发送者）import socketclient &#x3D; socket.socket()client.connect((&#39;127.0.0.1&#39;, 8001))client.sendall(&#39;alex正在吃&#39;.encode(&#39;utf-8&#39;))client.sendall(&#39;翔&#39;.encode(&#39;utf-8&#39;))client.close()# socket服务端（接收者）import socketsock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.bind((&#39;127.0.0.1&#39;, 8001))sock.listen(5)conn, addr &#x3D; sock.accept()client_data &#x3D; conn.recv(1024)print(client_data.decode(&#39;utf-8&#39;))conn.close()sock.close()</code></pre><p><strong>如何解决粘包的问题？</strong></p><blockquote><p>每次发送的消息时，都将消息划分为 头部（固定字节长度） 和 数据 两部分。例如：头部，用4个字节表示后面数据的长度。</p><ul><li>发送数据，先发送数据的长度，再发送数据（或拼接起来再发送）。</li><li>接收数据，先读4个字节就可以知道自己这个数据包中的数据长度，再根据长度读取到数据。</li></ul><p>对于头部需要一个数字并固定为4个字节，这个功能可以借助python的struct包来实现：</p><pre class="language-python" data-language="python"><code class="language-python">import struct# ########### 数值转换为固定4个字节，四个字节的范围 -2147483648 &lt;&#x3D; number &lt;&#x3D; 2147483647  ###########v1 &#x3D; struct.pack(&#39;i&#39;, 199)print(v1)  # b&#39;\xc7\x00\x00\x00&#39;for item in v1:    print(item, bin(item))# ########### 4个字节转换为数字 ###########v2 &#x3D; struct.unpack(&#39;i&#39;, v1) # v1&#x3D; b&#39;\xc7\x00\x00\x00&#39;print(v2) # (199,)</code></pre><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210215090446549.png" class="" title="image-20210215090446549"><p>示例代码：</p><ul><li><p>服务端</p><pre class="language-python" data-language="python"><code class="language-python">import socketimport structsock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.bind((&#39;127.0.0.1&#39;, 8001))sock.listen(5)conn, addr &#x3D; sock.accept()# 固定读取4字节header1 &#x3D; conn.recv(4)data_length1 &#x3D; struct.unpack(&#39;i&#39;, header1)[0] # 数据字节长度 21has_recv_len &#x3D; 0data1 &#x3D; b&quot;&quot;while True:    length &#x3D; data_length1 - has_recv_len    if length &gt; 1024:        lth &#x3D; 1024else:        lth &#x3D; lengthchunk &#x3D; conn.recv(lth) # 可能一次收不完，自己可以计算长度再次使用recv收取，指导收完为止。 1024*8 &#x3D; 8196    data1 +&#x3D; chunk    has_recv_len +&#x3D; len(chunk)    if has_recv_len &#x3D;&#x3D; data_length1:        breakprint(data1.decode(&#39;utf-8&#39;))# 固定读取4字节header2 &#x3D; conn.recv(4)data_length2 &#x3D; struct.unpack(&#39;i&#39;, header2)[0] # 数据字节长度data2 &#x3D; conn.recv(data_length2) # 长度print(data2.decode(&#39;utf-8&#39;))conn.close()sock.close()</code></pre></li><li><p>客户端</p><pre class="language-python" data-language="python"><code class="language-python">import socketimport struct          client &#x3D; socket.socket()client.connect((&#39;127.0.0.1&#39;, 8001))          # 第一条数据data1 &#x3D; &#39;alex正在吃&#39;.encode(&#39;utf-8&#39;)          header1 &#x3D; struct.pack(&#39;i&#39;, len(data1))          client.sendall(header1)client.sendall(data1)          # 第二条数据data2 &#x3D; &#39;翔&#39;.encode(&#39;utf-8&#39;)header2 &#x3D; struct.pack(&#39;i&#39;, len(data2))client.sendall(header2)client.sendall(data2)          client.close()</code></pre></li></ul></blockquote><h4 id="案例：消息-amp-文件上传"><a href="#案例：消息-amp-文件上传" class="headerlink" title="案例：消息 &amp; 文件上传"></a>案例：消息 &amp; 文件上传</h4><ul><li><p>服务端</p><pre class="language-python" data-language="python"><code class="language-python">import osimport jsonimport socketimport structdef recv_data(conn, chunk_size&#x3D;1024):    # 获取头部信息：数据长度    has_read_size &#x3D; 0    bytes_list &#x3D; []    while has_read_size &lt; 4:        chunk &#x3D; conn.recv(4 - has_read_size)        has_read_size +&#x3D; len(chunk)        bytes_list.append(chunk)    header &#x3D; b&quot;&quot;.join(bytes_list)    data_length &#x3D; struct.unpack(&#39;i&#39;, header)[0]    # 获取数据    data_list &#x3D; []    has_read_data_size &#x3D; 0    while has_read_data_size &lt; data_length:        size &#x3D; chunk_size if (data_length - has_read_data_size) &gt; chunk_size else data_length - has_read_data_size        chunk &#x3D; conn.recv(size)        data_list.append(chunk)        has_read_data_size +&#x3D; len(chunk)    data &#x3D; b&quot;&quot;.join(data_list)    return datadef recv_file(conn, save_file_name, chunk_size&#x3D;1024):    save_file_path &#x3D; os.path.join(&#39;files&#39;, save_file_name)    # 获取头部信息：数据长度    has_read_size &#x3D; 0    bytes_list &#x3D; []    while has_read_size &lt; 4:        chunk &#x3D; conn.recv(4 - has_read_size)        bytes_list.append(chunk)        has_read_size +&#x3D; len(chunk)    header &#x3D; b&quot;&quot;.join(bytes_list)    data_length &#x3D; struct.unpack(&#39;i&#39;, header)[0]    # 获取数据    file_object &#x3D; open(save_file_path, mode&#x3D;&#39;wb&#39;)    has_read_data_size &#x3D; 0    while has_read_data_size &lt; data_length:        size &#x3D; chunk_size if (data_length - has_read_data_size) &gt; chunk_size else data_length - has_read_data_size        chunk &#x3D; conn.recv(size)        file_object.write(chunk)        file_object.flush()        has_read_data_size +&#x3D; len(chunk)    file_object.close()def run():    sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # IP可复用    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    sock.bind((&#39;127.0.0.1&#39;, 8001))    sock.listen(5)    while True:        conn, addr &#x3D; sock.accept()        while True:            # 获取消息类型            message_type &#x3D; recv_data(conn).decode(&#39;utf-8&#39;)            if message_type &#x3D;&#x3D; &#39;close&#39;:  # 四次挥手，空内容。                print(&quot;关闭连接&quot;)                break            # 文件：&#123;&#39;msg_type&#39;:&#39;file&#39;, &#39;file_name&#39;:&quot;xxxx.xx&quot; &#125;            # 消息：&#123;&#39;msg_type&#39;:&#39;msg&#39;&#125;            message_type_info &#x3D; json.loads(message_type)            if message_type_info[&#39;msg_type&#39;] &#x3D;&#x3D; &#39;msg&#39;:                data &#x3D; recv_data(conn)                print(&quot;接收到消息：&quot;, data.decode(&#39;utf-8&#39;))            else:                file_name &#x3D; message_type_info[&#39;file_name&#39;]                print(&quot;接收到文件，要保存到：&quot;, file_name)                recv_file(conn, file_name)        conn.close()    sock.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    run()</code></pre></li><li><p>客户端</p><pre class="language-python" data-language="python"><code class="language-python">import osimport jsonimport socketimport structdef send_data(conn, content):    data &#x3D; content.encode(&#39;utf-8&#39;)    header &#x3D; struct.pack(&#39;i&#39;, len(data))    conn.sendall(header)    conn.sendall(data)def send_file(conn, file_path):    file_size &#x3D; os.stat(file_path).st_size    header &#x3D; struct.pack(&#39;i&#39;, file_size)    conn.sendall(header)    has_send_size &#x3D; 0    file_object &#x3D; open(file_path, mode&#x3D;&#39;rb&#39;)    while has_send_size &lt; file_size:        chunk &#x3D; file_object.read(2048)        conn.sendall(chunk)        has_send_size +&#x3D; len(chunk)    file_object.close()def run():    client &#x3D; socket.socket()    client.connect((&#39;127.0.0.1&#39;, 8001))    while True:        &quot;&quot;&quot;        请发送消息，格式为：            - 消息：msg|你好呀            - 文件：file|xxxx.png        &quot;&quot;&quot;        content &#x3D; input(&quot;&gt;&gt;&gt;&quot;)  # msg or file        if content.upper() &#x3D;&#x3D; &#39;Q&#39;:            send_data(client, &quot;close&quot;)            break        input_text_list &#x3D; content.split(&#39;|&#39;)        if len(input_text_list) !&#x3D; 2:            print(&quot;格式错误，请重新输入&quot;)            continue        message_type, info &#x3D; input_text_list        # 发消息        if message_type &#x3D;&#x3D; &#39;msg&#39;:            # 发消息类型            send_data(client, json.dumps(&#123;&quot;msg_type&quot;: &quot;msg&quot;&#125;))            # 发内容            send_data(client, info)        # 发文件        else:            file_name &#x3D; info.rsplit(os.sep, maxsplit&#x3D;1)[-1]            # 发消息类型            send_data(client, json.dumps(&#123;&quot;msg_type&quot;: &quot;file&quot;, &#39;file_name&#39;: file_name&#125;))            # 发内容            send_file(client, info)    client.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    run()</code></pre></li></ul><h3 id="4-阻塞和非阻塞"><a href="#4-阻塞和非阻塞" class="headerlink" title="4. 阻塞和非阻塞"></a>4. 阻塞和非阻塞</h3><p>默认情况下我们编写的网络编程的代码都是阻塞的（等待），阻塞主要体现在：</p><pre class="language-python" data-language="python"><code class="language-python"># ################### socket服务端（接收者）###################import socketsock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.bind((&#39;127.0.0.1&#39;, 8001))sock.listen(5)# 阻塞conn, addr &#x3D; sock.accept()# 阻塞client_data &#x3D; conn.recv(1024)print(client_data.decode(&#39;utf-8&#39;))conn.close()sock.close()# ################### socket客户端（发送者） ###################import socketclient &#x3D; socket.socket()# 阻塞client.connect((&#39;127.0.0.1&#39;, 8001))client.sendall(&#39;alex正在吃翔&#39;.encode(&#39;utf-8&#39;))client.close()</code></pre><p>如果想要让代码变为非阻塞，需要这样写：</p><pre class="language-python" data-language="python"><code class="language-python"># ################### socket服务端（接收者）###################import socketsock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.setblocking(False) # 加上就变为了非阻塞sock.bind((&#39;127.0.0.1&#39;, 8001))sock.listen(5)# 非阻塞conn, addr &#x3D; sock.accept()# 非阻塞client_data &#x3D; conn.recv(1024)print(client_data.decode(&#39;utf-8&#39;))conn.close()sock.close()# ################### socket客户端（发送者） ###################import socketclient &#x3D; socket.socket()client.setblocking(False) # 加上就变为了非阻塞# 非阻塞client.connect((&#39;127.0.0.1&#39;, 8001))client.sendall(&#39;alex正在吃翔&#39;.encode(&#39;utf-8&#39;))client.close()</code></pre><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210216093805252.png" class="" title="image-20210216093805252"><p>如果代码变成了非阻塞，程序运行时一旦遇到 <code>accept</code>、<code>recv</code>、<code>connect</code> 就会抛出 BlockingIOError 的异常。</p><p>这不是代码编写的有错误，而是原来的IO阻塞变为非阻塞之后，由于没有接收到相关的IO请求抛出的固定错误。</p><p>非阻塞的代码一般与IO多路复用结合，可以迸发出更大的作用。</p><h3 id="5-IO多路复用"><a href="#5-IO多路复用" class="headerlink" title="5. IO多路复用"></a>5. IO多路复用</h3><p>I&#x2F;O多路复用指：通过一种机制，可以<strong>监视多个描述符</strong>，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p><p>IO多路复用 + 非阻塞，可以实现让TCP的服务端同时处理多个客户端的请求，例如：</p><pre class="language-python" data-language="python"><code class="language-python"># ################### socket服务端 ###################import selectimport socketserver &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)server.setblocking(False)  # 加上就变为了非阻塞server.bind((&#39;127.0.0.1&#39;, 8001))server.listen(5)inputs &#x3D; [server, ] # socket对象列表 -&gt; [server, 第一个客户端连接conn ]while True:    # 当 参数1 序列中的socket对象发生可读时（accetp和read），则获取发生变化的对象并添加到 r列表中。    # r &#x3D; []    # r &#x3D; [server,]    # r &#x3D; [第一个客户端连接conn,]    # r &#x3D; [server,]    # r &#x3D; [第一个客户端连接conn，第二个客户端连接conn]    # r &#x3D; [第二个客户端连接conn,]    r, w, e &#x3D; select.select(inputs, [], [], 0.05)    for sock in r:        # server        if sock &#x3D;&#x3D; server:            conn, addr &#x3D; sock.accept() # 接收新连接。            print(&quot;有新连接&quot;)            # conn.sendall()            # conn.recv(&quot;xx&quot;)            inputs.append(conn)        else:            data &#x3D; sock.recv(1024)            if data:                print(&quot;收到消息：&quot;, data)            else:                print(&quot;关闭连接&quot;)                inputs.remove(sock)# 干点其他事 20s&quot;&quot;&quot;优点：1. 干点那其他的事。2. 让服务端支持多个客户端同时来连接。&quot;&quot;&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python"># ################### socket客户端 ###################import socketclient &#x3D; socket.socket()# 阻塞client.connect((&#39;127.0.0.1&#39;, 8001))while True:    content &#x3D; input(&quot;&gt;&gt;&gt;&quot;)    if content.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    client.sendall(content.encode(&#39;utf-8&#39;))client.close()</code></pre><pre class="language-python" data-language="python"><code class="language-python"># ################### socket客户端 ###################import socketclient &#x3D; socket.socket()# 阻塞client.connect((&#39;127.0.0.1&#39;, 8001))while True:    content &#x3D; input(&quot;&gt;&gt;&gt;&quot;)    if content.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    client.sendall(content.encode(&#39;utf-8&#39;))client.close() # 与服务端断开连接（四次挥手），默认会想服务端发送空数据。</code></pre><p>IO多路复用 + 非阻塞，可以实现让TCP的客户端同时发送多个请求，例如：去某个网站发送下载图片的请求。</p><pre class="language-python" data-language="python"><code class="language-python">import socketimport selectimport uuidimport osclient_list &#x3D; []  # socket对象列表for i in range(5):    client &#x3D; socket.socket()    client.setblocking(False)    try:        # 连接百度，虽然有异常BlockingIOError，但向还是正常发送连接的请求        client.connect((&#39;47.98.134.86&#39;, 80))    except BlockingIOError as e:        pass    client_list.append(client)recv_list &#x3D; []  # 放已连接成功，且已经把下载图片的请求发过去的socketwhile True:    # w &#x3D; [第一个socket对象,]    # r &#x3D; [socket对象,]    r, w, e &#x3D; select.select(recv_list, client_list, [], 0.1)    for sock in w:        # 连接成功，发送数据        # 下载图片的请求        sock.sendall(b&quot;GET &#x2F;nginx-logo.png HTTP&#x2F;1.1\r\nHost:47.98.134.86\r\n\r\n&quot;)        recv_list.append(sock)        client_list.remove(sock)    for sock in r:        # 数据发送成功后，接收的返回值（图片）并写入到本地文件中        data &#x3D; sock.recv(8196)        content &#x3D; data.split(b&#39;\r\n\r\n&#39;)[-1]        random_file_name &#x3D; &quot;&#123;&#125;.png&quot;.format(str(uuid.uuid4()))        with open(os.path.join(&quot;images&quot;, random_file_name), mode&#x3D;&#39;wb&#39;) as f:            f.write(content)        recv_list.remove(sock)    if not recv_list and not client_list:        break        &quot;&quot;&quot;优点：1. 可以伪造出并发的现象。&quot;&quot;&quot;</code></pre><p>基于 IO多路复用 + 非阻塞的特性，无论编写socket的服务端和客户端都可以提升性能。其中</p><ul><li>IO多路复用，监测socket对象是否有变化（是否连接成功？是否有数据到来等）。</li><li>非阻塞，socket的connect、recv过程不再等待。</li></ul><p>注意：IO多路复用只能用来监听 IO对象 是否发生变化，常见的有：文件是否可读写、电脑终端设备输入和输出、网络请求（常见）。</p><p>在Linux操作系统化中 IO多路复用 有三种模式，分别是：select，poll，epoll。（windows 只支持select模式）</p><blockquote><p>监测socket对象是否新连接到来 or 新数据到来。</p></blockquote><pre class="language-none"><code class="language-none">select select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。 poll poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。 epoll 直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I&#x2F;O就绪通知方法。epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select&#x2F;poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</code></pre><p>补充：socket + 非阻塞+ IO多路复用（IO操作对象都可以监测 + 文件）。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li><p>OSI 7层模型</p><pre class="language-python" data-language="python"><code class="language-python">应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</code></pre></li><li><p>UDP和TCP的区别</p><pre class="language-python" data-language="python"><code class="language-python">UDP，速度快但无法保证数据的准确性。TCP，需要先创建可靠连接，在进行收发数据（ack）。</code></pre></li><li><p>TCP的三次握手和四次挥手</p></li><li><p>为什么会有粘包？如何解决？</p></li><li><p>如何让socket请求变成非阻塞？</p></li><li><p>IO多路复用的作用？</p><pre class="language-python" data-language="python"><code class="language-python">监测多个 IO对象 是否发生变化（可读&#x2F;可写）。</code></pre><ul><li>IO多路复用 + 非阻塞 + socket服务端，可以让服务端同时处理多个客户端的请求。</li><li>IO多路复用 + 非阻塞 + socket客户端，可以向服务端同时发起多个请求。</li></ul></li></ol><h3 id="作业（模块大作业）"><a href="#作业（模块大作业）" class="headerlink" title="作业（模块大作业）"></a>作业（模块大作业）</h3><p>请基于TCP协议实现一个网盘系统，包含客户端、服务端，各自需求如下：</p><ul><li><p>客户端</p><ul><li><p>用户注册，注册成功之后，在服务端的指定目录下为此用户创建一个文件夹，该文件夹下以后存储当前用户的数据（类似于网盘）。</p></li><li><p>用户登录</p></li><li><p>查看网盘目录下的所有文件（一级即可），ls命令</p></li><li><p>上传文件，如果网盘已存在则重新上传（覆盖）。</p></li><li><p>下载文件（进度条）</p><pre class="language-none"><code class="language-none">先判断要下载本地路径中是否存在该文件。- 不存在，直接下载- 存在，则让用户选择是否续传（继续下载）。- 续传，在上次的基础上继续下载。- 不续传，从头开始下载。</code></pre></li></ul></li><li><p>服务端</p><ul><li><p>支持注册，并为用户初始化相关目录。</p><pre class="language-none"><code class="language-none">注册成功之后，将所有用户信息存储到特定的Excel文件中</code></pre><img src="/2022/06/17/python-mo-kuai-san-day2/image-20210218163617245.png" class="" title="image-20210218163617245"></li><li><p>支持登录</p></li><li><p>支持查看当前用户网盘目录下的所有文件。</p></li><li><p>支持上传</p></li><li><p>支持下载</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 第三阶段 </tag>
            
            <tag> 面向对象&amp;网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块三day1</title>
      <link href="/2022/06/15/python-mo-kuai-san-day1/"/>
      <url>/2022/06/15/python-mo-kuai-san-day1/</url>
      
        <content type="html"><![CDATA[<h2 id="第三模块-面向对象-amp-网络-amp-并发编程"><a href="#第三模块-面向对象-amp-网络-amp-并发编程" class="headerlink" title="第三模块 面向对象&amp;网络&amp;并发编程"></a>第三模块 面向对象&amp;网络&amp;并发编程</h2><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210117230507748-16552576104391.png" class=""><p>从今天开始，我们将进入系列课程第3个模块的的学习，此模块包含如下三大部分知识：</p><ul><li><p>面向对象，Python中支持两种编程方式来写代码，分别是：<code>函数式编程</code>、<code>面向对象式编程</code>。</p><ul><li><p>函数式</p><pre class="language-python" data-language="python"><code class="language-python"># 定义函数，在函数中实现功能def func():print(&quot;一个NB的功能&quot;)# 执行函数func()</code></pre></li><li><p>面向对象：<strong>后期功能更复杂，解决可扩展性时使用</strong></p><pre class="language-python" data-language="python"><code class="language-python"># 定义类class Foo(object):    # 在类中定义方法    def func(self):        print(&quot;一个NB的功能&quot;)    # 实例化类的对象obj &#x3D; Foo()# 执行类中的方法obj.func()</code></pre></li></ul><p>Python支持两种编程方式（其他很多语言只支持一种），所以初学者在刚开始学习往往不知道应如何选择，并且行业内对于 函数式编程 vs 面向对象编程 之间谁更好的讨论也是难分胜负，其实在开发中无论要实现什么样的功能，两种编程模式都能实现，哪种让我们能更好实现就选择谁？不必非纠结于那种方式更好，编程语言支持工具，最重要的是把功能实现。</p><p>初学者在选择编程方式时候，<font color="#dd0000"><strong>可以遵循如下规则</strong></font>：</p><ul><li><p>函数式，推荐初学者使用。理由：<strong>上手快且逻辑简单清晰。</strong></p></li><li><p>面向对象，推荐有一些代码经验后使用。理由：<strong>面向对象的思想需要有一定的项目积累之后（写多了&amp;看的多）才能真正理解其精髓，基于面向对象可以编写出扩展性更强的代码（在一定程序上也可以简化代码）。</strong></p></li></ul><p>现阶段，大家在学习面向对象时更重要的是：<font color="#dd0000"><strong>掌握相关知识点 &amp; 读懂源码 &amp; 编写简单的基于面向对象的程序。</strong></font></p></li><li><p>网络编程，学习网络知识后，可以让我们的程序<strong>通过网络来进行数据交互和传输 并 掌握其本质。</strong></p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210117224420539-16552576104392.png" class=""></li><li><p>并发编程，一个程序想要执行的<strong>速度更快</strong>是必须要掌握并发编程的相关知识。</p><pre class="language-none"><code class="language-none">例如：下载10个抖音视频，每个需要2分钟。- 按照以前的思路，逐一下载就需要20分钟。- 按照并发的思路，创建10个线程&#x2F;进程来实现，大概需要2分钟就可以完成。</code></pre></li></ul><h2 id="十八、面向对象基础"><a href="#十八、面向对象基础" class="headerlink" title="十八、面向对象基础"></a>十八、面向对象基础</h2><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210118204107085-16552576104393.png" class=""><p>课程目标：了解面向对象并可以根据面向对象知识进行编写代码。</p><p>课程概要：</p><ul><li>初识面向对象</li><li>三大特性（面向对象）<ul><li>封装</li><li>继承</li><li>多态</li></ul></li><li>再看数据类型</li></ul><h3 id="1-初识面向对象"><a href="#1-初识面向对象" class="headerlink" title="1. 初识面向对象"></a>1. 初识面向对象</h3><p>想要通过面向对象去实现某个或某些功能时需要2步：</p><ul><li><p>定义类，在类中定义方法，在方法中去实现具体的功能。</p></li><li><p>实例化类并的个一个对象，通过对象去调用并执行方法。</p></li></ul><pre class="language-python" data-language="python"><code class="language-python">class Message:    def send_email(self, email, content):        data &#x3D; &quot;给&#123;&#125;发邮件，内容是：&#123;&#125;&quot;.format(email,content)        print(data)msg_object &#x3D; Message() # 实例化一个对象 msg_object，创建了一个一块区域。msg_object.send_email(&quot;wupeiqi@live.com&quot;,&quot;注册成功&quot;)</code></pre><p><strong>注意</strong>：</p><ol><li><p>类名称首字母大写&amp;驼峰式命名；</p></li><li><p>py3之后默认类都继承object；</p></li><li><p>在类中编写的函数称为方法；</p></li><li><p>每个方法的第一个参数是self。</p></li></ol><p>类中可以定义多个方法，例如：</p><pre class="language-python" data-language="python"><code class="language-python">class Message:    def send_email(self, email, content):        data &#x3D; &quot;给&#123;&#125;发邮件，内容是：&#123;&#125;&quot;.format(email, content)        print(data)    def send_wechat(self, vid, content):        data &#x3D; &quot;给&#123;&#125;发微信，内容是：&#123;&#125;&quot;.format(vid, content)        print(data)msg_object &#x3D; Message()msg_object.send_email(&quot;wupeiqi@live.com&quot;, &quot;注册成功&quot;)msg_object.send_wechat(&quot;武沛齐&quot;, &quot;注册成功&quot;)</code></pre><p>你会发现，用面向对象编程写的类有点像归类的意思：将某些相似的函数划分到一个类中。</p><p>但，这种编写方式让人感觉有些鸡肋，直接用 函数 写多好呀。对吧？ </p><p>别着急，接着往下看。</p><h4 id="1-1-对象和self"><a href="#1-1-对象和self" class="headerlink" title="1.1 对象和self"></a>1.1 对象和self</h4><p>在每个类中都可以定义个特殊的：<code>__init__ 初始化方法 </code>，在实例化类创建对象时自动执行，即：<code>对象=类()</code>。</p><pre class="language-python" data-language="python"><code class="language-python">class Message:    def __init__(self, content):        self.data &#x3D; content    def send_email(self, email):        data &#x3D; &quot;给&#123;&#125;发邮件，内容是：&#123;&#125;&quot;.format(email, self.data)        print(data)    def send_wechat(self, vid):        data &#x3D; &quot;给&#123;&#125;发微信，内容是：&#123;&#125;&quot;.format(vid, self.data)        print(data)# 对象 &#x3D; 类名() # 自动执行类中的 __init__ 方法。# 1. 根据类创建一个对象，内存的一块 区域 。# 2. 执行__init__方法，模块会将创建的那块区域的内存地址当self参数传递进去。    往区域中(data&#x3D;&quot;注册成功&quot;)msg_object &#x3D; Message(&quot;注册成功&quot;)msg_object.send_email(&quot;wupeiqi@live.com&quot;) # 给wupeiqi@live.com发邮件，内容是：注册成功msg_object.send_wechat(&quot;武沛齐&quot;) # 给武沛齐发微信，内容是：注册成功</code></pre><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210123195714019-16552576104404.png" class=""><p>通过上述的示例，你会发现：</p><ul><li><font color="#dd0000"><strong>对象</strong></font>，让我们可以在它的内部先封装一部分数据，以后想要使用时，再去里面获取。</li><li><font color="#dd0000"><strong>self</strong></font>，类中的方法需要由这个类的对象来触发并执行（ 对象.方法名 ），且在执行时会自动将对象当做参数传递给self，以供方法中获取对象中已封装的值。</li></ul><p>注意：除了self默认参数以外，方法中的参数的定义和执行与函数是相同。</p><p>当然，根据类也可以创建多个对象并执行其中的方法，例如：</p><pre class="language-python" data-language="python"><code class="language-python">class Message:    def __init__(self, content):        self.data &#x3D; content    def send_email(self, email):        data &#x3D; &quot;给&#123;&#125;发邮件，内容是：&#123;&#125;&quot;.format(email, self.data)        print(data)    def send_wechat(self, vid):        data &#x3D; &quot;给&#123;&#125;发微信，内容是：&#123;&#125;&quot;.format(vid, self.data)        print(data)msg_object &#x3D; Message(&quot;注册成功&quot;)msg_object.send_email(&quot;wupeiqi@live.com&quot;) # 给wupeiqi@live.com发邮件，内容是：注册成功msg_object.send_wechat(&quot;武沛齐&quot;)login_object &#x3D; Message(&quot;登录成功&quot;)login_object.send_email(&quot;wupeiqi@live.com&quot;) # 给wupeiqi@live.com发邮件，内容是：登录成功login_object.send_wechat(&quot;武沛齐&quot;)</code></pre><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210123195714019-16552576104404.png" class=""><p><font color="#dd0000"><strong>面向对象的思想：将一些数据封装到对象中，在执行方法时，再去对象中获取。</strong></font></p><p><font color="#dd0000"><strong>函数式的思想：函数内部需要的数据均通过参数的形式传递。</strong></font></p><ul><li><font color="#dd0000"><strong>self</strong></font>，本质上就是一个参数。这个参数是Python内部会提供，其实本质上就是调用当前方法的那个对象。</li><li><font color="#dd0000"><strong>对象</strong></font>，基于类实例化出来”一块内存“，默认里面没有数据；经过类的 <code>__init__</code>方法，可以在内存中初始化一些数据。</li></ul><h4 id="1-2-常见成员"><a href="#1-2-常见成员" class="headerlink" title="1.2 常见成员"></a>1.2 常见成员</h4><p>在编写面向对象相关代码时，最常见成员有：</p><ul><li>实例变量，属于对象，只能通过对象调用。</li><li>绑定方法，属于类，通过对象调用 或 通过类调用。</li></ul><p>注意：还有很多其他的成员，后续再来介绍。</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210126140807446-16552576104405.png" class="" title="image-20210126140807446"><pre class="language-python" data-language="python"><code class="language-python">class Person:    def __init__(self, n1, n2):        # 实例变量        self.name &#x3D; n1        self.age &#x3D; n2    # 绑定方法    def show(self):        msg &#x3D; &quot;我叫&#123;&#125;，今年&#123;&#125;岁。&quot;.format(self.name, self.age)        print(msg)    def all_message(self):        msg &#x3D; &quot;我是&#123;&#125;人，我叫&#123;&#125;，今年&#123;&#125;岁。&quot;.format(Person.country, self.name, self.age)        print(msg)    def total_message(self):        msg &#x3D; &quot;我是&#123;&#125;人，我叫&#123;&#125;，今年&#123;&#125;岁。&quot;.format(self.country, self.name, self.age)        print(msg)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 执行绑定方法p1 &#x3D; Person(&quot;武沛齐&quot;,20)p1.show()# 或# p1 &#x3D; Person(&quot;武沛齐&quot;,20)# Person.show(p1)# 初始化，实例化了Person类的对象叫p1p1 &#x3D; Person(&quot;武沛齐&quot;,20)</code></pre><h4 id="1-3-应用示例"><a href="#1-3-应用示例" class="headerlink" title="1.3 应用示例"></a>1.3 应用示例</h4><ol><li><p>将数据封装到一个对象，便于以后使用。</p><pre class="language-python" data-language="python"><code class="language-python">class UserInfo:    def __init__(self, name, pwd,age):        self.name &#x3D; name        self.password &#x3D; pwd        self.age &#x3D; agedef run():    user_object_list &#x3D; []    # 用户注册    while True:        user &#x3D; input(&quot;用户名：&quot;)        if user.upper() &#x3D;&#x3D; &quot;Q&quot;:            break        pwd &#x3D; input(&quot;密码&quot;)                # user_object对象中有：name&#x2F;password        user_object &#x3D; UserInfo(user, pwd,19)        # user_dict &#x3D; &#123;&quot;name&quot;:user,&quot;password&quot;:pwd&#125;                user_object_list.append(user_object)     # user_object_list.append(user_dict)    # 展示用户信息    for obj in user_object_list:        print(obj.name, obj.password)        总结：- 数据封装到对象，以后再去获取。    - 规范数据（约束）</code></pre><p>注意：用字典也可以实现做封装，只不过字典在操作值时还需要自己写key，面向对象只需要 <code>.</code> 即可获取对象中封装的数据。</p></li><li><p>将数据分装到对象中，在方法中对原始数据进行加工处理。</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;用户-&#123;&#125;&quot;.format(i) for i in range(1,3000)]# 分页显示，每页显示10条while True:    page &#x3D; int(input(&quot;请输入页码：&quot;))    start_index &#x3D; (page - 1) * 10    end_index &#x3D; page * 10    page_data_list &#x3D; user_list[start_index:end_index]    for item in page_data_list:        print(item)</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Pagination:    def __init__(self, current_page, per_page_num&#x3D;10):        self.per_page_num &#x3D; per_page_num                # 判断页码是否是数字        if not current_page.isdecimal():            self.current_page &#x3D; 1            return        current_page &#x3D; int(current_page)        # 判断页码是否在页码范围        if current_page &lt; 1:            self.current_page &#x3D; 1            return        self.current_page &#x3D; current_page    def start(self):        return (self.current_page - 1) * self.per_page_num    def end(self):        return self.current_page * self.per_page_numuser_list &#x3D; [&quot;用户-&#123;&#125;&quot;.format(i) for i in range(1, 3000)]# 分页显示，每页显示10条while True:    page &#x3D; input(&quot;请输入页码：&quot;)    # page，当前访问的页码    # 10，每页显示10条数据# 内部执行Pagination类的__init__方法。    pg_object &#x3D; Pagination(page, 20)    page_data_list &#x3D; user_list[ pg_object.start() : pg_object.end() ]    for item in page_data_list:        print(item)</code></pre><p>还有这个示例：将数据封装到一个对象中，然后在方法中对已封装的数据进行操作。</p><pre class="language-python" data-language="python"><code class="language-python">import osimport requestsclass DouYin:    def __init__(self, folder_path):        self.folder_path &#x3D; folder_path                if not os.path.exists(folder_path):            os.makedirs(folder_path)                def download(self, file_name, url):        res &#x3D; requests.get(            url&#x3D;url,            headers&#x3D;&#123;                &quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 FS&quot;            &#125;        )        file_path &#x3D; os.path.join(self.folder_path, file_name)        with open(file_path, mode&#x3D;&#39;wb&#39;) as f:            f.write(res.content)            f.flush()    def multi_download(self, video_list):        for item in video_list:            self.download(item[0], item[1])if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    douyin_object &#x3D; DouYin(&quot;videos&quot;)    douyin_object.download(        &quot;罗斯.mp4&quot;,        &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&quot;    )    video_list &#x3D; [        (&quot;a1.mp4&quot;, &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300fc20000bvi413nedtlt5abaa8tg&quot;),        (&quot;a2.mp4&quot;, &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0d00fb60000bvi0ba63vni5gqts0uag&quot;),        (&quot;a3.mp4&quot;, &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&quot;)    ]    douyin_object.multi_download(video_list)</code></pre></li><li><p>根据类创建多个对象，在方法中对对象中的数据进行修改。</p><pre class="language-python" data-language="python"><code class="language-python">class Police:    &quot;&quot;&quot;警察&quot;&quot;&quot;    def __init__(self, name, role):        self.name &#x3D; name        self.role &#x3D; role        if role &#x3D;&#x3D; &quot;队员&quot;:            self.hit_points &#x3D; 200        else:            self.hit_points &#x3D; 500    def show_status(self):        &quot;&quot;&quot; 查看警察状态 &quot;&quot;&quot;        message &#x3D; &quot;警察&#123;&#125;的生命值为:&#123;&#125;&quot;.format(self.name, self.hit_points)        print(message)    def bomb(self, terrorist_list):        &quot;&quot;&quot; 投炸弹，炸掉恐怖分子 &quot;&quot;&quot;        for terrorist in terrorist_list:            terrorist.blood -&#x3D; 200            terrorist.show_status()&quot;&quot;&quot;p1 &#x3D; Police(&quot;武沛齐&quot;,&quot;队员&quot;)p1.show_status()p1.bomb([&quot;alex&quot;,&quot;李杰&quot;])p2 &#x3D; Police(&quot;日天&quot;,&quot;队长&quot;)p2.show_status()p2.bomb([&quot;alex&quot;,&quot;李杰&quot;])&quot;&quot;&quot;class Terrorist:    &quot;&quot;&quot; 恐怖分子 &quot;&quot;&quot;    def __init__(self, name, blood&#x3D;300):        self.name &#x3D; name        self.blood &#x3D; blood    def shoot(self, police_object):        &quot;&quot;&quot; 开枪射击某个警察 &quot;&quot;&quot;        police_object.hit_points -&#x3D; 5        police_object.show_status()                self.blood -&#x3D; 2    def strafe(self, police_object_list):        &quot;&quot;&quot; 扫射某些警察 &quot;&quot;&quot;        for police_object in police_object_list:            police_object.hit_points -&#x3D; 8            police_object.show_status()    def show_status(self):        &quot;&quot;&quot; 查看恐怖分子状态 &quot;&quot;&quot;        message &#x3D; &quot;恐怖分子&#123;&#125;的血量值为:&#123;&#125;&quot;.format(self.name, self.blood)        print(message)&quot;&quot;&quot;t1 &#x3D; Terrorist(&#39;alex&#39;)t2 &#x3D; Terrorist(&#39;李杰&#39;,200)&quot;&quot;&quot;        def run():    # 1.创建3个警察    p1 &#x3D; Police(&quot;武沛齐&quot;, &quot;队员&quot;)    p2 &#x3D; Police(&quot;苑昊&quot;, &quot;队员&quot;)    p3 &#x3D; Police(&quot;于超&quot;, &quot;队长&quot;)    # 2.创建2个匪徒    t1 &#x3D; Terrorist(&quot;alex&quot;)    t2 &#x3D; Terrorist(&quot;eric&quot;)        # alex匪徒射击于超警察    t1.shoot(p3)    # alex扫射    t1.strafe([p1, p2, p3])    # eric射击苑昊    t2.shoot(p2)    # 武沛齐炸了那群匪徒王八蛋    p1.bomb([t1, t2])        # 武沛齐又炸了一次alex    p1.bomb([t1])if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    run()</code></pre></li></ol><p>总结：</p><ul><li>仅做数据封装（示例一）。</li><li>封装数据 + 方法再对数据进行加工处理（示例二）。</li><li>创建同一类的数据且同类数据可以具有相同的功能（方法）（示例三）。</li></ul><h3 id="2-三大特性"><a href="#2-三大特性" class="headerlink" title="2. 三大特性"></a>2. 三大特性</h3><p>面向对象编程在很多语言中都存在，这种编程方式有三大特性：封装、继承、多态。</p><h4 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h4><p>封装主要体现在两个方面：</p><ul><li>将同一类方法封装到了一个类中，例如上述示例中：匪徒的相关方法都写在Terrorist类中；警察的相关方法都写在Police类中。</li><li>将数据封装到了对象中，在实例化一个对象时，可以通过<code>__init__</code>初始化方法在对象中封装一些数据，便于以后使用。</li></ul><h4 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h4><p>传统的理念中有：儿子可以继承父亲的财产。</p><p>在面向对象中也有这样的理念，即：子类可以继承父类中的方法和类变量（不是拷贝一份，父类的还是属于父类，子类可以继承而已）。</p><pre class="language-none"><code class="language-none">父类子类基类派生类</code></pre><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210126182724313-16552576104406.png" class=""><pre class="language-python" data-language="python"><code class="language-python">class Base:    def func(self):        print(&quot;Base.func&quot;)class Son(Base):        def show(self):        print(&quot;Son.show&quot;)        s1 &#x3D; Son()s1.show()s1.func() # 优先在自己的类中找，自己没有才去父类。s2 &#x3D; Base()s2.func()</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Base:    def f1(self):        passclass Foo(Base):    def f2(self):        pass    class Bar(Base):        def f3(self):        pass    o1 &#x3D; Foo()o1.f2()o1.f1()</code></pre><p><strong>练习题</strong></p><pre class="language-python" data-language="python"><code class="language-python">class Base:    def f1(self):        print(&#39;base.f1&#39;)class Foo(Base):    def f2(self):        print(&#39;foo.f2&#39;)obj &#x3D; Foo()obj.f1()  # &#39;base.f1&#39;obj.f2()  # &#39;foo.f2&#39;</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Base:    def f1(self):        print(&#39;base.f1&#39;)        class Foo(Base):    def f2(self):        print(&#39;before&#39;)        self.f1() # 调用了f1方法   obj.f1()        print(&#39;foo.f2&#39;)        obj &#x3D; Foo()obj.f2()&gt;&gt;&gt; before&gt;&gt;&gt; base.f1&gt;&gt;&gt; foo.f2</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Base:    def f1(self):        print(&#39;base.f1&#39;)        class Foo(Base):    def f2(self):        print(&quot;before&quot;)        self.f1() # obj,Foo类创建出来的对象。 obj.f1        print(&#39;foo.f2&#39;)def f1(self):        print(&#39;foo.f1&#39;)        obj &#x3D; Foo()obj.f1() # obj对象到底是谁？优先就会先去谁里面找。obj.f2()&gt;&gt;&gt; foo.f1&gt;&gt;&gt; before&gt;&gt;&gt; foo.f1&gt;&gt;&gt; foo.f2</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Base:    def f1(self):        print(&#39;before&#39;)        self.f2() # slef是obj对象（Foo类创建的对象） obj.f2        print(&#39;base.f1&#39;)        def f2(self):        print(&#39;base.f2&#39;)        class Foo(Base):    def f2(self):        print(&#39;foo.f2&#39;)        obj &#x3D; Foo()obj.f1() # 优先去Foo类中找f1，因为调用f1的那个对象是Foo类创建出来的。&gt;&gt;&gt; before&gt;&gt;&gt; foo.f2&gt;&gt;&gt; base.f1b1 &#x3D; Base()b1.f1()&gt;&gt;&gt; before&gt;&gt;&gt; base.f2&gt;&gt;&gt; base.f1</code></pre><pre class="language-python" data-language="python"><code class="language-python">class TCPServer:    def f1(self):        print(&quot;TCPServer&quot;)class ThreadingMixIn:    def f1(self):        print(&quot;ThreadingMixIn&quot;)class ThreadingTCPServer(ThreadingMixIn, TCPServer):     def run(self):        print(&#39;before&#39;)        self.f1()        print(&#39;after&#39;)        obj &#x3D; ThreadingTCPServer()obj.run()&gt;&gt;&gt; before&gt;&gt;&gt; ThreadingMixIn&gt;&gt;&gt; after</code></pre><pre class="language-python" data-language="python"><code class="language-python">class BaseServer:    def serve_forever(self, poll_interval&#x3D;0.5):        self._handle_request_noblock()def _handle_request_noblock(self):        self.process_request(request, client_address)        def process_request(self, request, client_address):        pass    class TCPServer(BaseServer):    passclass ThreadingMixIn:    def process_request(self, request, client_address):        pass    class ThreadingTCPServer(ThreadingMixIn, TCPServer):     passobj &#x3D; ThreadingTCPServer()obj.serve_forever()</code></pre><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210126192330261-16552576104407.png" class=""><p>小结：</p><ul><li>执行对象.方法时，优先去当前对象所关联的类中找，没有的话才去她的父类中查找。</li><li>Python支持多继承：先继承左边、再继承右边的。</li><li>self到底是谁？去self对应的那个类中去获取成员，没有就按照继承关系向上查找 。</li></ul><h4 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h4><p>多态，按字面翻译其实就是多种形态。</p><ul><li>其他编程语言多态</li><li>Python中多态</li></ul><p>其他编程语言中，是不允许这样类编写的，例如：Java</p><pre class="language-java" data-language="java"><code class="language-java">class Cat&#123;      public void eat() &#123;          System.out.println(&quot;吃鱼&quot;);      &#125;  &#125;class Dog &#123;      public void eat() &#123;          System.out.println(&quot;吃骨头&quot;);      &#125;      public void work() &#123;          System.out.println(&quot;看家&quot;);      &#125;  &#125;public class Test &#123;   public static void main(String[] args) &#123;       obj1 &#x3D; Cat()   obj2 &#x3D; Cat()       show(obj1)       show(obj2)           obj3 &#x3D; Dog()        show(obj3)   &#125;          public static void show(Cat a)  &#123;      a.eat()    &#125;  &#125; </code></pre><pre class="language-java" data-language="java"><code class="language-java">abstract class Animal &#123;      abstract void eat();  &#125;  class Cat extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃鱼&quot;);      &#125;  &#125;class Dog extends Animal &#123;      public void eat() &#123;          System.out.println(&quot;吃骨头&quot;);      &#125;      public void work() &#123;          System.out.println(&quot;看家&quot;);      &#125;  &#125;public class Test &#123;   public static void main(String[] args) &#123;       obj1 &#x3D; Cat()       show(obj1)              obj2 &#x3D; Dog()   show(obj2)   &#125;          public static void show(Animal a)  &#123;      a.eat()    &#125;  &#125; </code></pre><p>在java或其他语言中的多态是基于：接口 或 抽象类和抽象方法来实现，让数据可以以多种形态存在。</p><p>在Python中则不一样，由于Python对数据类型没有任何限制，所以他天生支持多态。</p><pre class="language-python" data-language="python"><code class="language-python">def func(arg):    v1 &#x3D; arg.copy() # 浅拷贝    print(v1)    func(&quot;武沛齐&quot;)func([11,22,33,44])</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Email(object):    def send(self):        print(&quot;发邮件&quot;)        class Message(object):    def send(self):        print(&quot;发短信&quot;)                        def func(arg):    v1 &#x3D; arg.send()    print(v1)    v1 &#x3D; Email()func(v1)v2 &#x3D; Message()func(v2)</code></pre><p>在程序设计中，鸭子类型（duck typing）是动态类型的一种风格。在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型，例如：一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟可以被称为鸭子。</p><h4 id="【面试题】-谈谈你对面向对象三大特性的理解"><a href="#【面试题】-谈谈你对面向对象三大特性的理解" class="headerlink" title="【面试题】 谈谈你对面向对象三大特性的理解"></a><font color="#dd0000"><strong>【面试题】 谈谈你对面向对象三大特性的理解</strong></font></h4><ul><li><p>封装，将方法封装到类中 或 将数据封装到对象中，便于以后使用。</p></li><li><p>继承，将类中的公共的方法提取到基类中去实现。</p></li><li><p>多态，Python默认支持多态（这种方式称之为鸭子类型），最简单的基础下面的这段代码即可。</p><pre class="language-python" data-language="python"><code class="language-python">def func(arg):    v1 &#x3D; arg.copy() # 浅拷贝    print(v1)    func(&quot;武沛齐&quot;)func([11,22,33,44])</code></pre></li></ul><h3 id="3-扩展：再看数据类型"><a href="#3-扩展：再看数据类型" class="headerlink" title="3. 扩展：再看数据类型"></a>3. 扩展：再看数据类型</h3><p>在初步了解面向对象之后，再来看看我们之前学习的：str、list、dict等数据类型，他们其实都一个类，根据类可以创建不同类的对象。</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210118203012874-16552576104408.png" class=""><pre class="language-python" data-language="python"><code class="language-python"># 实例化一个str类的对象v1v1 &#x3D; str(&quot;武沛齐&quot;) # 通过对象执行str类中的upper方法。data &#x3D; v1.upper()print(data)</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>类和对象的关系。</p></li><li><p>面向对象编程中常见的成员：</p><ul><li>绑定方法</li><li>实例变量</li></ul></li><li><p>self到底是什么？</p></li><li><p>面向对象的三大特性。</p></li><li><p>面向对象的应用场景</p><ol><li>数据封装。</li><li>封装数据 + 方法再对数据进行加工处理。</li><li>创建同一类的数据且同类数据可以具有相同的功能（方法）。</li></ol></li><li><p>补充：在Python3中编写类时，默认都会继承object（即使不写也会自动继承）。</p><pre class="language-python" data-language="python"><code class="language-python">class Foo:    passclass Foo(object):    pass</code></pre><p>这一点在Python2是不同的：</p><ul><li>继承object，新式类：继承时深度优先</li><li>不继承object，经典类：继承是广度优先</li></ul></li></ol><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol><li><p>简述面向对象三大特性?</p><p>答：</p><ul><li>封装性：将共同的功能封装到类中；将相同的属性封装到对象中</li><li>继承性：将不同类的公共方法封装到基类中去</li><li>多态性：Python对参数的类型没有限制，默认支持多态（鸭子类型）</li></ul></li><li><p>将以下函数改成类的方式并调用 :  </p><pre class="language-python" data-language="python"><code class="language-python">def func(a1):       print(a1) </code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">class Base:    def func(self, a1):        print(a1)f1 &#x3D; Base()f1.func(2)</code></pre></li><li><p>面向对象中的self指的是什么?</p><p>答：指由类创建出来的对象如 obj &#x3D; Base(), self &#x3D; obj</p><p><font color="#dd0000">存在问题：知识点未掌握</font></p><p>答案：self是一个参数，当使用 对象.方法 的方式执行函数时，python自动传递self参数（参数的值为调用当前方法的对象）</p></li><li><p>以下代码体现 向对象的什么特性?</p><pre class="language-python" data-language="python"><code class="language-python">class Person(object):    def __init__(self, name, age, gender):        self.name &#x3D; name        self.age &#x3D; age        self.gender &#x3D; genderobj &#x3D; Person(&#39;武沛齐&#39;, 18, &#39;男&#39;)</code></pre><p>答：封装性（封装了对象的属性）</p></li><li><p>以下代码体现 向对象的 么特点?</p><pre class="language-python" data-language="python"><code class="language-python">class Message(object):    def email(self):        &quot;&quot;&quot;        发送邮件        :return:        &quot;&quot;&quot;        pass    def msg(self):        &quot;&quot;&quot;        发送短信        :return:        &quot;&quot;&quot;        pass    def wechat(self):        &quot;&quot;&quot;        发送微信        :return:        &quot;&quot;&quot;        pass</code></pre><p>答：封装性（将共有的功能封装到Message类中）</p></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class Foo:    def func(self):        print(&#39;foo.func&#39;)        obj &#x3D; Foo()result &#x3D; obj.func()print(result)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; foo.func&gt;&gt;&gt; None</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class Base1:    def f1(self):        print(&#39;base1.f1&#39;)    def f2(self):        print(&#39;base1.f2&#39;)    def f3(self):        print(&#39;base1.f3&#39;)        self.f1()class Base2:    def f1(self):        print(&#39;base2.f1&#39;)class Foo(Base1, Base2):    def f0(self):        print(&#39;foo.f0&#39;)        self.f3()obj &#x3D; Foo()obj.f0()</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; foo.f0&gt;&gt;&gt; base1.f3&gt;&gt;&gt; base1.f1</code></pre></li><li><p>看代码写结果:</p><pre class="language-python" data-language="python"><code class="language-python">class Base:    def f1(self):        print(&#39;base.f1&#39;)    def f3(self):        self.f1()        print(&#39;base.f3&#39;)class Foo(Base):    def f1(self):        print(&#39;foo.f1&#39;)    def f2(self):        print(&#39;foo.f2&#39;)        self.f3()obj &#x3D; Foo()obj.f2()</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; foo.f2&gt;&gt;&gt; foo.f1&gt;&gt;&gt; base.f3</code></pre></li><li><p>补充代码实现</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; []while True:    user &#x3D; input(&quot;请输入用户名:&quot;)    pwd &#x3D; input(&quot;请输入密码:&quot;)    email &#x3D; input(&quot;请输入邮箱:&quot;)    &quot;&quot;&quot;# 需求1. while循环提示 户输 : 户名、密码、邮箱(正则满足邮箱格式)2. 为每个用户创建一个个对象，并添加到user_list中。3. 当列表中的添加 3个对象后，跳出循环并以此循环打印所有用户的姓名和邮箱&quot;&quot;&quot;</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">import reclass User:    def __init__(self, user, pwd, email):        self.user &#x3D; user        self.pwd &#x3D; pwd        self.email &#x3D; emailuser_list &#x3D; []while True:    user &#x3D; input(&quot;请输入用户名(输入Q&#x2F;q退出):&quot;).strip()    if user.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    pwd &#x3D; input(&quot;请输入密码:&quot;).strip()    email &#x3D; input(&quot;请输入邮箱:&quot;).strip()    email &#x3D; re.match(&#39;\w+@\w+\.\w+&#39;, email).group()    if not email:        print(&#39;输入格式错误&#39;)        break    u1 &#x3D; User(user, pwd, email)    user_list.append(u1)    if len(user_list) &#x3D;&#x3D; 3:        for user in user_list:            message &#x3D; &#39;用户&#123;&#125;您的邮箱为&#123;&#125;&#39;.format(user.user, user.email)            print(message)</code></pre><p><font color="#dd0000">存在问题：</font></p><ul><li><p>用户邮箱格式错误后应该使用continue而不是break</p></li><li><p>将user_list &#x3D; []和后面内容封装到函数中</p></li><li><p>如果列表长度大于3先break掉在打印</p><p>if len(user_list) &#x3D;&#x3D; 3:<br>    for user in user_list:</p></li></ul></li><li><p>补充代码:实现 户注册和登录。</p><pre class="language-python" data-language="python"><code class="language-python">class User:    def __init__(self, name, pwd):        self.name &#x3D; name        self.pwd &#x3D; pwdclass Account:    def __init__(self):        # 用户列表，数据格式：[user对象，user对象，user对象]        self.user_list &#x3D; []    def login(self):        &quot;&quot;&quot;        用户登录，输入用户名和密码然后去self.user_list中校验用户合法性        :return:        &quot;&quot;&quot;        pass    def register(self):        &quot;&quot;&quot;        用户注册，没注册一个用户就创建一个user对象，然后添加到self.user_list中，表示注册成功。        :return:        &quot;&quot;&quot;        pass    def run(self):        &quot;&quot;&quot;        主程序        :return:        &quot;&quot;&quot;        passif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    obj &#x3D; Account()    obj.run()</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">class User:    def __init__(self, name, pwd):        self.name &#x3D; name        self.pwd &#x3D; pwdclass Account:    def __init__(self):        # 用户列表，数据格式：[user对象，user对象，user对象]        self.user_list &#x3D; []    def login(self):        &quot;&quot;&quot;        用户登录，输入用户名和密码然后去self.user_list中校验用户合法性        :return:        &quot;&quot;&quot;        name &#x3D; input(&quot;请输入用户名: &quot;).strip()        pwd &#x3D; input(&quot;请输入密码: &quot;).strip()        for user in self.user_list:            if name &#x3D;&#x3D; user.name and pwd &#x3D;&#x3D; user.pwd:                print(&quot;登录成功&quot;)                break            else:                if user &#x3D;&#x3D; self.user_list[-1]:                    print(&#39;登录失败&#39;)    def register(self):        &quot;&quot;&quot;        用户注册，每注册一个用户就创建一个user对象，然后添加到self.user_list中，表示注册成功。        :return:        &quot;&quot;&quot;        name &#x3D; input(&quot;请输入用户名: &quot;).strip()        pwd &#x3D; input(&quot;请输入密码: &quot;).strip()        user &#x3D; User(name, pwd)        self.user_list.append(user)        print(&#39;恭喜&#123;&#125;注册成果，您的密码为&#123;&#125;&#39;.format(name, pwd))    def run(self):        &quot;&quot;&quot;        主程序        :return:        &quot;&quot;&quot;        while True:            choice &#x3D; input(&#39;请选择功能(输入Q&#x2F;q退出)：1-注册，2-登录: &#39;)            if choice.upper() &#x3D;&#x3D; &#39;Q&#39;:                break            if choice &#x3D;&#x3D; &#39;1&#39;:                self.register()            elif choice &#x3D;&#x3D; &#39;2&#39;:                self.login()            else:                print(&#39;输入错误&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    obj &#x3D; Account()    obj.run()</code></pre></li></ol><p><font color="#dd0000">存在问题：</font></p><ul><li><p>主函数中可以使用字典存储Account的两个功能</p><pre class="language-python" data-language="python"><code class="language-python">def run(self):    &quot;&quot;&quot;    主程序    :return:    &quot;&quot;&quot;    while True:        func_dic &#x3D; &#123;            &#39;1&#39;: &#123;&#39;name&#39;: &#39;注册&#39;, &#39;func&#39;: self.register&#125;,            &#39;2&#39;: &#123;&#39;name&#39;: &#39;登录&#39;, &#39;func&#39;: self.login&#125;        &#125;        # 打印提示信息        msg &#x3D; &#39;;&#39;.join([&#39;&#123;&#125;-&#123;&#125;&#39;.format(k, v[&#39;name&#39;]) for k, v in func_dic.items()])        print(msg)        choice &#x3D; input(&#39;请输入所选功能(输入Q&#x2F;q退出)： &#39;)        if choice.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        info &#x3D; func_dic.get(choice)        if not info:            print(&#39;输入错误请重新输入&#39;)            continue        func &#x3D; info[&#39;func&#39;]        func()</code></pre></li><li><p>注册时只能注册一次,且不能退出</p><pre class="language-python" data-language="python"><code class="language-python">def register(self):    &quot;&quot;&quot;    用户注册，每注册一个用户就创建一个user对象，然后添加到self.user_list中，表示注册成功。    :return:    &quot;&quot;&quot;    print(&#39;用户注册&#39;)    while True:        name &#x3D; input(&quot;请输入用户名(输入Q&#x2F;q退出): &quot;).strip()        if name.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        pwd &#x3D; input(&quot;请输入密码: &quot;).strip()        user_obj &#x3D; User(name, pwd)        self.user_list.append(user_obj)</code></pre></li><li><p>登录时只能注册一次,且不能退出</p><pre class="language-python" data-language="python"><code class="language-python">def login(self):    print(&#39;用户登录&#39;)    &quot;&quot;&quot;    用户登录，输入用户名和密码然后去self.user_list中校验用户合法性    :return:    &quot;&quot;&quot;    while True:        name &#x3D; input(&quot;请输入用户名(输入Q&#x2F;q退出): &quot;).strip()        if name.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        pwd &#x3D; input(&quot;请输入密码: &quot;).strip()        for user in self.user_list:            if name &#x3D;&#x3D; user.name and pwd &#x3D;&#x3D; user.pwd:                print(&quot;登录成功&quot;)                break            else:                if user &#x3D;&#x3D; self.user_list[-1]:                    print(&#39;登录失败&#39;)</code></pre></li></ul><h2 id="十九、面向对象进阶"><a href="#十九、面向对象进阶" class="headerlink" title="十九、面向对象进阶"></a>十九、面向对象进阶</h2><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210127104158850.png" class=""><p>课程目标：掌握面向对象进阶相关知识点，能沟通更加自如的使用面向对象来进行编程。</p><p>今日概要：</p><ul><li><p>成员</p><ul><li>变量<ul><li>实例变量</li><li>类变量</li></ul></li><li>方法<ul><li>绑定方法</li><li>类方法</li><li>静态方法</li></ul></li><li>属性：使代码更加简洁</li></ul></li><li><p>成员修饰符（公有&#x2F;私有）</p></li><li><p>“对象嵌套”：一些项目源码中大量使用，方便读懂源码</p></li><li><p>特殊成员：一些项目源码中大量使用，方便读懂源码</p></li></ul><h3 id="1-成员"><a href="#1-成员" class="headerlink" title="1.成员"></a>1.成员</h3><p>面向对象中的所有成员如下：</p><ul><li>变量<ul><li>实例变量</li><li>类变量</li></ul></li><li>方法<ul><li>绑定方法</li><li>类方法</li><li>静态方法</li></ul></li><li>属性</li></ul><p>通过面向对象进行编程时，会遇到很多种情况，也会使用不同的成员来实现，接下来我们来逐一介绍成员特性和应用场景。</p><h4 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h4><ul><li>实例变量，属于对象，每个对象中各自维护自己的数据。</li><li>类变量，属于类，可以被所有对象共享，一般用于给对象提供公共数据（类似于全局变量）。</li></ul><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210127111042911.png" class=""><pre class="language-python" data-language="python"><code class="language-python">class Person(object):    country &#x3D; &quot;中国&quot;    def __init__(self, name, age):        self.name &#x3D; name        self.age &#x3D; age    def show(self):        # 推荐        message &#x3D; &quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;.format(Person.country, self.name, self.age)        # message &#x3D; &quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;.format(self.country, self.name, self.age)        print(message)print(Person.country) # 中国p1 &#x3D; Person(&quot;武沛齐&quot;,20)print(p1.name)print(p1.age)print(p1.country) # 中国p1.show() # 中国-武沛齐-20</code></pre><p><strong>提示：当把每个对象中都存在的相同的示例变量时，可以选择把它放在类变量中，这样就可以避免对象中维护多个相同数据。</strong></p><h4 id="易错点-amp-面试题"><a href="#易错点-amp-面试题" class="headerlink" title="易错点 &amp; 面试题"></a><font color="#dd0000">易错点 &amp; 面试题</font></h4><p>第一题：注意读和写的区别。</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210127111042911.png" class=""><pre class="language-python" data-language="python"><code class="language-python">class Person(object):    country &#x3D; &quot;中国&quot;    def __init__(self, name, age):        self.name &#x3D; name        self.age &#x3D; age    def show(self):        message &#x3D; &quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;.format(self.country, self.name, self.age)        print(message)print(Person.country) # 中国p1 &#x3D; Person(&quot;武沛齐&quot;,20)print(p1.name) # 武沛齐print(p1.age) # 20print(p1.country) # 中国p1.show() # 中国-武沛齐-20p1.name &#x3D; &quot;root&quot;     # 在对象p1中将name重置为rootp1.num &#x3D; 19          # 在对象p1中新增实例变量 num&#x3D;19p1.country &#x3D; &quot;china&quot; # 在对象p1中新增实例变量 country&#x3D;&quot;china&quot;print(p1.country)   # chinaprint(Person.country) # 中国</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Person(object):    country &#x3D; &quot;中国&quot;    def __init__(self, name, age):        self.name &#x3D; name        self.age &#x3D; age    def show(self):        message &#x3D; &quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;.format(self.country, self.name, self.age)        print(message)print(Person.country) # 中国Person.country &#x3D; &quot;美国&quot;p1 &#x3D; Person(&quot;武沛齐&quot;,20)print(p1.name) # 武沛齐print(p1.age) # 20print(p1.country) # 美国</code></pre><p>第二题：继承关系中的读写</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210127124925846.png" class=""><pre class="language-python" data-language="python"><code class="language-python">class Base(object):    country &#x3D; &quot;中国&quot;class Person(Base):    def __init__(self, name, age):        self.name &#x3D; name        self.age &#x3D; age    def show(self):        message &#x3D; &quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;.format(Person.country, self.name, self.age)        # message &#x3D; &quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;.format(self.country, self.name, self.age)        print(message)# 读print(Base.country) # 中国print(Person.country) # 中国obj &#x3D; Person(&quot;武沛齐&quot;,19)print(obj.country) # 中国# 写Base.country &#x3D; &quot;china&quot;Person.country &#x3D; &quot;泰国&quot;obj.country &#x3D; &quot;日本&quot;</code></pre><h4 id="【面试题】：类变量和实例变量的读写"><a href="#【面试题】：类变量和实例变量的读写" class="headerlink" title="【面试题】：类变量和实例变量的读写"></a><font color="#dd0000">【面试题】</font>：类变量和实例变量的读写</h4><pre class="language-python" data-language="python"><code class="language-python">class Parent(object):    x &#x3D; 1class Child1(Parent):    passclass Child2(Parent):    passprint(Parent.x, Child1.x, Child2.x) # 1 1 1Child1.x &#x3D; 2print(Parent.x, Child1.x, Child2.x) # 1 2 1Parent.x &#x3D; 3print(Parent.x, Child1.x, Child2.x) # 3 2 3</code></pre><h4 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1.2 方法"></a>1.2 方法</h4><ul><li>绑定方法，默认有一个self参数，由对象进行调用（此时self就等于调用方法的这个对象）【对象&amp;类均可调用】</li><li>类方法，默认有一个cls参数，用类或对象都可以调用（此时cls就等于调用方法的这个类）【对象&amp;类均可调用】</li><li>静态方法，无默认参数，用类和对象都可以调用。【对象&amp;类均可调用】</li></ul><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210127141701335.png" class=""><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name,age):        self.name &#x3D; name        self.age &#x3D; age    def f1(self):        print(&quot;绑定方法&quot;, self.name)    @classmethod    def f2(cls):        print(&quot;类方法&quot;, cls)    @staticmethod    def f3():        print(&quot;静态方法&quot;)        # 绑定方法：主要做法是通过对象调用obj &#x3D; Foo(&quot;武沛齐&quot;,20)obj.f1() Foo.f1(obj)# 类方法：主流做法是通过类进行调用Foo.f2()  # cls就是当前调用这个方法的类。（类）obj.f2()  # cls就是当前调用这个方法的对象的类。# 静态方法：主流做法是通过类进行调用Foo.f3()  # 类执行执行方法（类）obj.f3()  # 对象执行执行方法</code></pre><p>在Python中比较灵活，方法都可以通过对象和类进行调用；而在java、c#等语言中，绑定方法只能由对象调用；类方法或静态方法只能由类调用。</p><pre class="language-python" data-language="python"><code class="language-python">import osimport requestsclass Download(object):    def __init__(self, folder_path):        self.folder_path &#x3D; folder_path    @staticmethod    def download_dou_yin():        # 下载抖音        res &#x3D; requests.get(&#39;.....&#39;)        with open(&quot;xxx.mp4&quot;, mode&#x3D;&#39;wb&#39;) as f:            f.write(res.content)    def download_dou_yin_2(self):        # 下载抖音        res &#x3D; requests.get(&#39;.....&#39;)        path &#x3D; os.path.join(self.folder_path, &#39;xxx.mp4&#39;)        with open(path, mode&#x3D;&#39;wb&#39;) as f:            f.write(res.content)obj &#x3D; Download(&quot;video&quot;)obj.download_dou_yin()</code></pre><h4 id="【面试题】：在类中-classmethod-和-staticmethod-的作用？"><a href="#【面试题】：在类中-classmethod-和-staticmethod-的作用？" class="headerlink" title="【面试题】：在类中 @classmethod 和 @staticmethod 的作用？"></a><font color="#dd0000">【面试题】</font>：在类中 <code>@classmethod</code> 和 <code>@staticmethod</code> 的作用？</h4><blockquote><p>在类中，方法装饰上@classmethod和@staticmethod后，该方法变为类方法或静态方法。</p><ul><li>在类方法中需要传入cls参数，以调用类中的变量和方法</li><li>在静态方法中不用传入任何参数</li></ul></blockquote><h4 id="1-3-属性"><a href="#1-3-属性" class="headerlink" title="1.3 属性"></a>1.3 属性</h4><p>属性其实是由绑定方法 + 特殊装饰器（<code>@property</code>） 组合创造出来的，<strong>让我们以后在调用方法时可以不加括号</strong>，例如：</p><p>在自己写代码的过程中应用较少，学习后主要应用场景为<strong>更好的阅读别人的源码</strong></p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name):        self.name &#x3D; name    def f1(self):        return 123    @property    def f2(self):        return 123obj &#x3D; Foo(&quot;武沛齐&quot;)v1 &#x3D; obj.f1()print(v1)v2 &#x3D; obj.f2print(v2)</code></pre><p>示例：以之前开发的分页的功能。</p><pre class="language-python" data-language="python"><code class="language-python">class Pagination:    def __init__(self, current_page, per_page_num&#x3D;10):        self.per_page_num &#x3D; per_page_num                if not current_page.isdecimal():            self.current_page &#x3D; 1            return        current_page &#x3D; int(current_page)        if current_page &lt; 1:            self.current_page &#x3D; 1            return        self.current_page &#x3D; current_page    def start(self):        return (self.current_page - 1) * self.per_page_num    def end(self):        return self.current_page * self.per_page_numuser_list &#x3D; [&quot;用户-&#123;&#125;&quot;.format(i) for i in range(1, 3000)]# 分页显示，每页显示10条while True:    page &#x3D; input(&quot;请输入页码：&quot;)    # page，当前访问的页码    # 10，每页显示10条数据# 内部执行Pagination类的init方法。    pg_object &#x3D; Pagination(page, 20)        page_data_list &#x3D; user_list[ pg_object.start() : pg_object.end() ]    for item in page_data_list:        print(item)</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Pagination:    def __init__(self, current_page, per_page_num&#x3D;10):        self.per_page_num &#x3D; per_page_num        if not current_page.isdecimal():            self.current_page &#x3D; 1            return        current_page &#x3D; int(current_page)        if current_page &lt; 1:            self.current_page &#x3D; 1            return        self.current_page &#x3D; current_page    @property    def start(self):        return (self.current_page - 1) * self.per_page_num    @property    def end(self):        return self.current_page * self.per_page_numuser_list &#x3D; [&quot;用户-&#123;&#125;&quot;.format(i) for i in range(1, 3000)]# 分页显示，每页显示10条while True:    page &#x3D; input(&quot;请输入页码：&quot;)    pg_object &#x3D; Pagination(page, 20)    page_data_list &#x3D; user_list[ pg_object.start : pg_object.end ]        for item in page_data_list:        print(item)</code></pre><p>其实，除了咱们写的示例以外，在很多模块和框架的源码中也有porperty的身影，例如：requests模块。</p><pre class="language-python" data-language="python"><code class="language-python">import requests# 内部下载视频，并将下载好的数据分装到Response对象中。res &#x3D; requests.get(    url&#x3D;&quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&quot;,    headers&#x3D;&#123;        &quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 FS&quot;    &#125;)# 去对象中获取text，其实需要读取原始文本字节并转换为字符串res.text</code></pre><p>关于属性的编写有两种方式：</p><ul><li><p>方式一，基于装饰器</p><pre class="language-python" data-language="python"><code class="language-python">class C(object):        @property    def x(self):        pass        @x.setter    def x(self, value):        pass        @x.deleter    def x(self):pass        obj &#x3D; C()obj.xobj.x &#x3D; 123del obj.x</code></pre></li><li><p>方式二，基于定义变量</p><pre class="language-python" data-language="python"><code class="language-python">class C(object):        def getx(self): pass        def setx(self, value): pass            def delx(self): pass            x &#x3D; property(getx, setx, delx, &quot;I&#39;m the &#39;x&#39; property.&quot;)    obj &#x3D; C()obj.xobj.x &#x3D; 123del obj.x</code></pre></li></ul><p>Django源码一撇：</p><pre class="language-python" data-language="python"><code class="language-python">class WSGIRequest(HttpRequest):    def __init__(self, environ):        script_name &#x3D; get_script_name(environ)        # If PATH_INFO is empty (e.g. accessing the SCRIPT_NAME URL without a        # trailing slash), operate as if &#39;&#x2F;&#39; was requested.        path_info &#x3D; get_path_info(environ) or &#39;&#x2F;&#39;        self.environ &#x3D; environ        self.path_info &#x3D; path_info        # be careful to only replace the first slash in the path because of        # http:&#x2F;&#x2F;test&#x2F;something and http:&#x2F;&#x2F;test&#x2F;&#x2F;something being different as        # stated in https:&#x2F;&#x2F;www.ietf.org&#x2F;rfc&#x2F;rfc2396.txt        self.path &#x3D; &#39;%s&#x2F;%s&#39; % (script_name.rstrip(&#39;&#x2F;&#39;),                               path_info.replace(&#39;&#x2F;&#39;, &#39;&#39;, 1))        self.META &#x3D; environ        self.META[&#39;PATH_INFO&#39;] &#x3D; path_info        self.META[&#39;SCRIPT_NAME&#39;] &#x3D; script_name        self.method &#x3D; environ[&#39;REQUEST_METHOD&#39;].upper()        # Set content_type, content_params, and encoding.        self._set_content_type_params(environ)        try:            content_length &#x3D; int(environ.get(&#39;CONTENT_LENGTH&#39;))        except (ValueError, TypeError):            content_length &#x3D; 0        self._stream &#x3D; LimitedStream(self.environ[&#39;wsgi.input&#39;], content_length)        self._read_started &#x3D; False        self.resolver_match &#x3D; None    def _get_scheme(self):        return self.environ.get(&#39;wsgi.url_scheme&#39;)    def _get_post(self):        if not hasattr(self, &#39;_post&#39;):            self._load_post_and_files()        return self._post    def _set_post(self, post):        self._post &#x3D; post    @property    def FILES(self):        if not hasattr(self, &#39;_files&#39;):            self._load_post_and_files()        return self._files    POST &#x3D; property(_get_post, _set_post)</code></pre><p>写在最后，对属性进行一个补充：</p><p>由于属性和实例变量的调用方式相同，所以在编写时需要注意：属性名称 不要 实例变量 重名。</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name, age):        self.name &#x3D; name        self.age &#x3D; age    @property    def func(self):        return 123obj &#x3D; Foo(&quot;武沛齐&quot;, 123)print(obj.name)print(obj.func)</code></pre><p>一旦重名，可能就会有报错。</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name, age):        self.name &#x3D; name  # 报错，错认为你想要调用 @name.setter 装饰的方法。        self.age &#x3D; age    @property    def name(self):        return &quot;&#123;&#125;-&#123;&#125;&quot;.format(self.name, self.age)obj &#x3D; Foo(&quot;武沛齐&quot;, 123)</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name, age):        self.name &#x3D; name         self.age &#x3D; age    @property    def name(self):        return &quot;&#123;&#125;-&#123;&#125;&quot;.format(self.name, self.age) # 报错，循环调用自己（直到层级太深报错）    @name.setter    def name(self, value):        print(value)obj &#x3D; Foo(&quot;武沛齐&quot;, 123)print(obj.name)</code></pre><p>如果真的想要在名称上创建一些关系，可以让实例变量加上一个下划线。</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name, age):        self._name &#x3D; name        self.age &#x3D; age    @property    def name(self):        return &quot;&#123;&#125;-&#123;&#125;&quot;.format(self._name, self.age)obj &#x3D; Foo(&quot;武沛齐&quot;, 123)print(obj._name)print(obj.name)</code></pre><h3 id="2-成员修饰符"><a href="#2-成员修饰符" class="headerlink" title="2.成员修饰符"></a>2.成员修饰符</h3><p>Python中成员的修饰符就是指的是：公有、私有。</p><ul><li>公有，在任何地方都可以调用这个成员。</li><li>私有，只有在类的内部才可以调用改成员（成员是以两个下划线开头，则表示该成员为私有）。</li></ul><p>示例一：</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name, age):        self.__name &#x3D; name        self.age &#x3D; age    def get_data(self):        return self.__name    def get_age(self):        return self.ageobj &#x3D; Foo(&quot;武沛齐&quot;, 123)# 公有成员print(obj.age)v1 &#x3D; self.get_age()print(v1)# 私有成员# print(obj.__name) # 错误，由于是私有成员，只能在类中进行使用。v2 &#x3D; obj.get_data()print(v2)</code></pre><p>示例2：</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def get_age(self):        print(&quot;公有的get_age&quot;)    def __get_data(self):        print(&quot;私有的__get_data方法&quot;)    def proxy(self):        print(&quot;公有的proxy&quot;)        self.__get_data()obj &#x3D; Foo()obj.get_age()obj.proxy()</code></pre><p>示例3：</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    @property    def __name(self):        print(&quot;公有的get_age&quot;)    @property    def proxy(self):        print(&quot;公有的proxy&quot;)        self.__name        return 1obj &#x3D; Foo()v1 &#x3D; obj.proxyprint(v1)</code></pre><p>特别提醒：父类中的私有成员，子类无法继承。</p><pre class="language-python" data-language="python"><code class="language-python">class Base(object):    def __data(self):        print(&quot;base.__data&quot;)    def num(self):        print(&quot;base.num&quot;)class Foo(Base):    def func(self):        self.num()        self.__data() # # 不允许执行父类中的私有方法obj &#x3D; Foo()obj.func()</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Base(object):    def __data(self):        print(&quot;base.__data&quot;)    def num(self):        print(&quot;base.num&quot;)        self.__data()  # 不允许执行父类中的私有方法class Foo(Base):    def func(self):        self.num()obj &#x3D; Foo()obj.func()</code></pre><p>写在最后，按理说私有成员是无法被外部调用，但如果用一些特殊的语法也可以（Flask源码中有这种写法，大家写代码不推荐这样写）。</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self):        self.__num &#x3D; 123        self.age &#x3D; 19    def __msg(self):        print(1234)obj &#x3D; Foo()print(obj.age)print(obj._Foo__num)obj._Foo__msg()</code></pre><p><strong>成员是否可以作为独立的功能暴露给外部，让外部调用并使用。</strong></p><ul><li>可以，公有。</li><li>不可以，内部其他放的一个辅助，私有。</li></ul><h3 id="3-对象嵌套"><a href="#3-对象嵌套" class="headerlink" title="3.对象嵌套"></a>3.对象嵌套</h3><p>在基于面向对象进行编程时，对象之间可以存在各种各样的关系，例如：组合、关联、依赖等（Java中的称呼），用大白话来说就是各种嵌套。</p><p>下面我们就用示例来学习常见的嵌套的情景：</p><p>情景一：</p><pre class="language-python" data-language="python"><code class="language-python">class Student(object):    &quot;&quot;&quot; 学生类 &quot;&quot;&quot;    def __init__(self, name, age):        self.name &#x3D; name        self.age &#x3D; age    def message(self):        data &#x3D; &quot;我是一名学生，我叫:&#123;&#125;,我今年&#123;&#125;岁&quot;.format(self.name, self.age)        print(data)s1 &#x3D; Student(&quot;武沛齐&quot;, 19)s2 &#x3D; Student(&quot;Alex&quot;, 19)s3 &#x3D; Student(&quot;日天&quot;, 19)class Classes(object):    &quot;&quot;&quot; 班级类 &quot;&quot;&quot;    def __init__(self, title):        self.title &#x3D; title        self.student_list &#x3D; []    def add_student(self, stu_object):        self.student_list.append(stu_object)    def add_students(self, stu_object_list):        for stu in stu_object_list:            self.add_student(stu)    def show_members(self):        for item in self.student_list:            # print(item)            item.message()c1 &#x3D; Classes(&quot;三年二班&quot;)c1.add_student(s1)c1.add_students([s2, s3])print(c1.title)print(c1.student_list)</code></pre><p>情景二：</p><pre class="language-python" data-language="python"><code class="language-python">class Student(object):    &quot;&quot;&quot; 学生类 &quot;&quot;&quot;    def __init__(self, name, age, class_object):        self.name &#x3D; name        self.age &#x3D; age        self.class_object &#x3D; class_object    def message(self):        data &#x3D; &quot;我是一名&#123;&#125;班的学生，我叫:&#123;&#125;,我今年&#123;&#125;岁&quot;.format(self.class_object.title, self.name, self.age)        print(data)class Classes(object):    &quot;&quot;&quot; 班级类 &quot;&quot;&quot;    def __init__(self, title):        self.title &#x3D; titlec1 &#x3D; Classes(&quot;Python全栈&quot;)c2 &#x3D; Classes(&quot;Linux云计算&quot;)user_object_list &#x3D; [    Student(&quot;武沛齐&quot;, 19, c1),    Student(&quot;Alex&quot;, 19, c1),    Student(&quot;日天&quot;, 19, c2)]for obj in user_object_list:    print(obj.name,obj.age, obj.class_object.title)</code></pre><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210127215951115.png" class=""><p>情景三：</p><pre class="language-python" data-language="python"><code class="language-python">class Student(object):    &quot;&quot;&quot; 学生类 &quot;&quot;&quot;    def __init__(self, name, age, class_object):        self.name &#x3D; name        self.age &#x3D; age        self.class_object &#x3D; class_object    def message(self):        data &#x3D; &quot;我是一名&#123;&#125;班的学生，我叫:&#123;&#125;,我今年&#123;&#125;岁&quot;.format(self.class_object.title, self.name, self.age)        print(data)class Classes(object):    &quot;&quot;&quot; 班级类 &quot;&quot;&quot;    def __init__(self, title, school_object):        self.title &#x3D; title        self.school_object &#x3D; school_objectclass School(object):    &quot;&quot;&quot; 学校类 &quot;&quot;&quot;    def __init__(self, name):        self.name &#x3D; names1 &#x3D; School(&quot;北京校区&quot;)s2 &#x3D; School(&quot;上海校区&quot;)c1 &#x3D; Classes(&quot;Python全栈&quot;, s1)c2 &#x3D; Classes(&quot;Linux云计算&quot;, s2)user_object_list &#x3D; [    Student(&quot;武沛齐&quot;, 19, c1),    Student(&quot;Alex&quot;, 19, c1),    Student(&quot;日天&quot;, 19, c2)]for obj in user_object_list:    print(obj.name, obj.class_object.title ,  obj.class_object.school_object.name)</code></pre><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210127220654414.png" class=""><h3 id="4-特殊成员"><a href="#4-特殊成员" class="headerlink" title="4.特殊成员"></a>4.特殊成员</h3><p>在Python的类中存在一些特殊的方法，这些方法都是 <code>__方法__</code> 格式，这种方法在内部均有特殊的含义，接下来我们来讲一些常见的特殊成员：</p><ul><li><p><code>__init__</code>，初始化方法</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name):        self.name &#x3D; nameobj &#x3D; Foo(&quot;武沛齐&quot;)</code></pre></li><li><p><code>__new__</code>，构造方法</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name):        print(&quot;第二步：初始化对象，在空对象中创建数据&quot;)        self.name &#x3D; name    def __new__(cls, *args, **kwargs):        print(&quot;第一步：先创建空对象并返回&quot;)        return object.__new__(cls)obj &#x3D; Foo(&quot;武沛齐&quot;)</code></pre></li><li><p><code>__call__</code>，使对象可执行</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __call__(self, *args, **kwargs):        print(&quot;执行call方法&quot;)obj &#x3D; Foo()obj()</code></pre></li><li><p><code>__str__</code>，使对象支持被打印</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __str__(self):        return &quot;哈哈哈哈&quot;obj &#x3D; Foo()data &#x3D; str(obj)print(data)</code></pre></li><li><p><code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>，使对象支持通过索引查、改、删值，<code>obj[&quot;x1&quot;]</code>、<code>obj[&#39;x2&#39;] = 123</code>、<code>del obj[&#39;x3&#39;]</code></p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __getitem__(self, item):        pass    def __setitem__(self, key, value):        pass    def __delitem__(self, key):        passobj &#x3D; Foo(&quot;武沛齐&quot;, 19)obj[&quot;x1&quot;]obj[&#39;x2&#39;] &#x3D; 123del obj[&#39;x3&#39;]</code></pre></li><li><p><code>__enter__</code>、<code>__exit__</code>，使对象支持<code>with</code>语法</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __enter__(self):        print(&quot;进入了&quot;)        return 666    def __exit__(self, exc_type, exc_val, exc_tb):        print(&quot;出去了&quot;)obj &#x3D; Foo()# with obj as data：执行__enter__方法并将返回值传给data# 当with缩进内的代码执行完毕后，自动执行__exit__with obj as data:     print(data)</code></pre><pre class="language-python" data-language="python"><code class="language-python">超前知识：数据连接，每次对远程的数据进行操作时候都必须经历。1.连接 &#x3D; 连接数据库2.操作数据库3.关闭连接</code></pre><pre class="language-python" data-language="python"><code class="language-python">class SqlHelper(object):    def __enter__(self):        self.连接 &#x3D; 连接数据库        return 连接    def __exit__(self, exc_type, exc_val, exc_tb):        self.连接.关闭                with SqlHelper() as 连接:    连接.操作..        with SqlHelper() as 连接:    连接.操作...</code></pre></li><li><p><code>__dict__</code>以字典形式返回对象&#x2F;类的所有成员</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name, age):        self.name &#x3D; name        self.age &#x3D; ageobj &#x3D; Foo(&quot;武沛齐&quot;,19)print(obj.__dict__)</code></pre></li></ul><h4 id="【面试题】：-enter-和-exit"><a href="#【面试题】：-enter-和-exit" class="headerlink" title="【面试题】：__enter__和__exit__"></a><font color="#dd0000">【面试题】</font>：<code>__enter__</code>和<code>__exit__</code></h4><pre class="language-python" data-language="python"><code class="language-python"># （补充代码，实现如下功能）class Context:        def do_something(self):        print(&#39;内部执行&#39;)with Context() as ctx:    print(&#39;内部执行&#39;)    ctx.do_something()</code></pre><p>上下文管理的语法。</p><ul><li><p><code>__add__</code> 等。</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name):        self.name &#x3D; name    def __add__(self, other):        return &quot;&#123;&#125;-&#123;&#125;&quot;.format(self.name, other.name)v1 &#x3D; Foo(&quot;alex&quot;)v2 &#x3D; Foo(&quot;sb&quot;)# 对象+值，内部会去执行 对象.__add__方法，并将+后面的值当做参数传递过去。v3 &#x3D; v1 + v2print(v3)</code></pre></li><li><p><code>__iter__</code></p><ul><li><p>迭代器</p><pre class="language-python" data-language="python"><code class="language-python"># 迭代器类型的定义：    1.当类中定义了 __iter__ 和 __next__ 两个方法。    2.__iter__ 方法需要返回对象本身，即：self    3. __next__ 方法，返回下一个数据，如果没有数据了，则需要抛出一个StopIteration的异常。官方文档：https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;stdtypes.html#iterator-types        # 创建 迭代器类型 ：class IT(object):        def __init__(self):            self.counter &#x3D; 0        def __iter__(self):            return self        def __next__(self):            self.counter +&#x3D; 1            if self.counter &#x3D;&#x3D; 3:                raise StopIteration()            return self.counter# 根据类实例化创建一个迭代器对象：    obj1 &#x3D; IT()        # v1 &#x3D; obj1.__next__()    # v2 &#x3D; obj1.__next__()    # v3 &#x3D; obj1.__next__() # 抛出异常        v1 &#x3D; next(obj1) # obj1.__next__()    print(v1)    v2 &#x3D; next(obj1)    print(v2)    v3 &#x3D; next(obj1)    print(v3)    obj2 &#x3D; IT()    for item in obj2:  # 首先会执行迭代器对象的__iter__方法并获取返回值，一直去反复的执行 next(对象)         print(item)        迭代器对象支持通过next取值，如果取值结束则自动抛出StopIteration。for循环内部在循环时，先执行__iter__方法，获取一个迭代器对象，然后不断执行的next取值（有异常StopIteration则终止循环）。</code></pre></li><li><p>生成器</p><pre class="language-python" data-language="python"><code class="language-python"># 创建生成器函数    def func():        yield 1        yield 2    # 创建生成器对象（内部是根据生成器类generator创建的对象），生成器类的内部也声明了：__iter__、__next__ 方法。    obj1 &#x3D; func()        v1 &#x3D; next(obj1)    print(v1)    v2 &#x3D; next(obj1)    print(v2)    v3 &#x3D; next(obj1)    print(v3)    obj2 &#x3D; func()    for item in obj2:        print(item)如果按照迭代器的规定来看，其实生成器类也是一种特殊的迭代器类（生成器也是一种特殊的迭代器）。</code></pre></li><li><p>可迭代对象</p><pre class="language-python" data-language="python"><code class="language-python"># 如果一个类中有__iter__方法且返回一个迭代器对象 ；则我们称以这个类创建的对象为可迭代对象。class Foo(object):        def __iter__(self):        return 迭代器对象(生成器对象)    obj &#x3D; Foo() # obj是 可迭代对象。# 可迭代对象是可以使用for来进行循环，在循环的内部其实是先执行 __iter__ 方法，获取其迭代器对象，然后再在内部执行这个迭代器对象的next功能，逐步取值。for item in obj:    pass</code></pre><pre class="language-python" data-language="python"><code class="language-python">class IT(object):    def __init__(self):        self.counter &#x3D; 0    def __iter__(self):        return self    def __next__(self):        self.counter +&#x3D; 1        if self.counter &#x3D;&#x3D; 3:            raise StopIteration()        return self.counterclass Foo(object):    def __iter__(self):        return IT()obj &#x3D; Foo() # 可迭代对象for item in obj: # 循环可迭代对象时，内部先执行obj.__iter__并获取迭代器对象；不断地执行迭代器对象的next方法。    print(item)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 基于可迭代对象&amp;迭代器实现：自定义rangeclass IterRange(object):    def __init__(self, num):        self.num &#x3D; num        self.counter &#x3D; -1    def __iter__(self):        return self    def __next__(self):        self.counter +&#x3D; 1        if self.counter &#x3D;&#x3D; self.num:            raise StopIteration()        return self.counterclass Xrange(object):    def __init__(self, max_num):        self.max_num &#x3D; max_num    def __iter__(self):        return IterRange(self.max_num)obj &#x3D; Xrange(100)for item in obj:    print(item)</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __iter__(self):        yield 1        yield 2obj &#x3D; Foo()for item in obj:    print(item)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 基于可迭代对象&amp;生成器 实现：自定义rangeclass Xrange(object):    def __init__(self, max_num):        self.max_num &#x3D; max_num    def __iter__(self):        counter &#x3D; 0        while counter &lt; self.max_num:            yield counter            counter +&#x3D; 1obj &#x3D; Xrange(100)for item in obj:    print(item)</code></pre><p>常见的数据类型：</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; list([11,22,33,44])v1是一个可迭代对象，因为在列表中声明了一个 __iter__ 方法并且返回一个迭代器对象。</code></pre><pre class="language-python" data-language="python"><code class="language-python">from collections.abc import Iterator, Iterablev1 &#x3D; [11, 22, 33]print( isinstance(v1, Iterator) )  # false，判断是否是迭代器；判断依据是__iter__ 和 __next__。v2 &#x3D; v1.__iter__()print( isinstance(v2, Iterator) )  # Truev1 &#x3D; [11, 22, 33]print( isinstance(v1, Iterable) )  # True，判断依据是是否有 __iter__且返回迭代器对象。v2 &#x3D; v1.__iter__()print( isinstance(v2, Iterable) )  # True，判断依据是是否有 __iter__且返回迭代器对象。</code></pre></li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li><p>面向对象编程中的成员</p><ul><li>变量<ul><li>实例变量</li><li>类变量</li></ul></li></ul></li></ol><ul><li>方法<br>- 绑定方法<br>- 类方法<br>- 静态方法<ul><li>属性</li></ul></li></ul><ol start="2"><li>成员修饰符</li><li>对象中的数据嵌套</li><li>特殊成员</li><li>重要概念：<ul><li>迭代器</li><li>生成器</li><li>可迭代对象</li></ul></li></ol><h3 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h3><ol><li><p>列举面向对象的成员并简述他们的特点。</p><p>答：</p><ul><li><p>变量</p><ul><li>实例变量：属于对象，只能被对象调用</li><li>类变量：属于类，既能被类调用，也能被实例调用</li></ul></li><li><p>方法</p><ul><li>绑定方法：既能被类调用，也能被实例调用，推荐使用对象进行调用，参数中需要传入 <code>self</code> 和 实例变量</li><li>类方法：既能被类调用，也能被实例调用，推荐使用类进行调用，参数中需要传入<code>cls</code>  和 类变量</li><li>静态方法：既能被类调用，也能被实例调用，推荐使用类进行调用，不用传入实例变量和类变量</li></ul></li><li><p>属性</p><p>通过绑定方法 + <code>@property</code> 组成，可以在执行该实例方法是不用加括号</p></li></ul><p><font color="#dd0000">存在问题</font>：</p><ul><li><code>self</code>、<code>cls</code>为默认参数不需要传递</li><li>未说明完全属性的作用</li></ul></li><li><p><code>@staticmethod</code> 和 <code>@classmethod</code>的作用是什么？</p><p>答：在绑定方法上装饰<code>@staticmethod</code> 或<code>@classmethod</code>，可以将该方法变为类方法或静态方法，具体视该方法有无调用实例变量和类变量而定。</p></li><li><p>面向对象中如何让成员变为私有。</p><p>答：在成员前加双下划线<code>__</code></p></li><li><p><code>__new__</code>方法的作用？</p><p>答：</p><p><font color="#dd0000">存在问题</font>：未掌握<code>__new__</code>用法</p></li><li><p>简述你理解的：迭代器、生成器、可迭代对象。</p><p>答：</p><ul><li>迭代器：内部封装有<code>__iter__</code>方法并返回对象本身，同时封装<code>__next__</code>方法</li><li>可迭代对象：内部封装有<code>__iter__</code>方法并返回一个迭代器</li><li>生成器：方法内包含<code>yield</code>关键字，同时满足迭代器的条件，是一种特殊的迭代器</li></ul><p><font color="#dd0000">存在问题</font>：</p><ul><li><p>缺少对<code>__next__</code>作用的介绍:<code>__next__</code>可以获取数据（终止抛出StopIteration异常），可以被for循环</p></li><li><p>生成器：函数中包含yield关键字，则被称为生成器函数，执行生成器函数获得一个生成器对象（特殊的迭代器），满足迭代器的条件。</p></li></ul></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    a1 &#x3D; 1        def __init__(self,num):        self.num &#x3D; num            def show_data(self):        print(self.num+self.a1)    obj1 &#x3D; Foo(666)obj2 &#x3D; Foo(999)print(obj1.num)print(obj1.a1)obj1.num &#x3D; 18obj1.a1 &#x3D; 99print(obj1.num)print(obj1.a1)print(obj2.a1)print(obj2.num)print(obj2.num)print(Foo.a1)print(obj1.a1)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 666&gt;&gt;&gt; 1&gt;&gt;&gt; 18&gt;&gt;&gt; 99&gt;&gt;&gt; 1&gt;&gt;&gt; 999&gt;&gt;&gt; 999&gt;&gt;&gt; 1&gt;&gt;&gt; 99</code></pre></li><li><p>看代码写结果，注意返回值。</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):        def f1(self):        return 999        def f2(self):        v &#x3D; self.f1()        print(&#39;f2&#39;)        return v        def f3(self):        print(&#39;f3&#39;)        return self.f2()        def run(self):        result &#x3D; self.f3()        print(result)obj &#x3D; Foo()v1 &#x3D; obj.run()print(v1)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; f3&gt;&gt;&gt; f2&gt;&gt;&gt; 999&gt;&gt;&gt; None</code></pre></li><li><p>看代码写结果【如果有错误，则标注错误即可，并且假设程序报错可以继续执行】</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):        def f1(self):        print(&#39;f1&#39;)    @staticmethod    def f2():        print(&#39;f2&#39;)        obj &#x3D; Foo()obj.f1()obj.f2()Foo.f1()Foo.f2()</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; f1&gt;&gt;&gt; f2&gt;&gt;&gt; Foo.f1()  # 报错：未传入obj对象&gt;&gt;&gt; f2</code></pre></li><li><p>看代码写结果【如果有错误，则标注错误即可，并且假设程序报错可以继续执行】</p><pre class="language-pthon" data-language="pthon"><code class="language-pthon">class Foo(object):        def f1(self):        print(&#39;f1&#39;)        self.f2()        self.f3()    @classmethod    def f2(cls):          print(&#39;f2&#39;)    @staticmethod    def f3():          print(&#39;f3&#39;)obj &#x3D; Foo()obj.f1()</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; f1&gt;&gt;&gt; f2&gt;&gt;&gt; f3</code></pre></li><li><p>看代码写结果【如果有错误，则标注错误即可，并且假设程序报错可以继续执行】</p><pre class="language-python" data-language="python"><code class="language-python">class Base(object):    @classmethod    def f2(cls):          print(&#39;f2&#39;)    @staticmethod    def f3():          print(&#39;f3&#39;)class Foo(Base):    def f1(self):        print(&#39;f1&#39;)        self.f2()        self.f3()obj &#x3D; Foo()obj.f1()</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; f1&gt;&gt;&gt; f2&gt;&gt;&gt; f3</code></pre></li><li><p>看代码写结果【如果有错误，则标注错误即可，并且假设程序报错可以继续执行】</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    a1 &#x3D; 1    __a2 &#x3D; 2        def __init__(self,num):        self.num &#x3D; num        self.__salary &#x3D; 1000             def show_data(self):         print(self.num+self.a1)    obj &#x3D; Foo(666)print(obj.num)print(obj.a1)print(obj.__salary)print(obj.__a2)print(Foo.a1)print(Foo.__a2)obj.show_data()</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 666&gt;&gt;&gt; 1&gt;&gt;&gt; print(obj.__salary)  # 报错无法在类的外部访问私有变量&gt;&gt;&gt; print(obj.__a2)  # 报错无法在类的外部访问私有变量&gt;&gt;&gt; 1&gt;&gt;&gt; print(Foo.__a2)  # 报错无法在类的外部访问私有变量&gt;&gt;&gt; 667</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, age):        self.age &#x3D; age    def display(self):        print(self.age)data_list &#x3D; [Foo(8), Foo(9)]# print(data_list[0].age)# data_list[1].display()for item in data_list:    print(item.age, item.display()) </code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 8&gt;&gt;&gt; 9&gt;&gt;&gt; 8&gt;&gt;&gt; 8 None&gt;&gt;&gt; 9&gt;&gt;&gt; 9 None</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class Base(object):    def __init__(self, a1):        self.a1 &#x3D; a1    def f2(self, arg):        print(self.a1, arg)class Foo(Base):    def f2(self, arg):        print(&#39;666&#39;)obj_list &#x3D; [Base(1), Foo(2), Foo(3)]for item in obj_list:    item.f2(1)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 1 1&gt;&gt;&gt; 666&gt;&gt;&gt; 666</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, num):        self.num &#x3D; num        v1 &#x3D; [Foo for i in range(10)]v2 &#x3D; [Foo(5) for i in range(10)]v3 &#x3D; [Foo(i) for i in range(10)]print(v1)print(v2)print(v3)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; [class, class, ... , class]  # 10个类Foo&gt;&gt;&gt; [Foo(5), Foo(5), ... , Foo(5)]  # 10个对象Foo(5)&gt;&gt;&gt;[Foo(0), Foo(1), ... , Foo(9)]  # 10个对象Foo(0)-Foo(9)</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class StarkConfig(object):    def __init__(self, num):        self.num &#x3D; num    def changelist(self, request):        print(self.num, request)config_obj_list &#x3D; [ StarkConfig(1),  StarkConfig(2),  StarkConfig(3) ]for item in config_obj_list:    print(item.num)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 1&gt;&gt;&gt; 2&gt;&gt;&gt; 3</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class StarkConfig(object):    def __init__(self, num):        self.num &#x3D; num    def changelist(self, request):        print(self.num, request)config_obj_list &#x3D; [StarkConfig(1), StarkConfig(2), StarkConfig(3)]for item in config_obj_list:    item.changelist(666)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 1 666&gt;&gt;&gt; 2 666&gt;&gt;&gt; 3 666</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class StarkConfig(object):    def __init__(self, num):        self.num &#x3D; num    def changelist(self, request):        print(self.num, request)    def run(self):        self.changelist(999)class RoleConfig(StarkConfig):    def changelist(self, request):        print(666, self.num)class AdminSite(object):    def __init__(self):        self._registry &#x3D; &#123;&#125;    def register(self, k, v):        self._registry[k] &#x3D; vsite &#x3D; AdminSite()site.register(&#39;武沛齐&#39;, StarkConfig(19))site.register(&#39;root&#39;, StarkConfig(20))site.register(&quot;admin&quot;, RoleConfig(33))print(len(site._registry))for k, row in site._registry.items():    row.changelist(5)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 3&gt;&gt;&gt; 19 5&gt;&gt;&gt; 20 5&gt;&gt;&gt; 666 33</code></pre></li><li><p>看代码写结果（如有报错，请标注报错位置）</p><pre class="language-python" data-language="python"><code class="language-python">class StarkConfig(object):    def __init__(self, num):        self.num &#x3D; num    def run(self):        self()    def __call__(self, *args, **kwargs):        print(self.num)        class RoleConfig(StarkConfig):    def __call__(self, *args, **kwargs):        print(345)    def __getitem__(self, item):        return self.num[item]    v1 &#x3D; RoleConfig(&#39;alex&#39;)v2 &#x3D; StarkConfig(&quot;wupeiqi&quot;)print(v1[1])print(v2[2])</code></pre><p>答：</p><p><font color="#dd0000">存在问题</font>：未掌握成员<code>__call__</code>和<code>__getitem__</code></p></li><li><p>补全代码</p><pre class="language-python" data-language="python"><code class="language-python">class Context:passwith Context() as ctx:    ctx.do_something()</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">class Context:    def __enter__(self):        return self    def do_something(self):        pass    def __exit__(self, exc_type, exc_val, exc_tb):        passwith Context() as ctx:    ctx.do_something()</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class Department(object):    def __init__(self,title):        self.title &#x3D; titleclass Person(object):    def __init__(self,name,age,depart):        self.name &#x3D; name        self.age &#x3D; age         self.depart &#x3D; depart    def message(self):        msg &#x3D; &quot;我是%s,年龄%s,属于%s&quot; %(self.name,self.age,self.depart.title)        print(msg)        d1 &#x3D; Department(&#39;人事部&#39;)d2 &#x3D; Department(&#39;销售部&#39;)p1 &#x3D; Person(&#39;武沛齐&#39;,18,d1)p2 &#x3D; Person(&#39;alex&#39;,18,d1)p1.message()p2.message()</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 我是武沛齐,年龄18,属于人事部&gt;&gt;&gt; 我是alex,年龄18,属于人事部</code></pre></li><li><p>分析代码关系，并写出正确的输出结果。</p><pre class="language-python" data-language="python"><code class="language-python">class Node(object):    def __init__(self, title):        self.title &#x3D; title        self.children &#x3D; []    def add(self, node):        self.children.append(node)    def __getitem__(self, item):        return self.children[item]root &#x3D; Node(&quot;中国&quot;)root.add(Node(&quot;河南省&quot;))root.add(Node(&quot;河北省&quot;))print(root.title)print(root[0])print(root[0].title)print(root[1])print(root[1].title)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 中国&gt;&gt;&gt; 河南省&gt;&gt;&gt; print(root[0].title)  # 报错河南省没有title&gt;&gt;&gt; 河北省&gt;&gt;&gt; print(root[1].title)  # 报错河北省没有title</code></pre><p><font color="#dd0000">存在问题</font>：</p><p><code>root.add(Node(&quot;河南省&quot;))</code>传入的是对象<code>Node(&quot;河南省&quot;)</code>而不是’河南省’字符串</p></li><li><p>分析代码关系，并写出正确的输出结果。</p><pre class="language-python" data-language="python"><code class="language-python">class Node(object):    def __init__(self, title):        self.title &#x3D; title        self.children &#x3D; []    def add(self, node):        self.children.append(node)    def __getitem__(self, item):        return self.children[item]root &#x3D; Node(&quot;中国&quot;)root.add(Node(&quot;河南省&quot;))root.add(Node(&quot;河北省&quot;))root.add(Node(&quot;陕西省&quot;))root.add(Node(&quot;山东省&quot;))root[1].add(Node(&quot;石家庄&quot;))root[1].add(Node(&quot;保定&quot;))root[1].add(Node(&quot;廊坊&quot;))root[3].add(Node(&quot;潍坊&quot;))root[3].add(Node(&quot;烟台&quot;))root[3].add(Node(&quot;威海&quot;))root[1][1].add(Node(&quot;雄安&quot;))root[1][1].add(Node(&quot;望都&quot;))print(root.title)print(root[0].title)print(root[1].title)print(root[1][0].title)print(root[1][2].title)print(root[1][1][0].title)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 中国&gt;&gt;&gt; 河南省&gt;&gt;&gt; 河北省&gt;&gt;&gt; 石家庄&gt;&gt;&gt; 廊坊&gt;&gt;&gt; 雄安</code></pre></li></ol><h2 id="二十、面向对象高级和应用"><a href="#二十、面向对象高级和应用" class="headerlink" title="二十、面向对象高级和应用"></a>二十、面向对象高级和应用</h2><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210129122824670.png" class=""><p>课程目标：掌握面向对象高级知识和相关应用。</p><p>今日概要</p><ul><li>继承【补充】：理解即可（个人开发中使用较少，面试可能涉及）</li><li>内置函数【补充】：重要（以后开发中经常使用）</li><li>异常处理：重要（以后开发中经常使用）</li><li>反射：重要（以后开发中经常使用）</li></ul><h3 id="1-继承【补充】"><a href="#1-继承【补充】" class="headerlink" title="1. 继承【补充】"></a>1. 继承【补充】</h3><p>对于Python面向对象中的继承，我们已学过：</p><ul><li><p>继承存在意义：将公共的方法提取到父类中，有利于增加代码重用性。</p></li><li><p>继承的编写方式：</p><pre class="language-python" data-language="python"><code class="language-python"># 继承class Base(object):    passclass Foo(Base):    pass</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 多继承class Base(object):    passclass Bar(object):    passclass Foo(Base,Bar):    pass</code></pre></li><li><p>调用类中的成员时，遵循：</p><ul><li>优先在自己所在类中找，没有的话则去父类中找。</li><li>如果类存在多继承（多个父类），则先找左边再找右边。</li></ul></li></ul><p>上述的知识点掌握之后，其实就可以解决继承相关的大部分问题。</p><p>但如果遇到一些特殊情况（不常见），你就可能不知道怎么搞了，例如：</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210129134949419.png" class=""><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210129140026593.png" class=""><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210129142756667.png" class=""><h4 id="1-1-mro和c3算法"><a href="#1-1-mro和c3算法" class="headerlink" title="1.1 mro和c3算法"></a>1.1 mro和c3算法</h4><p>如果类中存在继承关系，在可以通过<code>mro()</code>获取当前类的继承关系（找成员的顺序）。</p><p>示例1：</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210129134831112.png" class=""><pre class="language-python" data-language="python"><code class="language-python">mro(A) &#x3D; [A] + [B,C]mro(A) &#x3D; [A,B,C]</code></pre><pre class="language-python" data-language="python"><code class="language-python">mro(A) &#x3D; [A] + merge( mro(B), mro(C), [B,C] )mro(A) &#x3D; [A] + merge( [object], [object], [] )mro(A) &#x3D; [A] + [B,C,object]mro(A) &#x3D; [A,B,C,object]</code></pre><pre class="language-python" data-language="python"><code class="language-python">mro(A) &#x3D; [A] + merge( mro(B), mro(C), [B,C] )mro(A) &#x3D; [A] + merge( [], [C], [,C] mro(A) &#x3D; [A] + [B,C]</code></pre><pre class="language-python" data-language="python"><code class="language-python">class C(object):    passclass B(object):    passclass A(B, C):    passprint( A.mro() )   # [&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;object&#39;&gt;]print( A.__mro__ ) # (&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code></pre><p>示例2：</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210129134912674.png" class=""><pre class="language-python" data-language="python"><code class="language-python">mro(A) &#x3D; [A] + merge( mro(B), mro(C), [B,C] )mro(A) &#x3D; [A] + merge( [], [D], [] )mro(A) &#x3D; [A] + [B,C,D]mro(A) &#x3D; [A,B,C,D]</code></pre><pre class="language-python" data-language="python"><code class="language-python">class D(object):    passclass C(D):    passclass B(object):    passclass A(B, C):    passprint( A.mro() ) # [&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code></pre><p>示例3:</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210129134949419.png" class=""><pre class="language-python" data-language="python"><code class="language-python">mro(A) &#x3D; [A] + merge( mro(B),mro(C),[B,C])mro(A) &#x3D; [A] + merge( [], [C], [C])mro(A) &#x3D; [A,B,D,C]</code></pre><pre class="language-python" data-language="python"><code class="language-python">class D(object):    passclass C(object):    passclass B(D):    passclass A(B, C):    passprint(A.mro()) # [&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code></pre><p>示例4：</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210129140026593.png" class=""><pre class="language-python" data-language="python"><code class="language-python">mro(A) &#x3D; [A] + merge( mro(B), mro(C), [B,C])mro(A) &#x3D; [A] + merge( [B,D], [C,D], [B,C])mro(A) &#x3D; [A] + [B,C,D] mro(A) &#x3D; [A,B,C,D] </code></pre><pre class="language-python" data-language="python"><code class="language-python">class D(object):    passclass C(D):    passclass B(D):    passclass A(B, C):    passprint(A.mro()) # [&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code></pre><p>示例5：</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210129142756667.png" class=""><pre class="language-python" data-language="python"><code class="language-python">简写为：A -&gt; B -&gt; D -&gt; G -&gt; H -&gt; K -&gt; C -&gt; E -&gt; F -&gt; M -&gt; N -&gt; P -&gt; object</code></pre><pre class="language-none"><code class="language-none">mro(A) &#x3D; [A] + merge( mro(B),          mro(C),      mro(P),      [B,C,P])                  []   [N]     [P]          [P]mro(A) &#x3D; [A,B,D,G,H,K,C,E,F,M,N,P]-----------------------------------------------------mro(B) &#x3D; [B] + merge( mro(D), mro(E), [D,E])mro(D) &#x3D; [D] + merge(mro(G),mro(H), [G,H])mro(G) &#x3D; [G]mro(H) &#x3D; [H,K]mro(B) &#x3D; [B] + merge( [], [E,M], [E])mro(B) &#x3D; [B,D,G,H,K,E,M]-----------------------------------------------------mro(C) &#x3D; [C] + merge(mro(E),mro(F),[E,F])mro(E) &#x3D; [E,M]mro(F) &#x3D; [F,M,N] mro(C) &#x3D; [C] + merge([M],[M,N] ,[])mro(C) &#x3D; [C,E,F,M,N]</code></pre><pre class="language-python" data-language="python"><code class="language-python">class M:    passclass N:    passclass E(M):    passclass G:    passclass K:    passclass H(K):    passclass D(G, H):    passclass F(M, N):    passclass P:    passclass C(E, F):    passclass B(D, E):    passclass A(B, C, P):    passprint(A.mro()) # 简写为：A -&gt; B -&gt; D -&gt; G -&gt; H -&gt; K -&gt; C -&gt; E -&gt; F -&gt; M -&gt; N -&gt; P -&gt; object</code></pre><p><strong>特别补充：一句话搞定继承关系</strong></p><p>不知道你是否发现，如果用正经的C3算法规则去分析一个类继承关系有点繁琐，尤其是遇到一个复杂的类也要分析很久。</p><p>所以，我自己根据经验总结了一句话赠送给大家：<span style="color:red"><strong>从左到右，深度优先，大小钻石，留住顶端</strong></span>，基于这句话可以更快的找到继承关系。</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210129142756667.png" class=""><pre class="language-none"><code class="language-none">简写为：A -&gt; B -&gt; D -&gt; G -&gt; H -&gt; K -&gt; C -&gt; E -&gt; F -&gt; M -&gt; N -&gt; P -&gt; object</code></pre><h4 id="1-2-py2和py3区别（了解）"><a href="#1-2-py2和py3区别（了解）" class="headerlink" title="1.2 py2和py3区别（了解）"></a>1.2 py2和py3区别（了解）</h4><p>概述：</p><ul><li><p>在python2.2之前，只支持经典类【从左到右，深度优先，大小钻石，不留顶端】</p></li><li><p>后来，Python想让类默认继承object（其他语言的面向对象基本上也都是默认都继承object），此时发现原来的经典类不能直接集成这个功能，有Bug。</p></li><li><p>所以，Python决定不再原来的经典类上进行修改了，而是再创建一个新式类来支持这个功能。【从左到右，深度优先，大小钻石，留住顶端。】</p><ul><li><p>经典类，不继承object类型</p><pre class="language-python" data-language="python"><code class="language-python">class Foo:    pass</code></pre></li><li><p>新式类，直接或间接继承object</p><pre class="language-python" data-language="python"><code class="language-python">class Base(object):    passclass Foo(Base):    pass</code></pre></li></ul></li><li><p>这样，python2.2之后 中就出现了经典类和新式类共存。（正式支持是2.3）</p></li><li><p>最终，python3中丢弃经典类，只保留新式类。</p></li></ul><pre class="language-none"><code class="language-none">详细文档：https:&#x2F;&#x2F;www.python.org&#x2F;dev&#x2F;peps&#x2F;pep-0253&#x2F;#mro-method-resolution-order-the-lookup-ruleIn classic Python, the rule is given by the following recursive function, also known as the left-to-right depth-first rule.def classic_lookup(cls, name):    if cls.__dict__.has_key(name):        return cls.__dict__[name]    for base in cls.__bases__:        try:            return classic_lookup(base, name)        except AttributeError:            pass    raise AttributeError, name    The problem with this becomes apparent when we consider a &quot;diamond diagram&quot;:      class A:        ^ ^  def save(self): ...       &#x2F;   \      &#x2F;     \     &#x2F;       \    &#x2F;         \class B     class C:    ^         ^  def save(self): ...     \       &#x2F;      \     &#x2F;       \   &#x2F;        \ &#x2F;      class D      Arrows point from a subtype to its base type(s). This particular diagram means B and C derive from A, and D derives from B and C (and hence also, indirectly, from A).Assume that C overrides the method save(), which is defined in the base A. (C.save() probably calls A.save() and then saves some of its own state.) B and D don&#39;t override save(). When we invoke save() on a D instance, which method is called? According to the classic lookup rule, A.save() is called, ignoring C.save()!This is not good. It probably breaks C (its state doesn&#39;t get saved), defeating the whole purpose of inheriting from C in the first place.Why was this not a problem in classic Python? Diamond diagrams are rarely found in classic Python class hierarchies. Most class hierarchies use single inheritance, and multiple inheritance is usually confined to mix-in classes. In fact, the problem shown here is probably the reason why multiple inheritance is unpopular in classic Python.Why will this be a problem in the new system? The &#39;object&#39; type at the top of the type hierarchy defines a number of methods that can usefully be extended by subtypes, for example __getattr__().(Aside: in classic Python, the __getattr__() method is not really the implementation for the get-attribute operation; it is a hook that only gets invoked when an attribute cannot be found by normal means. This has often been cited as a shortcoming -- some class designs have a legitimate need for a __getattr__() method that gets called for all attribute references. But then of course this method has to be able to invoke the default implementation directly. The most natural way is to make the default implementation available as object.__getattr__(self, name).)Thus, a classic class hierarchy like this:class B     class C:    ^         ^  def __getattr__(self, name): ...     \       &#x2F;      \     &#x2F;       \   &#x2F;        \ &#x2F;      class D      will change into a diamond diagram under the new system:      object:        ^ ^  __getattr__()       &#x2F;   \      &#x2F;     \     &#x2F;       \    &#x2F;         \class B     class C:    ^         ^  def __getattr__(self, name): ...     \       &#x2F;      \     &#x2F;       \   &#x2F;        \ &#x2F;      class Dand while in the original diagram C.__getattr__() is invoked, under the new system with the classic lookup rule, object.__getattr__() would be invoked!Fortunately, there&#39;s a lookup rule that&#39;s better. It&#39;s a bit difficult to explain, but it does the right thing in the diamond diagram, and it is the same as the classic lookup rule when there are no diamonds in the inheritance graph (when it is a tree).</code></pre><p>总结：Python2和Python3在关于面向对象的区别。</p><ul><li><p>Py2：</p><ul><li><p>经典类，未继承object类型。【从左到右，深度优先，大小钻石，不留顶端】</p><pre class="language-python" data-language="python"><code class="language-python">class Foo:    pass</code></pre></li><li><p>新式类，直接获取间接继承object类型。【从左到右，深度优先，大小钻石，留住顶端 – C3算法】</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    pass</code></pre><p>  或</p>  <pre class="language-python" data-language="python"><code class="language-python">class Base(object):    passclass Foo(Base):    pass</code></pre></li></ul></li><li><p>Py3</p><ul><li><p>新式类，丢弃了经典类只保留了新式类。【从左到右，深度优先，大小钻石，留住顶端 – C3算法】</p><pre class="language-python" data-language="python"><code class="language-python">class Foo:    passclass Bar(object):    pass</code></pre></li></ul></li></ul><h3 id="2-内置函数补充"><a href="#2-内置函数补充" class="headerlink" title="2. 内置函数补充"></a>2. 内置函数补充</h3><p>本次要给讲解的内置函数共8个，他们都跟面向对象的知识相关。</p><ul><li><p>classmethod、staticmethod、property 。</p></li><li><p>callable，是否可在后面加括号执行。</p><ul><li><p>函数</p><pre class="language-python" data-language="python"><code class="language-python">def func():    passprint( callable(func) ) # True</code></pre></li><li><p>类</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    passprint( callable(Foo) ) # True</code></pre></li><li><p>类中具有<code>__call__</code>方法的对象</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):passobj &#x3D; Foo()print( callable(obj) ) # False</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __call__(self, *args, **kwargs):        pass    obj &#x3D; Foo()print( callable(obj) ) # True</code></pre></li></ul><p>所以当你以后在见到下面的情况时，首先就要想到handler可以是：函数、类、具有call方法的对象 这三种，到底具体是什么，需要根据代码的调用关系才能分析出来。</p><pre class="language-python" data-language="python"><code class="language-python">def do_something(handler):    handler()</code></pre></li><li><p>super，按照mro继承关系向上找成员。</p><pre class="language-python" data-language="python"><code class="language-python">class Top(object):    def message(self, num):        print(&quot;Top.message&quot;, num)        class Base(Top):    passclass Foo(Base):    def message(self, num):        print(&quot;Foo.message&quot;, num)        super().message(num + 100)obj &#x3D; Foo()obj.message(1)&gt;&gt;&gt; Foo.message 1&gt;&gt;&gt; Top.message 101</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Base(object):    def message(self, num):        print(&quot;Base.message&quot;, num)        super().message(1000)class Bar(object):    def message(self, num):        print(&quot;Bar.message&quot;, num)class Foo(Base, Bar):    passobj &#x3D; Foo()obj.message(1)&gt;&gt;&gt; Base.message 1&gt;&gt;&gt; Bar.message 1000</code></pre><p><strong>应用场景</strong></p><p>假设有一个类，他原来已实现了某些功能，但我们想在他的基础上再扩展点功能，重新写一遍？比较麻烦，此时可以用super。</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; dict() # &#123;&#125;info[&#39;name&#39;] &#x3D; &quot;武沛齐&quot;info[&quot;age&quot;] &#x3D; 18value &#x3D; info.get(&quot;age&quot;)print(value)</code></pre><pre class="language-python" data-language="python"><code class="language-python">class MyDict(dict):    def get(self, k):        print(&quot;自定义功能&quot;)        return super().get(k)info &#x3D; MyDict()info[&#39;name&#39;] &#x3D; &quot;武沛齐&quot; # __setitem__info[&quot;age&quot;] &#x3D; 18       # __setitem__print(info)value &#x3D; info.get(&quot;age&quot;)print(value)</code></pre><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210131150707551.png" class=""></li><li><p>type，获取一个对象的类型。</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;武沛齐&quot;result &#x3D; type(v1)print(result) # &lt;class &#39;str&#39;&gt;</code></pre><pre class="language-python" data-language="python"><code class="language-python">v2 &#x3D; &quot;武沛齐&quot;print( type(v2) &#x3D;&#x3D; str )  # Truev3 &#x3D; [11, 22, 33] # list(...)print( type(v3) &#x3D;&#x3D; list )  # True</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    passv4 &#x3D; Foo()print( type(v4) &#x3D;&#x3D; Foo )  # True</code></pre></li><li><p>isinstance，判断对象是否是某个类或其子类的实例。</p><pre class="language-python" data-language="python"><code class="language-python">class Top(object):    passclass Base(Top):    passclass Foo(Base):    passv1 &#x3D; Foo()print( isinstance(v1, Foo) )   # True，对象v1是Foo类的实例print( isinstance(v1, Base) )  # True，对象v1的Base子类的实例。print( isinstance(v1, Top) )   # True，对象v1的Top子类的实例。</code></pre><pre class="language-python" data-language="python"><code class="language-python">class Animal(object):    def run(self):        passclass Dog(Animal):    passclass Cat(Animal):    passdata_list &#x3D; [    &quot;alex&quot;,    Dog(),    Cat(),&quot;root&quot;]for item in data_list:    if type(item) &#x3D;&#x3D; Cat:        item.run()    elif type(item) &#x3D;&#x3D; Dog:        item.run()    else:        pass    for item in data_list:    if isinstance(item, Animal):        item.run()    else:        pass</code></pre></li><li><p>issubclass，判断类是否是某个类的子孙类。</p><pre class="language-python" data-language="python"><code class="language-python">class Top(object):    passclass Base(Top):    passclass Foo(Base):    passprint(issubclass(Foo, Base))  # Trueprint(issubclass(Foo, Top))   # True</code></pre></li></ul><h3 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3.异常处理"></a>3.异常处理</h3><p>在程序开发中如果遇到一些 <code>不可预知</code>的错误 或 你懒得做一些判断 时，可以选择用异常处理来做。</p><pre class="language-python" data-language="python"><code class="language-python">import requestswhile True:    url &#x3D; input(&quot;请输入要下载网页地址：&quot;)    res &#x3D; requests.get(url&#x3D;url)    with open(&#39;content.txt&#39;, mode&#x3D;&#39;wb&#39;) as f:        f.write(res.content)</code></pre><p>上述下载视频的代码在正常情况下可以运行，但如果遇到网络出问题，那么此时程序就会报错无法正常执行。</p><pre class="language-python" data-language="python"><code class="language-python">try:    res &#x3D; requests.get(url&#x3D;url)except Exception as e:    代码块，上述代码出异常待执行。print(&quot;结束&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">import requestswhile True:    url &#x3D; input(&quot;请输入要下载网页地址：&quot;)        try:        res &#x3D; requests.get(url&#x3D;url)    except Exception as e:        print(&quot;请求失败，原因：&#123;&#125;&quot;.format(str(e)))        continue            with open(&#39;content.txt&#39;, mode&#x3D;&#39;wb&#39;) as f:        f.write(res.content)</code></pre><pre class="language-python" data-language="python"><code class="language-python">num1 &#x3D; input(&quot;请输入数字：&quot;)num2 &#x3D; input(&quot;请输入数字：&quot;)try:    num1 &#x3D; int(num1)    num2 &#x3D; int(num2)    result &#x3D; num1 + num2    print(result)except Exception as e:    print(&quot;输入错误&quot;)</code></pre><p>以后常见的应用场景：</p><ul><li><p>调用微信的API实现微信消息的推送、微信支付等</p></li><li><p>支付宝支付、视频播放等</p></li><li><p>数据库 或 redis连接和操作</p></li><li><p>调用第三方的视频播放发的功能，由第三方的程序出问题导致的错误。</p></li></ul><p>异常处理的基本格式：</p><pre class="language-python" data-language="python"><code class="language-python">try:    # 逻辑代码except Exception as e:    # try中的代码如果有异常，则此代码块中的代码会执行。</code></pre><pre class="language-python" data-language="python"><code class="language-python">try:    # 逻辑代码except Exception as e:    # try中的代码如果有异常，则此代码块中的代码会执行。finally:    # try中的代码无论是否报错，finally中的代码都会执行，一般用于释放资源。print(&quot;end&quot;)&quot;&quot;&quot;try:    file_object &#x3D; open(&quot;xxx.log&quot;)    # ....except Exception as e:    # 异常处理finally:    file_object.close()  # try中没异常，最后执行finally关闭文件；try有异常，执行except中的逻辑，最后再执行finally关闭文件。&quot;&quot;&quot;    </code></pre><h4 id="3-1-异常细分"><a href="#3-1-异常细分" class="headerlink" title="3.1 异常细分"></a>3.1 异常细分</h4><pre class="language-python" data-language="python"><code class="language-python">import requestswhile True:    url &#x3D; input(&quot;请输入要下载网页地址：&quot;)        try:        res &#x3D; requests.get(url&#x3D;url)    except Exception as e:        print(&quot;请求失败，原因：&#123;&#125;&quot;.format(str(e)))        continue            with open(&#39;content.txt&#39;, mode&#x3D;&#39;wb&#39;) as f:        f.write(res.content)</code></pre><p>之前只是简单的捕获了异常，出现异常则统一提示信息即可。如果想要对异常进行更加细致的异常处理，则可以这样来做：</p><pre class="language-python" data-language="python"><code class="language-python">import requestsfrom requests import exceptionswhile True:    url &#x3D; input(&quot;请输入要下载网页地址：&quot;)    try:        res &#x3D; requests.get(url&#x3D;url)        print(res)        except exceptions.MissingSchema as e:        print(&quot;URL架构不存在&quot;)    except exceptions.InvalidSchema as e:        print(&quot;URL架构错误&quot;)    except exceptions.InvalidURL as e:        print(&quot;URL地址格式错误&quot;)    except exceptions.ConnectionError as e:        print(&quot;网络连接错误&quot;)    except Exception as e:        print(&quot;代码出现错误&quot;, e)        # 提示：如果想要写的简单一点，其实只写一个Exception捕获错误就可以了。</code></pre><p>如果想要对错误进行细分的处理，例如：发生Key错误和发生Value错误分开处理。</p><p>基本格式：</p><pre class="language-python" data-language="python"><code class="language-python">try:    # 逻辑代码    passexcept KeyError as e:    # 小兵，只捕获try代码中发现了键不存在的异常，例如：去字典 info_dict[&quot;n1&quot;] 中获取数据时，键不存在。    print(&quot;KeyError&quot;)except ValueError as e:    # 小兵，只捕获try代码中发现了值相关错误，例如：把字符串转整型 int(&quot;无诶器&quot;)    print(&quot;ValueError&quot;)except Exception as e:    # 王者，处理上面except捕获不了的错误（可以捕获所有的错误）。    print(&quot;Exception&quot;)</code></pre><p>Python中内置了很多细分的错误，供你选择。</p><pre class="language-python" data-language="python"><code class="language-python">常见异常：&quot;&quot;&quot;AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性xIOError 输入&#x2F;输出异常；基本上是无法打开文件ImportError 无法引入模块或包；基本上是路径问题或名称错误IndentationError 语法错误（的子类） ；代码没有正确对齐IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问n x[5]KeyError 试图访问字典里不存在的键 inf[&#39;xx&#39;]KeyboardInterrupt Ctrl+C被按下NameError 使用一个还未被赋予对象的变量SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）TypeError 传入对象类型与要求的不符合UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它ValueError 传入一个调用者不期望的值，即使值的类型是正确的&quot;&quot;&quot;更多异常：&quot;&quot;&quot;ArithmeticErrorAssertionErrorAttributeErrorBaseExceptionBufferErrorBytesWarningDeprecationWarningEnvironmentErrorEOFErrorExceptionFloatingPointErrorFutureWarningGeneratorExitImportErrorImportWarningIndentationErrorIndexErrorIOErrorKeyboardInterruptKeyErrorLookupErrorMemoryErrorNameErrorNotImplementedErrorOSErrorOverflowErrorPendingDeprecationWarningReferenceErrorRuntimeErrorRuntimeWarningStandardErrorStopIterationSyntaxErrorSyntaxWarningSystemErrorSystemExitTabErrorTypeErrorUnboundLocalErrorUnicodeDecodeErrorUnicodeEncodeErrorUnicodeErrorUnicodeTranslateErrorUnicodeWarningUserWarningValueErrorWarningZeroDivisionError&quot;&quot;&quot;</code></pre><h4 id="3-2-自定义异常-amp-抛出异常"><a href="#3-2-自定义异常-amp-抛出异常" class="headerlink" title="3.2 自定义异常&amp;抛出异常"></a>3.2 自定义异常&amp;抛出异常</h4><p>上面都是Python内置的异常，只有遇到特定的错误之后才会抛出相应的异常。</p><p>其实，在开发中也可以自定义异常。</p><pre class="language-python" data-language="python"><code class="language-python">class MyException(Exception):    pass</code></pre><pre class="language-python" data-language="python"><code class="language-python">try:    passexcept MyException as e:    print(&quot;MyException异常被触发了&quot;, e)except Exception as e:    print(&quot;Exception&quot;, e)</code></pre><p>上述代码在except中定义了捕获MyException异常，但他永远不会被触发。因为默认的那些异常都有特定的触发条件，例如：索引不存在、键不存在会触发IndexError和KeyError异常。</p><p>对于我们自定义的异常，如果想要触发，则需要使用：<code>raise MyException()</code>类实现。</p><pre class="language-python" data-language="python"><code class="language-python">class MyException(Exception):    passtry:    # 。。。    raise MyException()    # 。。。except MyException as e:    print(&quot;MyException异常被触发了&quot;, e)except Exception as e:    print(&quot;Exception&quot;, e)</code></pre><pre class="language-python" data-language="python"><code class="language-python">class MyException(Exception):    def __init__(self, msg, *args, **kwargs):        super().__init__(*args, **kwargs)        self.msg &#x3D; msgtry:    raise MyException(&quot;xxx失败了&quot;)except MyException as e:    print(&quot;MyException异常被触发了&quot;, e.msg)except Exception as e:    print(&quot;Exception&quot;, e)</code></pre><pre class="language-python" data-language="python"><code class="language-python">class MyException(Exception):    title &#x3D; &quot;请求错误&quot;try:    raise MyException()except MyException as e:    print(&quot;MyException异常被触发了&quot;, e.title)except Exception as e:    print(&quot;Exception&quot;, e)</code></pre><p><strong>案例一</strong>：你我合作协同开发，你调用我写的方法。</p><ul><li><p>我定义了一个函数</p><pre class="language-python" data-language="python"><code class="language-python">class EmailValidError(Exception):    title &#x3D; &quot;邮箱格式错误&quot;class ContentRequiredError(Exception):    title &#x3D; &quot;文本不能为空错误&quot;    def send_email(email,content):    if not re.match(&quot;\w+@live.com&quot;,email):        raise EmailValidError()if len(content) &#x3D;&#x3D; 0 :        raise ContentRequiredError()# 发送邮件代码...    # ...</code></pre></li><li><p>你调用我写的函数</p><pre class="language-python" data-language="python"><code class="language-python">def execute():    # 其他代码    # ...    try:        send_email(...)    except EmailValidError as e:        pass    except ContentRequiredError as e:        pass    except Exception as e:        print(&quot;发送失败&quot;)execute()# 提示：如果想要写的简单一点，其实只写一个Exception捕获错误就可以了。</code></pre></li></ul><p><strong>案例二</strong>：在框架内部已经定义好，遇到什么样的错误都会触发不同的异常。</p><pre class="language-python" data-language="python"><code class="language-python">import requestsfrom requests import exceptionswhile True:    url &#x3D; input(&quot;请输入要下载网页地址：&quot;)    try:        res &#x3D; requests.get(url&#x3D;url)        print(res)        except exceptions.MissingSchema as e:        print(&quot;URL架构不存在&quot;)    except exceptions.InvalidSchema as e:        print(&quot;URL架构错误&quot;)    except exceptions.InvalidURL as e:        print(&quot;URL地址格式错误&quot;)    except exceptions.ConnectionError as e:        print(&quot;网络连接错误&quot;)    except Exception as e:        print(&quot;代码出现错误&quot;, e)        # 提示：如果想要写的简单一点，其实只写一个Exception捕获错误就可以了。</code></pre><p><strong>案例三</strong>：按照规定去触发指定的异常，每种异常都具备被特殊的含义。</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210131231423064.png" class=""><h4 id="3-3-特殊的finally"><a href="#3-3-特殊的finally" class="headerlink" title="3.3 特殊的finally"></a>3.3 特殊的finally</h4><pre class="language-python" data-language="python"><code class="language-python">try:    # 逻辑代码except Exception as e:    # try中的代码如果有异常，则此代码块中的代码会执行。finally:    # try中的代码无论是否报错，finally中的代码都会执行，一般用于释放资源。print(&quot;end&quot;)</code></pre><p>当在函数或方法中定义异常处理的代码时，要特别注意finally和return。</p><pre class="language-python" data-language="python"><code class="language-python">def func():    try:        return 123    except Exception as e:        pass    finally:        print(666)        func()</code></pre><p>在try或except中即使定义了return，也会执行最后的finally块中的代码。</p><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><ol><li><p>补充代码实现捕获程序中的错误。</p><pre class="language-python" data-language="python"><code class="language-python"># 迭代器class IterRange(object):    def __init__(self, num):        self.num &#x3D; num        self.counter &#x3D; -1    def __iter__(self):        return self    def __next__(self):        self.counter +&#x3D; 1        if self.counter &#x3D;&#x3D; self.num:            raise StopIteration()        return self.counter    obj &#x3D; IterRange(20)while True:    try:    ele &#x3D; next(obj)except StopIteration as e:        print(&quot;数据获取完毕&quot;)        break    print(ele)    </code></pre></li><li><p>补充代码实现捕获程序中的错误。</p><pre class="language-python" data-language="python"><code class="language-python">class IterRange(object):    def __init__(self, num):        self.num &#x3D; num        self.counter &#x3D; -1    def __iter__(self):        return self    def __next__(self):        self.counter +&#x3D; 1        if self.counter &#x3D;&#x3D; self.num:            raise StopIteration()        return self.counterclass Xrange(object):    def __init__(self, max_num):        self.max_num &#x3D; max_num    def __iter__(self):        return IterRange(self.max_num)data_object &#x3D; Xrange(100)obj_iter &#x3D; data_object.__iter__()while True:    try:    ele &#x3D; next(obj_iter)except StopIteration as e:        print(&quot;数据获取完毕&quot;)        break    print(ele)</code></pre></li><li><p>补充代码实现捕获程序中的错误。</p><pre class="language-python" data-language="python"><code class="language-python">def func():    yield 1    yield 2    yield 3    gen &#x3D; func()while True:    try:    ele &#x3D; next(gen)except StopIteration as e:        print(&quot;数据获取完毕&quot;)        break    print(ele)</code></pre></li><li><p>补充代码实现捕获程序中的错误。（注意：本案例用于练习，在真是开发中对于这种情况建议还是自己做判断处理，不要用异常）</p><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; int(&quot;武沛齐&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">try:    num &#x3D; int(&quot;武沛齐&quot;)except ValueError as e:    print(&quot;转换失败&quot;)</code></pre></li><li><p>补充代码实现捕获程序中的错误。（注意：本案例用于练习，在真是开发中对于这种情况建议还是自己做判断处理，不要用异常）</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; [11,22,33,44,55]data[1000]</code></pre><pre class="language-python" data-language="python"><code class="language-python">try:    data &#x3D; [11,22,33,44,55]data[1000]except IndexError as e:    print(&quot;转换失败&quot;)</code></pre></li><li><p>补充代码实现捕获程序中的错误。（注意：本案例用于练习，在真是开发中对于这种情况建议还是自己做判断处理，不要用异常）</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &#123;&quot;k1&quot;:123,&quot;k2&quot;:456&#125;data[&quot;xxxx&quot;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">try:    data &#x3D; &#123;&quot;k1&quot;:123,&quot;k2&quot;:456&#125;data[&quot;xxxx&quot;]except KyeError as e:    print(&quot;转换失败&quot;)</code></pre></li><li><p>分析代码，写结果</p><pre class="language-python" data-language="python"><code class="language-python">class MyDict(dict):    def __getitem__(self, item):        try:            return super().__getitem__(item) # KeyError        except KeyError as e:            return Noneinfo &#x3D; MyDict()info[&#39;name&#39;] &#x3D; &quot;武沛齐&quot;info[&#39;wx&#39;] &#x3D; &quot;wupeiq666&quot;print(info[&#39;wx&#39;])     # info[&#39;wx&#39;]  -&gt; __getitem__print(info[&#39;email&#39;])  # info[&#39;email&#39;]  -&gt; __getitem__</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; wupeiq666&gt;&gt;&gt; None</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def run(handler):    try:        num &#x3D; handler()        print(num)        return &quot;成功&quot;    except Exception as e:        return &quot;错误&quot;    finally:        print(&quot;END&quot;)    print(&quot;结束&quot;)res &#x3D; run(lambda: 123) print(res)</code></pre><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 123&gt;&gt;&gt; END&gt;&gt;&gt; 成功</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func():    print(666)    return &quot;成功&quot;def run(handler):    try:        num &#x3D; handler()        print(num)        return func()    except Exception as e:        return &quot;错误&quot;    finally:        print(&quot;END&quot;)    print(&quot;结束&quot;)res &#x3D; run(lambda: 123) print(res)</code></pre><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 123&gt;&gt;&gt; 666&gt;&gt;&gt; END&gt;&gt;&gt; 成功</code></pre></li></ol><h3 id="4-反射"><a href="#4-反射" class="headerlink" title="4.反射"></a>4.反射</h3><p>反射，提供了一种更加灵活的方式让你可以实现去 对象 中操作成员（以字符串的形式去 <code>对象</code> 中进行成员的操作）。</p><pre class="language-python" data-language="python"><code class="language-python">class Person(object):        def __init__(self,name,wx):        self.name &#x3D; name        self.wx &#x3D; wx    def show(self):        message &#x3D; &quot;姓名&#123;&#125;，微信：&#123;&#125;&quot;.format(self.name,self.wx)                user_object &#x3D; Person(&quot;武沛齐&quot;,&quot;wupeiqi666&quot;)# 对象.成员 的格式去获取数据user_object.nameuser_object.wxuser_object.show()# 对象.成员 的格式无设置数据user_object.name &#x3D; &quot;吴培期&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">user &#x3D; Person(&quot;武沛齐&quot;,&quot;wupeiqi666&quot;)# getattr 获取成员getattr(user,&quot;name&quot;) # user.namegetattr(user,&quot;wx&quot;)   # user.wxmethod &#x3D; getattr(user,&quot;show&quot;) # user.showmethod()# 或getattr(user,&quot;show&quot;)()# setattr 设置成员setattr(user, &quot;name&quot;, &quot;吴培期&quot;) # user.name &#x3D; &quot;吴培期&quot;</code></pre><p>Python中提供了4个内置函数来支持反射：</p><ul><li><p>getattr</p><pre class="language-none"><code class="language-none">v1 &#x3D; getattr(对象,&quot;成员名称&quot;)v2 &#x3D; getattr(对象,&quot;成员名称&quot;, 不存在时的默认值)</code></pre></li><li><p>setattr，去对象中设置成员</p><pre class="language-none"><code class="language-none">setattr(对象,&quot;成员名称&quot;,值)</code></pre></li><li><p>hasattr，对象中是否包含成员</p><pre class="language-none"><code class="language-none">v1 &#x3D; hasattr(对象,&quot;成员名称&quot;) # True&#x2F;False</code></pre></li><li><p>delattr，删除对象中的成员</p><pre class="language-none"><code class="language-none">delattr(对象,&quot;成员名称&quot;)</code></pre></li></ul><p>以后如果再遇到 对象.成员 这种编写方式时，均可以基于反射来实现。</p><p>案例：</p><pre class="language-python" data-language="python"><code class="language-python">class Account(object):    def login(self):        pass    def register(self):        pass    def index(self):        pass    def run(self):    name &#x3D; input(&quot;请输入要执行的方法名称：&quot;) # index register login xx run ..        account_object &#x3D; Account()    method &#x3D; getattr(account_object, name) # index &#x3D; getattr(account_object,&quot;index&quot;)        if not method:        print(&quot;输入错误&quot;)        return     method()</code></pre><h4 id="4-1-一些皆对象"><a href="#4-1-一些皆对象" class="headerlink" title="4.1 一些皆对象"></a>4.1 一些皆对象</h4><p>在Python中有这么句话：<code>一切皆对象</code>。 每个对象的内部都有自己维护的成员。</p><ul><li><p>对象是对象</p><pre class="language-python" data-language="python"><code class="language-python">class Person(object):        def __init__(self,name,wx):        self.name &#x3D; name        self.wx &#x3D; wx    def show(self):        message &#x3D; &quot;姓名&#123;&#125;，微信：&#123;&#125;&quot;.format(self.name,self.wx)                user_object &#x3D; Person(&quot;武沛齐&quot;,&quot;wupeiqi666&quot;)user_object.name</code></pre></li><li><p>类是对象</p><pre class="language-python" data-language="python"><code class="language-python">class Person(object):    title &#x3D; &quot;武沛齐&quot;Person.title# Person类也是一个对象（平时不这么称呼）</code></pre></li><li><p>模块是对象</p><pre class="language-python" data-language="python"><code class="language-python">import rere.match# re模块也是一个对象（平时不这么称呼）。</code></pre></li></ul><p>由于反射支持以字符串的形式去对象中操作成员【等价于 对象.成员 】，所以，基于反射也可以对类、模块中的成员进行操作。</p><p>简单粗暴：只要看到 xx.oo 都可以用反射实现。</p><pre class="language-python" data-language="python"><code class="language-python">class Person(object):    title &#x3D; &quot;武沛齐&quot;v1 &#x3D; Person.titleprint(v1)v2 &#x3D; getattr(Person,&quot;title&quot;)print(v2)</code></pre><pre class="language-python" data-language="python"><code class="language-python">import rev1 &#x3D; re.match(&quot;\w+&quot;,&quot;dfjksdufjksd&quot;)print(v1)func &#x3D; getattr(re,&quot;match&quot;)v2 &#x3D; func(&quot;\w+&quot;,&quot;dfjksdufjksd&quot;)print(v2)</code></pre><h4 id="4-2-import-module-反射"><a href="#4-2-import-module-反射" class="headerlink" title="4.2 import_module + 反射"></a><font color="#dd0000">4.2 import_module + 反射</font></h4><p>在Python中如果想要导入一个模块，可以通过import语法导入；其实也可以通过字符串的形式导入。<font color="#dd0000"><strong>可提高代码的可扩展性。</strong></font></p><p>示例一：</p><pre class="language-python" data-language="python"><code class="language-python"># 导入模块import randomv1 &#x3D; random.randint(1,100)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 导入模块from importlib import import_modulem &#x3D; import_module(&quot;random&quot;)v1 &#x3D; m.randint(1,100)</code></pre><p>示例二：</p><pre class="language-python" data-language="python"><code class="language-python"># 导入模块exceptionsfrom requests import exceptions as m</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 导入模块exceptionsfrom importlib import import_modulem &#x3D; import_module(&quot;requests.exceptions&quot;)</code></pre><p>示例三：</p><pre class="language-python" data-language="python"><code class="language-python"># 导入模块exceptions，获取exceptions中的InvalidURL类。from requests.exceptions import InvalidURL</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 错误方式from importlib import import_modulem &#x3D; import_module(&quot;requests.exceptions.InvalidURL&quot;) # 报错，import_module只能导入到模块级别。</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 导入模块from importlib import import_modulem &#x3D; import_module(&quot;requests.exceptions&quot;)# 去模块中获取类cls &#x3D; m.InvalidURL</code></pre><p>在很多项目的源码中都会有 <code>import_module</code> 和 <code>getattr</code> 配合实现根据字符串的形式导入模块并获取成员，例如：</p><pre class="language-python" data-language="python"><code class="language-python">from importlib import import_modulepath &#x3D; &quot;openpyxl.utils.exceptions.InvalidFileException&quot;module_path,class_name &#x3D; path.rsplit(&quot;.&quot;,maxsplit&#x3D;1) # &quot;openpyxl.utils.exceptions&quot;   &quot;InvalidFileException&quot;module_object &#x3D; import_module(module_path)cls &#x3D; getattr(module_object,class_name)print(cls)</code></pre><p>我们在开发中也可以基于这个来进行开发，提高代码的可扩展性，例如：请在项目中实现一个发送 短信、微信 的功能。</p><p>参考示例代码中的：auto_message 项目。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol><li><p>了解 mro和c3算法</p></li><li><p>python2和python3在面向对象中的区别。</p></li><li><p>内置函数</p><pre class="language-none"><code class="language-none">staticmethod,classmethod,property,callable,type,isinstance,issubclass,supergetattr,setattr,hasattr,delattr</code></pre></li><li><p>异常处理</p></li><li><p>根据字符串的形式导入模块 <code>import_module</code></p></li><li><p>根据字符串的形式操作成员 <code>反射-getattr,setattr,hasattr,delattr</code></p></li></ol><h3 id="作业-2"><a href="#作业-2" class="headerlink" title="作业"></a>作业</h3><ol><li><p>super的作用？</p><p>答：super()可以调用上n层继承关系中的类的变量和方法</p><p><font color="#dd0000">存在问题：未掌握知识点</font></p><p>答案：按照类的mro继承关系，去上级查找相关成员。</p></li><li><p>看图分析类A的继承关系</p><img src="/2022/06/15/python-mo-kuai-san-day1/image-20210202180951900.png" class=""><p>答：A-&gt;B-&gt;C-&gt;M-&gt;D-&gt;F-&gt;J-&gt;G-&gt;H</p></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __init__(self, name, age):        self.name &#x3D; name        self.age &#x3D; age    @property    def message(self):        return &quot;&#123;&#125;-&#123;&#125;&quot;.format(self.name, self.age)class Bar(Foo):    def __init__(self, email, *args, **kwargs):        super().__init__(*args, **kwargs)        self.email &#x3D; email    def total(self):        data &#x3D; &quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;.format(self.name, self.age, self.email)        return dataobj1 &#x3D; Foo(&quot;武沛齐&quot;, 20)print(obj1.message)obj2 &#x3D; Bar(&quot;xx@live.com&quot;, &quot;root&quot;, 100)print(obj2.message)obj2.total()</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; 武沛齐-20&gt;&gt;&gt; root-100</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class Foo(object):    def __call__(self, *args, **kwargs):        return 666    data_list &#x3D; [    &quot;武沛齐&quot;,    dict,lambda :123,    True,    Foo,    Foo()]for item in data_list:    if callable(item):        val &#x3D; item()        print(val)else:        print(item)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; &quot;武沛齐&quot;&gt;&gt;&gt; &#123;&#125;&gt;&gt;&gt; 123&gt;&gt;&gt; True&gt;&gt;&gt; 对象 FOO()&gt;&gt;&gt; 666</code></pre></li><li><p>如何主动触发一个异常？</p><p>答：raise + 异常类（…）</p></li><li><p>反射的作用？</p><p>答：可以基于字符串操作加上xxxattr()等方法获取到指定模块以及内部的成员，增强代码的可拓展性。</p></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">class Person(object):    title &#x3D; &quot;北京&quot;    def __init__(self, name, wx):        self.name &#x3D; name        self.wx &#x3D; wx    def show(self):        message &#x3D; &quot;姓名&#123;&#125;，微信：&#123;&#125;&quot;.format(self.name, self.wx)        return message    @property    def message(self):        return 666    @staticmethod    def something():        return 999obj &#x3D; Person(&quot;武沛齐&quot;, &quot;wupeiqi666&quot;)print(getattr(obj, &#39;wx&#39;))print(getattr(obj, &#39;message&#39;))  # obj.messageprint(getattr(obj, &#39;show&#39;)())  # obj.show()print(getattr(obj, &#39;something&#39;)())  # obj.something()</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; wupeiqi666&gt;&gt;&gt; 666&gt;&gt;&gt; 姓名武沛齐，微信wupeiqi666&gt;&gt;&gt; 999</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 第三阶段 </tag>
            
            <tag> 面向对象&amp;网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一阶段重点</title>
      <link href="/2022/06/14/di-yi-jie-duan-chong-dian/"/>
      <url>/2022/06/14/di-yi-jie-duan-chong-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、python介绍"><a href="#一、python介绍" class="headerlink" title="一、python介绍"></a>一、python介绍</h2><h3 id="（一）编程语言的分类"><a href="#（一）编程语言的分类" class="headerlink" title="（一）编程语言的分类"></a>（一）编程语言的分类</h3><ul><li><p><code>翻译</code>的维度</p><ul><li>解释型语言</li><li>编译型语言</li></ul></li><li><p><code>高低</code>的维度</p><ul><li><p>低级语言：写出来的代码直接可以被计算机识别。</p><pre class="language-none"><code class="language-none">机器语言，101 001 00001 00010 001000100010001，机器码，交给计算机去执行。汇编语言，MOV INC ... ，指令，交给计算机去执行</code></pre></li><li><p>高级语言：写出来的代码无法直接被计算机识别，但可以通过某中方式将其转换为计算机可以识别的语言。</p><p>C、C++、Java、Python、Ruby…，这类编程语言在编写代码时几乎是写英语作文。</p></li></ul></li></ul><h3 id="（二）python介绍"><a href="#（二）python介绍" class="headerlink" title="（二）python介绍"></a>（二）python介绍</h3><ul><li>python的解释器种类<ul><li>Cpython：【主流】，底层是由C语言开发出来的Python解释器。</li><li>PyPy：是对CPython的优化，他的执行效率提高了。引入编译器的功能，本质上将Python代码进行编译，再去执行编译后的代码。</li><li>Jython：是由Java语言开发出来的Python解释器，方便与让Python和Java代码做集成。</li><li>IronPython：是基于C#语言开发出来的Python解释器，方便与让Python和C#代码做集成。</li><li>RubyPython</li><li>…</li></ul></li><li>Cpython的两大版本<ul><li>2.x</li><li>3.x</li></ul></li></ul><h2 id="二、运算符"><a href="#二、运算符" class="headerlink" title="二、运算符"></a>二、运算符</h2><h3 id="（一）运算符优先级"><a href="#（一）运算符优先级" class="headerlink" title="（一）运算符优先级"></a><font color="#dd0000"><strong>（一）运算符优先级</strong></font></h3><p>运算符的优先级有很多，常见的没几个，推荐你记住3个即可：</p><ul><li><p><font color="#dd0000"><strong>算数</strong></font>优先级优先级 <font color="#dd0000"><strong>大于</strong></font> <font color="#dd0000"><strong>比较</strong></font>运算符</p></li><li><p><font color="#dd0000"><strong>比较</strong></font>优先级优先级 <font color="#dd0000"><strong>大于</strong></font> <font color="#dd0000"><strong>逻辑</strong></font>运算符</p></li><li><p><font color="#dd0000"><strong>逻辑运算符内部</strong></font><font color="#dd0000"><strong>not &gt; and &gt;  or</strong></font></p></li></ul><p><strong>一般情况下逻辑运算符两边都为布尔值–返回布尔值</strong></p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; name &#x3D;&#x3D; &quot;alex&quot; and pwd &#x3D;&#x3D; &quot;123&quot;# v1 &#x3D; True and Falseif name &#x3D;&#x3D; &quot;alex&quot; and pwd &#x3D;&#x3D; &quot;123&quot;:  pass</code></pre><p><strong>当逻辑运算符两边不为布尔值时–直接取值</strong></p><pre class="language-python" data-language="python"><code class="language-python"># 当逻辑运算符两边不为布尔值时v2 &#x3D; &quot;wupeiqi&quot; and &quot;alex&quot;# 第一步：将and前后的只转换为布尔值 True and True# 第二步：判断本次操作取决于谁？由于前面的是True，所以本次逻辑判断取决于后面的值。# 所以，后面的值等于多少最终结果就是多少。 v2 &#x3D; &quot;alex&quot;v3 &#x3D; &quot;&quot; and &quot;alex&quot;# 第一步：将and前后的只转换为布尔值 False and True# 第二步：判断本次操作取悦于谁？由于前面的是False，所以本次逻辑判断取决于前面的值。# 所以，前面的只等于多少最终结果就是多少。 v2 &#x3D; &quot;&quot;v4 &#x3D; 1 or 8 # 第一步：将and前后的只转换为布尔值 True or True# 第二步：判断本次操作取悦于谁？由于前面的是True，所以本次逻辑判断取决于前面的值。# v4 &#x3D; 1v5 &#x3D; 0 or 8 # 第一步：将and前后的只转换为布尔值 False or True# 第二步：判断本次操作取悦于谁？由于前面的是False，所以本次逻辑判断取决于后面的值。# v5 &#x3D; 8</code></pre><h4 id="【面试题】运算符优先级"><a href="#【面试题】运算符优先级" class="headerlink" title="【面试题】运算符优先级"></a><font color="#dd0000"><strong>【面试题】运算符优先级</strong></font></h4><p>先计算not，在计算and，最后计算or.</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 0 or 4 and 3 or 7 or 9 and 6     0 or 3 or 7 or 9 and 6     0 or 3 or 7 or 6     3 or 7 or 6     3 or 6     3    v2 &#x3D; 8 or 3 and 4 or 2 and 0 or 9 and 7 8  v3 &#x3D; 0 or 2 and 3 and 4 or 6 and 0 or 3 4    v4 &#x3D; not 8 or 3 and 4 or 2 4</code></pre><h2 id="三、编码"><a href="#三、编码" class="headerlink" title="三、编码"></a>三、编码</h2><p>编码，文字和二进制之间的一个对照表。</p><ul><li><h2 id="ascii编码：规定使用1个字节来表示字母与二进制的对应关系。"><a href="#ascii编码：规定使用1个字节来表示字母与二进制的对应关系。" class="headerlink" title="ascii编码：规定使用1个字节来表示字母与二进制的对应关系。"></a>ascii编码：规定使用1个字节来表示字母与二进制的对应关系。</h2></li><li><p>gbk编码：gb-2312编码，由国家信息标准委员会制作（1980年）。gbk编码，对gb2312进行扩展，包含了中日韩等文字（1995年）。在与二进制做对应关系时，有如下逻辑：</p><ul><li>单字节表示，用一个字节表示对应关系（ASCII码的内容）。2**8 &#x3D; 256</li><li>双字节表示，用两个字节表示对应关系（汉字）。2**16 &#x3D; 65536种可能性。</li></ul></li><li><p>unicode编码：unicode（<a href="https://unicode-table.com/en/">对照表网址</a>）也被称为万国码，为全球的每个文字都分配了一个码位（二进制表示）。</p><ul><li>ucs2：用固定的2个字节去表示一个文字。</li><li>ucs4：用固定的4个字节去表示一个文字。</li><li>unicode的应用：在文件存储和网络传输时，不会直接使用unicode，而在<strong>内存中</strong>会unicode。</li></ul></li><li><p>utf-8编码：包含所有文字和二进制的对应关系，全球应用最为广泛的一种编码（站在巨人的肩膀上功成名就）。<strong>本质上：utf-8是对unicode的压缩</strong>，用尽量少的二进制去与文字进行对应。</p><p>具体压缩流程</p><ul><li><p>第一步：选择转换模板</p><pre class="language-none"><code class="language-none">  码位范围（十六进制）                转换模板   0000 ~ 007F              0XXXXXXX   0080 ~ 07FF              110XXXXX 10XXXXXX   0800 ~ FFFF              1110XXXX 10XXXXXX 10XXXXXX  10000 ~ 10FFFF            11110XXX 10XXXXXX 10XXXXXX 10XXXXXX    例如：      &quot;B&quot;  对应的unicode码位为 0042，那么他应该选择的一个模板。      &quot;ǣ&quot;  对应的unicode码位为 01E3，则应该选择第二个模板。      &quot;武&quot; 对应的unicode码位为 6B66，则应该选择第三个模板。      &quot;沛&quot; 对应的unicode码位为 6C9B，则应该选择第三个模板。      &quot;齐&quot; 对应的unicode码位为 9F50，则应该选择第三个模板。       😆  对应的unicode码位为 1F606，则应该选择第四个模板。            注意：一般中文都使用第三个模板（3个字节），这也就是平时大家说中文在utf-8中会占3个字节的原因了</code></pre></li><li><p>第二步：在模板中填入数据</p><pre class="language-none"><code class="language-none"># 文字  -&gt;  16进制编码号  -&gt;  二进制- &quot;武&quot;  -&gt;  6B66  -&gt;  110 101101 100110- 根据模板去套入数据1110XXXX 10XXXXXX 10XXXXXX1110XXXX 10XXXXXX 101001101110XXXX 10101101 1010011011100110 10101101 10100110在UTF-8编码中 ”武“  11100110 10101101 10100110</code></pre></li></ul></li></ul><h2 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h2><h3 id="（一）整型（int）"><a href="#（一）整型（int）" class="headerlink" title="（一）整型（int）"></a>（一）整型（int）</h3><p>整型其实就是十进制整数的统称，比如：1、68、999都属于整型。他一般用于表示 年龄、序号等。</p><h4 id="1-1-定义："><a href="#1-1-定义：" class="headerlink" title="1.1 定义："></a>1.1 定义：</h4><pre class="language-python" data-language="python"><code class="language-python">number &#x3D; 10age &#x3D; 99</code></pre><h4 id="1-2-独有功能："><a href="#1-2-独有功能：" class="headerlink" title="1.2 独有功能："></a>1.2 独有功能：</h4><pre class="language-python" data-language="python"><code class="language-python">int.bit_lenth()  #获取v1的二进制有多少个位组成。</code></pre><h4 id="1-3-公共功能：加减乘除"><a href="#1-3-公共功能：加减乘除" class="headerlink" title="1.3 公共功能：加减乘除"></a>1.3 公共功能：加减乘除</h4><h4 id="1-4-转换："><a href="#1-4-转换：" class="headerlink" title="1.4 转换："></a>1.4 转换：</h4><pre class="language-python" data-language="python"><code class="language-python"># int 转 其它bool(0)  # 转布尔str(1)  # 转字符串# 字符串 转 intint(&#39;12&#39;, base&#x3D;10)  # 将字符串转为10进制整数，10为默认值可以不传int(&#39;12&#39;, base&#x3D;2)  # 将字符串转为2进制整数int(&#39;12&#39;, base&#x3D;8)  # 将字符串转为8进制整数int(&#39;12&#39;, base&#x3D;16)  # 将字符串转为16进制整数</code></pre><h3 id="（二）布尔（bool）"><a href="#（二）布尔（bool）" class="headerlink" title="（二）布尔（bool）"></a>（二）布尔（bool）</h3><p>布尔值，其实就是 “真”、“假” 。</p><h4 id="2-1-定义："><a href="#2-1-定义：" class="headerlink" title="2.1 定义："></a>2.1 定义：</h4><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; Falsealex_is_sb &#x3D; True</code></pre><h4 id="2-2-独有功能："><a href="#2-2-独有功能：" class="headerlink" title="2.2 独有功能："></a>2.2 独有功能：</h4><p>无</p><h4 id="2-3-公共功能：加减乘除"><a href="#2-3-公共功能：加减乘除" class="headerlink" title="2.3 公共功能：加减乘除"></a>2.3 公共功能：加减乘除</h4><pre class="language-python" data-language="python"><code class="language-python">print(True + True)  # 2print(True - False)  # 1print(True * True)  # 1print(False &#x2F; True)  # 0.0</code></pre><h4 id="2-4-转换："><a href="#2-4-转换：" class="headerlink" title="2.4 转换："></a>2.4 转换：</h4><blockquote><p>整数0、空字符串、空列表、空元组、空集合、空字典、None转换为布尔值时均为False<br>其他均为True</p></blockquote><h4 id="2-5-其它："><a href="#2-5-其它：" class="headerlink" title="2.5 其它："></a>2.5 其它：</h4><p>如果在 <code>if</code> 、<code>while</code> 条件后面写一个值当做条件时，他会默认转换为布尔类型，然后再做条件判断。</p><h3 id="（三）字符串（str）"><a href="#（三）字符串（str）" class="headerlink" title="（三）字符串（str）"></a>（三）字符串（str）</h3><p>字符串，我们平时会用他来表示文本信息。例如：姓名、地址、自我介绍等。</p><h4 id="3-1-定义："><a href="#3-1-定义：" class="headerlink" title="3.1 定义："></a>3.1 定义：</h4><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;包治百病&quot;v2 &#x3D; &#39;包&quot;治百病&#39;v3 &#x3D; &quot;&quot;&quot;吵架都是我的错，因为大家打不过。&quot;&quot;&quot;</code></pre><h4 id="3-2-独有功能（48）："><a href="#3-2-独有功能（48）：" class="headerlink" title="3.2 独有功能（48）："></a>3.2 独有功能（48）：</h4><ol><li><p><code>str.startswith() </code>判断字符串是否以 XX 开头？得到一个布尔值</p></li><li><p><code>str.endswith() </code>判断字符串是否以 XX 结尾？得到一个布尔值</p></li><li><p><code>str.isdecimal() </code>判断字符串是否为十进制数？得到一个布尔值</p><blockquote><p> 为什么不用isdigit()</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;123&quot;print(v1.isdecimal()) # Truev2 &#x3D; &quot;①&quot;print(v2.isdecimal()) # Falsev3 &#x3D; &quot;123&quot;print(v3.isdigit()) # Truev4 &#x3D; &quot;①&quot;print(v4.isdigit()) # True</code></pre></li><li><p><code>str.strip() </code></p><ul><li>默认情况：去除字符串两边的 空格、换行符、制表符，得到一个新字符串</li><li>传入字符串作为参数：去除字符串<strong>两边</strong>指定的内容</li><li><code>str.lstrip()</code>：去除字符串<strong>左边</strong>指定的内容</li><li><code>str.rstrip()</code>：去除字符串<strong>右边</strong>指定的内容</li></ul></li><li><p><code>str.upper()</code> 字符串变大写，得到一个新字符串</p></li><li><p><code>str.lower() </code>字符串变小写，得到一个新字符串</p></li><li><p><code>str.replace() </code>字符串内容替换，得到一个新的字符串</p></li><li><p><code>str.split() </code>字符串切割，得到一个列表</p><ul><li><p><code>str.split(&#39;分隔符&#39;, n )</code> 只切遇到的前第n个</p></li><li><p><code>str.rsplit(&#39;分隔符&#39;, n ) </code>从右向左切</p><pre class="language-python" data-language="python"><code class="language-python">file_path &#x3D; &quot;xxx&#x2F;xxxx&#x2F;xx.xx&#x2F;xxx.mp4&quot;data_list &#x3D; file_path.rsplit(&quot;.&quot;,1) # [&quot;xxx&#x2F;xxxx&#x2F;xx.xx&#x2F;xxx&quot;,&quot;mp4&quot;]data_list[1]  # 路径拓展名</code></pre></li></ul></li><li><p><code>str.join()</code> 字符串拼接，得到一个新的字符串</p></li><li><p><code>str.format() </code>格式化字符串，得到新的字符串</p></li><li><p><code>str.encode() </code>字符串转换为字节类型</p><p><code>str.decode() </code>字节类型转换为字符串</p></li><li><p><code>str.center() str.ljust() str.rjust()</code>将字符串内容居中、居左、居右展示</p></li><li><p><code>str.zfill() </code>帮助你填充0</p></li></ol><h4 id="3-3-公共功能："><a href="#3-3-公共功能：" class="headerlink" title="3.3 公共功能："></a>3.3 公共功能：</h4><ul><li>相加：字符串+字符串</li><li>相乘：字符串*int</li><li>包含运算：in</li><li>求长度：len</li><li>索引、切片、步长</li><li>循环</li></ul><h4 id="3-4-转换："><a href="#3-4-转换：" class="headerlink" title="3.4 转换："></a>3.4 转换：</h4><p> 一般情况下，只有整型转字符串才有意义。</p><h4 id="3-5-其它："><a href="#3-5-其它：" class="headerlink" title="3.5 其它："></a>3.5 其它：</h4><p>字符串属于<strong>不可变</strong>类型</p><h3 id="（四）列表（list）"><a href="#（四）列表（list）" class="headerlink" title="（四）列表（list）"></a>（四）列表（list）</h3><p>列表（list），是一个<strong>有序</strong>且<strong>可变</strong>的<strong>容器</strong>，在里面可以存放<strong>多个不同类型</strong>的元素。</p><h4 id="4-1-定义："><a href="#4-1-定义：" class="headerlink" title="4.1 定义："></a>4.1 定义：</h4><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; []user_list.append(&quot;铁锤&quot;)  # 可变user_list.append(True)  # 可变print(user_list) # [&quot;铁锤&quot;,123,True] 有序、可存放多种数据类型</code></pre><h4 id="4-2-独有功能"><a href="#4-2-独有功能" class="headerlink" title="4.2 独有功能"></a>4.2 独有功能</h4><ul><li><p><code>list.append()</code> 追加，在原列表中<strong>尾部追加</strong>值。</p></li><li><p><code>list.extend()</code> 批量追加，将一个<strong>列表中的元素逐一添加另外一个列表</strong>。</p></li><li><p><code>list.insert()</code> 插入，在原列表的指定索引位置插入值</p></li><li><p><code>list.remove()</code>在原列表中根据值删除（从左到右找到第一个删除）【慎用，里面没有会报错】</p></li><li><p><code>list.pop()</code>在原列表中根据索引踢出某个元素（根据索引位置删除）</p></li><li><p><code>list.clear()</code>清空原列表</p></li><li><p><code>list.reverse</code>反转原列表</p></li></ul><h4 id="4-3-公共功能"><a href="#4-3-公共功能" class="headerlink" title="4.3 公共功能"></a>4.3 公共功能</h4><ul><li>相加：两个列表相加获取生成一个新的列表。</li><li>相乘：列表*整型 将列表中的元素再创建N份并生成一个新的列表。</li><li>包含运算：in</li><li>获取长度：len()</li><li>索引、切片、步长</li><li>for循环</li></ul><p>【面试题】 循环的过程中对数据进行删除</p><pre class="language-python" data-language="python"><code class="language-python"># 错误方式， 有坑，结果不是你想要的。user_list &#x3D; [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &#39;刘尼古拉斯赵四&#39;, &quot;宋小宝&quot;, &quot;刘能&quot;]for item in user_list:    if item.startswith(&quot;刘&quot;):        user_list.remove(item)        print(user_list)# 正确方式，倒着删除user_list &#x3D; [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &#39;刘尼古拉斯赵四&#39;, &quot;宋小宝&quot;, &quot;刘能&quot;]for index in range(len(user_list) - 1, -1, -1):    item &#x3D; user_list[index]    if item.startswith(&quot;刘&quot;):        user_list.remove(item)        print(user_list)# 实现原理：倒着取无论删不删后面的数据，都不会改变前面索引的顺序# [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &#39;刘尼古拉斯赵四&#39;, &quot;宋小宝&quot;, &quot;刘能&quot;]# 5 &quot;刘能&quot; [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &#39;刘尼古拉斯赵四&#39;, &quot;宋小宝&quot;]# 4 &quot;宋小宝&quot; [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &#39;刘尼古拉斯赵四&#39;, &quot;宋小宝&quot;]# 3 &#39;刘尼古拉斯赵四&#39; [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &quot;宋小宝&quot;]# 2 &quot;刘华强&quot; [&quot;刘的话&quot;, &quot;范德彪&quot;,&quot;宋小宝&quot;]# 1 &quot;范德彪&quot; [&quot;刘的话&quot;, &quot;范德彪&quot;,&quot;宋小宝&quot;]# 0 &quot;刘的话&quot; [&quot;范德彪&quot;,&quot;宋小宝&quot;]</code></pre><h4 id="4-4-转换"><a href="#4-4-转换" class="headerlink" title="4.4 转换"></a>4.4 转换</h4><ul><li>int、bool无法转换成列表</li><li>str、tuple可以转换成列表</li></ul><h4 id="4-5-其它"><a href="#4-5-其它" class="headerlink" title="4.5 其它"></a>4.5 其它</h4><ul><li>嵌套：列表属于容器，内部可以存放各种数据，所以他也支持列表的嵌套，对于嵌套的值，可以根据之前学习的索引知识点来进行学习</li></ul><h3 id="（五）元组（tuple）"><a href="#（五）元组（tuple）" class="headerlink" title="（五）元组（tuple）"></a>（五）元组（tuple）</h3><p>元组（tuple），是一个<strong>有序</strong>且<strong>不可变</strong>的容器，在里面可以存放<strong>多个不同类型</strong>的元素。如何体现不可变呢？记住一句话：<font color="#dd0000"><strong>《”我儿子永远不能换成是别人，但我儿子可以长大”》</strong></font></p><pre class="language-python" data-language="python"><code class="language-python"># 元组是不可变的，但元组的元素中嵌套有可变的数据类型时，元组中该元素内部可以改变v1 &#x3D; (True,123,&quot;Alex&quot;,[11,22,33,44])data &#x3D; v1[-1]data.append(3)print(v1)  # (True, 123, &#39;Alex&#39;, [11, 22, 33, 44, 3])</code></pre><h4 id="5-1-定义："><a href="#5-1-定义：" class="headerlink" title="5.1 定义："></a>5.1 定义：</h4><p><strong>议在元组的最后多加一个逗v1 &#x3D; (“李杰”,”Alex”,)，用于标识他是一个元组。当元组只有一个元素时，元组的符号不会被当成运算符中的括号</strong></p><pre class="language-python" data-language="python"><code class="language-python">d1 &#x3D; (1)  # int 1d2 &#x3D; (1,) # tuple (1,)</code></pre><p>【面试题】 元组定义</p><pre class="language-python" data-language="python"><code class="language-python">1. 比较值 v1 &#x3D; (1) 和 v2 &#x3D; 1 和 v3 &#x3D; (1,) 有什么区别？2. 比较值 v1 &#x3D; ( (1),(2),(3) ) 和 v2 &#x3D; ( (1,) , (2,) , (3,),) 有什么区别？              (1,2,3)</code></pre><h4 id="5-2-独有功能："><a href="#5-2-独有功能：" class="headerlink" title="5.2 独有功能："></a>5.2 独有功能：</h4><p>无</p><h4 id="5-3-公共功能："><a href="#5-3-公共功能：" class="headerlink" title="5.3 公共功能："></a>5.3 公共功能：</h4><ul><li>相加：两个元组相加获取生成一个新的元组。</li><li>相乘，元组*整型 将元组中的元素再创建N份并生成一个新的元组。</li><li>成员运算：in</li><li>获取长度：len()</li><li>索引、切片、步长</li><li>for循环</li></ul><h4 id="5-4-转换："><a href="#5-4-转换：" class="headerlink" title="5.4 转换："></a>5.4 转换：</h4><p>其他类型转换为元组，使用<code>tuple(其他类型)</code>，目前只有字符串和列表可以转换为元组。</p><h4 id="5-5-嵌套"><a href="#5-5-嵌套" class="headerlink" title="5.5 嵌套"></a>5.5 嵌套</h4><p>由于元组和列表都可以充当<code>容器</code>，他们内部可以放很多元素，并且也支持元素内的各种嵌套。</p><h3 id="（六）集合（set）"><a href="#（六）集合（set）" class="headerlink" title="（六）集合（set）"></a>（六）集合（set）</h3><p>集合是一个 <strong>无序 、可变、不允许数据重复</strong>的<strong>容器</strong>。</p><p>一般什么时候用集合呢？ 就是想要维护一大堆不重复的数据时，就可以用它。比如：做爬虫去网上找图片的链接，为了避免链接重复，可以选择用集合去存储链接地址。</p><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#123; 11, 22, 33, &quot;alex&quot; &#125;</code></pre><p><strong>注意：定义空集合时，只能使用<code>v = set()</code>，不能使用 <code>v=&#123;&#125;</code>（这样是定义一个空字典）。</strong></p><h4 id="6-2-独有功能"><a href="#6-2-独有功能" class="headerlink" title="6.2 独有功能"></a>6.2 独有功能</h4><ul><li><code>set.add() </code>添加元素</li><li><code>set.discard()</code> 删除元素</li><li><code>set.intersection()</code> 交集</li><li><code>set.union ()</code>并集</li><li><code>set.difference()</code> 补集</li></ul><h4 id="6-3-公共功能"><a href="#6-3-公共功能" class="headerlink" title="6.3 公共功能"></a>6.3 公共功能</h4><ul><li>计算补集：-</li><li>计算交集：&amp;</li><li>计算并集：|</li><li>计算长度：len()</li><li>for 循环</li></ul><h4 id="6-4-转化"><a href="#6-4-转化" class="headerlink" title="6.4 转化"></a>6.4 转化</h4><p> <strong>int&#x2F;list&#x2F;tuple&#x2F;dict都可以转换为集合</strong>其他类型如果想要转换为集合类型，可以通过set()进行转换，并且<strong>如果数据有重复自动剔除。</strong></p><p><strong>提示：这其实也是去重的一个手段。</strong></p><h4 id="6-5-其它"><a href="#6-5-其它" class="headerlink" title="6.5 其它"></a>6.5 其它</h4><ul><li><strong>集合的内部存储原理</strong></li></ul><img src="第一阶段重点/image-20201120193837492.png" alt="image-20201120193837492" style="zoom:50%;" /><ul><li><p><strong>元素必须可哈希</strong></p><p>因存储原理，集合的元素必须是可哈希的值，即：内部通过哈希函数把值转换成一个数字。</p><img src="第一阶段重点/image-20201120190454120.png" alt="image-20201120190454120" style="zoom: 25%;" /><p><font color="#dd0000"><strong>目前可哈希的数据类型：int、bool、str、tuple，而list、set是不可哈希的，因此集合的元素只能是 int、bool、str、tuple 。</strong></font></p></li><li><p><strong>查找速度特别快</strong></p><p>因存储原理特殊，集合的查找效率非常高（数据量大了才明显）。</p></li><li><p><strong>容器比较</strong></p><table><thead><tr><th align="left">是否可变</th><th align="left">类型</th><th align="left">是否有序</th><th align="left">元素要求</th><th align="left">是否可哈希</th><th align="left">转换</th><th align="left">定义空</th></tr></thead><tbody><tr><td align="left">是</td><td align="left">list</td><td align="left">是</td><td align="left">无</td><td align="left">否</td><td align="left">list(其他)</td><td align="left"><code>v=[]或v=list()</code></td></tr><tr><td align="left">否</td><td align="left">tuple</td><td align="left">是</td><td align="left">无</td><td align="left">是</td><td align="left">tuple(其他)</td><td align="left"><code>v=()或v=tuple()</code></td></tr><tr><td align="left">是</td><td align="left">set</td><td align="left">否</td><td align="left">可哈希</td><td align="left">否</td><td align="left">set(其他)</td><td align="left"><code>v=set()</code></td></tr></tbody></table><p><font color="#dd0000"><strong>注意：集合中的所有元素，包括元素里的子子孙孙都必须是可哈希的</strong></font></p></li></ul><h2 id="（七）字典（dict）"><a href="#（七）字典（dict）" class="headerlink" title="（七）字典（dict）"></a>（七）字典（dict）</h2><p>字典是 <strong>无序</strong>、<strong>键不重复</strong> 且 元素只能是<strong>键值对</strong>的<strong>可变的</strong> <strong>容器</strong>。</p><h3 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a>7.1 定义</h3><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#123;&#125;v2 &#x3D; dict()info &#x3D; &#123;     &quot;age&quot;:12,     &quot;status&quot;:True,      &quot;name&quot;:&quot;wupeiqi&quot;,       &quot;hobby&quot;:[&#39;篮球&#39;,&#39;足球&#39;]  &#125;</code></pre><p><font color="#dd0000"><strong>字典中对键值得要求：</strong></font></p><ul><li><p><strong>键：必须可哈希。</strong> 目前为止学到的可哈希的类型：<strong>int&#x2F;bool&#x2F;str&#x2F;tuple；</strong>不可哈希的类型：<strong>list&#x2F;set&#x2F;dict。</strong>（集合）</p></li><li><p><strong>值：任意类型。</strong></p></li></ul><h3 id="7-2-独有功能"><a href="#7-2-独有功能" class="headerlink" title="7.2 独有功能"></a>7.2 独有功能</h3><ul><li><p><code>dict.get(, 返回值)</code>获取值，键不存在，默认返回 None</p></li><li><p><code>dict.keys()</code>所有的键</p></li><li><p><code>dict.values()</code>所有的值</p></li><li><p><code>dict.items()</code>所有的键值， 伪列表dict_items， 元素为元组(k1, v1) …</p></li><li><p><code>dict.setdefault(k, v)</code>没有k则创建k，v  有k则保持原有k , v</p></li><li><p><code>dict.update(&#123;k: v&#125;)</code>更新字典键值对, 没有k则创建k，v  ,有k则更新k, v</p></li><li><p><code>dict.pop(k)</code>移除指定键值对 返回值为v</p></li><li><p><code>dict.popitem()</code>按照顺序移除（后进先出）</p><ul><li>py3.6后，popitem移除最后的值。</li><li>py3.6之前，popitem随机删除。</li></ul></li></ul><h3 id="7-3-公共功能"><a href="#7-3-公共功能" class="headerlink" title="7.3 公共功能"></a>7.3 公共功能</h3><ul><li>求<code>并集</code>：|（Python3.9新加入）</li><li>成员运算：in</li><li>计算长度：len()</li><li>索引：通过k</li><li>for 循环</li></ul><h3 id="7-4-转换"><a href="#7-4-转换" class="headerlink" title="7.4 转换"></a>7.4 转换</h3><pre class="language-python" data-language="python"><code class="language-python">v &#x3D; dict( [ (&quot;k1&quot;, &quot;v1&quot;), [&quot;k2&quot;, &quot;v2&quot;] ] )print(v) # &#123; &quot;k1&quot;:&quot;v1&quot;, &quot;k2&quot;:&quot;v2&quot; &#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123; &quot;age&quot;:12, &quot;status&quot;:True, &quot;name&quot;:&quot;武沛齐&quot; &#125;v1 &#x3D; list(info)        # [&quot;age&quot;,&quot;status&quot;,&quot;name&quot;]v2 &#x3D; list(info.keys()) # [&quot;age&quot;,&quot;status&quot;,&quot;name&quot;]v3 &#x3D; list(info.values()) # [12,True,&quot;武沛齐&quot;]v4 &#x3D; list(info.items()) # [ (&quot;age&quot;,12), (&quot;status&quot;,True), (&quot;name&quot;,&quot;武沛齐&quot;) ]</code></pre><h3 id="7-5-其它"><a href="#7-5-其它" class="headerlink" title="7.5 其它"></a>7.5 其它</h3><ul><li><p>存储原理</p><img src="/2022/06/14/di-yi-jie-duan-chong-dian/image-20201121131221807.png" class="" title="img"></li><li><p>速度快</p></li><li><p>嵌套</p><ul><li><strong>字典的键必须可哈希，且它的子子孙孙都必须是可哈希的。（list&#x2F;set&#x2F;dict不可哈希）。</strong></li><li>字典的值可以是任意类型。</li><li>字典的键和集合的元素在遇到 布尔值 和 1、0 时，需注意重复的情况。</li><li>元组的元素不可以被替换</li></ul></li></ul><h3 id="（八）None"><a href="#（八）None" class="headerlink" title="（八）None"></a>（八）None</h3><p>Python的数据类型中有一个特殊的值None，意味着这个值啥都不是 或 表示空。 相当于其他语言中 <code>null</code>作用一样。</p><p>在一定程度上可以帮助我们去节省内存。例如：</p><pre class="language-python" data-language="python"><code class="language-python"># v1, v2指向同一块idv1 &#x3D; None  v2 &#x3D; None# v3, v4指向不同的idv3 &#x3D; []v4 &#x3D; []</code></pre><h3 id="（九）浮点型（float）"><a href="#（九）浮点型（float）" class="headerlink" title="（九）浮点型（float）"></a>（九）浮点型（float）</h3><p>浮点型，一般在开发中用于表示小数。</p><ul><li><p>在类型转换时需要，在浮点型转换为整型时，会将小数部分去掉。</p></li><li><p>想要四舍五入保留小数点后N位：round()</p></li><li><p>浮点型的坑（所有语言中）</p><img src="第一阶段重点/image-20220614211602382.png" alt="image-20220614211602382" style="zoom:25%;" /></li></ul><p>底层原理视频：<a href="https://www.bilibili.com/video/BV1354y1B7o1/">https://www.bilibili.com/video/BV1354y1B7o1/</a></p><ul><li>在项目中如果遇到精确的小数计算应该怎么办？</li></ul><pre class="language-python" data-language="python"><code class="language-python">import decimalv1 &#x3D; decimal.Decimal(&quot;0.1&quot;)v2 &#x3D; decimal.Decimal(&quot;0.2&quot;)v3 &#x3D; v1 + v2print(v3) # 0.3</code></pre>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 第一阶段 </tag>
            
            <tag> python基础 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二阶段重点</title>
      <link href="/2022/06/13/di-er-jie-duan-chong-dian/"/>
      <url>/2022/06/13/di-er-jie-duan-chong-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、文件操作相关"><a href="#一、文件操作相关" class="headerlink" title="一、文件操作相关"></a>一、文件操作相关</h2><p>​本部分内容对常见的文件类型相关操作进行简单介绍，主要包括以下文件的读写操作。</p><ul><li><p>普通文本和二进制文件</p></li><li><p>csv 格式文件</p></li><li><p>ini 格式文件</p></li><li><p>XML 格式文件</p></li><li><p>Excel 格式文件</p></li><li><p>文件的压缩和解压</p></li><li><p>路径相关</p></li></ul><h3 id="（一）读文件"><a href="#（一）读文件" class="headerlink" title="（一）读文件"></a>（一）读文件</h3><pre class="language-python" data-language="python"><code class="language-python">file_path &#x3D; r&#39;C:\Users\Geng\Desktop\我在b站学编程\python\模块二\0考试\pear\db\video.csv&#39;# 读所有数据with open(file_path, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as file_object:    # with open(file_path, mode&#x3D;&#39;rb&#39;) as file_object:  读取字节数据    data &#x3D; file_object.read()    print(data)# 一行一行读with open(file_path, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as file_object:    for line in file_object:        print(line)# 只有一行时，按字节读import osfile_size &#x3D; os.path.getsize(file_path) # 获取总字节长度with open(file_path, mode&#x3D;&#39;rb&#39;) as file_object:  # 只能一字节类型打开    read_byte &#x3D; 0    while read_byte &lt;&#x3D; file_size:        data &#x3D; file_object.read(1)        read_byte +&#x3D; 1        print(data)</code></pre><h3 id="（二）文件打开模式-常用"><a href="#（二）文件打开模式-常用" class="headerlink" title="（二）文件打开模式-常用"></a>（二）文件打开模式-常用</h3><ul><li><p>只读：<code>r</code>&#x3D;&#x3D;<code>rt</code>（读文本）、<code>rb</code> （读二进制）</p><ul><li>存在，读</li><li>不存在，报错</li></ul></li><li><p>只写：<code>w</code>&#x3D;&#x3D;<code>wt</code>、<code>wb</code></p><ul><li>存在，清空再写</li><li>不存在，创建再写</li></ul></li><li><p>只写：<code>a</code>&#x3D;&#x3D;<code>at</code>、<code>ab</code>【尾部追加】</p><ul><li>存在，尾部追加。</li></ul></li><li><p>不存在，创建再写。</p></li></ul><h3 id="（三）Excel格式文件"><a href="#（三）Excel格式文件" class="headerlink" title="（三）Excel格式文件"></a>（三）Excel格式文件</h3><ul><li><p>读</p><ul><li><p>读sheet（工作表）</p><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import load_workbookwb &#x3D; load_workbook(&quot;files&#x2F;p1.xlsx&quot;)# 1.获取excel文件中的所有sheet名称print(wb.sheetnames)  # [&#39;数据导出&#39;, &#39;用户列表&#39;, &#39;Sheet1&#39;, &#39;Sheet2&#39;]# 2.选择sheetsheet &#x3D; wb[&quot;数据导出&quot;]  # 基于sheet名称sheet &#x3D; wb.worksheets[0]  # 基于索引位置# 3.循环所有的sheetfor name in wb.sheetnames:    sheet &#x3D; wb[name]</code></pre></li><li><p>读cell（单元格）</p><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import load_workbookwb &#x3D; load_workbook(&quot;files&#x2F;p1.xlsx&quot;)sheet &#x3D; wb.worksheets[0]# 1.获取第N行第N列的单元格(位置是从1开始）cell &#x3D; sheet.cell(1, 1)print(cell.value)  # 单元格的内容print(cell.style)  # 单元格的样式print(cell.font)  # 单元格的字体print(cell.alignment)  # 单元格的排列# 2.获取某个单元格c1 &#x3D; sheet[&quot;A2&quot;]# 3.所有的单元格for cell in sheet[1]:    print(cell.value)    # 4.所有行的数据（获取某一列数据）for row in sheet.rows:    print(row[0].value, row[1].value)  # 第一列和第二列数据    # 5.获取所有列的数据for col in sheet.columns:    print(col[1].value)  # 第二行的数据</code></pre></li></ul></li><li><p>写</p><ul><li><p>创建sheet工作表</p><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import workbook# 创建excel且默认会创建一个sheet（名称为Sheet）wb &#x3D; workbook.Workbook()sheet &#x3D; wb.worksheets[0] # 或 sheet &#x3D; wb[&quot;Sheet&quot;]</code></pre></li><li><p>写cell，在找到对于cell的基础上对其值进行更改或写入。</p></li></ul></li></ul><h3 id="（四）路径相关"><a href="#（四）路径相关" class="headerlink" title="（四）路径相关"></a><font color="#dd0000"><strong>（四）路径相关</strong></font></h3><pre class="language-python" data-language="python"><code class="language-python">import shutilimport os# 1. 获取当前脚本绝对路径abs_path &#x3D; os.path.abspath(__file__)# 2. 获取当前文件的上级目录base_path &#x3D; os.path.dirname(路径)  # 可以多层嵌套获取上N级目录# 3. 路径拼接p1 &#x3D; os.path.join(base_path, &#39;xx&#39;)# 4. 判断路径是否存在exists &#x3D; os.path.exists(p1)# 5. 创建文件夹path &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;uuuu&#39;)if not os.path.exists(path):    os.makedirs(path)    # 6. 是否是文件夹file_path &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;uuuu.png&#39;)is_dir &#x3D; os.path.isdir(file_path)print(is_dir) # False# 7. 删除文件或文件夹os.remove(&quot;文件路径&quot;)path &#x3D; os.path.join(base_path, &#39;xx&#39;)shutil.rmtree(path)# 8. 拷贝文件夹shutil.copytree(原路径, 目标路径)# 9.拷贝文件shutil.copy(原路径, 目标路径)# 10.文件或文件夹重命名shutil.move(原路径, 目标路径)</code></pre><p>​文件绝对路径（推荐），<strong>不要将文件路径写死，而是基于 os 模块中的相关功能自动化获取绝对路径</strong>，以方便项目移动到其他文件或电脑上。</p><h2 id="二、初识函数"><a href="#二、初识函数" class="headerlink" title="二、初识函数"></a>二、初识函数</h2><h3 id="（一）概念相关"><a href="#（一）概念相关" class="headerlink" title="（一）概念相关"></a>（一）概念相关</h3><p>​函数，可以当做是<strong>一大堆功能代码的集合。</strong></p><p>​函数的作用：</p><ul><li><p>当有重复的代码时，可以考虑封装为函数提高代码的<strong>重用性</strong></p></li><li><p>代码太长时，使用函数可以增强代码的<strong>可读性</strong></p></li></ul><h3 id="（二）函数的参数"><a href="#（二）函数的参数" class="headerlink" title="（二）函数的参数"></a>（二）函数的参数</h3><blockquote><p>面试题一：<strong>请问Python的参数默认传递的是什么？</strong></p></blockquote><p>答：<strong>内存地址</strong></p><ul><li>节省内存</li><li>对于可变类型且函数中修改元素的内容，所有的地方都会修改。可变类型：列表、字典、集合。</li></ul><blockquote><p>面试题二：<strong>请问Python的返回值默认传递的是什么？</strong></p></blockquote><p>答：<strong>内存地址</strong></p><blockquote><p>面试题三：参数的默认值</p></blockquote><ul><li><p>坑</p><pre class="language-python" data-language="python"><code class="language-python"># 在函数内部内存中会维护一块区域存储 id1 [1,2] def func(a1,a2&#x3D;[1,2]):    a2.append(666)    print(a1,a2)# a1&#x3D;100# a2 -&gt; id1 [1,2] func(100) # 100  [1,2,666]# a1&#x3D;200# a2 -&gt; id1 [1,2,666]func(200) # 200 [1,2,666,666]# a1&#x3D;99# a2 -&gt; id2 [77,88]func(99,[77,88]) # 66 [77,88,666]# a1&#x3D;300# a2 -&gt; id2 [1,2,666]func(300) # 300 [1,2,666,666,666] </code></pre></li><li><p>大坑</p><pre class="language-python" data-language="python"><code class="language-python"># 在函数内部内存会维护一块区域存储  id1 [1, 2] def func(a1, a2&#x3D;[1, 2]):    a2.append(a1)    return a2# a1&#x3D;10# a2 -&gt; id1 [1, 2] # v1 -&gt; id1 [1, 2, 10] v1 &#x3D; func(10)print(v1) # [1, 2, 10]# a1&#x3D;20# a2 -&gt; id1 [1, 2, 10]# v2 -&gt; id1 [1, 2, 10, 20]v2 &#x3D; func(20)print(v2) # [1, 2, 10, 20 ]# a1&#x3D;30# a2 -&gt; id2 [11, 22]# v3 -&gt; id2 [11, 22, 30]v3 &#x3D; func(30, [11, 22])print(v3) #  [11, 22,30]# a1&#x3D;40# a2 -&gt; id1 [1, 2, 10, 20]# v4 -&gt; id1 [1, 2, 10, 20, 40]v4 &#x3D; func(40)print(v4) # [1, 2, 10, 20, 40] </code></pre></li><li><p>深坑</p><pre class="language-python" data-language="python"><code class="language-python"># 内存中创建空间存储 id1 [1, 2] def func(a1, a2&#x3D;[1, 2]):    a2.append(a1)    return a2# a1&#x3D;10# a2 -&gt; id1 [1, 2] # v1 -&gt; id1 [1, 2, 10] v1 &#x3D; func(10)# a1&#x3D;20# a2 -&gt; id1 [1, 2, 10]# v2 -&gt; id1 [1, 2, 10, 20]v2 &#x3D; func(20)# a1&#x3D;30# a2 -&gt; id2 [11, 22]# v3 -&gt; id2 [11, 22, 30]v3 &#x3D; func(30, [11, 22])# a1&#x3D;40# a2 -&gt; id1 [1, 2, 10, 20]# v4 -&gt; id1 [1, 2, 10, 20, 40]v4 &#x3D; func(40)# v1, v2, v4 -&gt; id1 [1, 2, 10, 20, 40]# v3 -&gt; id2[11, 22, 30]print(v1) # [1, 2, 10, 20, 40]print(v2) # [1, 2, 10, 20, 40]print(v3) # [11,22,30]print(v4) # [1, 2, 10, 20, 40] </code></pre></li></ul><h3 id="（三）函数的返回值"><a href="#（三）函数的返回值" class="headerlink" title="（三）函数的返回值"></a>（三）函数的返回值</h3><ul><li><p>返回值可以是任意类型，如果函数中没写return，则<strong>默认返回None</strong></p></li><li><p>return后面的值如果<strong>有逗号</strong>，则默认会将返回值<strong>转换成元组</strong>再返回</p></li><li><p>函数一旦遇到return就会<strong>立即退出函数（终止函数中的所有代码）</strong></p></li></ul><h2 id="三、函数高级"><a href="#三、函数高级" class="headerlink" title="三、函数高级"></a>三、函数高级</h2><h3 id="（一）三句话搞定作用域："><a href="#（一）三句话搞定作用域：" class="headerlink" title="（一）三句话搞定作用域："></a>（一）三句话搞定作用域：</h3><ul><li><strong>优先在自己的作用域找，自己没有就去上级作用域。</strong></li><li><strong>在作用域中寻找值时，要确保此次此刻值是什么。</strong></li><li><strong>分析函数的执行，并确定函数<code>作用域链</code>。（函数嵌套）</strong></li></ul><h3 id="（二）装饰器"><a href="#（二）装饰器" class="headerlink" title="（二）装饰器"></a><font color="#dd0000"><strong>（二）装饰器</strong></font></h3><p><font color="#dd0000"><strong>面试题：手写函数装饰器</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">import functoolsdef outer(origin):    @functools.wraps(origin)    def inner(*args, **kwargs):        # 加入功能        res &#x3D; origin(*args, **kwargs)        # 加入功能        return res    return inner</code></pre><h3 id="（三）匿名函数"><a href="#（三）匿名函数" class="headerlink" title="（三）匿名函数"></a>（三）匿名函数</h3><ul><li><p>语法：lambda 参数：函数体</p><ul><li>参数：支持任意参数（包括动态参数）</li><li>函数体：只能是一行代码</li><li>返回值：默认返回函数体执行的结果</li></ul></li><li><p>等价于</p><pre class="language-python" data-language="python"><code class="language-python">def func(参数):    res &#x3D; 函数体    return res</code></pre></li><li><p>示例</p><pre class="language-python" data-language="python"><code class="language-python">def func(data):    name_list &#x3D; data.replace(&quot;.&quot;)    return name_list[-1]func &#x3D; lambda data: data.replace(&quot;.&quot;)[-1]</code></pre></li></ul><h3 id="（四）三元运算"><a href="#（四）三元运算" class="headerlink" title="（四）三元运算"></a>（四）三元运算</h3><ul><li><p>语法：if 函数体 else </p></li><li><p>怎么看三元表达式</p><blockquote><p>1.看if和else中间的语句</p><p>2.成立，把if前面的值赋值给data</p><p>3.不成立，把else后的值赋值给data</p></blockquote></li><li><p>示例</p><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; input(&quot;请写入内容&quot;)data &#x3D; &quot;臭不要脸&quot; if &quot;苍老师&quot; in num else &quot;正经人&quot;print(data)</code></pre></li></ul><h3 id="（五）生成器"><a href="#（五）生成器" class="headerlink" title="（五）生成器"></a><font color="#dd0000">（五）生成器</font></h3><p>生成器是由<strong>函数+yield关键字</strong>创造出来的写法，在特定情况下，用他可以帮助我们节省内存。（后期学习操作MySQL 或 Redis等数据源再操作，了解思想即可）。</p><ul><li>生成器函数：当函数中有yield存在时，这个函数就是生产生成器函数</li><li>生成器对象：执行生成器函数时，会返回一个生成器对象<ul><li>for</li><li>next</li><li>send</li></ul></li></ul><p>应用场景：假设要让你生成 300w个随机的4位数，并打印出来。</p><ul><li><p>常规做法</p><pre class="language-python" data-language="python"><code class="language-python">import randomdata_list &#x3D; []for i in range(300000000):    val &#x3D; random.randint(1000, 9999)data_list.append(val)# 再使用时，去 data_list 中获取即可</code></pre></li><li><p>使用生成器函数</p>  <pre class="language-python" data-language="python"><code class="language-python">import randomdef gen_random_num(max_count):    counter &#x3D; 0    while counter &lt; max_count:        yield random.randint(1000, 9999)        counter +&#x3D; 1data_list &#x3D; gen_random_num(3000000)# 再使用时，去 data_list 中获取即可</code></pre></li></ul><h3 id="（六）推导式"><a href="#（六）推导式" class="headerlink" title="（六）推导式"></a>（六）推导式</h3><p>推导式是Python中提供了一个非常方便的功能，可以让我们通过一行代码实现创建<strong>list、dict、tuple、set 的同时初始化一些值</strong></p><ul><li><p>适应范围</p><ul><li>列表：生成一个列表</li><li>集合：生成一个集合</li><li>字典：生成一个字典</li><li>元组：生成一个<strong>生成器对象</strong></li></ul></li><li><p>示例</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;    &#39;sign_type&#39;: &quot;MD5&quot;,    &#39;out_refund_no&#39;: &quot;12323&quot;,    &#39;appid&#39;: &#39;wx55cca0b94f723dc7&#39;,    &#39;mch_id&#39;: &#39;1526049051&#39;,    &#39;out_trade_no&#39;: &quot;ffff&quot;,    &#39;nonce_str&#39;: &quot;sdfdffd&quot;,    &#39;total_fee&#39;: 9901,    &#39;refund_fee&#39;: 10000&#125;data &#x3D; &quot;&amp;&quot;.join([&quot;&#123;&#125;&#x3D;&#123;&#125;&quot;.format(key, value) for key, value in sorted(info.items(), key&#x3D;lambda x: x[0])])print(data)</code></pre></li></ul><h2 id="四、函数高阶"><a href="#四、函数高阶" class="headerlink" title="四、函数高阶"></a>四、函数高阶</h2><h3 id="（一）导入相关"><a href="#（一）导入相关" class="headerlink" title="（一）导入相关"></a>（一）导入相关</h3><p>当定义好一个模块或包之后，如果想要使用其中定义的功能，必须要<strong>先导入，然后再能使用</strong>。导入，其实就是将模块或包加载的内存中，以后再去内存中去拿就行。在Python内部默认设置了一些路径，导入模块或包时，都会按照指定顺序逐一去特定的路径查找。</p><pre class="language-python" data-language="python"><code class="language-python">import sysprint(sys.path)&#39;&#39;&#39;[    &#39;当前执行脚本所在的目录&#39;, &#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day14&#x2F;bin&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day14    &#39;&#x2F;Applications&#x2F;PyCharm.app&#x2F;Contents&#x2F;plugins&#x2F;python&#x2F;helpers&#x2F;pycharm_display&#39;,    &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;lib&#x2F;python39.zip&#39;,    &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;lib&#x2F;python3.9&#39;,    &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;lib&#x2F;python3.9&#x2F;lib-dynload&#39;,    &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#39;,    &#39;&#x2F;Applications&#x2F;PyCharm.app&#x2F;Contents&#x2F;plugins&#x2F;python&#x2F;helpers&#x2F;pycharm_matplotlib_backend&#39;    ]&#39;&#39;&#39;</code></pre><p>两条建议：</p><ol><li><p><strong>以后写模块名称时，千万不能和内置和第三方的同名（新手容易犯错误）。</strong></p></li><li><p><strong>项目执行文件一般都在项目根目录，如果执行文件嵌套的内存目录，就需要自己手动在sys.path中添加路径。</strong></p></li></ol><h3 id="（二）常用内置模块"><a href="#（二）常用内置模块" class="headerlink" title="（二）常用内置模块"></a>（二）常用内置模块</h3><h4 id="2-1-os模块"><a href="#2-1-os模块" class="headerlink" title="2.1 os模块"></a>2.1 os模块</h4><pre class="language-python" data-language="python"><code class="language-python">import os# 1. 获取当前脚本绝对路径abs_path &#x3D; os.path.abspath(__file__)print(abs_path)# 2. 获取当前文件的上级目录base_path &#x3D; os.path.dirname( os.path.dirname(路径) ）print(base_path)# 3. 路径拼接p1 &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;a1.png&#39;)print(p1)# 4. 判断路径是否存在exists &#x3D; os.path.exists(p1)print(exists)# 5. 创建文件夹os.makedirs(路径)path &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;uuuu&#39;)if not os.path.exists(path):    os.makedirs(path)# 6. 是否是文件夹file_path &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;uuuu.png&#39;)is_dir &#x3D; os.path.isdir(file_path)print(is_dir) # False# 7. 删除文件或文件夹os.remove(&quot;文件路径&quot;)path &#x3D; os.path.join(base_path, &#39;xx&#39;)shutil.rmtree(path)</code></pre><ul><li><p>listdir，查看目录下所有的文件</p></li><li><p>walk，查看目录下所有的文件（含子孙文件）</p></li></ul><pre class="language-python" data-language="python"><code class="language-python">import osdata &#x3D; os.listdir(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day14&#x2F;commons&quot;)print(data)# [&#39;convert.py&#39;, &#39;__init__.py&#39;, &#39;page.py&#39;, &#39;__pycache__&#39;, &#39;utils.py&#39;, &#39;tencent&#39;]# 要遍历一个文件夹下的所有文件，例如：遍历文件夹下的所有mp4文件data &#x3D; os.walk(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;Documents&#x2F;视频教程&#x2F;路飞Python&#x2F;mp4&quot;)for path, folder_list, file_list in data:    for file_name in file_list:        file_abs_path &#x3D; os.path.join(path, file_name)        ext &#x3D; file_abs_path.rsplit(&quot;.&quot;,1)[-1]        if ext &#x3D;&#x3D; &quot;mp4&quot;:            print(file_abs_path)</code></pre><h4 id="2-2-shutil模块"><a href="#2-2-shutil模块" class="headerlink" title="2.2 shutil模块"></a>2.2 shutil模块</h4><pre class="language-python" data-language="python"><code class="language-python">import shutil# 1. 删除文件夹path &#x3D; os.path.join(base_path, &#39;xx&#39;)shutil.rmtree(path)# 2. 拷贝文件夹shutil.copytree(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;Desktop&#x2F;图&#x2F;csdn&#x2F;&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;files&quot;)# 3.拷贝文件shutil.copy(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;Desktop&#x2F;图&#x2F;csdn&#x2F;WX20201123-112406@2x.png&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;&quot;)shutil.copy(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;Desktop&#x2F;图&#x2F;csdn&#x2F;WX20201123-112406@2x.png&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;x.png&quot;)# 4.文件或文件夹重命名shutil.move(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;x.png&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;xxxx.png&quot;)shutil.move(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;files&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;images&quot;)# 5. 压缩文件# base_name，压缩后的压缩包文件# format，压缩的格式，例如：&quot;zip&quot;, &quot;tar&quot;, &quot;gztar&quot;, &quot;bztar&quot;, or &quot;xztar&quot;.# root_dir，要压缩的文件夹路径# shutil.make_archive(base_name&#x3D;r&#39;datafile&#39;,format&#x3D;&#39;zip&#39;,root_dir&#x3D;r&#39;files&#39;)# 6. 解压文件# filename，要解压的压缩包文件# extract_dir，解压的路径# format，压缩文件格式# shutil.unpack_archive(filename&#x3D;r&#39;datafile.zip&#39;, extract_dir&#x3D;r&#39;xxxxxx&#x2F;xo&#39;, format&#x3D;&#39;zip&#39;)</code></pre><h4 id="2-3-sys模块"><a href="#2-3-sys模块" class="headerlink" title="2.3 sys模块"></a>2.3 sys模块</h4><pre class="language-python" data-language="python"><code class="language-python">import sys# 1. 获取解释器版本print(sys.version)print(sys.version_info)print(sys.version_info.major, sys.version_info.minor, sys.version_info.micro)# 2. 导入模块路径print(sys.path)# 3.获取执行脚本时，python解释器后面传入的参数print(sys.argv)</code></pre><h4 id="2-4-random模块"><a href="#2-4-random模块" class="headerlink" title="2.4 random模块"></a>2.4 random模块</h4><pre class="language-python" data-language="python"><code class="language-python">import random# 1. 获取范围内的随机整数v &#x3D; random.randint(10, 20)print(v)# 2. 获取范围内的随机小数v &#x3D; random.uniform(1, 10)print(v)# 3. 随机抽取一个元素v &#x3D; random.choice([11, 22, 33, 44, 55])print(v)# 4. 随机抽取多个元素v &#x3D; random.sample([11, 22, 33, 44, 55], 3)print(v)# 5. 打乱顺序data &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]random.shuffle(data)print(data)</code></pre><h4 id="2-5-hashlib-模块"><a href="#2-5-hashlib-模块" class="headerlink" title="2.5 hashlib 模块"></a>2.5 hashlib 模块</h4><pre class="language-python" data-language="python"><code class="language-python">import hashlibhash_object &#x3D; hashlib.md5()hash_object.update(&quot;武沛齐&quot;.encode(&#39;utf-8&#39;))result &#x3D; hash_object.hexdigest()print(result)</code></pre><h4 id="2-6-configparser-模块"><a href="#2-6-configparser-模块" class="headerlink" title="2.6 configparser 模块"></a>2.6 configparser 模块</h4><p> ini文件是Initialization File的缩写，平时用于存储软件的的配置文件。例如：MySQL数据库的配置文件。</p><p>my.conf文件示例</p><pre class="language-ini" data-language="ini"><code class="language-ini">[mysqld]datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysqlsocket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.socklog-bin&#x3D;py-mysql-bincharacter-set-server&#x3D;utf8collation-server&#x3D;utf8_general_cilog-error&#x3D;&#x2F;var&#x2F;log&#x2F;mysqld.log# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links&#x3D;0[mysqld_safe]log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.logpid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mariadb&#x2F;mariadb.pid[client]default-character-set&#x3D;utf8</code></pre><pre class="language-python" data-language="python"><code class="language-python">import configparserconfig &#x3D; configparser.ConfigParser()config.read(&#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;files&#x2F;my.conf&#39;, encoding&#x3D;&#39;utf-8&#39;)# 读取所有节点ret &#x3D; config.sections()print(ret) # 读取节点下的键值item_list &#x3D; config.items(&quot;mysqld_safe&quot;)print(item_list)# 读取节点下值（根据 节点+键 ）value &#x3D; config.get(&#39;mysqld&#39;, &#39;log-bin&#39;)print(value)# 检查节点has_sec &#x3D; config.has_section(&#39;mysqld&#39;)print(has_sec)# 添加节点config.add_section(&quot;SEC_1&quot;)# 节点中设置键值config.set(&#39;SEC_1&#39;, &#39;k10&#39;, &quot;123&quot;)config.set(&#39;SEC_1&#39;, &#39;name&#39;, &quot;哈哈哈哈哈&quot;)config.add_section(&quot;SEC_2&quot;)config.set(&#39;SEC_2&#39;, &#39;k10&#39;, &quot;123&quot;)# 内容写入新文件config.write(open(&#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;files&#x2F;xxoo.conf&#39;, &#39;w&#39;))# 删除节点config.remove_section(&quot;SEC_2&quot;)# 删除节点中的键值config.remove_option(&#39;SEC_1&#39;, &#39;k10&#39;)config.write(open(&#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;files&#x2F;new.conf&#39;, &#39;w&#39;))</code></pre><h4 id="2-7-xml模块"><a href="#2-7-xml模块" class="headerlink" title="2.7 xml模块"></a>2.7 xml模块</h4><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/2885849">可扩展标记语言</a>，是一种简单的数据存储语言，XML 被设计用来传输和存储数据。</p><p>xo.xml文件示例</p><pre class="language-markup" data-language="markup"><code class="language-markup">content = """<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>country</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Liechtenstein<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rank</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rank</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>year</span><span class="token punctuation">></span></span>2023<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>year</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gdppc</span><span class="token punctuation">></span></span>141100<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gdppc</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>neighbor</span> <span class="token attr-name">direction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>E<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Austria<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>neighbor</span> <span class="token attr-name">direction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>W<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Switzerland<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>country</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>country</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Panama<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rank</span><span class="token punctuation">></span></span>69<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rank</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>year</span><span class="token punctuation">></span></span>2026<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>year</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gdppc</span><span class="token punctuation">></span></span>13600<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gdppc</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>neighbor</span> <span class="token attr-name">direction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>W<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Costa Rica<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>neighbor</span> <span class="token attr-name">direction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>E<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Colombia<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>country</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span>"""</code></pre><ul><li><p>打开文件</p><ul><li>以xml文件存在</li></ul><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ET# ET去打开xml文件tree &#x3D; ET.parse(&quot;files&#x2F;xo.xml&quot;)# 获取根标签root &#x3D; tree.getroot()print(root) # &lt;Element &#39;data&#39; at 0x7f94e02763b0&gt;</code></pre><ul><li>通过网络获取或str格式</li></ul><pre class="language-python" data-language="python"><code class="language-python">root &#x3D; ET.XML(content)print(root)  # &lt;Element &#39;data&#39; at 0x7fdaa019cea0&gt;</code></pre></li><li><p>读取数据</p><pre class="language-python" data-language="python"><code class="language-python"># 获取根标签 dataroot &#x3D; ET.XML(content)# 获取data标签的孩子标签for child in root:    # child.tag &#x3D; country    # child.attrib &#x3D; &#123;&quot;name&quot;:&quot;Liechtenstein&quot;&#125;    print(child.tag, child.attrib)    for node in child:        print(node.tag, node.attrib, node.text)# 在data的子子孙孙里面找第一个year标签for child in root.iter(&#39;year&#39;):    print(child.tag, child.text)    # 获取所有&#39;country&#39;v1 &#x3D; root.findall(&#39;country&#39;)print(v1)# 获取第一个&#39;country&#39;的第一个&#39;rank&#39;v2 &#x3D; root.find(&#39;country&#39;).find(&#39;rank&#39;)print(v2.text)# 修改标签的值rank.text &#x3D; &quot;999&quot;# 给标签加属性rank.set(&#39;update&#39;, &#39;2020-11-11&#39;)print(rank.text, rank.attrib)############ 保存文件 ############上述对xml的操作是在内存中tree &#x3D; ET.ElementTree(root)tree.write(&quot;new.xml&quot;, encoding&#x3D;&#39;utf-8&#39;)# 删除节点root.remove( root.find(&#39;country&#39;) )print(root.findall(&#39;country&#39;))############ 保存文件 ############tree &#x3D; ET.ElementTree(root)tree.write(&quot;newnew.xml&quot;, encoding&#x3D;&#39;utf-8&#39;)</code></pre></li><li><p>构建文档</p><ul><li>方式一：</li></ul><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ET# 创建根标签root &#x3D; ET.Element(&quot;home&quot;)# 创建节点大儿子son1 &#x3D; ET.Element(&#39;son&#39;, &#123;&#39;name&#39;: &#39;儿1&#39;&#125;)# 创建小儿子son2 &#x3D; ET.Element(&#39;son&#39;, &#123;&quot;name&quot;: &#39;儿2&#39;&#125;)# 在大儿子中创建两个孙子grandson1 &#x3D; ET.Element(&#39;grandson&#39;, &#123;&#39;name&#39;: &#39;儿11&#39;&#125;)grandson2 &#x3D; ET.Element(&#39;grandson&#39;, &#123;&#39;name&#39;: &#39;儿12&#39;&#125;)son1.append(grandson1)son1.append(grandson2)# 把儿子添加到根节点中root.append(son1)root.append(son2)tree &#x3D; ET.ElementTree(root)tree.write(&#39;oooo.xml&#39;, encoding&#x3D;&#39;utf-8&#39;, short_empty_elements&#x3D;False)</code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>famliy</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>grandson</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿11<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>grandson</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>grandson</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿12<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>grandson</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>famliy</span><span class="token punctuation">></span></span></code></pre><ul><li>方式二</li></ul><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ET# 创建根节点root &#x3D; ET.Element(&quot;famliy&quot;)# 创建大儿子son1 &#x3D; root.makeelement(&#39;son&#39;, &#123;&#39;name&#39;: &#39;儿1&#39;&#125;)# 创建小儿子son2 &#x3D; root.makeelement(&#39;son&#39;, &#123;&quot;name&quot;: &#39;儿2&#39;&#125;)# 在大儿子中创建两个孙子grandson1 &#x3D; son1.makeelement(&#39;grandson&#39;, &#123;&#39;name&#39;: &#39;儿11&#39;&#125;)grandson2 &#x3D; son1.makeelement(&#39;grandson&#39;, &#123;&#39;name&#39;: &#39;儿12&#39;&#125;)son1.append(grandson1)son1.append(grandson2)# 把儿子添加到根节点中root.append(son1)root.append(son2)tree &#x3D; ET.ElementTree(root)tree.write(&#39;oooo.xml&#39;,encoding&#x3D;&#39;utf-8&#39;)</code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>famliy</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>age</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿11<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>孙子<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>age</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>famliy</span><span class="token punctuation">></span></span></code></pre></li></ul><h4 id="2-8-josn-模块"><a href="#2-8-josn-模块" class="headerlink" title="2.8 josn 模块"></a>2.8 josn 模块</h4><p> json模块，是python内部的一个模块，可以将python的数据格式 转换为json格式的数据，也可以将json格式的数据转换为python的数据格式。</p><ul><li><p><strong>数据类型 -&gt; json ，一般称为：序列化</strong></p><pre class="language-python" data-language="python"><code class="language-python">import jsondata &#x3D; [    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;,    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;,]res &#x3D; json.dumps(data)print(res) # &#39;[&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;\u6b66\u6c9b\u9f50&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;]&#39;res &#x3D; json.dumps(data, ensure_ascii&#x3D;False)print(res) # &#39;[&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;]&#39;</code></pre></li><li><p><strong>json格式 -&gt; 数据类型，一般称为：反序列化</strong></p><pre class="language-python" data-language="python"><code class="language-python">import jsondata_string &#x3D; &#39;[&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;]&#39;data_list &#x3D; json.loads(data_string)print(data_list)</code></pre></li><li><p><code>json.dump</code>，将数据序列化并写入文件（不常用）</p></li><li><p><code>json.load</code>，读取文件中的数据并反序列化为python的数据类型（不常用）</p></li></ul><h4 id="2-9-时间处理模块"><a href="#2-9-时间处理模块" class="headerlink" title="2.9 时间处理模块"></a>2.9 时间处理模块</h4><ul><li>UTC&#x2F;GMT：世界时间</li><li>本地时间：本地时区的时间。</li></ul><p>Python中关于时间处理的模块有两个，分别是time和datetime。</p><h5 id="2-9-1-time-模块"><a href="#2-9-1-time-模块" class="headerlink" title="2.9.1 time 模块"></a>2.9.1 time 模块</h5><pre class="language-python" data-language="python"><code class="language-python">import time# 获取当前时间戳（自1970-1-1 00:00）v1 &#x3D; time.time()  # 单位秒print(v1)# 时区v2 &#x3D; time.timezoneprint(v2, v2&#x2F;60&#x2F;60)  # 单位秒 小时：v2&#x2F;60&#x2F;60  东八区# 停止n秒，再执行后续的代码。print(&#39;开始&#39;)time.sleep(5)print(&#39;结束&#39;)</code></pre><h5 id="2-9-2-datetime-模块"><a href="#2-9-2-datetime-模块" class="headerlink" title="2.9.2 datetime 模块"></a>2.9.2 datetime 模块</h5><pre class="language-python" data-language="python"><code class="language-python">from datetime import datetime, timezone, timedeltav1 &#x3D; datetime.now()  # 当前本地时间print(v1)tz &#x3D; timezone(timedelta(hours&#x3D;7))  # 当前东7区时间v2 &#x3D; datetime.now(tz)print(v2)v3 &#x3D; datetime.utcnow()  # 当前UTC时间print(v3)</code></pre><p><strong>注意：</strong></p><ol><li><p><strong><code>datetime</code>类型 和 <code>timedelta</code>类型之间支持加减运算</strong></p></li><li><p><strong><code>datetime</code>类型 和 <code>datetime</code>类型之间只支持减运算和比较运算不能相加</strong></p></li></ol><h5 id="2-9-3-三种格式时间的转换"><a href="#2-9-3-三种格式时间的转换" class="headerlink" title="2.9.3 三种格式时间的转换"></a>2.9.3 三种格式时间的转换</h5><img src="/2022/06/13/di-er-jie-duan-chong-dian/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20220608200220.jpg" class="" title="img"><h4 id="2-10-re模块"><a href="#2-10-re模块" class="headerlink" title="2.10 re模块"></a>2.10 re模块</h4><p>python中提供了re模块，可以处理正则表达式并对文本进行处理。</p><ul><li><p>findall，获取匹配到的所有数据</p></li><li><p>match，<strong>从起始位置开始匹配</strong>，匹配成功返回一个对象，未匹配成功返回None</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;逗2B最逗3B欢乐&quot;data &#x3D; re.match(&quot;逗\dB&quot;, text)if data:    content &#x3D; data.group() # &quot;逗2B&quot;    print(content)</code></pre></li><li><p>search，浏览整个字符串去匹配第一个，匹配成功返回一个对象，未匹配成功返回None</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;大小逗2B最逗3B欢乐&quot;data &#x3D; re.search(&quot;逗\dB&quot;, text)if data:    print(data.group())  # &quot;逗2B&quot;</code></pre></li><li><p>sub，替换匹配成功的位置 相较于字符串的replace可以实现动态替换</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;逗2B最逗3B欢乐&quot;data &#x3D; re.sub(&quot;\dB&quot;, &quot;沙雕&quot;, text, 1)print(data) # 逗沙雕最逗3B欢乐</code></pre></li><li><p>split，根据匹配成功的位置分割 相较于字符串的split可以实现动态分割</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;逗2B最逗3B欢乐&quot;data &#x3D; re.split(&quot;\dB&quot;, text, 1)print(data) # [&#39;逗&#39;, &#39;最逗3B欢乐&#39;]</code></pre></li><li><p>finditer+<code>?p&lt;name&gt;</code>：命名分组</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;dsf130429191912015219k13042919591219521Xkk&quot;data_list &#x3D; re.finditer(&quot;\d&#123;6&#125;(?P&lt;year&gt;\d&#123;4&#125;)(?P&lt;month&gt;\d&#123;2&#125;)(?P&lt;day&gt;\d&#123;2&#125;)\d&#123;3&#125;[\d|X]&quot;, text)  # 迭代器for item in data_list:        info_dict &#x3D; item.groupdict()    print(info_dict)  # &#123;&#39;year&#39;: &#39;1919&#39;, &#39;month&#39;: &#39;12&#39;, &#39;day&#39;: &#39;01&#39;&#125;...</code></pre></li></ul><h2 id="五、正则表达式相关"><a href="#五、正则表达式相关" class="headerlink" title="五、正则表达式相关"></a><font color="#dd0000">五、正则表达式相关</font></h2><p>当给你一大堆文本信息，让你提取其中的指定数据时，可以使用正则来实现。例如：提取文本中的邮箱和手机号</p><h3 id="（一）字符相关"><a href="#（一）字符相关" class="headerlink" title="（一）字符相关"></a>（一）字符相关</h3><ul><li><code>wupeiqi</code> 匹配文本中的wupeiqi</li><li><code>[abc]</code> 匹配a或b或c 字符。</li><li><code>[^abc]</code> 匹配除了abc以外的其他字符。</li><li><code>[a-z]</code> 匹配a~z的任意字符（ [0-9]也可以 ）。</li><li><code>.</code> 代指除换行符以外的任意字符。</li><li><code>\w</code> 代指字母或数字或下划线（汉字）。</li><li><code>\d</code> 代指数字</li><li><code>\s</code> 代指任意的空白符，包括空格、制表符等。</li></ul><h3 id="（二）数量相关"><a href="#（二）数量相关" class="headerlink" title="（二）数量相关"></a>（二）数量相关</h3><ul><li><code>*</code> 重复0次或更多次</li><li><code>+</code> 重复1次或更多次</li><li><code>?</code> 重复0次或1次</li><li><code>&#123;n&#125;</code> 重复n次</li><li><code>&#123;n,&#125;</code> 重复n次或更多次</li><li><code>&#123;n,m&#125;</code> 重复n到m次</li></ul><h3 id="（三）分组"><a href="#（三）分组" class="headerlink" title="（三）分组"></a>（三）分组</h3><ul><li><p>提取数据区域</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;data_list &#x3D; re.findall(&quot;15131(2\d&#123;5&#125;)&quot;, text)print(data_list)  # [&#39;255789&#39;]</code></pre></li><li><p>获取指定区域 + 或条件</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主15131root太牛15131alex逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;data_list &#x3D; re.findall(&quot;15131(2\d&#123;5&#125;|r\w+太)&quot;, text)print(data_list)  # [&#39;root太&#39;, &#39;255789&#39;]</code></pre></li></ul><h3 id="（四）起始和结束"><a href="#（四）起始和结束" class="headerlink" title="（四）起始和结束"></a>（四）起始和结束</h3><p>上述示例中都是去一段文本中提取数据，只要文本中存在即可。但，如果要求用户输入的内容必须是指定的内容开头和结尾，比就需要用到如下两个字符。</p><ul><li><code>^</code> 开始</li><li><code>$</code> 结束</li></ul><h3 id="（五）特殊字符"><a href="#（五）特殊字符" class="headerlink" title="（五）特殊字符"></a>（五）特殊字符</h3><p>由于正则表达式中 <code>* . \ &#123; &#125; ( ) </code>等都具有特殊的含义，所以如果想要在正则中匹配这种指定的字符，需要转义</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;我是你&#123;5&#125;爸爸&quot;data &#x3D; re.findall(&quot;你&#123;5&#125;爸&quot;, text)print(data) # []data &#x3D; re.findall(&quot;你\&#123;5\&#125;爸&quot;, text)print(data)</code></pre><h3 id="（六）应用"><a href="#（六）应用" class="headerlink" title="（六）应用"></a>（六）应用</h3><ol><li><p>QQ号码：不能以0开头，至少是五位的数字</p><pre class="language-python" data-language="python"><code class="language-python">[1-9]\d&#123;4,&#125;</code></pre></li><li><p>身份证号码：十八位数字，最后一位可是数字也可能是X</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;dsf130429191912015219k13042919591219521Xkk&quot;data_list &#x3D; re.findall(&quot;\d&#123;17&#125;[\dX]&quot;, text) # [abc]print(data_list) # [&#39;130429191912015219&#39;, &#39;13042919591219521X&#39;]data_list &#x3D; re.findall(&quot;\d&#123;17&#125;(\d|X)&quot;, text)print(data_list) # [&#39;9&#39;, &#39;X&#39;]data_list &#x3D; re.findall(&quot;(\d&#123;17&#125;(\d|X))&quot;, text)print(data_list) # [(&#39;130429191912015219&#39;, &#39;9&#39;), (&#39;13042919591219521X&#39;, &#39;X&#39;)]data_list &#x3D; re.findall(&quot;(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;3&#125;)([0-9]|X)&quot;, text)print(data_list) # [(&#39;130429&#39;, &#39;1919&#39;, &#39;12&#39;, &#39;01&#39;, &#39;521&#39;, &#39;9&#39;), (&#39;130429&#39;, &#39;1959&#39;, &#39;12&#39;, &#39;19&#39;, &#39;521&#39;, &#39;X&#39;)]</code></pre></li><li><p>匹配手机号：十一位数，第一位为1， 第二位为数字[3~9]， 再跟9位数字</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;我的手机哈是15133377892，你的手机号是1171123啊？&quot;data_list &#x3D; re.findall(&quot;1[3-9]\d&#123;9&#125;&quot;, text)print(data_list)  # [&#39;15133377892&#39;]</code></pre></li><li><p>邮箱地址：字符数字下划线+‘<code>@</code>+字母数字下划线+<code>.</code>+字母数字下划线</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;email_list &#x3D; re.findall(&quot;\w+@\w+\.\w+&quot;, text, re.ASCII)print(email_list) # [&#39;442662578@qq.com&#39;, &#39;xxxxx@live.com&#39;]email_list &#x3D; re.findall(&quot;\w+@\w+\.\w+&quot;,text)print(email_list) # [&#39;442662578@qq.com和xxxxx&#39;]email_list &#x3D; re.findall(&quot;(\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*)&quot;, text, re.ASCII)print(email_list) # [(&#39;44266-2578@qq.com&#39;, &#39;-2578&#39;, &#39;&#39;, &#39;&#39;), (&#39;xxxxx@live.com&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;)]</code></pre></li></ol><h2 id="六、开发规范"><a href="#六、开发规范" class="headerlink" title="六、开发规范"></a>六、开发规范</h2><p>现阶段，我们在开发一些程序时（终端运行），应该遵循一些结构的规范，让你的系统更加专业。</p><h3 id="（一）单文件应用"><a href="#（一）单文件应用" class="headerlink" title="（一）单文件应用"></a>（一）单文件应用</h3><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;文件注释&quot;&quot;&quot;import reimport randomimport requestsfrom openpyxl import load_workbookDB &#x3D; &quot;XXX&quot;def do_something():    &quot;&quot;&quot; 函数注释 &quot;&quot;&quot;    # TODO 待完成时，下一期实现xxx功能    for i in range(10):        passdef run():    &quot;&quot;&quot; 函数注释 &quot;&quot;&quot;    # 对功能代码进行注释    text &#x3D; input(&quot;&gt;&gt;&gt;&quot;)    print(text)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    run()</code></pre><h3 id="（二）文件夹应用"><a href="#（二）文件夹应用" class="headerlink" title="（二）文件夹应用"></a>（二）文件夹应用</h3><ul><li><p>单可执行文件</p><p> 新创建一个项目，假设名字叫 【crm】，可以创建如下文件和文件夹来存放代码和数据。</p> <pre class="language-python" data-language="python"><code class="language-python">crm├── app.py        文件，程序的主文件（尽量精简）├── config.py     文件，配置文件（放相关配置信息，代码中读取配置信息，如果想要修改配置，即可以在此修改，不用再去代码中逐一修改了）├── db            文件夹，存放数据├── files         文件夹，存放文件├── src           包，业务处理的代码└── utils         包，公共功能</code></pre></li></ul><img src="/2022/06/13/di-er-jie-duan-chong-dian/image-20210105163335127-16551284849975.png" class="" title="img"><ul><li><p>多可执行文件</p><pre class="language-none"><code class="language-none">killer├── bin文件夹，存放多个主文件（可运行）│   ├── app1.py│   └── app2.py├── config              包，配置文件│   ├── __init__.py│   └── settings.py├── db                  文件夹，存放数据├── files               文件夹，存放文件├── src                 包，业务代码│   └── __init__.py└── utils               包，公共功能    └── __init__.py</code></pre></li></ul><img src="/2022/06/13/di-er-jie-duan-chong-dian/image-20210105164740583.png" class="" title="img">]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 第二阶段 </tag>
            
            <tag> 函数和模块 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二阶段考试</title>
      <link href="/2022/06/12/di-er-jie-duan-kao-shi/"/>
      <url>/2022/06/12/di-er-jie-duan-kao-shi/</url>
      
        <content type="html"><![CDATA[<ol><li><p>一个大小为100G的文件 etl_log.txt，要读取文件中的内容，写出具体过程代码。</p><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;一次读1&#x2F;10&quot;&quot;&quot;def read_file(file_path, read_times):    with open(file_path, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as file_object:        total_line &#x3D; len(file_object.readlines())        file_object.seek(0)        lines_each_time, reminder &#x3D; divmod(total_line, read_times)        if reminder:            read_times +&#x3D; 1        i &#x3D; 0        while i &lt; read_times:            data_list &#x3D; []            for j in range(lines_each_time):                data_list.append(file_object.readline())            yield data_list            i +&#x3D; 1gen_obj &#x3D; read_file(&#39;etl_log.txt&#39;, 10)print(next(gen_obj))</code></pre><p><font color="#dd0000"><strong>答案</strong></font></p><pre class="language-python" data-language="python"><code class="language-python"># 存在多行：一行一行读with open(file_path, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as file_object:    for line in file_object:        pass</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 只有一行：按字节读import osfile_size &#x3D; os.path.getsize(&quot;etl_log.txt.txt&quot;)with open(file_path, mode&#x3D;&#39;rb&#39;) as file_object:    read_byte &#x3D; 0    while read_byte &lt;&#x3D; file_size:        file_object.read(1)        read_byte +&#x3D; 1    </code></pre></li><li><p>编写一个函数，这个函数接受一个文件夹名称作为参数，寻找文件夹中所有文件的路径并输入（包含嵌套）。</p><p>答：</p><pre class="language-python" data-language="python"><code class="language-python"># 编写一个函数，这个函数接受一个文件夹名称作为参数，寻找文件夹中所有文件的路径并输入（包含嵌套）。import osdef findall_path(dir_path):    for item in os.walk(dir_path):        path, dir_list, file_list &#x3D; item                for file_name in file_list:            print(os.path.join(path, file_name))result &#x3D; findall_path(r&#39;C:\Users\Geng\Desktop\我在b站学编程\python\模块二&#39;)print(result)</code></pre><p><font color="#dd0000"><strong>存在问题</strong></font>：item变量是否有必要创建</p><pre class="language-python" data-language="python"><code class="language-python">for path, dir_list, file_list in os.walk(dir_path):</code></pre></li><li><p>以下的代码数据的结果是什么？</p><pre class="language-python" data-language="python"><code class="language-python">def extend_list(val,data&#x3D;[]):    data.append(val)    return datalist1 &#x3D; extend_list(10)list2 &#x3D; extend_list(123,[])list3 &#x3D; extend_list(&quot;a&quot;)print(list1,list2,list3)</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python"># [10]  # 【10, a】# [123]# [&#39;a&#39;]  # 【10, a】</code></pre><p><font color="#dd0000"><strong>存在问题：list1， list3没有传入参数data使用的是extend_list函数内部维护的data，因此list1，list3输出错误</strong></font></p></li><li><p>python代码获取命令行参数。</p><p><font color="#dd0000"><strong>答案</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">import syssys.argv</code></pre></li><li><p>简述深浅拷贝？</p><p>​答：</p><ul><li>深浅拷贝只对可变类型有意义，不可变类型本质都不会对数据进行拷贝。</li><li>不可变数据类型的浅拷贝：只对数据不可变类型的第一层进行拷贝，而不会对不可变数据类型和更深层级的可变类型进行拷贝。</li><li>不可变数据类型的深拷贝：对所有层级的可变数据类型进行拷贝，不会对不可变数据类型进行拷贝。</li><li>特例：对元组进行拷贝时，会对内部可变元素进行拷贝。</li></ul></li><li><p>基于推导式一行代码生成1-100以内的偶数列表。</p><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [i for i in range(1, 101) if i%2 &#x3D;&#x3D; 0]print(data_list)</code></pre></li><li><p>请把以下函数转化为python lambda匿名函数</p><pre class="language-python" data-language="python"><code class="language-python">def add(x,y):      return x+y</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">add &#x3D; lambda x, y: x+yprint(add(2, 3))</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def num():    return [lambda x: i * x for i in range(4)]result &#x3D; [m(2) for m in num()]print(result)</code></pre><p>答：[6, 6, 6, 6]</p></li><li><p>列表推导式和生成器表达式 [i % 2 for i in range(10)] 和 (i % 2 for i in range(10)) 输出结果分别是什么？</p><p>答：推导式结果为列表：[0, 1, 0, 1, 0, 1, 0, 1, 0, 1]</p><p>​生成器结果为生成器对象：gen_obj。通过for循环，next()方法可获取内部值</p></li><li><p>写装饰器</p></li></ol>   <pre class="language-python" data-language="python"><code class="language-python"># 写timer装饰器实现：计算fun函数执行时间，并将结果给 result，最终打印（不必使用datetime,使用time.time即可）。@timerdef func():    passresult &#x3D; func()print(result) </code></pre><p>   答：忘记@functools.wraps()内的参数</p>   <pre class="language-python" data-language="python"><code class="language-python">import timeimport functoolsdef timer(origin):    @functools.wraps(origin)    def inner(*args, **kwargs):        start_time &#x3D; time.time()        origin(*args, **kwargs)        end_time &#x3D; time.time()        res &#x3D; end_time - start_time        return res    return inner@timerdef func():    time.sleep(10)</code></pre><p>   <font color="#dd0000"><strong>存在问题:</strong></font></p><ul><li><p><font color="#dd0000"><strong>@functools.wraps()内的参数，为原函数</strong></font></p></li><li><p><font color="#dd0000"><strong>装饰器不要改变原函数的返回值</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">def timer(origin):    @functools.wraps(origin)    def inner(*args, **kwargs):        start_time &#x3D; time.time()        res &#x3D; origin(*args, **kwargs)        end_time &#x3D; time.time()        message &#x3D; &#39;共用时&#123;&#125;秒&#39;.format(end_time - start_time)        return res    return inner</code></pre></li></ul><ol start="11"><li><p>re的match和search区别？</p><p>答：</p><ul><li>match返回第一个匹配结果</li><li>search</li></ul><p><font color="#dd0000"><strong>存在问题：知识点未掌握</strong></font></p><ul><li>match 返回从头开始匹配</li><li>search 在整个字符串进行匹配</li><li>他们均获取一个匹配成果的字符串</li></ul></li><li><p>什么是正则的贪婪匹配？或 正则匹配中的贪婪模式与非贪婪模式的区别？</p><p>答：</p><ul><li>贪婪匹配：匹配到正则表达式后，继续往后匹配，以求得满足结果的最长字符串</li><li>非贪婪匹配：匹配到正则表达式后停止匹配返回结果</li></ul></li><li><p>sys.path.append(“&#x2F;root&#x2F;mods”)的作用？</p><p>答：将”&#x2F;root&#x2F;mods”加入系统环境变量</p><p><font color="#dd0000"><strong>存在问题：未回答完整</strong></font></p><p>答：将”&#x2F;root&#x2F;mods”加入系统环境变量，可以直接对该路径下的模块和包进行导入</p></li><li><p>写函数</p></li></ol><pre class="language-python" data-language="python"><code class="language-python">有一个数据结构如下所示，请编写一个函数从该结构数据中返回由指定的 字段和对应的值组成的字典。如果指定字段不存在，则跳过该字段。DATA &#x3D; &#123;    &quot;time&quot;: &quot;2016-08-05T13:13:05&quot;,    &quot;some_id&quot;: &quot;ID1234&quot;,    &quot;grp1&quot;: &#123;&quot;fld1&quot;: 1, &quot;fld2&quot;: 2, &#125;,    &quot;xxx2&quot;: &#123;&quot;fld3&quot;: 0, &quot;fld4&quot;: 0.4, &#125;,    &quot;fld6&quot;: 11,    &quot;fld7&quot;: 7,    &quot;fld46&quot;: 8&#125;fields:由&quot;|&quot;连接的以fld开头的字符串, 如fld2|fld7|fld29  def select(fields):    print(DATA)    return result</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">DATA &#x3D; &#123;    &quot;time&quot;: &quot;2016-08-05T13:13:05&quot;,    &quot;some_id&quot;: &quot;ID1234&quot;,    &quot;grp1&quot;: &#123;&quot;fld1&quot;: 1, &quot;fld2&quot;: 2, &#125;,    &quot;xxx2&quot;: &#123;&quot;fld3&quot;: 0, &quot;fld4&quot;: 0.4, &#125;,    &quot;fld6&quot;: 11,    &quot;fld7&quot;: 7,    &quot;fld46&quot;: 8&#125;def select(fields):    data_list &#x3D; fields.split(&#39;|&#39;)    res &#x3D; &#123;&#125;    for data in data_list:        value &#x3D; DATA.get(data)        if not value:            continue        res[data] &#x3D; value    return resprint(select(&#39;fld2|fld7|fld29&#39;))</code></pre><ol start="15"><li>编写函数，实现base62encode加密（62进制），例如：</li></ol><pre class="language-none"><code class="language-none">内部维护的数据有：0123456789AB..Zab..z(10个数字+26个大写字母+26个小写字母)。当执行函数：base62encode(1)，获取的返回值为1base62encode(61)，获取的返回值为zbase62encode(62)，获取的返回值为10</code></pre><p>答：</p><pre class="language-python" data-language="python"><code class="language-python">import stringdef base62encode(value):    data &#x3D; string.digits + string.ascii_letters    res &#x3D; &#39;&#39;    if value &lt; 62:        res &#x3D; data[value]    count &#x3D; 1    while value &gt; 61:        div, reminder &#x3D; divmod(value, 62)        if div:            res &#x3D; str(div) + data[reminder]        value -&#x3D; div*pow(62, count)    return res</code></pre><p><font color="#dd0000"><strong>存在问题：</strong></font></p><ul><li>可适当简化</li><li>不要把62写死，通过len获取进制</li></ul><pre class="language-none"><code class="language-none">思路：一直让输入的数值除以62取余数，以此取到的余数分别是每一位的索引位置。5&#x2F;62得到 0 , 余数 5         0562&#x2F;62得到 1 , 余数 0         10178&#x2F;62得到 2 ，余数 54         2P98723&#x2F;62 得到1592，余数19          [C,B,K]1592&#x2F;62得到25，余数42</code></pre><pre class="language-python" data-language="python"><code class="language-python">import stringdef base62encode(value):    data &#x3D; string.digits + string.ascii_letters    length &#x3D; len(data)    res &#x3D; &#39;&#39;    while value &gt; 61:        value, reminder &#x3D; divmod(value, 62)        res &#x3D; data[reminder] + res    res &#x3D; data[value] + res    return res</code></pre><ol start="16"><li><p>基于列表推导式一行实现输出9*9乘法表。</p><pre class="language-python" data-language="python"><code class="language-python"># 基于列表推导式一行实现输出9*9乘法表。a &#x3D; [&#39;&#123;&#125;*&#123;&#125;&#x3D;&#123;&#125;\n&#39;.format(j, i, i*j) if j &#x3D;&#x3D; i else &#39;&#123;&#125;*&#123;&#125;&#x3D;&#123;&#125;&#39;.format(j, i, i*j) for i in range(1, 10) for j in range(1, i+1)]for i in a:    if i &#x3D;&#x3D; &#39;1*1&#x3D;1\n&#39;:        print(&#39; &#123;&#125;&#39;.format(i), end&#x3D;&#39; &#39;)        continue    print(i, end&#x3D;&#39; &#39;)</code></pre><p><font color="#dd0000"><strong>另一种思路</strong></font></p><pre class="language-python" data-language="python"><code class="language-python"># 1.输出9个空列表print([[] for i in range(10)])# 2.将九个空列表按9*9乘法表列进行填充print([[&#39;&#123;&#125;*&#123;&#125;&#x3D;&#123;&#125;&#39;.format(j, i, i*j) for j in range(1, i+1)] for i in range(1, 10)])# 3.每个列表中各元素用空格连接，各列表之间用换行符连接print(&#39;\n&#39;.join([&#39; &#39;.join([&#39;&#123;&#125;*&#123;&#125;&#x3D;&#123;&#125;&#39;.format(j, i, i*j) for j in range(1, i+1)]) for i in range(1, 10)]))</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 第二阶段 </tag>
            
            <tag> 函数和模块 </tag>
            
            <tag> 考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>租房闭坑</title>
      <link href="/2022/06/10/zu-fang-bi-keng/"/>
      <url>/2022/06/10/zu-fang-bi-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、西安对外出租房屋分类"><a href="#一、西安对外出租房屋分类" class="headerlink" title="一、西安对外出租房屋分类"></a>一、西安对外出租房屋分类</h2><ul><li><p>城中村</p><blockquote><p>价格区间：800~1000</p><p>特点：房源多、交通好、价格便宜、环境差</p></blockquote></li><li><p>居民老校区</p><blockquote><p>价格区间：1400~2000</p><p>特点：房源少、位置靠近市中心、很少有一室（需要合租），不一定有地铁、但公交发达</p></blockquote></li><li><p><font color="#dd0000">新楼盘</font></p><blockquote><p>价格区间：一室（1500<del>1800）、两室（2200</del>2800）、三室（2500~3500）</p><p>特点：房源多、环境好、位置好、价格高</p></blockquote></li><li><p><font color="#dd0000">单身公寓</font></p><blockquote><p>价格区间：1500~2200</p><p>特点：一般一室户、装修好、房源多、位置稍远、价格高</p></blockquote></li></ul><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li><p>先找工作再找房</p><ul><li><p>居住地到工作地点时间小于30分钟</p></li><li><p>租房开销小于工资30%</p></li></ul></li></ul><h2 id="二、关于长租公寓"><a href="#二、关于长租公寓" class="headerlink" title="二、关于长租公寓"></a>二、关于长租公寓</h2><h3 id="坑一：租房贷"><a href="#坑一：租房贷" class="headerlink" title="坑一：租房贷"></a>坑一：租房贷</h3><p>​就是在用户尚未充分了解情况的前提下，利用租客的信息去银行贷款，转手再用从银行贷得的资金，批量从高价圈占更多房源。</p><blockquote><p>​传统租房的押一付三：押一个月的房租的钱作为押金，再付三个月的房租。(一次性掏四个月的房租)</p></blockquote><blockquote><p>​长租公寓的租房贷：房租月付。（<font color="#dd0000"><strong>几乎都是租房贷：看合同是否与租房机构合作的金融机构申请了一笔12期的租赁贷款,每个月的房租只是在偿还贷款</strong></font>）</p></blockquote><h4 id="长租公寓的租房贷存在问题："><a href="#长租公寓的租房贷存在问题：" class="headerlink" title="长租公寓的租房贷存在问题："></a>长租公寓的租房贷存在问题：</h4><ol><li><p>贷款合同：中途退出无法解除贷款合同，搬走后还要继续支付房租，否则会列入征信黑名单。</p></li><li><p>暴雷：二房东的盈利模式，从房东那租房，装修后，提高价格再租给租客，存在压价太低租不到房子，抬价太高没有租客，加上装修成本、日常维护成本、人力成本、房屋空置损失等问题（青客、蛋壳暴雷）。<font color="#dd0000"><strong>加之公寓高价圈占更多房源，可能造成资金链断裂进而暴雷，发生暴雷的长租公寓已有十几家</strong></font>。</p></li><li><p>甲醛房：长租公寓大多数房源较新，同时空置时间不足，可能存在甲醛超标的问题（自如甲醛房事件）。</p><p>建议：</p><ul><li><p>选择大的租房公司（自如：甲醛房事件已作出承诺）</p></li><li><p>尽量选择运营时间超过一年的房子</p></li><li><p>尽量选择空气流通性较好的房子</p></li><li><p>尽量选择木质家具少的房子</p></li><li><p>尽量选择不贴墙纸的房子 </p></li><li><p>在每一个合适的日子里开窗通风</p></li></ul></li><li><p>违建问题：长租公寓经常将房屋中的客厅或者较大的主卧再改造出一间房单独出租，以提高利润，<font color="#dd0000"><strong>但隔断房并不合法</strong></font>。</p><p>建议：</p><ul><li>**存在隔断房时：不想退房，又不想支付违约金，拨打12345举报可以进行<font color="#dd0000">免责退房</font>**。</li></ul></li></ol><p>总结：</p><ul><li><p>选择大的租房公司（自如：甲醛房事件已作出承诺）</p></li><li><p>注意看租房合同是否有租房贷</p></li><li><p>注意甲醛问题</p></li><li><p>注意违建问题</p></li><li><p>不建议租长租房</p></li></ul><h2 id="参考视频："><a href="#参考视频：" class="headerlink" title="参考视频："></a>参考视频：</h2><ol><li><a href="https://www.bilibili.com/video/BV1mr4y1a7SH?share_source=copy_web">西安最全租房攻略，新手必备！</a></li><li><a href="https://www.bilibili.com/video/BV1fk4y1q7sr?share_source=copy_web">长租公寓：毕业生进入社会遭到的第一顿毒打</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python模块二day3</title>
      <link href="/2022/06/08/python-mo-kuai-er-day5/"/>
      <url>/2022/06/08/python-mo-kuai-er-day5/</url>
      
        <content type="html"><![CDATA[<h2 id="十五、模块"><a href="#十五、模块" class="headerlink" title="十五、模块"></a>十五、模块</h2><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210102105502236.png" class="" title="image-20210102105502236"><p>课程目标：掌握Python中常用模块的使用方法。</p><p>今日概要：</p><ul><li>自定义模块（包）</li><li>第三方模块</li><li>内置模块【1&#x2F;2】</li></ul><h3 id="1-自定义模块"><a href="#1-自定义模块" class="headerlink" title="1. 自定义模块"></a>1. 自定义模块</h3><h4 id="1-1-模块和包"><a href="#1-1-模块和包" class="headerlink" title="1.1 模块和包"></a>1.1 模块和包</h4><pre class="language-python" data-language="python"><code class="language-python">import hashlibdef encrypt(data):    &quot;&quot;&quot; 数据加密 &quot;&quot;&quot;    hash_object &#x3D; hashlib.md5()    hash_object.update(data.encode(&#39;utf-8&#39;))    return hash_object.hexdigest()user &#x3D; input(&quot;请输入用户名：&quot;)pwd &#x3D; input(&quot;请输入密码：&quot;)md5_password &#x3D; encrypt(pwd)message &#x3D; &quot;用户名：&#123;&#125;，密码：&#123;&#125;&quot;.format(user, md5_password)print(message)</code></pre><p>​在开发简单的程序时，使用一个py文件就可以搞定，如果程序比较庞大，需要些10w行代码，此时为了，代码结构清晰，<strong>将功能按照某种规则拆分到不同的py文件中，使用时再去导入即可</strong>。另外，当其他项目也需要此项目的某些模块时，也可以直接把模块拿过去使用，<strong>增加重用性。</strong></p><p>​如果按照某个规则进行拆分，发现拆分到 <code>commons.py</code> 中函数太多，也可以通过文件夹来进行再次拆分，例如：</p><pre class="language-none"><code class="language-none">├── commons│   ├── convert.py│   ├── page.py│   └── utils.py└── run.py</code></pre><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210103144059473.png" class="" title="image-20210103144059473"><p>在Python中一般对文件和文件夹的称呼（很多开发者的平时开发中也有人都称为模块）</p><ul><li>一个py文件，模块（module）。</li><li>含多个py文件的文件夹，包（package）。</li></ul><p>注意：在包（文件夹）中有一个默认内容为空的<code>__init__.py</code>的文件，一般用于描述当前包的信息（在导入他下面的模块时，也会自动加载）。</p><ul><li>py2必须有，如果没有导入包就会失败。</li><li>py3可有可无。</li></ul><h4 id="1-2-导入"><a href="#1-2-导入" class="headerlink" title="1.2 导入"></a>1.2 导入</h4><p>​当定义好一个模块或包之后，如果想要使用其中定义的功能，必须要<strong>先导入，然后再能使用</strong>。导入，其实就是将模块或包加载的内存中，以后再去内存中去拿就行。</p><p>关于导如时的路径：</p><blockquote><p> 在Python内部默认设置了一些路径，导入模块或包时，都会按照指定顺序逐一去特定的路径查找。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">import sysprint(sys.path)</code></pre><pre class="language-python" data-language="python"><code class="language-python">[    &#39;当前执行脚本所在的目录&#39;, &#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day14&#x2F;bin&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day14    &#39;&#x2F;Applications&#x2F;PyCharm.app&#x2F;Contents&#x2F;plugins&#x2F;python&#x2F;helpers&#x2F;pycharm_display&#39;,    &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;lib&#x2F;python39.zip&#39;,    &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;lib&#x2F;python3.9&#39;,    &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;lib&#x2F;python3.9&#x2F;lib-dynload&#39;,    &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#39;,    &#39;&#x2F;Applications&#x2F;PyCharm.app&#x2F;Contents&#x2F;plugins&#x2F;python&#x2F;helpers&#x2F;pycharm_matplotlib_backend&#39;    ]</code></pre><p>​想要导入任意的模块和包，都必须写在如上路径，才能被找到。也可以自动手动在sys.path中添加指定路径，然后再导入可以，例如：</p><pre class="language-python" data-language="python"><code class="language-python">import syssys.path.append(&quot;路径A&quot;)import xxxxx  # 导入路径A下的一个xxxxx.py文件</code></pre><ol><li><font color="#dd0000"><strong>你以后写模块名称时，千万不能和内置和第三方的同名（新手容易犯错误）。</strong></font></li><li><font color="#dd0000"><strong>项目执行文件一般都在项目根目录，如果执行文件嵌套的内存目录，就需要自己手动在sys.path中添加路径。</strong></font><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210103163446464.png" class="" title="image-20210103163446464"></li><li><font color="#dd0000"><strong>pycharm中默认会将项目目录加入到sys.path中</strong></font></li></ol><p>关于导入的方式：</p><p>​导入本质上是<strong>将某个文件中的内容先加载到内存中，然后再去内存中拿过来使用。</strong>而在Python开发中常用的导入的方式有2类方式，每类方式都也多种情况。</p><ul><li><p><font color="#dd0000"><strong>第一类：import xxxx（开发中，一般多用于导入sys.path目录下的一个py文件或包）</strong></font></p><ul><li><p>模块级别</p><pre class="language-none"><code class="language-none">├── commons│   ├── __init__.py│   ├── convert.py│   ├── page.py│   ├── tencent│   │   ├── __init__.py│   │   ├── sms.py│   │   └── wechat.py│   └── utils.py├── many.py└── run.py</code></pre><img src="Python模块二day5/image-20210102175534535.png" alt="image-20210102175534535" style="zoom: 40%; float: left;" /></li><li><p>包级别</p><pre class="language-none"><code class="language-none">├── commons│   ├── __init__.py│   ├── convert.py│   ├── page.py│   └── utils.py├── third│   ├── __init__.py│   ├── ali│   │   └── oss.py│   └── tencent│       ├── __init__.py│       ├── __pycache__│       ├── sms.py│       └── wechat.py└── run.py</code></pre><img src="Python模块二day5/image-20210102180002867.png" alt="image-20210102180002867" style="zoom:50%;float:left;" /></li></ul></li><li><p>第二类：<font color="#dd0000"><strong>from xxx import xxx 【常用】，一般适用于多层嵌套和导入模块、包和其中某个成员的情况。</strong></font></p><ul><li><p>成员级别</p><pre class="language-none"><code class="language-none">├── commons│   ├── __init__.py│   ├── convert.py│   ├── page.py│   └── utils.py├── many.py└── run.py</code></pre><img src="Python模块二day5/image-20210102173907386.png" alt="image-20210102173907386" style="zoom:40%;float:left;" /><p>提示：基于from模式也可以支持 <code>from many import *</code>，即：导入一个模块中所有的成员（可能会重名，所以用的少）。</p></li><li><p>模块级别</p><pre class="language-none"><code class="language-none">├── commons│   ├── __init__.py│   ├── convert.py│   ├── page.py│   └── utils.py├── many.py└── run.py</code></pre><img src="Python模块二day5/image-20210102174119314.png" alt="image-20210102174119314" style="zoom:40%;float:left" /></li><li><p>包级别</p><pre class="language-python" data-language="python"><code class="language-python">├── commons│   ├── __init__.py│   ├── convert.py│   ├── page.py│   ├── tencent│   │   ├── __init__.py│   │   ├── sms.py│   │   └── wechat.py│   └── utils.py├── many.py└── run.py</code></pre><img src="Python模块二day5/image-20210102182326500.png" alt="image-20210102182326500" style="zoom:40%;float:left;" /></li></ul></li></ul><h4 id="1-3-相对导入（不建议使用）"><a href="#1-3-相对导入（不建议使用）" class="headerlink" title="1.3 相对导入（不建议使用）"></a>1.3 相对导入（不建议使用）</h4><p>​在导入模块时，对于 <code>from xx import xx</code>这种模式，还支持相对到导入。例如：</p><img src="Python模块二day5/image-20210102182539642.png" alt="image-20210102182539642" style="zoom:50%;" /><p>​<font color="#dd0000"><strong>切记</strong></font>，相对导入只能用在包中的py文件中（即：嵌套在文件中的py文件才可以使用，项目根目录下无法使用）。</p><img src="Python模块二day5/image-20210102182921911.png" alt="image-20210102182921911" style="zoom: 43%;" /><h4 id="1-4-导入别名"><a href="#1-4-导入别名" class="headerlink" title="1.4 导入别名"></a>1.4 导入别名</h4><p>​如果项目中导入 成员&#x2F;模块&#x2F;包 有重名，那么后导入的会覆盖之前导入，为了避免这种情况的发生，Python支持重命名，即：</p><pre class="language-python" data-language="python"><code class="language-python">from xxx.xxx import xx as xoimport x1.x2 as pg</code></pre><p>除此之外，有了as的存在，让 import xx.xxx.xxxx.xxx 在调用执行时，会更加简单（<strong>不常用，了解即可</strong>）。</p><ul><li><p>原来</p><pre class="language-python" data-language="python"><code class="language-python">import commons.pagev1 &#x3D; commons.page.pagination()</code></pre></li><li><p>现在</p><pre class="language-python" data-language="python"><code class="language-python">import commons.page as pgv1 &#x3D; pg.pagination()</code></pre></li></ul><h4 id="1-5-主文件"><a href="#1-5-主文件" class="headerlink" title="1.5 主文件"></a>1.5 主文件</h4><ul><li><p>执行一个py文件时</p><pre class="language-none"><code class="language-none">__name__ &#x3D; &quot;__main__&quot;</code></pre></li><li><p>导入一个py文件时</p><pre class="language-python" data-language="python"><code class="language-python">__name__ &#x3D; &quot;模块名&quot;</code></pre></li></ul><p>​主文件，其实就是在程序执行的入口文件，例如：</p><pre class="language-python" data-language="python"><code class="language-python">├── commons│   ├── __init__.py│   ├── convert.py│   ├── page.py│   ├── tencent│   │   ├── __init__.py│   │   ├── sms.py│   │   └── wechat.py│   └── utils.py├── many.py└── run.py</code></pre><p>​我们通常是执行 run.py 去运行程序，其他的py文件都是一些功能代码。当我们去执行一个文件时，文件内部的 <code>__name__</code>变量的值为 <code>__main__</code>，所以，主文件经常会看到：</p><pre class="language-python" data-language="python"><code class="language-python">import manyfrom commons import pagefrom commons import utilsdef start():    v1 &#x3D; many.show()    v2 &#x3D; page.pagination()    v3 &#x3D; utils.encrypt()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    start()</code></pre><p>​只有是以主文件的形式运行此脚本时start函数才会执行，被导入时则不会被执行。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li><p>模块和包的区别</p></li><li><p>导入模块的两种方式：</p><pre class="language-none"><code class="language-none">import xxfrom xxx import xxx</code></pre></li><li><p>相对导入，需要有包名称。</p></li><li><p>模块重名可以通过as取别名。</p></li><li><p>执行py文件时，内部<code>__name__==&quot;__main__&quot;</code>，导入模块时，被导入的模块 <code>__name__=&quot;模块名&quot;</code></p></li><li><p>在项目开发中，一般在主文件中会写上 main （主文件标记，不是绝对的，因为其他文件在开发调试时候有时候也可能有main）。</p></li></ol><h3 id="2-第三方模块"><a href="#2-第三方模块" class="headerlink" title="2. 第三方模块"></a>2. 第三方模块</h3><p>Python内部提供的模块有限，所以在平时在开发的过程中，经常会使用第三方模块。</p><p>而第三方模块必须要先安装才能可以使用，下面介绍常见的3中安装第三方模块的方式。</p><p>其实，使用第三方模块的行为就是去用别人写好并开源出来的py代码，这样自己拿来就用，不必重复造轮子了。。。。</p><h4 id="2-1-pip（最常用）"><a href="#2-1-pip（最常用）" class="headerlink" title="2.1 pip（最常用）"></a>2.1 pip（最常用）</h4><p>这是Python中最最最常用的安装第三方模块的方式。</p><p>pip其实是一个第三方模块包管理工具，默认安装Python解释器时自动会安装，默认目录：</p><pre class="language-none"><code class="language-none">MAC系统，即：Python安装路径的bin目录下&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;pip3&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;pip3.9Windows系统，即：Python安装路径的scripts目录下C:\Python39\Scripts\pip3.exeC:\Python39\Scripts\pip3.9.exe</code></pre><p>提示：为了方便在终端运行pip管理工具，我们也会把它所在的路径添加到系统环境变量中。</p><pre class="language-none"><code class="language-none">pip3 install 模块名称</code></pre><p>如果你的电脑上某个写情况没有找到pip，也可以自己手动安装：</p><ul><li><p>下载 <code>get-pip.py</code> 文件，到任意目录</p><pre class="language-none"><code class="language-none">地址：https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py</code></pre></li><li><p>打开终端进入目录，用Python解释器去运行已下载的 <code>get-pip.py</code>文件即刻安装成功。</p><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210102191829546.png" class="" title="image-20210102191829546"></li></ul><p>使用pip去安装第三方模块也非常简单，只需要在自己终端执行：<code>pip install 模块名称</code> 即可。</p><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210102192637805.png" class="" title="image-20210102192637805"><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210102192757171.png" class="" title="image-20210102192757171"><p>默认安装的是最新的版本，如果想要指定版本：</p><pre class="language-python" data-language="python"><code class="language-python">pip3 install 模块名称&#x3D;&#x3D;版本例如：pip3 install django&#x3D;&#x3D;2.2</code></pre><h5 id="2-1-1-pip更新"><a href="#2-1-1-pip更新" class="headerlink" title="2.1.1 pip更新"></a>2.1.1 pip更新</h5><p>​上图的黄色字体提示：目前我电脑上的pip是20.2.3版本，最新的是 20.3.3 版本，如果想要升级为最新的版本，可以在终端执行他提示的命令：</p><pre class="language-none"><code class="language-none">&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;python3.9 -m pip install --upgrade pip</code></pre><p>注意：根据自己电脑的提示命令去执行，不要用我这里的提示命令哈。</p><h5 id="2-1-2-豆瓣源"><a href="#2-1-2-豆瓣源" class="headerlink" title="2.1.2 豆瓣源"></a>2.1.2 豆瓣源</h5><p>​<strong>pip默认是去 <code>https://pypi.org</code> 去下载第三方模块（本质上就是别人写好的py代码），国外的网站速度会比较慢，为了加速可以使用国内的豆瓣源。</strong></p><ul><li><p>一次性使用</p><pre class="language-none"><code class="language-none">pip3.9 install 模块名称  -i  https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;</code></pre></li><li><p>永久使用</p><ul><li><p>配置</p><pre class="language-none"><code class="language-none"># 在终端执行如下命令pip3.9 config set global.index-url https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;# 执行完成后，提示在我的本地文件中写入了豆瓣源，以后再通过pip去安装第三方模块时，就会默认使用豆瓣源了。# 自己以后也可以打开文件直接修改源地址。Writing to &#x2F;Users&#x2F;wupeiqi&#x2F;.config&#x2F;pip&#x2F;pip.conf</code></pre></li><li><p>使用</p><pre class="language-none"><code class="language-none">pip3.9 install 模块名称</code></pre></li></ul></li></ul><p>写在最后，也还有其他的源可供选择（豆瓣应用广泛）。</p><pre class="language-none"><code class="language-none">阿里云：http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;中国科技大学：https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F; 清华大学：https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;中国科学技术大学：http:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;</code></pre><h4 id="2-2-源码"><a href="#2-2-源码" class="headerlink" title="2.2 源码"></a>2.2 源码</h4><p>​如果要安装的模块在pypi.org中不存在 或 因特殊原因无法通过pip install 安装时，可以直接下载源码，然后基于源码安装，例如：</p><ul><li><p>下载requests源码（压缩包zip、tar、tar.gz）并解压。</p><pre class="language-none"><code class="language-none">下载地址：https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;requests&#x2F;#files</code></pre></li><li><p>进入目录</p></li><li><p>执行编译和安装命令</p><pre class="language-none"><code class="language-none">python3 setup.py buildpython3 setup.py install</code></pre><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210102215833498.png" class="" title="image-20210102215833498"></li></ul><h4 id="2-3-wheel"><a href="#2-3-wheel" class="headerlink" title="2.3 wheel"></a>2.3 wheel</h4><p>​wheel是Python的第三方模块包的文件格式的一种，我们也可以基于wheel去安装一些第三方模块。</p><ul><li><p>安装wheel格式支持，这样pip再安装第三方模块时，就可以处理wheel格式的文件了。</p><pre class="language-python" data-language="python"><code class="language-python">pip3.9 install wheel</code></pre></li><li><p>下载第三方的包（wheel格式），例如：<a href="https://pypi.org/project/requests/#files">https://pypi.org/project/requests/#files</a></p><img src="Python模块二day5/image-20210102221033465.png" alt="image-20210102221033465" style="zoom:50%;" /></li><li><p>进入下载目录，在终端基于pip直接安装</p><img src="Python模块二day5/image-20210102221254461.png" alt="image-20210102221254461" style="zoom:50%;" /></li></ul><p>无论通过什么形式去安装第三方模块，默认模块的安装路径在：</p><pre class="language-none"><code class="language-none">Max系统：&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;lib&#x2F;python3.9&#x2F;site-packagesWindows系统：C:\Python39\Lib\site-packages\</code></pre><p>提醒：这个目录在sys.path中，所以我们直接在代码中直接导入下载的第三方包是没问题的。</p><h3 id="3-内置模块（一）"><a href="#3-内置模块（一）" class="headerlink" title="3.内置模块（一）"></a>3.内置模块（一）</h3><p>​Python内置的模块有很多，我们也已经接触了不少相关模块，接下来咱们就来做一些汇总和介绍。内置模块有很多 &amp; 模块中的功能也非常多，我们是没有办法注意全局给大家讲解，在此我会整理出项目开发最常用的来进行讲解。</p><h4 id="3-1-os"><a href="#3-1-os" class="headerlink" title="3.1 os"></a>3.1 os</h4><pre class="language-python" data-language="python"><code class="language-python">import os# 1. 获取当前脚本绝对路径&quot;&quot;&quot;abs_path &#x3D; os.path.abspath(__file__)print(abs_path)&quot;&quot;&quot;# 2. 获取当前文件的上级目录&quot;&quot;&quot;base_path &#x3D; os.path.dirname( os.path.dirname(路径) ）print(base_path)&quot;&quot;&quot;# 3. 路径拼接&quot;&quot;&quot;p1 &#x3D; os.path.join(base_path, &#39;xx&#39;)print(p1)p2 &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;a1.png&#39;)print(p2)&quot;&quot;&quot;# 4. 判断路径是否存在&quot;&quot;&quot;exists &#x3D; os.path.exists(p1)print(exists)&quot;&quot;&quot;# 5. 创建文件夹&quot;&quot;&quot;os.makedirs(路径)&quot;&quot;&quot;&quot;&quot;&quot;path &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;uuuu&#39;)if not os.path.exists(path):    os.makedirs(path)&quot;&quot;&quot;# 6. 是否是文件夹&quot;&quot;&quot;file_path &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;uuuu.png&#39;)is_dir &#x3D; os.path.isdir(file_path)print(is_dir) # Falsefolder_path &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;uuuu&#39;)is_dir &#x3D; os.path.isdir(folder_path)print(is_dir) # True&quot;&quot;&quot;# 7. 删除文件或文件夹&quot;&quot;&quot;os.remove(&quot;文件路径&quot;)&quot;&quot;&quot;&quot;&quot;&quot;path &#x3D; os.path.join(base_path, &#39;xx&#39;)shutil.rmtree(path)&quot;&quot;&quot;</code></pre><ul><li>listdir，查看目录下所有的文件</li><li>walk，查看目录下所有的文件（含子孙文件）</li></ul><pre class="language-python" data-language="python"><code class="language-python">import os&quot;&quot;&quot;data &#x3D; os.listdir(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day14&#x2F;commons&quot;)print(data)# [&#39;convert.py&#39;, &#39;__init__.py&#39;, &#39;page.py&#39;, &#39;__pycache__&#39;, &#39;utils.py&#39;, &#39;tencent&#39;]&quot;&quot;&quot;&quot;&quot;&quot;要遍历一个文件夹下的所有文件，例如：遍历文件夹下的所有mp4文件&quot;&quot;&quot;data &#x3D; os.walk(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;Documents&#x2F;视频教程&#x2F;路飞Python&#x2F;mp4&quot;)for path, folder_list, file_list in data:    for file_name in file_list:        file_abs_path &#x3D; os.path.join(path, file_name)        ext &#x3D; file_abs_path.rsplit(&quot;.&quot;,1)[-1]        if ext &#x3D;&#x3D; &quot;mp4&quot;:            print(file_abs_path)</code></pre><h4 id="3-2-shutil"><a href="#3-2-shutil" class="headerlink" title="3.2 shutil"></a>3.2 shutil</h4><pre class="language-python" data-language="python"><code class="language-python">import shutil# 1. 删除文件夹&quot;&quot;&quot;path &#x3D; os.path.join(base_path, &#39;xx&#39;)shutil.rmtree(path)&quot;&quot;&quot;# 2. 拷贝文件夹&quot;&quot;&quot;shutil.copytree(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;Desktop&#x2F;图&#x2F;csdn&#x2F;&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;files&quot;)&quot;&quot;&quot;# 3.拷贝文件&quot;&quot;&quot;shutil.copy(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;Desktop&#x2F;图&#x2F;csdn&#x2F;WX20201123-112406@2x.png&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;&quot;)shutil.copy(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;Desktop&#x2F;图&#x2F;csdn&#x2F;WX20201123-112406@2x.png&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;x.png&quot;)&quot;&quot;&quot;# 4.文件或文件夹重命名&quot;&quot;&quot;shutil.move(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;x.png&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;xxxx.png&quot;)shutil.move(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;files&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;images&quot;)&quot;&quot;&quot;# 5. 压缩文件&quot;&quot;&quot;# base_name，压缩后的压缩包文件# format，压缩的格式，例如：&quot;zip&quot;, &quot;tar&quot;, &quot;gztar&quot;, &quot;bztar&quot;, or &quot;xztar&quot;.# root_dir，要压缩的文件夹路径&quot;&quot;&quot;# shutil.make_archive(base_name&#x3D;r&#39;datafile&#39;,format&#x3D;&#39;zip&#39;,root_dir&#x3D;r&#39;files&#39;)# 6. 解压文件&quot;&quot;&quot;# filename，要解压的压缩包文件# extract_dir，解压的路径# format，压缩文件格式&quot;&quot;&quot;# shutil.unpack_archive(filename&#x3D;r&#39;datafile.zip&#39;, extract_dir&#x3D;r&#39;xxxxxx&#x2F;xo&#39;, format&#x3D;&#39;zip&#39;)</code></pre><h4 id="3-3-sys"><a href="#3-3-sys" class="headerlink" title="3.3 sys"></a>3.3 sys</h4><pre class="language-python" data-language="python"><code class="language-python">import sys# 1. 获取解释器版本&quot;&quot;&quot;print(sys.version)print(sys.version_info)print(sys.version_info.major, sys.version_info.minor, sys.version_info.micro)&quot;&quot;&quot;# 2. 导入模块路径&quot;&quot;&quot;print(sys.path)&quot;&quot;&quot;</code></pre><ul><li>argv，执行脚本时，python解释器后面传入的参数</li></ul><pre class="language-python" data-language="python"><code class="language-python">import sysprint(sys.argv)# [#       &#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day14&#x2F;2.接受执行脚本的参数.py&#39;# ]# [#     &quot;2.接受执行脚本的参数.py&quot;# ]# [&#39;2.接受执行脚本的参数.py&#39;, &#39;127&#39;, &#39;999&#39;, &#39;666&#39;, &#39;wupeiqi&#39;]# 例如，请实现下载图片的一个工具。def download_image(url):    print(&quot;下载图片&quot;, url)def run():    # 接受用户传入的参数    url_list &#x3D; sys.argv[1:]    for url in url_list:        download_image(url)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    run()</code></pre><h4 id="3-4-random"><a href="#3-4-random" class="headerlink" title="3.4 random"></a>3.4 random</h4><pre class="language-python" data-language="python"><code class="language-python">import random# 1. 获取范围内的随机整数v &#x3D; random.randint(10, 20)print(v)# 2. 获取范围内的随机小数v &#x3D; random.uniform(1, 10)print(v)# 3. 随机抽取一个元素v &#x3D; random.choice([11, 22, 33, 44, 55])print(v)# 4. 随机抽取多个元素v &#x3D; random.sample([11, 22, 33, 44, 55], 3)print(v)# 5. 打乱顺序data &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]random.shuffle(data)print(data)</code></pre><h4 id="3-5-hashlib"><a href="#3-5-hashlib" class="headerlink" title="3.5 hashlib"></a>3.5 hashlib</h4><pre class="language-python" data-language="python"><code class="language-python">import hashlibhash_object &#x3D; hashlib.md5()hash_object.update(&quot;武沛齐&quot;.encode(&#39;utf-8&#39;))result &#x3D; hash_object.hexdigest()print(result)</code></pre><pre class="language-python" data-language="python"><code class="language-python">import hashlibhash_object &#x3D; hashlib.md5(&quot;iajfsdunjaksdjfasdfasdf&quot;.encode(&#39;utf-8&#39;))hash_object.update(&quot;武沛齐&quot;.encode(&#39;utf-8&#39;))result &#x3D; hash_object.hexdigest()print(result)</code></pre><h4 id="3-6-configparser"><a href="#3-6-configparser" class="headerlink" title="3.6 configparser"></a>3.6 configparser</h4><p>见：day09</p><h4 id="3-7-xml"><a href="#3-7-xml" class="headerlink" title="3.7 xml"></a>3.7 xml</h4><p>见：day09</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>模块和包的区别</p></li><li><p>了解如何导入模块</p><ul><li>路径</li><li>导入方式</li></ul></li><li><p>导入模块时一般要遵循的规范【补充】</p><ul><li><p>注释：使用<strong>双引号</strong>在文件顶部或init文件中。</p></li><li><p>在文件顶部导入</p></li><li><p>有规则导入，并用空行分割。</p><pre class="language-none"><code class="language-none"># 先内置模块# 再第三方模块# 最后自定义模块</code></pre><pre class="language-none"><code class="language-none">import osimport sysimport randomimport hashlibimport requestsimport openpyxlfrom commons.utils import encrypt</code></pre></li></ul></li><li><p>第三方模块安装的方法</p></li><li><p>常见内置模块</p></li></ol><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol><li><p>自己去网上搜索如何基于Python计算mp4视频的时长，最终实现用代码统计某个文件夹下所有mp4的时长。</p><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;本模块功能为统计某个文件夹下所有mp4的时长&quot;&quot;&quot;import osfrom moviepy.editor import VideoFileClipdef get_file_names(path):    # 遍历文件夹下所有目录并返回生成器    data &#x3D; os.walk(path)    # 找到所有mp4文件    for path, folder_list, file_list in data:        for file_name in file_list:            file_abs_path &#x3D; os.path.join(path, file_name)                        if file_abs_path.endswith(&#39;.mp4&#39;):                yield file_abs_pathif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    # 这里我的文件都在D:\FFOutput目录下    path &#x3D; &quot;E:\\美剧&quot;    l &#x3D; get_file_names(path)        sum_time &#x3D; 0.    for f in l:        # print(f)        clip &#x3D; VideoFileClip(f)        sum_time +&#x3D; clip.duration        # 计算视频的时长，单位为分钟        print(f, clip.duration)        clip.close()    print(&#39;文件夹:&#123;&#125;，电影总时长为&#123;&#125;&#39;.format(path, sum_time))</code></pre></li></ol><h2 id="十六、内置模块和开发规范"><a href="#十六、内置模块和开发规范" class="headerlink" title="十六、内置模块和开发规范"></a>十六、内置模块和开发规范</h2><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210104122555935.png" class="" title="image-20210104122555935"><p>目标：掌握常见的内置模块的使用及了解软件开发的规范。</p><p>今日概要：</p><ul><li>内置模块<ul><li>json</li><li>time</li><li>datetime</li><li>re</li></ul></li><li>开发规范<ul><li>主文件</li><li>配置文件</li><li>数据</li><li>附件</li><li>业务代码</li></ul></li></ul><h3 id="1-内置模块"><a href="#1-内置模块" class="headerlink" title="1. 内置模块"></a>1. 内置模块</h3><h4 id="1-1-json"><a href="#1-1-json" class="headerlink" title="1.1 json"></a>1.1 json</h4><p>​json模块，是python内部的一个模块，可以将python的数据格式 转换为json格式的数据，也可以将json格式的数据转换为python的数据格式。</p><p>​json格式，是一个数据格式（<font color="#dd0000"><strong>本质上就是个字符串，常用语网络数据传输</strong></font>）</p><pre class="language-python" data-language="python"><code class="language-python"># Python中的数据类型的格式data &#x3D; [    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;,    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;,    (&#39;wupeiqi&#39;,123),]# JSON格式value &#x3D; &#39;[&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;,[&quot;wupeiqi&quot;,123]]&#39;</code></pre><h5 id="1-1-1-核心功能"><a href="#1-1-1-核心功能" class="headerlink" title="1.1.1 核心功能"></a>1.1.1 核心功能</h5><p>​json格式的作用？</p><pre class="language-none"><code class="language-none">跨语言数据传输，例如：A系统用Python开发，有列表类型和字典类型等。B系统用Java开发，有数组、map等的类型。语言不同，基础数据类型格式都不同。为了方便数据传输，大家约定一个格式：json格式，每种语言都是将自己数据类型转换为json格式，也可以将json格式的数据转换为自己的数据类型。</code></pre><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210104123415566.png" class="" title="image-20210104123415566"><p>Python数据类型与json格式的相互转换：</p><ul><li><p><font color="#dd0000"><strong>数据类型 -&gt; json ，一般称为：序列化</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">import jsondata &#x3D; [    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;,    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;,]res &#x3D; json.dumps(data)print(res) # &#39;[&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;\u6b66\u6c9b\u9f50&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;]&#39;res &#x3D; json.dumps(data, ensure_ascii&#x3D;False)print(res) # &#39;[&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;]&#39;</code></pre></li><li><p><strong>json格式 -&gt; 数据类型，一般称为：反序列化</strong></p><pre class="language-python" data-language="python"><code class="language-python">import jsondata_string &#x3D; &#39;[&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;]&#39;data_list &#x3D; json.loads(data_string)print(data_list)</code></pre></li></ul><p><strong>练习题</strong></p><ol><li><p>写网站，给用户返回json格式数据</p><ul><li><p>安装flask模块，协助我们快速写网站（之前已安装过）</p><pre class="language-python" data-language="python"><code class="language-python">pip3 install flask</code></pre></li><li><p>使用flask写网站</p><pre class="language-python" data-language="python"><code class="language-python">import jsonfrom flask import Flaskapp &#x3D; Flask(__name__)def index():    return &quot;首页&quot;def users():    data &#x3D; [        &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;,        &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;,    ]    return json.dumps(data)app.add_url_rule(&#39;&#x2F;index&#x2F;&#39;, view_func&#x3D;index, endpoint&#x3D;&#39;index&#39;)app.add_url_rule(&#39;&#x2F;users&#x2F;&#39;, view_func&#x3D;users, endpoint&#x3D;&#39;users&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app.run()</code></pre></li></ul></li><li><p>发送网络请求，获取json格式数据并处理。</p><pre class="language-python" data-language="python"><code class="language-python">import jsonimport requestsurl &#x3D; &quot;https:&#x2F;&#x2F;movie.douban.com&#x2F;j&#x2F;search_subjects?type&#x3D;movie&amp;tag&#x3D;%E7%83%AD%E9%97%A8&amp;sort&#x3D;recommend&amp;page_limit&#x3D;5&amp;page_start&#x3D;20&quot;res &#x3D; requests.get(    url&#x3D;url,    headers&#x3D;&#123;        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36&quot;    &#125;)# json格式print(res.text)# json格式转换为python数据类型data_dict &#x3D; json.loads(res.text)print(data_dict)</code></pre></li></ol><h5 id="1-1-2-类型要求"><a href="#1-1-2-类型要求" class="headerlink" title="1.1.2 类型要求"></a>1.1.2 类型要求</h5><p>​python的数据类型转换为 json 格式，对数据类型是有要求的，默认只支持：</p><pre class="language-none"><code class="language-none">+-------------------+---------------+| Python            | JSON          |+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+| dict              | object        |+-------------------+---------------+| list, tuple       | array         |+-------------------+---------------+| str               | string        |+-------------------+---------------+| int, float        | number        |+-------------------+---------------+| True              | true          |+-------------------+---------------+| False             | false         |+-------------------+---------------+| None              | null          |+-------------------+---------------+</code></pre><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; [    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;,    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;,]</code></pre><p>​其他类型如果想要支持，需要自定义<code>JSONEncoder </code>才能实现【目前只需要了解大概意思即可，以后项目开发中用到了还会讲解。】，例如：</p><pre class="language-python" data-language="python"><code class="language-python">import jsonfrom decimal import Decimalfrom datetime import datetimedata &#x3D; [    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18, &#39;size&#39;: Decimal(&quot;18.99&quot;), &#39;ctime&#39;: datetime.now()&#125;,    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18, &#39;size&#39;: Decimal(&quot;9.99&quot;), &#39;ctime&#39;: datetime.now()&#125;,]class MyJSONEncoder(json.JSONEncoder):    def default(self, o):        if type(o) &#x3D;&#x3D; Decimal:            return str(o)        elif type(o) &#x3D;&#x3D; datetime:            return o.strftime(&quot;%Y-%M-%d&quot;)        return super().default(o)res &#x3D; json.dumps(data, cls&#x3D;MyJSONEncoder)print(res)</code></pre><h5 id="1-1-3-其他功能"><a href="#1-1-3-其他功能" class="headerlink" title="1.1.3 其他功能"></a>1.1.3 其他功能</h5><p>json模块中常用的是：</p><ul><li><p><code>json.dumps</code>，序列化生成一个字符串。</p></li><li><p><code>json.loads</code>，发序列化生成python数据类型。</p></li><li><p><code>json.dump</code>，将数据序列化并写入文件（不常用）</p><pre class="language-python" data-language="python"><code class="language-python">import jsondata &#x3D; [    &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;,    &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18&#125;,]file_object &#x3D; open(&#39;xxx.json&#39;, mode&#x3D;&#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;)json.dump(data, file_object)file_object.close()</code></pre></li><li><p><code>json.load</code>，读取文件中的数据并反序列化为python的数据类型（不常用）</p><pre class="language-python" data-language="python"><code class="language-python">import jsonfile_object &#x3D; open(&#39;xxx.json&#39;, mode&#x3D;&#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;)data &#x3D; json.load(file_object)print(data)file_object.close()</code></pre></li></ul><h4 id="1-2-时间处理"><a href="#1-2-时间处理" class="headerlink" title="1.2 时间处理"></a>1.2 时间处理</h4><ul><li><p>UTC&#x2F;GMT：世界时间</p></li><li><p>本地时间：本地时区的时间。</p></li></ul><p>Python中关于时间处理的模块有两个，分别是time和datetime。</p><h5 id="1-2-1-time"><a href="#1-2-1-time" class="headerlink" title="1.2.1 time"></a>1.2.1 time</h5><pre class="language-python" data-language="python"><code class="language-python">import time# 获取当前时间戳（自1970-1-1 00:00）v1 &#x3D; time.time()  # 单位秒print(v1)# 时区v2 &#x3D; time.timezoneprint(v2, v2&#x2F;60&#x2F;60)  # 单位秒 小时：v2&#x2F;60&#x2F;60  东八区# 停止n秒，再执行后续的代码。print(&#39;开始&#39;)time.sleep(5)print(&#39;结束&#39;)</code></pre><h5 id="1-2-2-datetime"><a href="#1-2-2-datetime" class="headerlink" title="1.2.2 datetime"></a>1.2.2 datetime</h5><p>​在平时开发过程中的时间一般是以为如下三种格式存在：</p><ul><li><p>datetime</p><pre class="language-python" data-language="python"><code class="language-python">from datetime import datetime, timezone, timedeltav1 &#x3D; datetime.now()  # 当前本地时间print(v1)tz &#x3D; timezone(timedelta(hours&#x3D;7))  # 当前东7区时间v2 &#x3D; datetime.now(tz)print(v2)v3 &#x3D; datetime.utcnow()  # 当前UTC时间print(v3)</code></pre><pre class="language-python" data-language="python"><code class="language-python">from datetime import datetime, timedeltav1 &#x3D; datetime.now()print(v1)# 时间的加减v2 &#x3D; v1 + timedelta(days&#x3D;140, minutes&#x3D;5)print(v2)</code></pre><p>​<strong>注意：<code>datetime</code>类型 和 <code>timedelta</code>类型之间<font color="#dd0000">支持加减运算</font></strong></p><pre class="language-python" data-language="python"><code class="language-python">from datetime import datetime, timezone, timedeltav1 &#x3D; datetime.now()print(v1)v2 &#x3D; datetime.utcnow()  # 当前UTC时间print(v2)# datetime之间相减，计算间隔时间（不能相加）data &#x3D; v1 - v2print(data.days, data.seconds &#x2F; 60 &#x2F; 60, data.microseconds)# datetime类型 - datetime类型# datetime类型 比较 datetime类型</code></pre><p>​<strong>注意：<code>datetime</code>类型 和 <code>datetime</code>类型之间<font color="#dd0000">只支持减运算和比较运算不能相加</font></strong></p></li><li><p>字符串</p><pre class="language-python" data-language="python"><code class="language-python"># 字符串格式的时间  ---&gt; 转换为datetime格式时间text &#x3D; &quot;2021-11-11&quot;v1 &#x3D; datetime.strptime(text,&#39;%Y-%m-%d&#39;) # %Y 年，%m，月份，%d，天。print(v1)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># datetime格式 ----&gt; 转换为字符串格式v1 &#x3D; datetime.now()val &#x3D; v1.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)print(val)</code></pre></li><li><p>时间戳</p><pre class="language-python" data-language="python"><code class="language-python"># 时间戳格式 --&gt; 转换为datetime格式ctime &#x3D; time.time() # 11213245345.123v1 &#x3D; datetime.fromtimestamp(ctime)print(v1)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># datetime格式 ---&gt; 转换为时间戳格式v1 &#x3D; datetime.now()val &#x3D; v1.timestamp()print(val)</code></pre></li></ul><img src="/2022/06/08/python-mo-kuai-er-day5/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20220608200220.jpg" class="" title="微信图片编辑_20220608200220"><p><strong>练习题</strong></p><ol><li><p>日志记录，将用户输入的信息写入到文件，文件名格式为<code>年-月-日-时-分.txt</code>。</p><pre class="language-python" data-language="python"><code class="language-python">from datetime import datetimewhile True:    text &#x3D; input(&quot;请输入内容：&quot;)    if text.upper() &#x3D;&#x3D; &quot;Q&quot;:        break            current_datetime &#x3D; datetime.now().strftime(&quot;%Y-%m-%d-%H-%M&quot;)    file_name &#x3D; &quot;&#123;&#125;.txt&quot;.format(current_datetime)        with open(file_name, mode&#x3D;&#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;) as file_object:        file_object.write(text)        file_object.flush()</code></pre></li><li><p>用户注册，将用户信息写入Excel，其中包含：用户名、密码、注册时间 三列。</p><pre class="language-python" data-language="python"><code class="language-python">import osimport hashlibfrom datetime import datetimefrom openpyxl import load_workbookfrom openpyxl import workbookBASE_DIR &#x3D; os.path.dirname(os.path.abspath(__file__))FILE_NAME &#x3D; &quot;db.xlsx&quot;def md5(origin):    hash_object &#x3D; hashlib.md5(&quot;sdfsdfsdfsd23sd&quot;.encode(&#39;utf-8&#39;))    hash_object.update(origin.encode(&#39;utf-8&#39;))    return hash_object.hexdigest()def register(username, password):    db_file_path &#x3D; os.path.join(BASE_DIR, FILE_NAME)    if os.path.exists(db_file_path):        wb &#x3D; load_workbook(db_file_path)        sheet &#x3D; wb.worksheets[0]        next_row_position &#x3D; sheet.max_row + 1    else:        wb &#x3D; workbook.Workbook()        sheet &#x3D; wb.worksheets[0]        next_row_position &#x3D; 1    user &#x3D; sheet.cell(next_row_position, 1)    user.value &#x3D; username    pwd &#x3D; sheet.cell(next_row_position, 2)    pwd.value &#x3D; md5(password)    ctime &#x3D; sheet.cell(next_row_position, 3)    ctime.value &#x3D; datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)    wb.save(db_file_path)def run():    while True:        username &#x3D; input(&quot;请输入用户名：&quot;)        if username.upper() &#x3D;&#x3D; &quot;Q&quot;:            break        password &#x3D; input(&quot;请输入密码：&quot;)        register(username, password)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    run()</code></pre></li></ol><h4 id="1-3-正则表达式相关"><a href="#1-3-正则表达式相关" class="headerlink" title="1.3 正则表达式相关"></a>1.3 正则表达式相关</h4><p>​当给你一大堆文本信息，让你提取其中的指定数据时，可以使用正则来实现。例如：提取文本中的邮箱和手机号</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;phone_list &#x3D; re.findall(&quot;1[3|5|8|9]\d&#123;9&#125;&quot;, text)print(phone_list)</code></pre><h5 id="1-3-1-正则表达式"><a href="#1-3-1-正则表达式" class="headerlink" title="1.3.1 正则表达式"></a>1.3.1 正则表达式</h5><h6 id="1-字符相关"><a href="#1-字符相关" class="headerlink" title="1. 字符相关"></a>1. 字符相关</h6><ul><li><p><code>wupeiqi</code> 匹配文本中的wupeiqi</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;你好wupeiqi,阿斯顿发wupeiqasd 阿士大夫能接受的wupeiqiff&quot;data_list &#x3D; re.findall(&quot;wupeiqi&quot;, text)print(data_list) # [&#39;wupeiqi&#39;, &#39;wupeiqi&#39;] 可用于计算字符串中某个字符出现的次数</code></pre></li><li><p><code>[abc]</code> 匹配a或b或c 字符。</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;你2b好wupeiqi,阿斯顿发awupeiqasd 阿士大夫a能接受的wffbbupqaceiqiff&quot;data_list &#x3D; re.findall(&quot;[abc]&quot;, text)print(data_list) # [&#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;你2b好wupeiqi,阿斯顿发awupeiqasd 阿士大夫a能接受的wffbbupqcceiqiff&quot;data_list &#x3D; re.findall(&quot;q[abc]&quot;, text)print(data_list) # [&#39;qa&#39;, &#39;qc&#39;]</code></pre></li><li><p><code>[^abc]</code> 匹配除了abc意外的其他字符。</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;你wffbbupceiqiff&quot;data_list &#x3D; re.findall(&quot;[^abc]&quot;, text)print(data_list)  # [&#39;你&#39;, &#39;w&#39;, &#39;f&#39;, &#39;f&#39;, &#39;u&#39;, &#39;p&#39;, &#39;e&#39;, &#39;i&#39;, &#39;q&#39;, &#39;i&#39;, &#39;f&#39;, &#39;f&#39;]</code></pre></li><li><p><code>[a-z]</code>  匹配a~z的任意字符（ [0-9]也可以 ）。</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;alexrootrootadmin&quot;data_list &#x3D; re.findall(&quot;t[a-z]&quot;, text)print(data_list)  # [&#39;tr&#39;, &#39;ta&#39;]</code></pre></li><li><p><code>.</code>  代指除换行符以外的任意字符。</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;alexraotrootadmin&quot;data_list &#x3D; re.findall(&quot;r.o&quot;, text)print(data_list) # [&#39;rao&#39;, &#39;roo&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;alexraotrootadmin&quot;data_list &#x3D; re.findall(&quot;r.+o&quot;, text) # 贪婪匹配print(data_list) # [&#39;raotroo&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;alexraotrootadmin&quot;data_list &#x3D; re.findall(&quot;r.+?o&quot;, text) # 非贪婪匹配print(data_list) # [&#39;rao&#39;]</code></pre></li><li><p><code>\w</code> 代指字母或数字或下划线（汉字）。</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;北京武沛alex齐北  京武沛alex齐&quot;data_list &#x3D; re.findall(&quot;武\w+x&quot;, text)print(data_list) # [&#39;武沛alex&#39;, &#39;武沛alex&#39;]</code></pre></li><li><p><code>\d</code> 代指数字</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;root-ad32min-add3-admd1in&quot;data_list &#x3D; re.findall(&quot;d\d&quot;, text)print(data_list) # [&#39;d3&#39;, &#39;d3&#39;, &#39;d1&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;root-ad32min-add3-admd1in&quot;data_list &#x3D; re.findall(&quot;d\d+&quot;, text)print(data_list) # [&#39;d32&#39;, &#39;d3&#39;, &#39;d1&#39;]</code></pre></li><li><p><code>\s</code> 代指任意的空白符，包括空格、制表符等。</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;root admin add admin&quot;data_list &#x3D; re.findall(&quot;a\w+\s\w+&quot;, text)print(data_list) # [&#39;admin add&#39;]</code></pre></li></ul><h6 id="2-数量相关"><a href="#2-数量相关" class="headerlink" title="2. 数量相关"></a>2. 数量相关</h6><ul><li><p><code>*</code> 重复0次或更多次</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;他是大B个，确实是个大2B。&quot;data_list &#x3D; re.findall(&quot;大2*B&quot;, text)print(data_list) # [&#39;大B&#39;, &#39;大2B&#39;]</code></pre></li><li><p><code>+</code> 重复1次或更多次</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;他是大B个，确实是个大2B，大3B，大66666B。&quot;data_list &#x3D; re.findall(&quot;大\d+B&quot;, text)print(data_list) # [&#39;大2B&#39;, &#39;大3B&#39;, &#39;大66666B&#39;]</code></pre></li><li><p><code>?</code> 重复0次或1次</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;他是大B个，确实是个大2B，大3B，大66666B。&quot;data_list &#x3D; re.findall(&quot;大\d?B&quot;, text)print(data_list) # [&#39;大B&#39;, &#39;大2B&#39;, &#39;大3B&#39;]</code></pre></li><li><p><code>&#123;n&#125;</code> 重复n次</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;data_list &#x3D; re.findall(&quot;151312\d&#123;5&#125;&quot;, text)print(data_list) # [&#39;15131255789&#39;]</code></pre></li><li><p><code>&#123;n,&#125;</code> 重复n次或更多次</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;data_list &#x3D; re.findall(&quot;\d&#123;9,&#125;&quot;, text)print(data_list) # [&#39;442662578&#39;, &#39;15131255789&#39;]</code></pre></li><li><p><code>&#123;n,m&#125;</code> 重复n到m次</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;data_list &#x3D; re.findall(&quot;\d&#123;10,15&#125;&quot;, text)print(data_list) # [&#39;15131255789&#39;]</code></pre></li></ul><h6 id="3-括号（分组）"><a href="#3-括号（分组）" class="headerlink" title="3. 括号（分组）"></a>3. 括号（分组）</h6><ul><li><p>提取数据区域</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;data_list &#x3D; re.findall(&quot;15131(2\d&#123;5&#125;)&quot;, text)print(data_list)  # [&#39;255789&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来15131266666呀&quot;data_list &#x3D; re.findall(&quot;15(13)1(2\d&#123;5&#125;)&quot;, text)print(data_list)  # [ (&#39;13&#39;, &#39;255789&#39;)   ]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;data_list &#x3D; re.findall(&quot;(15131(2\d&#123;5&#125;))&quot;, text)print(data_list)  # [(&#39;15131255789&#39;, &#39;255789&#39;)]</code></pre></li><li><p>获取指定区域 + 或条件</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主15131root太牛15131alex逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;data_list &#x3D; re.findall(&quot;15131(2\d&#123;5&#125;|r\w+太)&quot;, text)print(data_list)  # [&#39;root太&#39;, &#39;255789&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主15131root太牛15131alex逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;data_list &#x3D; re.findall(&quot;(15131(2\d&#123;5&#125;|r\w+太))&quot;, text)print(data_list)  # [(&#39;15131root太&#39;, &#39;root太&#39;), (&#39;15131255789&#39;, &#39;255789&#39;)]</code></pre></li></ul><p><strong>练习题</strong></p><ol><li><p>利用正则匹配QQ号码</p><pre class="language-none"><code class="language-none"># 不能以0开头，至少是五位的数字[1-9]\d&#123;4,&#125;</code></pre></li><li><p>身份证号码</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;dsf130429191912015219k13042919591219521Xkk&quot;data_list &#x3D; re.findall(&quot;\d&#123;17&#125;[\dX]&quot;, text) # [abc]print(data_list) # [&#39;130429191912015219&#39;, &#39;13042919591219521X&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;dsf130429191912015219k13042919591219521Xkk&quot;data_list &#x3D; re.findall(&quot;\d&#123;17&#125;(\d|X)&quot;, text)print(data_list) # [&#39;9&#39;, &#39;X&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;dsf130429191912015219k13042919591219521Xkk&quot;data_list &#x3D; re.findall(&quot;(\d&#123;17&#125;(\d|X))&quot;, text)print(data_list) # [(&#39;130429191912015219&#39;, &#39;9&#39;), (&#39;13042919591219521X&#39;, &#39;X&#39;)]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;dsf130429191912015219k13042919591219521Xkk&quot;data_list &#x3D; re.findall(&quot;(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;3&#125;)([0-9]|X)&quot;, text)print(data_list) # [(&#39;130429&#39;, &#39;1919&#39;, &#39;12&#39;, &#39;01&#39;, &#39;521&#39;, &#39;9&#39;), (&#39;130429&#39;, &#39;1959&#39;, &#39;12&#39;, &#39;19&#39;, &#39;521&#39;, &#39;X&#39;)]</code></pre></li><li><p>手机号</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;我的手机哈是15133377892，你的手机号是1171123啊？&quot;data_list &#x3D; re.findall(&quot;1[3-9]\d&#123;9&#125;&quot;, text)print(data_list)  # [&#39;15133377892&#39;]</code></pre></li><li><p>邮箱地址</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;email_list &#x3D; re.findall(&quot;\w+@\w+\.\w+&quot;,text)print(email_list) # [&#39;442662578@qq.com和xxxxx&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;email_list &#x3D; re.findall(&quot;[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+&quot;, text)print(email_list) # [&#39;442662578@qq.com&#39;, &#39;xxxxx@live.com&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;email_list &#x3D; re.findall(&quot;\w+@\w+\.\w+&quot;, text, re.ASCII)print(email_list) # [&#39;442662578@qq.com&#39;, &#39;xxxxx@live.com&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;楼主太牛44266-2578@qq.com逼了，在线想要 442662578@qq.com和xxxxx@live.com谢谢楼主，手机号也可15131255789，搞起来呀&quot;email_list &#x3D; re.findall(&quot;(\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*)&quot;, text, re.ASCII)print(email_list) # [(&#39;44266-2578@qq.com&#39;, &#39;-2578&#39;, &#39;&#39;, &#39;&#39;), (&#39;xxxxx@live.com&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;)]</code></pre></li><li><p>补充代码，实现获取页面上的所有评论（已实现），并提取里面的邮箱。</p><pre class="language-python" data-language="python"><code class="language-python"># 先安装两个模块pip3 install requestspip3 install beautifulsoup4</code></pre><pre class="language-python" data-language="python"><code class="language-python">import reimport requestsfrom bs4 import BeautifulSoupres &#x3D; requests.get(    url&#x3D;&quot;https:&#x2F;&#x2F;www.douban.com&#x2F;group&#x2F;topic&#x2F;79870081&#x2F;&quot;,    headers&#x3D;&#123;        &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;80.0.3987.163 Safari&#x2F;537.36&#39;,    &#125;)bs_object &#x3D; BeautifulSoup(res.text, &quot;html.parser&quot;)comment_object_list &#x3D; bs_object.find_all(&quot;p&quot;, attrs&#x3D;&#123;&quot;class&quot;: &quot;reply-content&quot;&#125;)for comment_object in comment_object_list:    text &#x3D; comment_object.text    print(text)    # 请继续补充代码，提取text中的邮箱地址</code></pre></li></ol><h6 id="4-起始和结束"><a href="#4-起始和结束" class="headerlink" title="4. 起始和结束"></a>4. 起始和结束</h6><p>上述示例中都是去一段文本中提取数据，只要文本中存在即可。</p><p>但，如果要求用户输入的内容必须是指定的内容开头和结尾，比就需要用到如下两个字符。</p><ul><li><code>^</code> 开始</li><li><code>$</code> 结束</li></ul><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;啊442662578@qq.com我靠&quot;email_list &#x3D; re.findall(&quot;^\w+@\w+.\w+$&quot;, text, re.ASCII)print(email_list) # []</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;442662578@qq.com&quot;email_list &#x3D; re.findall(&quot;^\w+@\w+.\w+$&quot;, text, re.ASCII)print(email_list) # [&#39;442662578@qq.com&#39;]</code></pre><p>这种一般用于对用户输入数据格式的校验比较多，例如：</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; input(&quot;请输入邮箱：&quot;)email &#x3D; re.findall(&quot;^\w+@\w+.\w+$&quot;, text, re.ASCII)if not email:    print(&quot;邮箱格式错误&quot;)else:    print(email)</code></pre><h6 id="5-特殊字符"><a href="#5-特殊字符" class="headerlink" title="5. 特殊字符"></a>5. 特殊字符</h6><p>由于正则表达式中 <code>*  .  \ &#123; &#125; ( ) </code> 等都具有特殊的含义，所以如果想要在正则中匹配这种指定的字符，需要转义，例如：</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;我是你&#123;5&#125;爸爸&quot;data &#x3D; re.findall(&quot;你&#123;5&#125;爸&quot;, text)print(data) # []</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;我是你&#123;5&#125;爸爸&quot;data &#x3D; re.findall(&quot;你\&#123;5\&#125;爸&quot;, text)print(data)</code></pre><h5 id="1-3-2-re模块"><a href="#1-3-2-re模块" class="headerlink" title="1.3.2 re模块"></a>1.3.2 re模块</h5><p>python中提供了re模块，可以处理正则表达式并对文本进行处理。</p><ul><li><p>findall，获取匹配到的所有数据</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;dsf130429191912015219k13042919591219521Xkk&quot;data_list &#x3D; re.findall(&quot;(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;3&#125;)([0-9]|X)&quot;, text)print(data_list) # [(&#39;130429&#39;, &#39;1919&#39;, &#39;12&#39;, &#39;01&#39;, &#39;521&#39;, &#39;9&#39;), (&#39;130429&#39;, &#39;1959&#39;, &#39;12&#39;, &#39;19&#39;, &#39;521&#39;, &#39;X&#39;)]</code></pre></li><li><p>match，<strong>从起始位置开始匹配</strong>，匹配成功返回一个对象，未匹配成功返回None</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;大小逗2B最逗3B欢乐&quot;data &#x3D; re.match(&quot;逗\dB&quot;, text)print(data) # None</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;逗2B最逗3B欢乐&quot;data &#x3D; re.match(&quot;逗\dB&quot;, text)if data:    content &#x3D; data.group() # &quot;逗2B&quot;    print(content)</code></pre></li><li><p>search，浏览整个字符串去匹配第一个，未匹配成功返回None</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;大小逗2B最逗3B欢乐&quot;data &#x3D; re.search(&quot;逗\dB&quot;, text)if data:    print(data.group())  # &quot;逗2B&quot;</code></pre></li><li><p>sub，替换匹配成功的位置  相较于字符串的replace可以<font color="#dd0000">实现动态替换</font></p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;逗2B最逗3B欢乐&quot;data &#x3D; re.sub(&quot;\dB&quot;, &quot;沙雕&quot;, text)print(data) # 逗沙雕最逗沙雕欢乐</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;逗2B最逗3B欢乐&quot;data &#x3D; re.sub(&quot;\dB&quot;, &quot;沙雕&quot;, text, 1)print(data) # 逗沙雕最逗3B欢乐</code></pre></li><li><p>split，根据匹配成功的位置分割 相较于字符串的split可以<font color="#dd0000">实现动态分割</font></p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;逗2B最逗3B欢乐&quot;data &#x3D; re.split(&quot;\dB&quot;, text)print(data) # [&#39;逗&#39;, &#39;最逗&#39;, &#39;欢乐&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;逗2B最逗3B欢乐&quot;data &#x3D; re.split(&quot;\dB&quot;, text, 1)print(data) # [&#39;逗&#39;, &#39;最逗3B欢乐&#39;]</code></pre></li><li><p>finditer</p><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;逗2B最逗3B欢乐&quot;data &#x3D; re.finditer(&quot;\dB&quot;, text)for item in data:    print(item.group())</code></pre><pre class="language-python" data-language="python"><code class="language-python">import retext &#x3D; &quot;逗2B最逗3B欢乐&quot;data &#x3D; re.finditer(&quot;(?P&lt;xx&gt;\dB)&quot;, text)  # 命名分组for item in data:    print(item.groupdict())</code></pre><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; &quot;dsf130429191912015219k13042919591219521Xkk&quot;data_list &#x3D; re.finditer(&quot;\d&#123;6&#125;(?P&lt;year&gt;\d&#123;4&#125;)(?P&lt;month&gt;\d&#123;2&#125;)(?P&lt;day&gt;\d&#123;2&#125;)\d&#123;3&#125;[\d|X]&quot;, text)for item in data_list:    info_dict &#x3D; item.groupdict()    print(info_dict)</code></pre></li></ul><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>到此，关于最常见的内置模块就全部讲完了（共11个），现阶段只需要掌握这些模块的使用即可，在后续的课程和练习题中也会涉及到一起其他内置模块。</p><ul><li>os</li><li>shutil</li><li>sys</li><li>random</li><li>hashlib</li><li>configparser</li><li>xml</li><li>json</li><li>time</li><li>datetime</li><li>re</li></ul><h3 id="2-项目开发规范"><a href="#2-项目开发规范" class="headerlink" title="2. 项目开发规范"></a>2. 项目开发规范</h3><p>​现阶段，我们在开发一些程序时（终端运行），应该遵循一些结构的规范，让你的系统更加专业。</p><h4 id="2-1-单文件应用"><a href="#2-1-单文件应用" class="headerlink" title="2.1 单文件应用"></a>2.1 单文件应用</h4><p>​当基于python开发简单应用时（一个py文件就能搞定），需要注意如下几点。</p><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;文件注释&quot;&quot;&quot;import reimport randomimport requestsfrom openpyxl import load_workbookDB &#x3D; &quot;XXX&quot;def do_something():    &quot;&quot;&quot; 函数注释 &quot;&quot;&quot;    # TODO 待完成时，下一期实现xxx功能    for i in range(10):        passdef run():    &quot;&quot;&quot; 函数注释 &quot;&quot;&quot;    # 对功能代码进行注释    text &#x3D; input(&quot;&gt;&gt;&gt;&quot;)    print(text)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    run()</code></pre><img src="Python模块二day5/image-20210105160728297.png" alt="image-20210105160728297" style="zoom:50%;" /><h4 id="2-2-单可执行文件"><a href="#2-2-单可执行文件" class="headerlink" title="2.2 单可执行文件"></a>2.2 单可执行文件</h4><p>​新创建一个项目，假设名字叫 【crm】，可以创建如下文件和文件夹来存放代码和数据。</p><pre class="language-python" data-language="python"><code class="language-python">crm├── app.py        文件，程序的主文件（尽量精简）├── config.py     文件，配置文件（放相关配置信息，代码中读取配置信息，如果想要修改配置，即可以在此修改，不用再去代码中逐一修改了）├── db            文件夹，存放数据├── files         文件夹，存放文件├── src           包，业务处理的代码└── utils         包，公共功能</code></pre><p>示例程序见附件：crm.zip</p><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210105163335127.png" class="" title="image-20210105163335127"><h4 id="2-3-多可执行文件"><a href="#2-3-多可执行文件" class="headerlink" title="2.3 多可执行文件"></a>2.3 多可执行文件</h4><p>​新创建项目，假设名称叫【killer】，可以创建如下文件和文件夹来存放代码和数据。</p><pre class="language-none"><code class="language-none">killer├── bin文件夹，存放多个主文件（可运行）│   ├── app1.py│   └── app2.py├── config              包，配置文件│   ├── __init__.py│   └── settings.py├── db                  文件夹，存放数据├── files               文件夹，存放文件├── src                 包，业务代码│   └── __init__.py└── utils               包，公共功能    └── __init__.py</code></pre><p>示例程序见附件：killer.zip</p><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210105164740583.png" class="" title="image-20210105164740583"><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>json格式和json模块</li><li>json模块处理特殊的数据类型</li><li>datetime格式与字符串、时间戳以及相关之间的转换。</li><li>datetime格式时间与timedelta的加减。</li><li>两个datetime相减可以计算时间间隔，得到的是一个timedelta格式的时间。</li><li>了解正则表达式的编写方式和python中re模块的使用。</li><li>项目开发规范。</li></ol><h3 id="作业：开发短视频资讯平台"><a href="#作业：开发短视频资讯平台" class="headerlink" title="作业：开发短视频资讯平台"></a>作业：开发短视频资讯平台</h3><ul><li><p>有video.csv视频库文件，其中有999条短视频数据，格式如下：【 video.csv 文件已为大家提供好，在day15课件目录下。 】</p><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210105223331765.png" class="" title="image-20210105223331765"></li><li><p>项目的核心功能有：</p><ul><li><p>分页看新闻（每页显示10条），提示用户输入页码，根据页码显示指定页面的数据。</p><ul><li>提示用户输入页码，根据页码显示指定页面的数据。</li><li>当用户输入的页码不存在时，默认显示第1页</li></ul></li><li><p>搜索专区</p><ul><li>用户输入关键字，根据关键词筛选出所有匹配成功的短视频资讯。</li><li>支持的搜索两种搜索格式：<ul><li><code>id=1715025</code>，筛选出id等于1715025的视频（video.csv的第一列）。</li><li><code>key=文本</code>，模糊搜索，筛选包含关键字的所有新闻（video.csv的第二列）。</li></ul></li></ul></li><li><p>下载专区</p><ul><li><p>用户输入视频id，根据id找到对应的mp4视频下载地址，然后下载视频到项目的files目录。</p><ul><li><p>视频的文件名为：<code>视频id-年-月-日-时-分-秒.mp4</code></p></li><li><p>视频下载代码示例</p><pre class="language-python" data-language="python"><code class="language-python">import requestsres &#x3D; requests.get(    url&#x3D;&#39;https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715046-15562045_adpkg-ad_hd.mp4&#39;)# 视频总大小（字节）file_size &#x3D; int(res.headers[&#39;Content-Length&#39;])download_size &#x3D; 0with open(&#39;xxx.mp4&#39;, mode&#x3D;&#39;wb&#39;) as file_object:    # 分块读取下载的视频文件（最多一次读128字节），并逐一写入到文件中。 len(chunk)表示实际读取到每块的视频文件大小。    for chunk in res.iter_content(128):        download_size +&#x3D; len(chunk)        file_object.write(chunk)        file_object.flush()        message &#x3D; &quot;视频总大小为：&#123;&#125;字节，已下载&#123;&#125;字节。&quot;.format(file_size, download_size)        print(message)    file_object.close()res.close()</code></pre></li><li><p>下载的过程中，输出已下载的百分比，示例代码如下：</p><pre class="language-python" data-language="python"><code class="language-python">import timeprint(&quot;正在下载中...&quot;)for i in range(101):    text &#x3D; &quot;\r&#123;&#125;%&quot;.format(i)    print(text, end&#x3D;&quot;&quot;)    time.sleep(0.2)print(&quot;\n下载完成&quot;)</code></pre></li></ul></li></ul></li></ul></li></ul><p><strong>附赠</strong></p><p>​自动采集梨视频1000条资讯的爬虫脚本。<span style='color:red;'>梨视频平台系统更新后可能会导致下载失败，到时候需根据平台调整再来修改代码。</span></p><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;下载梨视频的：视频ID，视频标题，视频URL地址 并写入到本次 video.csv 文件中。运行此脚本需要预先安装：    pip install request    pip install beautifulsoup4&quot;&quot;&quot;import requestsfrom bs4 import BeautifulSoupdef get_mp4_url(video_id):    data &#x3D; requests.get(        url&#x3D;&quot;https:&#x2F;&#x2F;www.pearvideo.com&#x2F;videoStatus.jsp?contId&#x3D;&#123;&#125;&quot;.format(video_id),        headers&#x3D;&#123;            &quot;Referer&quot;: &quot;https:&#x2F;&#x2F;www.pearvideo.com&#x2F;video_&#123;&#125;&quot;.format(video_id),        &#125;    )    response &#x3D; data.json()    image_url &#x3D; response[&#39;videoInfo&#39;][&#39;video_image&#39;]    video_url &#x3D; response[&#39;videoInfo&#39;][&#39;videos&#39;][&#39;srcUrl&#39;]    middle &#x3D; image_url.rsplit(&#39;&#x2F;&#39;, 1)[-1].rsplit(&#39;-&#39;, 1)[0]    before, after &#x3D; video_url.rsplit(&#39;&#x2F;&#39;, 1)    suffix &#x3D; after.split(&#39;-&#39;, 1)[-1]    url &#x3D; &quot;&#123;&#125;&#x2F;&#123;&#125;-&#123;&#125;&quot;.format(before, middle, suffix)    return urldef download_video():    file_object &#x3D; open(&#39;video.csv&#39;, mode&#x3D;&#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;)    count &#x3D; 0    while count &lt;&#x3D; 999:        res &#x3D; requests.get(            url&#x3D;&quot;https:&#x2F;&#x2F;www.pearvideo.com&#x2F;category_loading.jsp?reqType&#x3D;14&amp;categoryId&#x3D;&amp;start&#x3D;&#123;&#125;&quot;.format(count)        )        bs &#x3D; BeautifulSoup(res.text, &#39;lxml&#39;)        a_list &#x3D; bs.find_all(&quot;a&quot;, attrs&#x3D;&#123;&#39;class&#39;: &quot;vervideo-lilink&quot;&#125;)        for tag in a_list:            title &#x3D; tag.find(&#39;div&#39;, attrs&#x3D;&#123;&#39;class&#39;: &quot;vervideo-title&quot;&#125;).text.strip()            video_id &#x3D; tag.get(&#39;href&#39;).split(&#39;_&#39;)[-1]            mp4_url &#x3D; get_mp4_url(video_id)            row &#x3D; &quot;&#123;&#125;,&#123;&#125;,&#123;&#125;\n&quot;.format(video_id, title, mp4_url)            file_object.write(row)            file_object.flush()            count +&#x3D; 1            message &#x3D; &quot;已下载&#123;&#125;个&quot;.format(count)            print(message)    file_object.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    download_video()</code></pre><p><strong>我的版本</strong></p><pre class="language-python" data-language="python"><code class="language-python">import osimport reimport timeimport requestsBASE_DIR &#x3D; os.path.dirname(os.path.abspath(__file__))FILE_NAME &#x3D; os.path.join(BASE_DIR, &#39;video.csv&#39;)SELECT_MP4 &#x3D; set()def read_file(file_name):    file_object &#x3D; open(file_name, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;)    info_dic &#x3D; &#123;&#125;    for index, line in enumerate(file_object, 1):        news_id &#x3D; re.findall(&#39;^\d&#123;7&#125;&#39;, line)[0]  # re,findall() 返回列表要将其中的元素取出        url &#x3D; re.findall(&#39;https.+&#39;, line)[0]        title &#x3D; &#39;&#39;.join(re.findall(&#39;[\u0391-\uFFE5]+&#39;, line))        info_dic[index] &#x3D; &#123;&#39;id&#39;: news_id, &#39;title&#39;: title, &#39;url&#39;: url&#125;        # print(info_dic)    file_object.close()    return info_dicdef watch_news(info_dict):    first_indexes &#x3D; range(1, 11)    def show_first():        for index in first_indexes:            title &#x3D; info_dict.get(index)[&#39;title&#39;]            print(index, title)    while True:        page &#x3D; input(&quot;欢迎进入分页看新闻：请输入页码（输入Q&#x2F;q退出）： &quot;).strip()        if page.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        indexes &#x3D; range((int(page)-1)*10+1, int(page)*10+1)        for index in indexes:            get &#x3D; info_dict.get(index)            if not get:                show_first()            else:                print(index, get[&#39;title&#39;])def search(info_dict):    while True:        search_news &#x3D; input(&#39;请输入要搜索的内容（输入Q&#x2F;q退出）： &#39;).strip()        if search_news.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        for item in info_dict:            # print(info_dict[item][&#39;id&#39;])            if info_dict[item][&#39;id&#39;] &#x3D;&#x3D; search_news:                print(info_dict[item][&#39;id&#39;], info_dict[item][&#39;title&#39;])            elif search_news in info_dict[item][&#39;title&#39;]:                print(info_dict[item][&#39;id&#39;], info_dict[item][&#39;title&#39;])def download(info_dict):    choice_vedio &#x3D; input(&#39;请输入要下载视频的id（输入Q&#x2F;q退出）： &#39;)    for item in info_dict:        global SELECT_MP4        if info_dict[item][&#39;id&#39;] in SELECT_MP4:            print(&#39;视频已下载无法重复下载&#39;)            continue        if info_dict[item][&#39;id&#39;] &#x3D;&#x3D; choice_vedio:            res &#x3D; requests.get(                url&#x3D;&#39;https:&#x2F;&#x2F;video.pearvideo.com&#x2F;mp4&#x2F;adshort&#x2F;20210105&#x2F;cont-1715046-15562045_adpkg-ad_hd.mp4&#39;            )            # 视频总大小（字节）            file_size &#x3D; int(res.headers[&#39;Content-Length&#39;])            download_size &#x3D; 0            # 路径不存在就创建            if not os.path.exists(os.path.join(BASE_DIR, &#39;files&#39;)):                os.makedirs(os.path.join(BASE_DIR, &#39;files&#39;))            # 下载视频            with open(&#39;files&#x2F;&#123;&#125;.mp4&#39;.format(info_dict[item][&#39;title&#39;]), mode&#x3D;&#39;wb&#39;) as file_object:                # 分块读取下载的视频文件（最多一次读128字节），并逐一写入到文件中。 len(chunk)表示实际读取到每块的视频文件大小。                for chunk in res.iter_content(128):                    download_size +&#x3D; len(chunk)                    file_object.write(chunk)                    file_object.flush()                    # 显示下载进度                    print(&#39;\r正在下载中&#39;, end&#x3D;&#39;&#39;)                    message &#x3D; &#39;\r&#123;&#125;%&#39;.format(round((download_size &#x2F; file_size) * 100))                    # message &#x3D; &quot;视频总大小为：&#123;&#125;字节，已下载&#123;&#125;字节。&quot;.format(file_size, download_size)                    print(message, end&#x3D;&#39;&#39;)                    # time.sleep(0.2)                file_object.close()                res.close()                SELECT_MP4.add(choice_vedio)# 1、启动后，让用户选择专区，每个专区用单独的函数实现，提供的专区如下：function_dict &#x3D; &#123;    &quot;1&quot;: watch_news,    &quot;2&quot;: search,    &quot;3&quot;: download,&#125;while True:    print(&#39;欢迎来到天霸短视频资讯平台,请输入对应数字进入下载专区（输入Q&#x2F;q退出）： &#39;)    zone_choice &#x3D; input(&#39;请输入对应数字：1. 分页看新闻, 2. 搜索专区, 3. 下载专区: &#39;).strip()    if zone_choice.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    zone &#x3D; function_dict.get(zone_choice)    if not zone:        print(&#39;输入类型错误，请重新输入&#39;)        continue    zone(read_file(FILE_NAME))</code></pre><p><strong>存在问题</strong></p><pre class="language-none"><code class="language-none">1. 可以将不同的功能用文件进行分割，参照项目规范进行更改2. 功能内部过长可以适当拆分</code></pre><h2 id="十七、阶段总结"><a href="#十七、阶段总结" class="headerlink" title="十七、阶段总结"></a>十七、阶段总结</h2><p>课程目标：对第二模块  “函数和模块” 阶段的知识点进行总结和考试，让学员更好的掌握此模块的相关知识。</p><p>课程概要：</p><ul><li>知识补充</li><li>阶段总结（思维导图）</li><li><span style='color:red;'>考试题（全部都是面试题）</span></li></ul><h3 id="1-知识补充"><a href="#1-知识补充" class="headerlink" title="1.知识补充"></a>1.知识补充</h3><h4 id="1-1-nolocal关键字"><a href="#1-1-nolocal关键字" class="headerlink" title="1.1 nolocal关键字"></a>1.1 nolocal关键字</h4><p>在之前的课程中，我们学过global关键字。</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &#39;root&#39;def outer():    name &#x3D; &quot;武沛齐&quot;    def inner():        global name        name &#x3D; 123    inner()    print(name)outer()print(name)</code></pre><p>其实，还有一个nolocal关键字，用的比较少，此处作为了解即可。</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &#39;root&#39;def outer():    name &#x3D; &quot;武沛齐&quot;    def inner():        nonlocal name        name &#x3D; 123    inner()    print(name)outer()print(name)</code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &#39;root&#39;def outer():    name &#x3D; &#39;alex&#39;    def func():        name &#x3D; &quot;武沛齐&quot;        def inner():            nonlocal name            name &#x3D; 123        inner()        print(name)    func()    print(name)outer()print(name)</code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &#39;root&#39;def outer():    name &#x3D; &#39;alex&#39;    def func():        nonlocal name        name &#x3D; &quot;武沛齐&quot;        def inner():            nonlocal name            name &#x3D; 123        inner()        print(name)    func()    print(name)outer()print(name)</code></pre><h4 id="1-2-yield-from"><a href="#1-2-yield-from" class="headerlink" title="1.2 yield from"></a>1.2 yield from</h4><p>在生成器部分我们了解了yield关键字，其在python3.3之后有引入了一个yield from。</p><pre class="language-python" data-language="python"><code class="language-python">def foo():    yield 2    yield 2    yield 2def func():    yield 1    yield 1    yield 1    yield from foo()    yield 1    yield 1for item in func():    print(item)</code></pre><h4 id="1-3-深浅拷贝"><a href="#1-3-深浅拷贝" class="headerlink" title="1.3 深浅拷贝"></a>1.3 深浅拷贝</h4><ul><li><p>浅拷贝</p><ul><li><p>不可变类型，不拷贝。</p><pre class="language-python" data-language="python"><code class="language-python">import copyv1 &#x3D; &quot;武沛齐&quot;print(id(v1)) # 140652260947312v2 &#x3D; copy.copy(v1) print(id(v2)) # 140652260947312</code></pre><p>按理说拷贝v1之后，v2的内存地址应该不同，但由于python内部优化机制，内存地址是相同的，因为对不可变类型而言，如果以后修改值，会重新创建一份数据，不会影响原数据，所以，不拷贝也无妨。</p></li><li><p>可变类型，只拷贝第一层。</p><pre class="language-python" data-language="python"><code class="language-python">import copyv1 &#x3D; [&quot;武沛齐&quot;, &quot;root&quot;, [44, 55]]print(id(v1))  # 140405837216896print(id(v1[2]))  # 140405837214592v2 &#x3D; copy.copy(v1)print(id(v2))  # 140405837214784print(id(v2[2]))  # 140405837214592</code></pre><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210106151332792.png" class="" title="image-20210106151332792"></li></ul></li><li><p>深拷贝</p><ul><li><p>不可变类型，不拷贝</p><pre class="language-python" data-language="python"><code class="language-python">import copyv1 &#x3D; &quot;武沛齐&quot;print(id(v1))  # 140188538697072v2 &#x3D; copy.deepcopy(v1)print(id(v2))  # 140188538697072</code></pre><p>特殊的元组：</p><ul><li><p>元组元素中无可变类型，不拷贝</p><pre class="language-python" data-language="python"><code class="language-python">import copyv1 &#x3D; (&quot;武沛齐&quot;, &quot;root&quot;)print(id(v1))  # 140243298961984v2 &#x3D; copy.deepcopy(v1)print(id(v2))  # 140243298961984</code></pre></li><li><p>元素元素中有可变类型，找到所有【可变类型】或【含有可变类型的元组】   均拷贝一份</p><pre class="language-python" data-language="python"><code class="language-python">import copyv1 &#x3D; (&quot;武沛齐&quot;, &quot;root&quot;, [11, [44, 55], (11, 22), (11, [], 22), 33])v2 &#x3D; copy.deepcopy(v1)print(id(v1))  # 140391475456384print(id(v2))  # 140391475456640print(id(v1[2]))  # 140352552779008print(id(v2[2]))  # 140352552920448print(id(v1[2][1]))  # 140642999940480print(id(v2[2][1]))  # 140643000088832print(id(v1[2][2]))  # 140467039914560print(id(v2[2][2]))  # 140467039914560print(id(v1[2][3]))  # 140675479841152print(id(v2[2][3]))  # 140675480454784</code></pre></li></ul></li><li><p>可变类型，找到所有层级的 【可变类型】或【含有可变类型的元组】   均拷贝一份</p><pre class="language-python" data-language="python"><code class="language-python">import copyv1 &#x3D; [&quot;武沛齐&quot;, &quot;root&quot;, [11, [44, 55], (11, 22), (11, [], 22), 33]]v2 &#x3D; copy.deepcopy(v1)print(id(v1))  # 140391475456384print(id(v2))  # 140391475456640print(id(v1[2]))  # 140352552779008print(id(v2[2]))  # 140352552920448print(id(v1[2][1]))  # 140642999940480print(id(v2[2][1]))  # 140643000088832print(id(v1[2][2]))  # 140467039914560print(id(v2[2][2]))  # 140467039914560print(id(v1[2][3]))  # 140675479841152print(id(v2[2][3]))  # 140675480454784</code></pre><pre class="language-python" data-language="python"><code class="language-python">import copyv1 &#x3D; [&quot;武沛齐&quot;, &quot;root&quot;, [44, 55]]v2 &#x3D; copy.deepcopy(v1)print(id(v1))  # 140405837216896print(id(v2))  # 140405837214784print(id(v1[2]))  # 140563140392256print(id(v2[2]))  # 140563140535744</code></pre><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210106152704591.png" class="" title="image-20210106152704591"></li></ul></li></ul><h3 id="2-阶段总结"><a href="#2-阶段总结" class="headerlink" title="2.阶段总结"></a>2.阶段总结</h3><img src="/2022/06/08/python-mo-kuai-er-day5/image-20210106143928141.png" class="" title="image-20210106143928141"><h3 id="3-考试题"><a href="#3-考试题" class="headerlink" title="3.考试题"></a>3.考试题</h3><p>考试题的目的是让大家对自己近期知识点学习练习 以及 自测，请大家务必【独立】完成（切勿翻看笔记 &amp; 切勿网上搜索 ）。</p><ul><li><p>第一步：自己独立完成（编程题目可以在pycharm中编写）</p></li><li><p>第二步：做完之后，翻看自己笔记去修改和更正。</p></li><li><p>第三步：觉自己做的没问题了，最后再去看考试题的参考答案和讲解。</p></li></ul><p>详情见附件《第二阶段考试题.md》文件。</p>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 第二阶段 </tag>
            
            <tag> 函数和模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python错题本</title>
      <link href="/2022/06/07/python-cuo-ti-ben/"/>
      <url>/2022/06/07/python-cuo-ti-ben/</url>
      
        <content type="html"><![CDATA[<h2 id="模块二"><a href="#模块二" class="headerlink" title="模块二"></a>模块二</h2><h3 id="函数高阶"><a href="#函数高阶" class="headerlink" title="函数高阶"></a>函数高阶</h3><ol><li>看代码写结果</li></ol><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;def func():    name &#x3D; &quot;root&quot;    def foo():        print(name)    foo()func()</code></pre><p>答案</p><pre class="language-python" data-language="python"><code class="language-python"># 武沛齐</code></pre><p>2. </p><pre class="language-python" data-language="python"><code class="language-python">def func(val):    def inner(a1, a2):        return a1 + a2 + val    return innerdata_list &#x3D; []for i in range(10):    data_list.append(  func(i)   )print(data_list)</code></pre><p>答案</p><pre class="language-python" data-language="python"><code class="language-python"># [&lt;function func.&lt;locals&gt;.inner at 0x000001D42674B670&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4269BD0D0&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4269BD8B0&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD310&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD280&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD1F0&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD160&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD0D0&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD040&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295A5CA0&gt;]</code></pre><ol start="3"><li>新浪微博面试题</li></ol><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [lambda x: x + i for i in range(10)]  # [函数,函数,函数]   i&#x3D;9v1 &#x3D; data_list[0](100)v2 &#x3D; data_list[3](100)print(v1, v2)  </code></pre><p>答案</p><pre class="language-python" data-language="python"><code class="language-python"># 109# 109# 解析- 函数在推导式中并未执行，只是创建了九个函数，此时i&#x3D;9- 到v1 &#x3D; data_list[0](100)时执行lambda0，此时i取值为9，x为100- 到v2 &#x3D; data_list[3](100)时执行lambda3，此时i取值为9，x为100</code></pre><ol start="4"><li>看代码写结果</li></ol><pre class="language-none"><code class="language-none">v &#x3D; [ lambda :x  for x in range(10)] print(v)print(v[0])print(v[0]())</code></pre><p>答案</p><pre class="language-python" data-language="python"><code class="language-python"># [lambda0, lambda1, lambda2, ... lambda9] i &#x3D; 9# lambda0 i&#x3D;9# 9</code></pre><ol start="5"><li>请编写一个生成器函数实现生成n个斐波那契数列的值。</li></ol><ul><li><p>什么是斐波那契数列？</p><pre class="language-none"><code class="language-none">前两个数相加的结果，就是下一个数。1 1 2 3 5 8 13 21 34 55 ...</code></pre></li><li><p>代码结构示例，请在此基础上补充代码实现。</p><pre class="language-python" data-language="python"><code class="language-python">def fib(max_count):    passcount &#x3D; input(&quot;请输入要生成斐波那契数列的个数：&quot;)count &#x3D; int(count)fib_generator &#x3D; fib(count)for num in fib_generator:    print(num) </code></pre><pre class="language-python" data-language="python"><code class="language-python">def fib(max_count):    first &#x3D; 1    second &#x3D; 0    count &#x3D; 0    while count &lt; max_count:        next_value &#x3D; first + second        first &#x3D; second        second &#x3D; next_value        yield next_value        count +&#x3D; 1count &#x3D; input(&quot;请输入要生成斐波那契数列的个数：&quot;)count &#x3D; int(count)fib_generator &#x3D; fib(count)for num in fib_generator:    print(num)    </code></pre></li></ul><h2 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h2><h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><ol><li><p>面向对象中的self指的是什么?</p><p>答案：self是一个参数，当使用 对象.方法 的方式执行函数时，python自动传递self参数（参数的值为调用当前方法的对象）</p></li><li><p>补充代码实现</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; []while True:    user &#x3D; input(&quot;请输入用户名:&quot;)    pwd &#x3D; input(&quot;请输入密码:&quot;)    email &#x3D; input(&quot;请输入邮箱:&quot;)    &quot;&quot;&quot;# 需求1. while循环提示 户输 : 户名、密码、邮箱(正则满足邮箱格式)2. 为每个用户创建一个个对象，并添加到user_list中。3. 当列表中的添加 3个对象后，跳出循环并以此循环打印所有用户的姓名和邮箱&quot;&quot;&quot;</code></pre><p>答案：</p><pre class="language-python" data-language="python"><code class="language-python">import reclass User:    def __init__(self, user, pwd, email):        self.user &#x3D; user        self.pwd &#x3D; pwd        self.email &#x3D; emaildef run():    user_list &#x3D; []    while True:        user &#x3D; input(&quot;请输入用户名(输入Q&#x2F;q退出):&quot;).strip()        if user.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        pwd &#x3D; input(&quot;请输入密码:&quot;).strip()        email &#x3D; input(&quot;请输入邮箱:&quot;).strip()        email &#x3D; re.match(&#39;\w+@\w+\.\w+&#39;, email).group()        if not email:            print(&#39;输入格式错误&#39;)            break        user_obj &#x3D; User(user, pwd, email)        user_list.append(user_obj)        if len(user_list) &#x3D;&#x3D; 3:            break    for user in user_list:        message &#x3D; &#39;用户&#123;&#125;您的邮箱为&#123;&#125;&#39;.format(user.user, user.email)        print(message)run()</code></pre></li><li><p>补充代码:实现 户注册和登录。</p><pre class="language-python" data-language="python"><code class="language-python">class User:    def __init__(self, name, pwd):        self.name &#x3D; name        self.pwd &#x3D; pwdclass Account:    def __init__(self):        # 用户列表，数据格式：[user对象，user对象，user对象]        self.user_list &#x3D; []    def login(self):        &quot;&quot;&quot;        用户登录，输入用户名和密码然后去self.user_list中校验用户合法性        :return:        &quot;&quot;&quot;        pass    def register(self):        &quot;&quot;&quot;        用户注册，没注册一个用户就创建一个user对象，然后添加到self.user_list中，表示注册成功。        :return:        &quot;&quot;&quot;        pass    def run(self):        &quot;&quot;&quot;        主程序        :return:        &quot;&quot;&quot;        passif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    obj &#x3D; Account()    obj.run()</code></pre><p>答案：</p><pre class="language-python" data-language="python"><code class="language-python">class User:    def __init__(self, name, pwd):        self.name &#x3D; name        self.pwd &#x3D; pwdclass Account:    def __init__(self):        # 用户列表，数据格式：[user对象，user对象，user对象]        self.user_list &#x3D; []    def login(self):        print(&#39;用户登录&#39;)        &quot;&quot;&quot;        用户登录，输入用户名和密码然后去self.user_list中校验用户合法性        :return:        &quot;&quot;&quot;        while True:            name &#x3D; input(&quot;请输入用户名(输入Q&#x2F;q退出): &quot;).strip()            if name.upper() &#x3D;&#x3D; &#39;Q&#39;:                break            pwd &#x3D; input(&quot;请输入密码: &quot;).strip()            for user in self.user_list:                if name &#x3D;&#x3D; user.name and pwd &#x3D;&#x3D; user.pwd:                    print(&quot;登录成功&quot;)                    break                else:                    if user &#x3D;&#x3D; self.user_list[-1]:                        print(&#39;登录失败&#39;)    def register(self):        &quot;&quot;&quot;        用户注册，每注册一个用户就创建一个user对象，然后添加到self.user_list中，表示注册成功。        :return:        &quot;&quot;&quot;        print(&#39;用户注册&#39;)        while True:            name &#x3D; input(&quot;请输入用户名(输入Q&#x2F;q退出): &quot;).strip()            if name.upper() &#x3D;&#x3D; &#39;Q&#39;:                break            pwd &#x3D; input(&quot;请输入密码: &quot;).strip()            user_obj &#x3D; User(name, pwd)            self.user_list.append(user_obj)    def run(self):            &quot;&quot;&quot;            主程序            :return:            &quot;&quot;&quot;            while True:                func_dic &#x3D; &#123;                    &#39;1&#39;: &#123;&#39;name&#39;: &#39;注册&#39;, &#39;func&#39;: self.register&#125;,                    &#39;2&#39;: &#123;&#39;name&#39;: &#39;登录&#39;, &#39;func&#39;: self.login&#125;                &#125;                # 打印提示信息                msg &#x3D; &#39;;&#39;.join([&#39;&#123;&#125;-&#123;&#125;&#39;.format(k, v[&#39;name&#39;]) for k, v in func_dic.items()])                print(msg)                choice &#x3D; input(&#39;请输入所选功能(输入Q&#x2F;q退出)： &#39;)                if choice.upper() &#x3D;&#x3D; &#39;Q&#39;:                    break                info &#x3D; func_dic.get(choice)                if not info:                    print(&#39;输入错误请重新输入&#39;)                    continue                func &#x3D; info[&#39;func&#39;]                func()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    obj &#x3D; Account()    obj.run()</code></pre></li></ol><h3 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h3><ol><li><p>列举面向对象的成员并简述他们的特点。</p><p>答案：</p><ul><li><p>变量：</p><ul><li>实例变量：属于对象【只能对象调用】</li><li>类变量：属于类【类和对象均可调用】</li></ul></li><li><p>方法</p><ul><li><p>绑定方法：默认传入<code>self</code>参数，一般由对象进行调用（此时<code>self</code>就等于调用方法的对象）【类和对象均可调用】</p></li><li><p>类方法：默认传入<code>cls</code>参数，一般由类进行调用（此时<code>cls</code>就等于调用方法的这个类）【类和对象均可调用】</p></li><li><p>静态方法：默认不传人任何参数，一般由类进行调用【类和对象均可调用】</p></li></ul></li><li><p>属性：由绑定方法+<code>@property</code>实现，作用为</p><ul><li><code>obj.属性名</code></li><li><code>obj.属性名 = 123</code></li><li><code>del obj.属性名</code></li></ul></li></ul></li><li><p><code>__new__</code>方法的作用？</p><p>答案：执行在<code>__init__</code>方法之前，用于创建一个空对象，然后<code>__init__</code>方法在其中初始化一些值。</p></li><li><p>简述你理解的迭代器、生成器和可迭代对象</p><ul><li><p>迭代器：内部封装有<code>__iter__</code>方法和<code>__next__</code>方法</p><ul><li><code>__iter__</code>方法：返回自身</li><li><code>__next__</code>可以获取数据（终止抛出StopIteration异常），可以被for循环</li></ul></li><li><p>可迭代对象：内部封装有<code>__iter__</code>方法并返回一个迭代器，可以被for循环</p></li><li><p>生成器：在定义函数时，包含yield关键字就是一个生成器函数，执行生成器函数可以获得生成器对象（一种特殊的迭代器）内部也有<code>__iter__</code>和<code>__next__</code>方法</p><ul><li><code>__iter__</code>方法：返回自身</li><li><code>__next__</code>可以获取数据（终止抛出StopIteration异常），可以被for循环</li></ul></li></ul></li><li><p>看代码写结果（如有报错，请标注报错位置）</p><pre class="language-python" data-language="python"><code class="language-python">class StarkConfig(object):    def __init__(self, num):        self.num &#x3D; num    def run(self):        self()    def __call__(self, *args, **kwargs):        print(self.num)        class RoleConfig(StarkConfig):    def __call__(self, *args, **kwargs):        print(345)    def __getitem__(self, item):        return self.num[item]    v1 &#x3D; RoleConfig(&#39;alex&#39;)v2 &#x3D; StarkConfig(&quot;wupeiqi&quot;)print(v1[1])print(v2[2])</code></pre><p><font color="#dd0000">存在问题</font>：未掌握成员<code>__call__</code>和<code>__getitem__</code></p><ul><li><code>__call__</code>：在执行<code>对象()</code>时，自动调用该方法，并返回结果</li><li><code>__getitem__</code>：在执行<code>对象[]</code>时，自动调用该方法，并返回结果</li></ul><p>答案：</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; l&gt;&gt;&gt; print(v2[2])  # 报错StarkConfig没有__gititem__方法，无法执行v2[]</code></pre></li></ol><h3 id="面向对象高级"><a href="#面向对象高级" class="headerlink" title="面向对象高级"></a>面向对象高级</h3><ol><li><p>super的作用？</p><p>答案：按照类的mro继承关系，去上级查找相关成员。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决ArcGIS安装后Arcmap无法启动的问题</title>
      <link href="/2022/06/05/jie-jue-arcgis-an-zhuang-hou-arcmap-wu-fa-qi-dong-de-wen-ti/"/>
      <url>/2022/06/05/jie-jue-arcgis-an-zhuang-hou-arcmap-wu-fa-qi-dong-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>​安装完python3.10后，Arcmap无法正常打开，显示完“正在加载文档后”,无法启动，直接退出。</p><img src="/2022/06/05/jie-jue-arcgis-an-zhuang-hou-arcmap-wu-fa-qi-dong-de-wen-ti/image-20220605173242455.png" class="" title="image-20220605173242455"><h2 id="二、问题解决"><a href="#二、问题解决" class="headerlink" title="二、问题解决"></a>二、问题解决</h2><p>​个人而言，问题产生的原因为python3.10安装目录为C盘根目录下，该位置同时为ArcGIS python27的安装目录，可能存在覆盖问题。</p><p>​<font color="#dd0000">将C盘根目录下的Python3.10所有文件夹卸载即可。</font></p>]]></content>
      
      
      <categories>
          
          <category> 技术问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块二day2</title>
      <link href="/2022/06/02/python-mo-kuai-er-day4/"/>
      <url>/2022/06/02/python-mo-kuai-er-day4/</url>
      
        <content type="html"><![CDATA[<h2 id="十三、函数高级"><a href="#十三、函数高级" class="headerlink" title="十三、函数高级"></a>十三、函数高级</h2><img src="/2022/06/02/python-mo-kuai-er-day4/image-20201228153850400.png" class="" title="image-20201228153850400"><p>课程目标：掌握函数嵌套、闭包、装饰器等高级知识点。</p><p>今日概要：</p><ul><li>函数的嵌套</li><li>闭包</li><li>装饰器</li></ul><p>上述内容均属于函数部分必备知识，以后开发时直接和间接都会使用，请务必理解<font color="#dd0000">（重在理解，不要去死记硬背）。</font></p><h3 id="1-函数嵌套"><a href="#1-函数嵌套" class="headerlink" title="1. 函数嵌套"></a>1. 函数嵌套</h3><p>​Python中以函数为作用域，在作用域中定义的相关数据只能被当前作用域或子作用域使用。</p><pre class="language-python" data-language="python"><code class="language-python">NAME &#x3D; &quot;武沛齐&quot;print(NAME)def func():    print(NAME)func()</code></pre><h4 id="1-1-函数在作用域中"><a href="#1-1-函数在作用域中" class="headerlink" title="1.1 函数在作用域中"></a>1.1 函数在作用域中</h4><p>​其实，函数也是定义在作用域中的数据，在执行函数时候，也同样遵循：优先在自己作用域中寻找，没有则向上一接作用域寻找，例如：</p><pre class="language-python" data-language="python"><code class="language-python"># 1. 在全局作用域定义了函数funcdef func():    print(&quot;你好&quot;)    # 2. 在全局作用域找到func函数并执行。func()# 3.在全局作用域定义了execute函数def execute():    print(&quot;开始&quot;)    # 优先在当前函数作用域找func函数，没有则向上级作用域中寻找。    func()    print(&quot;结束&quot;)# 4.在全局作用域执行execute函数execute()</code></pre><p>​此处，有一个易错点：作用域中的值在被调用时到底是啥？</p><ul><li><p>情景1</p><pre class="language-python" data-language="python"><code class="language-python">def func():    print(&quot;你好&quot;)    func()def execute():    print(&quot;开始&quot;)    func()    print(&quot;结束&quot;)    execute()def func():    print(666)    func()</code></pre></li><li><p>情景2</p><pre class="language-python" data-language="python"><code class="language-python">def func():    print(&quot;你好&quot;)    func()def execute():    print(&quot;开始&quot;)    func()    print(&quot;结束&quot;)def func():    print(666)func()execute()</code></pre></li></ul><h4 id="1-2-函数定义的位置"><a href="#1-2-函数定义的位置" class="headerlink" title="1.2 函数定义的位置"></a>1.2 函数定义的位置</h4><p>​上述示例中的函数均定义在全局作用域，其实<strong>函数也可以定义在局部作用域</strong>，这样函数被局部作用域和其子作用于中调用<font color="#dd0000">（函数的嵌套）</font>。</p><pre class="language-python" data-language="python"><code class="language-python">def func():    print(&quot;沙河高晓松&quot;)    def handler():    print(&quot;昌平吴彦祖&quot;)    def inner():        print(&quot;朝阳大妈&quot;)inner()    func()    print(&quot;海淀网友&quot;)handler()</code></pre><p>​到现在你会发现，只要理解数据定义时所存在的作用域，并根据从上到下代码执行过程进行分析，再怎么嵌套都可以搞定。</p><p>​现在的你可能有疑问：为什么要这么嵌套定义？把函数都定义在全局不好吗？</p><p>​其实，大多数情况下老师都会将函数定义在全局，不会嵌套着定义函数。不过，当我们定义一个函数去实现某功能，想要将内部功能拆分成N个函数，又担心这个N个函数放在全局会与其他<strong>函数名冲突</strong>时（尤其多人协同开发）可以<strong>选择使用函数的嵌套</strong>。</p><pre class="language-python" data-language="python"><code class="language-python">def f1():    passdef f2():    passdef func():f1()    f2()</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func():    def f1():        pass    def f2():        passf1()    f2()</code></pre><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;生成图片验证码的示例代码，需要提前安装pillow模块（Python中操作图片中一个第三方模块）pip3 install pillow&quot;&quot;&quot;import randomfrom PIL import Image, ImageDraw, ImageFontdef create_image_code(img_file_path, text&#x3D;None, size&#x3D;(120, 30), mode&#x3D;&quot;RGB&quot;, bg_color&#x3D;(255, 255, 255)):    &quot;&quot;&quot; 生成一个图片验证码 &quot;&quot;&quot;    _letter_cases &#x3D; &quot;abcdefghjkmnpqrstuvwxy&quot;  # 小写字母，去除可能干扰的i，l，o，z    _upper_cases &#x3D; _letter_cases.upper()  # 大写字母    _numbers &#x3D; &#39;&#39;.join(map(str, range(3, 10)))  # 数字    chars &#x3D; &#39;&#39;.join((_letter_cases, _upper_cases, _numbers))    width, height &#x3D; size  # 宽高    # 创建图形    img &#x3D; Image.new(mode, size, bg_color)    draw &#x3D; ImageDraw.Draw(img)  # 创建画笔    def get_chars():        &quot;&quot;&quot;生成给定长度的字符串，返回列表格式&quot;&quot;&quot;        return random.sample(chars, 4)    def create_lines():        &quot;&quot;&quot;绘制干扰线&quot;&quot;&quot;        line_num &#x3D; random.randint(*(1, 2))  # 干扰线条数        for i in range(line_num):            # 起始点            begin &#x3D; (random.randint(0, size[0]), random.randint(0, size[1]))            # 结束点            end &#x3D; (random.randint(0, size[0]), random.randint(0, size[1]))            draw.line([begin, end], fill&#x3D;(0, 0, 0))    def create_points():        &quot;&quot;&quot;绘制干扰点&quot;&quot;&quot;        chance &#x3D; min(100, max(0, int(2)))  # 大小限制在[0, 100]        for w in range(width):            for h in range(height):                tmp &#x3D; random.randint(0, 100)                if tmp &gt; 100 - chance:                    draw.point((w, h), fill&#x3D;(0, 0, 0))    def create_code():        &quot;&quot;&quot;绘制验证码字符&quot;&quot;&quot;        if text:            code_string &#x3D; text        else:            char_list &#x3D; get_chars()            code_string &#x3D; &#39;&#39;.join(char_list)  # 每个字符前后以空格隔开        # Win系统字体        # font &#x3D; ImageFont.truetype(r&quot;C:\Windows\Fonts\SEGOEPR.TTF&quot;, size&#x3D;24)        # Mac系统字体        # font &#x3D; ImageFont.truetype(&quot;&#x2F;System&#x2F;Library&#x2F;Fonts&#x2F;SFNSRounded.ttf&quot;, size&#x3D;24)        # 项目字体文件        font &#x3D; ImageFont.truetype(&quot;STKAITI.TTF&quot;, size&#x3D;15)        draw.text([0, 0], code_string, &quot;red&quot;, font&#x3D;font)        return code_string    create_lines()    create_points()    code &#x3D; create_code()    # 将图片写入到文件    with open(img_file_path, mode&#x3D;&#39;wb&#39;) as img_object:        img.save(img_object)    return codecode &#x3D; create_image_code(&quot;a2.png&quot;, &#39;耿天霸&#39;)print(code)</code></pre><h4 id="1-3-嵌套引发的作用域问题"><a href="#1-3-嵌套引发的作用域问题" class="headerlink" title="1.3 嵌套引发的作用域问题"></a>1.3 嵌套引发的作用域问题</h4><p>基于内存和执行过程分析作用域。</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;def run():    name &#x3D; &quot;alex&quot;    def inner():        print(name)inner()    run()</code></pre><img src="/2022/06/02/python-mo-kuai-er-day4/image-20201229131739455.png" class="" title="image-20201229131739455"><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;def run():    name &#x3D; &quot;alex&quot;    def inner():        print(name)return inner    v1 &#x3D; run()v1()v2 &#x3D; run()v2()</code></pre><img src="/2022/06/02/python-mo-kuai-er-day4/image-20201229132237241.png" class="" title="image-20201229132237241"><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;def run():    name &#x3D; &quot;alex&quot;    def inner():        print(name)return [inner,inner,inner]    func_list &#x3D; run()func_list[2]()func_list[1]()funcs &#x3D; run()funcs[2]()funcs[1]()</code></pre><img src="/2022/06/02/python-mo-kuai-er-day4/image-20201229132648896.png" class="" title="image-20201229132648896"><p><font color="#dd0000"><strong>三句话搞定作用域：</strong></font></p><ul><li><strong>优先在自己的作用域找，自己没有就去上级作用域。</strong></li><li><strong>在作用域中寻找值时，要确保此次此刻值是什么。</strong></li><li><strong>分析函数的执行，并确定函数<code>作用域链</code>。（函数嵌套）</strong></li></ul><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ol><li><p>分析代码，写结果</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &#39;武沛齐&#39;def func():    def inner():        print(name)    res &#x3D; inner()    return resv &#x3D; func()print(v)# 武沛齐# None</code></pre><img src="Python模块二day4/image-20220605203420301.png" alt="image-20220605203420301" style="zoom:25%;" /></li><li><p>分析代码，写结果</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &#39;武沛齐&#39;def func():    def inner():        print(name)        return &quot;alex&quot;    res &#x3D; inner()return resv &#x3D; func()print(v)</code></pre><img src="Python模块二day4/image-20220605204008387.png" alt="image-20220605204008387" style="zoom:25%;" /></li><li><p>分析代码，写结果</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &#39;root&#39;def func():    def inner():        print(name)        return &#39;admin&#39;    return innerv &#x3D; func()result &#x3D; v()print(result)</code></pre><img src="Python模块二day4/image-20220605204559954.png" alt="image-20220605204559954" style="zoom:25%;" /></li><li><p>分析代码，写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func():    name &#x3D; &#39;武沛齐&#39;    def inner():        print(name)         return &#39;路飞&#39;    return innerv11 &#x3D; func()data &#x3D; v11()print(data)v2 &#x3D; func()()print(v2)# 输出武沛齐路飞武沛齐路飞</code></pre></li><li><p>分析代码，写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(name):    # name&#x3D;&quot;alex&quot;    def inner():        print(name)        return &#39;luffy&#39;    return innerv1 &#x3D; func(&#39;武沛齐&#39;)()print(v1)v2 &#x3D; func(&#39;alex&#39;)()print(v2)</code></pre><img src="/2022/06/02/python-mo-kuai-er-day4/image-20201229140559322.png" class="" title="image-20201229140559322"><pre class="language-python" data-language="python"><code class="language-python">def func(name):    def inner():        print(name)        return &#39;luffy&#39;    return innerv1 &#x3D; func(&#39;武沛齐&#39;)v2 &#x3D; func(&#39;alex&#39;)v1()v2()</code></pre><img src="/2022/06/02/python-mo-kuai-er-day4/image-20201229165929911.png" class="" title="image-20201229165929911"></li><li><p>分析代码，写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(name&#x3D;None):    if not name:        name&#x3D; &#39;武沛齐&#39;    def inner():        print(name)        return &#39;root&#39;    return innerv1 &#x3D; func()()v2 &#x3D; func(&#39;alex&#39;)()print(v1,v2)# 武沛齐# alex# root root</code></pre><img src="/2022/06/02/python-mo-kuai-er-day4/image-20201229171258454.png" class="" title="image-20201229171258454"></li></ol><h3 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2.闭包"></a>2.闭包</h3><p>​闭包，简而言之就是将数据封装在一个包（区域）中，使用时再去里面取。（本质上 闭包是基于函数嵌套搞出来一个中特殊嵌套）</p><ul><li><p>闭包应用场景1：封装数据防止污染全局（<strong>使用较少，了解即可</strong>）。</p><pre class="language-python" data-language="python"><code class="language-python"># 函数f4不会用到name变量，因此可以定义函数func，在func内定义变量name，并将f1，f2，f3封装到func内name &#x3D; &quot;武沛齐&quot;def f1():    print(name, age)def f2():print(name, age)def f3():print(name, age)    def f4():    pass</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func(age):    name &#x3D; &quot;武沛齐&quot;    def f1():        print(name, age)    def f2():        print(name, age)    def f3():        print(name, age)    f1()    f2()    f3()def f4()passfunc(123)</code></pre></li><li><p>闭包应用场景2：<strong>封装数据封到一个包里，使用时在取。</strong></p><img src="/2022/06/02/python-mo-kuai-er-day4/image-20201229181719550.png" class="" title="image-20201229181719550"><pre class="language-python" data-language="python"><code class="language-python">def task(arg):    def inner():        print(arg)    return innerv1 &#x3D; task(11)v2 &#x3D; task(22)v3 &#x3D; task(33)v1()v2()v3()</code></pre><pre class="language-python" data-language="python"><code class="language-python">def task(arg):    def inner():        print(arg)    return innerinner_func_list &#x3D; []for val in [11,22,33]:    inner_func_list.append( task(val) )    inner_func_list[0]() # 11inner_func_list[1]() # 22inner_func_list[2]() # 33</code></pre><h4 id="案例：下载多个视频"><a href="#案例：下载多个视频" class="headerlink" title="案例：下载多个视频"></a><font color="#dd0000"><strong>案例</strong></font>：下载多个视频</h4><pre class="language-python" data-language="python"><code class="language-python"># ############### 原来方式：串行 ###############import requestsvideo_list &#x3D; [    (&quot;东北F4模仿秀.mp4&quot;, &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300f570000bvbmace0gvch7lo53oog&quot;),    (&quot;卡特扣篮.mp4&quot;, &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f3e0000bv52fpn5t6p007e34q1g&quot;),    (&quot;罗斯mvp.mp4&quot;, &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&quot;)]for item in video_list:    res &#x3D; requests.get(        url&#x3D;item[1],        headers&#x3D;&#123;            &quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 FS&quot;        &#125;    )    with open(item[0], mode&#x3D;&#39;wb&#39;) as file_object:        file_object.write(res.content)</code></pre><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot; 基于多线程去下载视频 &quot;&quot;&quot;from concurrent.futures.thread import ThreadPoolExecutorimport requestsdef download_video(url):    res &#x3D; requests.get(        url&#x3D;url,        headers&#x3D;&#123;            &quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 FS&quot;        &#125;    )    return res.contentdef outer(file_name):    def write_file(response):        content &#x3D; response.result()        with open(file_name, mode&#x3D;&#39;wb&#39;) as file_object:            file_object.write(content)    return write_filePOOL &#x3D; ThreadPoolExecutor(10)video_dict &#x3D; [    (&quot;东北F4模仿秀.mp4&quot;, &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300f570000bvbmace0gvch7lo53oog&quot;),    (&quot;卡特扣篮.mp4&quot;, &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f3e0000bv52fpn5t6p007e34q1g&quot;),    (&quot;罗斯mvp.mp4&quot;, &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&quot;)]for item in video_dict:    future &#x3D; POOL.submit(download_video, url&#x3D;item[1])    future.add_done_callback(outer(item[0]))POOL.shutdown()</code></pre><img src="/2022/06/02/python-mo-kuai-er-day4/image-20201229185549102.png" class="" title="image-20201229185549102"></li></ul><h3 id="3-装饰器"><a href="#3-装饰器" class="headerlink" title="3.装饰器"></a>3.装饰器</h3><p>​现在给你一个函数，在不修改函数源码的前提下，实现在函数执行前和执行后分别输入 “before” 和 “after”。</p><pre class="language-python" data-language="python"><code class="language-python">def func():    print(&quot;我是func函数&quot;)    value &#x3D; (11,22,33,44)     return value    result &#x3D; func()print(result)</code></pre><h4 id="3-1-第一回合"><a href="#3-1-第一回合" class="headerlink" title="3.1 第一回合"></a>3.1 第一回合</h4><p>你的实现思路：</p><pre class="language-python" data-language="python"><code class="language-python">def func():    print(&quot;before&quot;)        print(&quot;我是func函数&quot;)    value &#x3D; (11,22,33,44)         print(&quot;after&quot;)        return value    result &#x3D; func()</code></pre><p>老师的实现思路：</p><pre class="language-python" data-language="python"><code class="language-python">def func():    print(&quot;我是func函数&quot;)    value &#x3D; (11, 22, 33, 44)    return valuedef outer(origin):    def inner():        print(&#39;inner&#39;)        origin()        print(&quot;after&quot;)    return innerfunc &#x3D; outer(func)result &#x3D; func()</code></pre><p>处理返回值：</p><pre class="language-python" data-language="python"><code class="language-python">def func():    print(&quot;我是func函数&quot;)    value &#x3D; (11, 22, 33, 44)    return valuedef outer(origin):    def inner():        print(&#39;inner&#39;)        res &#x3D; origin()        print(&quot;after&quot;)        return res    return innerfunc &#x3D; outer(func)result &#x3D; func()</code></pre><h4 id="3-2-第二回合"><a href="#3-2-第二回合" class="headerlink" title="3.2 第二回合"></a>3.2 第二回合</h4><p>在Python中有个一个特殊的语法糖：</p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;在Python中有个一个特殊的语法糖：@函数名def xxx():    passpython内部会自动执行 函数名(xxx)， 并将结果赋值为xxx等价于：xxx &#x3D; 函数名(xxx)&#39;&#39;&#39;# 老师的思路def outer(origin):    def inner():        print(&#39;before&#39;)        res &#x3D; origin()        print(&#39;after&#39;)        return res    return inner@outer  # func &#x3D; outer(func)def func():    print(&quot;我是func函数&quot;)    value &#x3D; (11,22,33,44)    return valuefunc()</code></pre><h4 id="3-3-第三回合"><a href="#3-3-第三回合" class="headerlink" title="3.3 第三回合"></a>3.3 第三回合</h4><p>请在这3个函数执行前和执行后分别输入 “before” 和 “after”</p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;3个函数执行前和执行后分别输入 &quot;before&quot; 和 &quot;after&quot;&#39;&#39;&#39;def outer(origin):    def inner():        print(&quot;before 110&quot;)        res &#x3D; origin()  # 调用原来的func函数        print(&quot;after&quot;)        return res    return inner@outer  # func1 &#x3D; outer(func1)def func1():    print(&quot;我是func1函数&quot;)    value &#x3D; (11, 22, 33, 44)    return value@outer  # func2 &#x3D; outer(func2)def func2():    print(&quot;我是func2函数&quot;)    value &#x3D; (11, 22, 33, 44)    return value@outer  # func3 &#x3D; outer(func3)def func3():    print(&quot;我是func3函数&quot;)    value &#x3D; (11, 22, 33, 44)    return valuefunc1()func2()func3()</code></pre><p>你的实现思路：</p><pre class="language-python" data-language="python"><code class="language-python">def func1():    print(&#39;before&#39;)    print(&quot;我是func1函数&quot;)    value &#x3D; (11, 22, 33, 44)    print(&quot;after&quot;)    return value        def func2():    print(&#39;before&#39;)    print(&quot;我是func2函数&quot;)    value &#x3D; (11, 22, 33, 44)    print(&quot;after&quot;)    return value    def func3():    print(&#39;before&#39;)    print(&quot;我是func3函数&quot;)    value &#x3D; (11, 22, 33, 44)    print(&quot;after&quot;)    return value    func1()func2()func3()</code></pre><p>老师的实现思路：</p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;3个函数执行前和执行后分别输入 &quot;before&quot; 和 &quot;after&quot;&#39;&#39;&#39;def outer(origin):    def inner():        print(&quot;before 110&quot;)        res &#x3D; origin()  # 调用原来的func函数        print(&quot;after&quot;)        return res    return inner@outer  # func1 &#x3D; outer(func1)def func1():    print(&quot;我是func1函数&quot;)    value &#x3D; (11, 22, 33, 44)    return value@outer  # func2 &#x3D; outer(func2)def func2():    print(&quot;我是func2函数&quot;)    value &#x3D; (11, 22, 33, 44)    return value@outer  # func3 &#x3D; outer(func3)def func3():    print(&quot;我是func3函数&quot;)    value &#x3D; (11, 22, 33, 44)    return valuefunc1()func2()func3()</code></pre><p>​<strong>装饰器</strong>，在不修改原函数内容的前提下，通过@函数可以实现在函数前后自定义执行一些功能<font color="#dd0000"><strong>（批量操作会更有意义）。</strong></font></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>优化以支持多个参数的情况。</p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;3个函数执行前和执行后分别输入 &quot;before&quot; 和 &quot;after&quot;,并且每个函数都有参数&#39;&#39;&#39;def outer(origin):    def inner(*args, **kwargs):        print(&quot;before 110&quot;)        origin(*args, **kwargs)  # 调用原来的func函数        print(&quot;after&quot;)    return inner@outer  # func1 &#x3D; outer(func1)def func1(a1):    print(&quot;我是func1函数&quot;)    value &#x3D; (11, 22, 33, 44)    return value@outer  # func2 &#x3D; outer(func2)def func2(a1):    print(&quot;我是func2函数&quot;)    value &#x3D; (11, 22, 33, 44)    return value@outer  # func3 &#x3D; outer(func3)def func3(a1, a2):    print(&quot;我是func3函数&quot;)    value &#x3D; (11, 22, 33, 44)    return value# func1、2、3 函数本质上是在执行outer返回的inner函数，# 要想在func1、2、3中传入各种参数# 就要在inner函数内部能接受各种参数  *args**kwargs# 同时在inner内部调用origin的时候也要传入对应参数func1(1)func2(a1&#x3D;2)func3(1, a2&#x3D;3)</code></pre><p>其中，老师的那种写法就称为装饰器。</p><ul><li>实现原理：基于@语法和函数闭包，将原函数封装在闭包中，然后将函数赋值为一个新的函数（内层函数），执行函数时再在内层函数中执行闭包中的原函数。</li><li>实现效果：可以在不改变原函数内部代码 和 调用方式的前提下，实现在函数执行和执行扩展功能。</li><li>适用场景：多个函数系统统一在 执行前后自定义一些功能。</li></ul><h4 id="伪应用场景"><a href="#伪应用场景" class="headerlink" title="伪应用场景"></a>伪应用场景</h4><p>​在以后编写一个网站时，如果项目共有100个页面，其中99个是需要登录成功之后才有权限访问，就可以基于装饰器来实现。</p><pre class="language-none"><code class="language-none">pip3 install flask</code></pre><p>基于第三方模块Flask（框架）快速写一个网站：</p><pre class="language-python" data-language="python"><code class="language-python">from flask import Flaskapp &#x3D; Flask(__name__)def index():    return &quot;首页&quot;def info():    return &quot;用户中心&quot;def order():    return &quot;订单中心&quot;def login():    return &quot;登录页面&quot;app.add_url_rule(&quot;&#x2F;index&#x2F;&quot;, view_func&#x3D;index)app.add_url_rule(&quot;&#x2F;info&#x2F;&quot;, view_func&#x3D;info)app.add_url_rule(&quot;&#x2F;login&#x2F;&quot;, view_func&#x3D;login)app.run()</code></pre><p>​<strong>注意事项：在网址后面加上&#x2F;index&#x2F;…才能显示。</strong></p><p>基于装饰器实现的伪代码：</p><pre class="language-python" data-language="python"><code class="language-python">from flask import Flaskapp &#x3D; Flask(__name__)def auth(func):    def inner(*args, **kwargs):        # 在此处，判断如果用户是否已经登录，已登录则显示首页，未登录则自动跳转到登录页面。        return func(*args, **kwargs)    return inner@authdef index():    return &quot;首页&quot;@authdef info():    return &quot;用户中心&quot;@authdef order():    return &quot;订单中心&quot;def login():    return &quot;登录页面&quot;app.add_url_rule(&quot;&#x2F;index&#x2F;&quot;, view_func&#x3D;index, endpoint&#x3D;&#39;index&#39;)app.add_url_rule(&quot;&#x2F;info&#x2F;&quot;, view_func&#x3D;info, endpoint&#x3D;&#39;info&#39;)app.add_url_rule(&quot;&#x2F;order&#x2F;&quot;, view_func&#x3D;order, endpoint&#x3D;&#39;order&#39;)app.add_url_rule(&quot;&#x2F;login&#x2F;&quot;, view_func&#x3D;login, endpoint&#x3D;&#39;login&#39;)app.run()</code></pre><h4 id="重要补充：functools"><a href="#重要补充：functools" class="headerlink" title="重要补充：functools"></a>重要补充：functools</h4><p>​你会发现装饰器实际上就是将原函数更改为其他的函数，然后再此函数中再去调用原函数。</p><pre class="language-python" data-language="python"><code class="language-python">def handler():    passhandler()print(handler.__name__) # handler</code></pre><pre class="language-python" data-language="python"><code class="language-python">def auth(func):    def inner(*args, **kwargs):        return func(*args, **kwargs)    return inner@authdef handler():    passhandler()print(handler.__name__) # inner</code></pre><pre class="language-python" data-language="python"><code class="language-python">import functoolsdef auth(func):    @functools.wraps(func)    def inner(*args, **kwargs):        return func(*args, **kwargs)    return inner@authdef handler():    passhandler()print(handler.__name__)  # handler</code></pre><p>​其实，一般情况下大家不用functools也可以实现装饰器的基本功能，但后期<strong>在项目开发时，不加functools会出错（内部会读取<code>__name__</code>，且<code>__name__</code>重名的话就报错）</strong>，所以在此大家就要规范起来自己的写法。</p><h4 id="面试题-手写装饰器示例"><a href="#面试题-手写装饰器示例" class="headerlink" title="面试题:手写装饰器示例"></a><font color="#dd0000"><strong>面试题:手写装饰器示例</strong></font></h4><pre class="language-python" data-language="python"><code class="language-python">import functoolsdef auth(func):    @functools.wraps(func)    def inner(*args, **kwargs):        &quot;&quot;&quot;巴巴里吧&quot;&quot;&quot;        # 加入功能        res &#x3D; func(*args, **kwargs)  # 执行原函数        # 加入功能        return res    return inner</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>函数可以定义在全局、也可以定义另外一个函数中（函数的嵌套）</p></li><li><p>学会<strong>分析函数执行的步骤（内存中作用域的管理）</strong></p></li><li><p><strong>闭包</strong>，基于函数的嵌套，可以将数据封装到一个包中，以后再去调用。</p></li><li><p><font color="#dd0000"><strong>装饰器</strong></font><strong>装饰器</strong></p><ul><li><p>实现原理：基于@语法和函数闭包，将原函数封装在闭包中，然后将函数赋值为一个新的函数（内层函数），执行函数时再在内层函数中执行闭包中的原函数。</p></li><li><p>实现效果：可以在不改变原函数内部代码 和 调用方式的前提下，实现在函数执行和执行扩展功能。</p></li><li><p>适用场景：多个函数系统统一在 执行前后自定义一些功能。</p></li><li><p><font color="#dd0000"><strong>装饰器示例</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">import functoolsdef auth(func):    @functools.wraps(func)    def inner(*args, **kwargs):        &quot;&quot;&quot;巴巴里吧&quot;&quot;&quot;        res &#x3D; func(*args, **kwargs)  # 执行原函数        return res    return inner</code></pre></li></ul></li></ol><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol><li><p>请为以下所有函数编写一个装饰器，添加上装饰器后可以实现：执行func时，先执行func函数内部代码，再输出 “after”</p><pre class="language-python" data-language="python"><code class="language-python">def func(a1):    return a1 + &quot;傻叉&quot;def base(a1,a2):    return a1 + a2 + &#39;傻缺&#39;def foo(a1,a2,a3,a4):    return a1 + a2 + a3 + a4 + &#39;傻蛋&#39;</code></pre><pre class="language-python" data-language="python"><code class="language-python">import functoolsdef outer(origin):    @functools.wraps(origin)    def inner(*args, **kwargs):        &quot;&quot;&quot;inner函数&quot;&quot;&quot;        # 加入功能        res &#x3D; origin(*args, **kwargs)        # 加入功能        print(&#39;after&#39;)        return res    return inner@outerdef func(a1):    return a1 + &quot;傻叉&quot;@outerdef base(a1, a2):    return a1 + a2 + &#39;傻缺&#39;@outerdef foo(a1, a2, a3, a4):    return a1 + a2 + a3 + a4 + &#39;傻蛋&#39;func(&#39;1&#39;)base(&#39;1&#39;, a2&#x3D;&#39;aaa&#39;)foo(&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;, a4&#x3D;&#39;ddd&#39;)</code></pre></li><li><p>请为以下所有函数编写一个装饰器，添加上装饰器后可以实现：将被装饰的函数执行5次，将每次执行函数的结果按照顺序放到列表中，最终返回列表。</p><pre class="language-python" data-language="python"><code class="language-python">import random def func():    return random.randint(1,4)result &#x3D; func() # 内部自动执行5次，并将每次执行的结果追加到列表最终返回给resultprint(result) </code></pre><pre class="language-python" data-language="python"><code class="language-python">import functoolsimport randomdef outer(origin):    @functools.wraps(origin)    def inner(*args, **kwargs):        &quot;&quot;&quot;inner 函数&quot;&quot;&quot;        # 加入功能        count &#x3D; 0        out_list &#x3D; []        while count &lt; 5:            res &#x3D; origin()            # 加入功能            count +&#x3D; 1            out_list.append(res)        return out_list    return inner@outerdef func():    return random.randint(1,4)result &#x3D; func()print(result)</code></pre></li><li><p>请为以下函数编写一个装饰器，添加上装饰器后可以实现： 检查文件所在路径（文件件）是否存在，如果不存在自动创建文件夹（保证写入文件不报错）。</p><pre class="language-python" data-language="python"><code class="language-python">def write_user_info(path):    file_obj &#x3D; open(path, mode&#x3D;&#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;)    file_obj.write(&quot;武沛齐&quot;)    file_obj.close()write_user_info(&#39;&#x2F;usr&#x2F;bin&#x2F;xxx&#x2F;xxx.png&#39;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">import functoolsimport osdef path_exist(origin):    functools.wraps(origin)    @functools.wraps(origin)    def inner(path):        &quot;&quot;&quot;inner函数&quot;&quot;&quot;        # 加入功能        print(path)        dir &#x3D; path.rsplit(&#39;\\&#39;, 1)[0]  # [&#39;&#x2F;usr&#x2F;bin&#x2F;xxx&#39;]        if not os.path.exists(dir):            os.makedirs(dir)                origin(path)            # 加入功能    return inner@path_existdef write_user_info(path):    file_obj &#x3D; open(path, mode&#x3D;&#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;)    file_obj.write(&quot;武沛齐&quot;)    file_obj.close()    write_user_info(r&#39;C:\Users\Geng\Desktop\我在b站学编程\python\模块二\day13\xxx.txt&#39;)</code></pre></li><li><p>分析代码写结果：</p><pre class="language-python" data-language="python"><code class="language-python">def get_data():    scores &#x3D; []    def inner(val):        scores.append(val)        print(scores)    return innerfunc &#x3D; get_data()func(10)func(20)func(30)</code></pre><img src="Python模块二day4/image-20220606161005247.png" alt="image-20220606161005247" style="zoom:25%;" /><pre class="language-python" data-language="python"><code class="language-python"># [10]# [10, 20]# [10, 20, 30]</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;def foo():    print(name)def func():    name &#x3D; &quot;root&quot;    foo()func()</code></pre><pre class="language-pyhon" data-language="pyhon"><code class="language-pyhon"># root</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;def func():    name &#x3D; &quot;root&quot;    def foo():        print(name)    foo()func()</code></pre><pre class="language-python" data-language="python"><code class="language-python"># root</code></pre><p>答案：</p><pre class="language-python" data-language="python"><code class="language-python"># 武沛齐</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(val):    def inner(a1, a2):        return a1 + a2 + val    return innerdata_list &#x3D; []for i in range(10):    data_list.append(  func(i)   )print(data_list)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># [inner, inner, inner, inner, inner,  inner, inner, inner, inner, inner]</code></pre><p>答案</p><pre class="language-python" data-language="python"><code class="language-python"># [&lt;function func.&lt;locals&gt;.inner at 0x000001D42674B670&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4269BD0D0&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4269BD8B0&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD310&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD280&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD1F0&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD160&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD0D0&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295AD040&gt;, &lt;function func.&lt;locals&gt;.inner at 0x000001D4295A5CA0&gt;]</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(val):    def inner(a1, a2):        return a1 + a2 + val    return innerdata_list &#x3D; []for i in range(10):    data_list.append(func(i))v1 &#x3D; data_list[0](11,22)v2 &#x3D; data_list[2](33,11)print(v1)print(v2)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 33# 46</code></pre></li></ol><h2 id="十四、内置函数和推导式"><a href="#十四、内置函数和推导式" class="headerlink" title="十四、内置函数和推导式"></a>十四、内置函数和推导式</h2><img src="/2022/06/02/python-mo-kuai-er-day4/image-20201230125816095.png" class="" title="image-20201230125816095"> <p>今日概要：</p><ul><li>匿名函数</li><li>生成器</li><li>内置函数</li><li><span style='color:red;'><strong>附加</strong></span>：推导式，属于数据类型的知识，内部的高级的用法会涉及到【生成器】和【函数】的知识。</li></ul><h3 id="1-匿名函数"><a href="#1-匿名函数" class="headerlink" title="1. 匿名函数"></a>1. 匿名函数</h3><p>传统的函数的定义包括了：函数名 + 函数体。</p><pre class="language-python" data-language="python"><code class="language-python">def send_email():    pass# 1. 执行send_email()# 2. 当做列表元素data_list &#x3D; [send_email, send_email, send_email ]# 3. 当做参数传递other_function(send_email)</code></pre><p>匿名函数，则是基于lambda表达式实现定义一个可以没有名字的函数，例如：</p><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [ lambda x:x+100,  lambda x:x+110, lambda x:x+120 ]print( data_list[0] )</code></pre><pre class="language-python" data-language="python"><code class="language-python">f1 &#x3D; lambda x:x+100res &#x3D; f1(100)print(res)</code></pre><p><strong>基于Lambda定义的函数格式为：<code>lambda 参数:函数体</code></strong></p><ul><li><p>参数，支持任意参数。</p><pre class="language-python" data-language="python"><code class="language-python">lambda x: 函数体lambda x1,x2: 函数体lambda *args, **kwargs: 函数体</code></pre></li><li><p>函数体，<span style='color:red;'><strong>只能支持单行的代码。</strong></span></p><pre class="language-python" data-language="python"><code class="language-python">lambda x: x + 100# 等价于def xxx(x):    return x + 100</code></pre></li><li><p>返回值，默认将函数体单行代码执行的结果返回给函数的执行这。</p><pre class="language-python" data-language="python"><code class="language-python">func &#x3D; lambda x: x + 100v1 &#x3D; func(10)print(v1) # 110</code></pre></li></ul><pre class="language-python" data-language="python"><code class="language-python">def func(a1,a2):    return a1 + a2 + 100foo &#x3D; lambda a1,a2: a1 + a2 + 100</code></pre><p><strong>匿名函数适用于简单的业务处理，可以快速并简单的创建函数。</strong></p><h4 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h4><p>根据函数写写出其匿名函数的表达方式</p><pre class="language-python" data-language="python"><code class="language-python">def func(a1,a2):    return a1 + a2func &#x3D; lambda a1,a2: a1+a2</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func(data):    return data.replace(&quot;苍老师&quot;,&quot;***&quot;)func&#x3D; lambda data: data.replace(&quot;苍老师&quot;,&quot;***&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func(data):    name_list &#x3D; data.replace(&quot;.&quot;)    return name_list[-1]func &#x3D; lambda data: data.replace(&quot;.&quot;)[-1]</code></pre><p>在编写匿名函数时，由于受限 函数体只能写一行，所以匿名函数只能处理非常简单的功能。</p><h4 id="扩展：三元运算"><a href="#扩展：三元运算" class="headerlink" title="扩展：三元运算"></a>扩展：三元运算</h4><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; input(&quot;请写入内容&quot;)if &quot;苍老师&quot; in num:    data &#x3D; &quot;臭不要脸&quot;else:    data &#x3D; &quot;正经人&quot;    print(data)</code></pre><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; input(&quot;请写入内容&quot;)data &#x3D; &quot;臭不要脸&quot; if &quot;苍老师&quot; in num else &quot;正经人&quot;print(data)# 结果 &#x3D;  条件成立时    if   条件   else   不成立</code></pre><p><strong>怎么看三元表达式：</strong></p><blockquote><p>1.看if和else中间的语句</p><p>2.成立，把if前面的值赋值给data</p><p>3.不成立，把else后的值赋值给data</p></blockquote><p>​lambda表达式和三元运算没有任何关系，属于两个独立的知识点。</p><p>掌握三元运算之后，以后再编写匿名函数时，就可以处理再稍微复杂点的情况了，例如：</p><pre class="language-python" data-language="python"><code class="language-python">func &#x3D; lambda x: &quot;大了&quot; if x &gt; 66 else &quot;小了&quot;# 等价于def func(x):    return &quot;大了&quot; if x &gt; 66 else &quot;小了&quot;def func(x):    if x &gt; 66:        return &#39;大了&#39;    return &#39;小了&#39;</code></pre><p><strong>写在最后：</strong></p><ul><li><p><strong>简单的函数，可以基于lambda表达式实现。</strong></p></li><li><p><strong>简单的条件语句，可以基于三元运算实现，例如：</strong></p></li></ul><h3 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2. 生成器"></a>2. 生成器</h3><p>​生成器是由函数+yield关键字创造出来的写法，在特定情况下，用他可以帮助我们节省内存。</p><ul><li><p>生成器函数，但函数中有yield存在时，这个函数就是生产生成器函数。</p><pre class="language-python" data-language="python"><code class="language-python">def func():    print(111)    yield 1</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func():    print(111)    yield 1    print(222)    yield 2    print(333)    yield 3    print(444)</code></pre></li><li><p>生成器对象，执行生成器函数时，会返回一个生成器对象。</p><pre class="language-python" data-language="python"><code class="language-python">def func():    print(111)    yield 1    print(222)    yield 2    print(333)    yield 3    print(444)    data &#x3D; func()# 执行生成器函数func，返回的生成器对象。# 注意：执行生成器函数时，函数内部代码不会执行。</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func():    print(111)    yield 1    print(222)    yield 2    print(333)    yield 3    print(444)    data &#x3D; func()v1 &#x3D; next(data)print(v1)v2 &#x3D; next(data)print(v2)v3 &#x3D; next(data)print(v3)v4 &#x3D; next(data)print(v4)  # 结束或中途遇到return，程序爆：StopIteration 错误</code></pre><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; func()for item in data:    print(item)</code></pre></li></ul><p>​生成器的特点是，记录在函数中的执行位置，下次执行next时，会从上一次的位置基础上再继续向下执行。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p>假设要让你生成 300w个随机的4位数，并打印出来。</p><ul><li>在内存中一次性创建300w个</li><li>动态创建，用一个创建一个。</li></ul><pre class="language-python" data-language="python"><code class="language-python">import randomval &#x3D; random.randint(1000, 9999)print(val)</code></pre><pre class="language-python" data-language="python"><code class="language-python">import randomdata_list &#x3D; []for i in range(300000000):    val &#x3D; random.randint(1000, 9999)data_list.append(val)    # 再使用时，去 data_list 中获取即可。# ...</code></pre><pre class="language-python" data-language="python"><code class="language-python">import randomdef gen_random_num(max_count):    counter &#x3D; 0    while counter &lt; max_count:        yield random.randint(1000, 9999)        counter +&#x3D; 1data_list &#x3D; gen_random_num(3000000)# 再使用时，去 data_list 中获取即可。</code></pre></li><li><p>假设让你从某个数据源中获取300w条数据（后期学习操作MySQL 或 Redis等数据源再操作，了解思想即可）。</p></li></ul><img src="Python模块二day4/image-20201230174253215.png" alt="image-20201230174253215" style="zoom: 33%;" /><p>所以，当以后需要我们在内存中创建很多数据时，可以想着用基于生成器来实现一点一点生成（用一点生产一点），以节省内存的开销。</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><pre class="language-python" data-language="python"><code class="language-python">def func():    print(111)    v1 &#x3D; yield 1    print(v1)    print(222)    v2 &#x3D; yield 2    print(v2)    print(333)    v3 &#x3D; yield 3    print(v3)    print(444)data &#x3D; func()n1 &#x3D; data.send(None)print(n1)n2 &#x3D; data.send(666)print(n2)n3 &#x3D; data.send(777)print(n3)n4 &#x3D; data.send(888)print(n4)</code></pre><h3 id="3-内置函数"><a href="#3-内置函数" class="headerlink" title="3.内置函数"></a>3.内置函数</h3><img src="Python模块二day4/image-20201230201618164.png" alt="image-20201230201618164" style="zoom:50%;" /><p>Python内部为我们提供了很多方便的内置函数，在此整理出来<strong>36</strong>个给大家来讲解。</p><ul><li><p>第1组（5个）</p><ul><li><p>abs，绝对值</p><pre class="language-python" data-language="python"><code class="language-python">v &#x3D; abs(-10)</code></pre></li><li><p>pow，指数</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; pow(2,5) # 2的5次方  2**5print(v1)</code></pre></li><li><p>sum，求和</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; sum([-11, 22, 33, 44, 55]) # 可以被迭代（可for循环）print(v1)</code></pre></li><li><p>divmod，求商和余数</p><pre class="language-none"><code class="language-none">v1, v2 &#x3D; divmod(9, 2)print(v1, v2)</code></pre></li><li><p>round，小数点后n位（四舍五入）</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; round(4.11786, 2)print(v1) # 4.12</code></pre></li></ul></li><li><p>第2组：（4个）</p><ul><li><p>min，最小值</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; min(11, 2, 3, 4, 5, 56)print(v1) # 2</code></pre><pre class="language-none"><code class="language-none">v2 &#x3D; min([11, 22, 33, 44, 55]) # 迭代的类型（可for循环）print(v2)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 支持lambda表达式v3 &#x3D; min([-11, 2, 33, 44, 55], key&#x3D;lambda x: abs(x))  # key：含一个参数的函数print(v3) # 2（取原来的值）</code></pre></li><li><p>max，最大值</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; max(11, 2, 3, 4, 5, 56)print(v1)v2 &#x3D; max([11, 22, 33, 44, 55])print(v2)</code></pre><pre class="language-python" data-language="python"><code class="language-python">v3 &#x3D; max([-11, 22, 33, 44, 55], key&#x3D;lambda x: x * 10)print(v3) # 55</code></pre></li><li><p>all，是否全部为True</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; all(   [11,22,44,&quot;&quot;]   ) # False</code></pre></li><li><p>any，是否存在True</p><pre class="language-python" data-language="python"><code class="language-python">v2 &#x3D; any([11,22,44,&quot;&quot;]) # True</code></pre></li></ul></li><li><p>第3组（3个）</p><ul><li>bin，十进制转二进制</li><li>oct，十进制转八进制</li><li>hex，十进制转十六进制</li></ul></li><li><p>第4组（2个）</p><ul><li><p>ord，获取字符对应的unicode码点（十进制）</p><pre class="language-none"><code class="language-none">v1 &#x3D; ord(&quot;武&quot;)print(v1, hex(v1))</code></pre></li><li><p>chr，根据码点（十进制）获取对应字符</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; chr(27494)print(v1)</code></pre></li></ul></li><li><p>第5组（9个）</p><ul><li><p>int</p></li><li><p>foat</p></li><li><p>str，unicode编码</p></li><li><p>bytes，utf-8、gbk编码</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;武沛齐&quot;  # str类型v2 &#x3D; v1.encode(&#39;utf-8&#39;)  # bytes类型v3 &#x3D; bytes(v1,encoding&#x3D;&quot;utf-8&quot;) # bytes类型</code></pre></li><li><p>bool</p></li><li><p>list</p></li><li><p>dict</p></li><li><p>tuple</p></li><li><p>set</p></li></ul></li><li><p>第6组（13个）</p><ul><li><p>len</p></li><li><p>print</p></li><li><p>input</p></li><li><p>open</p></li><li><p>type，获取数据类型</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;123&quot;if type(v1) &#x3D;&#x3D; str:    passelse:    pass</code></pre></li><li><p>range </p><pre class="language-python" data-language="python"><code class="language-python">range(10)</code></pre></li><li><p>enumerate</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; [&quot;武沛齐&quot;, &quot;alex&quot;, &#39;root&#39;]for num, value in enumerate(v1, 1):    print(num, value)</code></pre></li><li><p>id</p></li><li><p>hash</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; hash(&quot;武沛齐&quot;)</code></pre></li><li><p>help，帮助信息</p><ul><li>pycharm，不用（ctrl+鼠标左键即可查看源码）</li><li>终端，使用（Q退出）</li></ul></li><li><p>zip</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; [11, 22, 33, 44, 55, 66]v2 &#x3D; [55, 66, 77, 88]v3 &#x3D; [10, 20, 30, 40, 50]    result &#x3D; zip(v1, v2, v3)for item in result:    print(item)</code></pre></li><li><p>callable，是否可执行（后面是否可以加括号）。</p><pre class="language-none"><code class="language-none">v1 &#x3D; &quot;武沛齐&quot;v2 &#x3D; lambda x: xdef v3():    passprint( callable(v1) ) # Falseprint(callable(v2))print(callable(v3))</code></pre></li><li><p>sorted，排序</p><p>相较于list.sort()，sorted还支持元组，字典的排序</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; sorted([11,22,33,44,55], reverse&#x3D;True)</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;    &quot;wupeiqi&quot;: &#123;        &#39;id&#39;: 10,        &#39;age&#39;: 119    &#125;,    &quot;root&quot;: &#123;        &#39;id&#39;: 20,        &#39;age&#39;: 29    &#125;,    &quot;seven&quot;: &#123;        &#39;id&#39;: 9,        &#39;age&#39;: 9    &#125;,    &quot;admin&quot;: &#123;        &#39;id&#39;: 11,        &#39;age&#39;: 139    &#125;,&#125;result &#x3D; sorted(info.items(), key&#x3D;lambda x: x[1][&#39;id&#39;])print(result)</code></pre><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [    &#39;1-5 编译器和解释器.mp4&#39;,    &#39;1-17 今日作业.mp4&#39;,    &#39;1-9 Python解释器种类.mp4&#39;,    &#39;1-16 今日总结.mp4&#39;,    &#39;1-2 课堂笔记的创建.mp4&#39;,    &#39;1-15 Pycharm使用和破解（win系统）.mp4&#39;,    &#39;1-12 python解释器的安装（mac系统）.mp4&#39;,    &#39;1-13 python解释器的安装（win系统）.mp4&#39;,    &#39;1-8 Python介绍.mp4&#39;, &#39;1-7 编程语言的分类.mp4&#39;,    &#39;1-3 常见计算机基本概念.mp4&#39;,    &#39;1-14 Pycharm使用和破解（mac系统）.mp4&#39;,    &#39;1-10 CPython解释器版本.mp4&#39;,    &#39;1-1 今日概要.mp4&#39;,    &#39;1-6 学习编程本质上的三件事.mp4&#39;,    &#39;1-18 作业答案和讲解.mp4&#39;,    &#39;1-4 编程语言.mp4&#39;,    &#39;1-11 环境搭建说明.mp4&#39;]result &#x3D; sorted(data_list, key&#x3D;lambda x: int(x.split(&#39; &#39;)[0].split(&quot;-&quot;)[-1]) )print(result)</code></pre></li></ul></li></ul><h3 id="4-推导式"><a href="#4-推导式" class="headerlink" title="4.推导式"></a>4.推导式</h3><p>​推导式是Python中提供了一个非常方便的功能，可以让我们通过一行代码实现创建list、dict、tuple、set 的同时初始化一些值。</p><p>请创建一个列表，并在列表中初始化：0、1、2、3、4、5、6、7、8、9…299 整数元素。</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; []for i in range(300):    data.append(i)</code></pre><ul><li><p>列表</p><pre class="language-python" data-language="python"><code class="language-python">num_list &#x3D; [ i for i in range(10)]num_list &#x3D; [ [i,i] for i in range(10)]num_list &#x3D; [ [i,i] for i in range(10) if i &gt; 6 ]</code></pre></li><li><p>集合</p><pre class="language-python" data-language="python"><code class="language-python">num_set &#x3D; &#123; i for i in range(10)&#125;num_set &#x3D; &#123; (i,i,i) for i in range(10)&#125;num_set &#x3D; &#123; (i,i,i) for i in range(10) if i&gt;3&#125;</code></pre></li><li><p>字典</p><pre class="language-python" data-language="python"><code class="language-python">num_dict &#x3D; &#123; i:i for i in range(10)&#125;num_dict &#x3D; &#123; i:(i,11) for i in range(10)&#125;num_dict &#x3D; &#123; i:(i,11) for i in range(10) if i&gt;7&#125;</code></pre></li><li><p>元组，<span style="color:red">不同于其他类型。</span></p><pre class="language-python" data-language="python"><code class="language-python"># 不会立即执行内部循环去生成数据，而是得到一个生成器。data &#x3D; (i for i in range(10))print(data)for item in data:    print(item)</code></pre></li></ul><h4 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h4><ol><li><p>去除列表中每个元素的 <code>.mp4</code>后缀。</p><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [    &#39;1-5 编译器和解释器.mp4&#39;,    &#39;1-17 今日作业.mp4&#39;,    &#39;1-9 Python解释器种类.mp4&#39;,    &#39;1-16 今日总结.mp4&#39;,    &#39;1-2 课堂笔记的创建.mp4&#39;,    &#39;1-15 Pycharm使用和破解（win系统）.mp4&#39;,    &#39;1-12 python解释器的安装（mac系统）.mp4&#39;,    &#39;1-13 python解释器的安装（win系统）.mp4&#39;,    &#39;1-8 Python介绍.mp4&#39;, &#39;1-7 编程语言的分类.mp4&#39;,    &#39;1-3 常见计算机基本概念.mp4&#39;,    &#39;1-14 Pycharm使用和破解（mac系统）.mp4&#39;,    &#39;1-10 CPython解释器版本.mp4&#39;,    &#39;1-1 今日概要.mp4&#39;,    &#39;1-6 学习编程本质上的三件事.mp4&#39;,    &#39;1-18 作业答案和讲解.mp4&#39;,    &#39;1-4 编程语言.mp4&#39;,    &#39;1-11 环境搭建说明.mp4&#39;]result &#x3D; []for item in data_list:    result.append(item.rsplit(&#39;.&#39;,1)[0])    result &#x3D; [ item.rsplit(&#39;.&#39;,1)[0] for item in data_list]</code></pre></li><li><p>将字典中的元素按照 <code>键-值</code>格式化，并最终使用 <code>;</code>连接起来。</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;    &quot;name&quot;:&quot;武沛齐&quot;,    &quot;email&quot;:&quot;xxx@live.com&quot;,    &quot;gender&quot;:&quot;男&quot;,&#125;data_list [] for k,v in info.items():    temp &#x3D; &quot;&#123;&#125;-&#123;&#125;&quot;.format(k,v)    temp.append(data_list)resutl &#x3D; &quot;;&quot;.join(data)result &#x3D; &quot;;&quot;.join( [ &quot;&#123;&#125;-&#123;&#125;&quot;.format(k,v) for k,v in info.items()] )</code></pre></li><li><p>将字典按照键从小到大排序，然后在按照如下格式拼接起来。（微信支付API内部处理需求）</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;    &#39;sign_type&#39;: &quot;MD5&quot;,    &#39;out_refund_no&#39;: &quot;12323&quot;,    &#39;appid&#39;: &#39;wx55cca0b94f723dc7&#39;,    &#39;mch_id&#39;: &#39;1526049051&#39;,    &#39;out_trade_no&#39;: &quot;ffff&quot;,    &#39;nonce_str&#39;: &quot;sdfdffd&quot;,    &#39;total_fee&#39;: 9901,    &#39;refund_fee&#39;: 10000&#125;data &#x3D; &quot;&amp;&quot;.join([&quot;&#123;&#125;&#x3D;&#123;&#125;&quot;.format(key, value) for key, value in sorted(info.items(), key&#x3D;lambda x: x[0])])print(data)</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func():    print(123)data_list &#x3D; [func for i in range(10)]print(data_list)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># [十个func函数]</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(num):    return num + 100data_list &#x3D; [func(i) for i in range(10)]print(data_list)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># [100, 101, 102, 103, 104, 105, 106, 107, 108, 109]</code></pre></li><li><p>看代码写结果（执行出错，通过他可以让你更好的理解执行过程）</p><pre class="language-python" data-language="python"><code class="language-python">def func(x):    return x + idata_list &#x3D; [func for i in range(10)]val &#x3D; data_list[0](100)print(val)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 没有定义变量i</code></pre></li><li><p>看代码写结果（新浪微博面试题）</p><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [lambda x: x + i for i in range(10)]  # [函数,函数,函数]   i&#x3D;9v1 &#x3D; data_list[0](100)v2 &#x3D; data_list[3](100)print(v1, v2)  </code></pre><pre class="language-python" data-language="python"><code class="language-python"># 100# 103</code></pre><p><span style="color:red"><strong>写在最后：推导式本质还是一个函数，因此在推导式中也会形成自己的作用域。</strong></span></p><h3 id="小高级"><a href="#小高级" class="headerlink" title="小高级"></a>小高级</h3></li><li><p>推导式支持嵌套</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; [ (i,j) for j in range(5) for i in range(10)]# 等价于data &#x3D; []for i in range(10):    for j in range(5):        data.append( (i,j) )data &#x3D; [ [i, j] for j in range(5) for i in range(10)]</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 一副扑克牌poker_list &#x3D; [ (color,num) for num in range(1,14) for color in [&quot;红桃&quot;, &quot;黑桃&quot;, &quot;方片&quot;, &quot;梅花&quot;]]poker_list &#x3D; [ [color, num] for num in range(1, 14) for color in [&quot;红桃&quot;, &quot;黑桃&quot;, &quot;方片&quot;, &quot;梅花&quot;]]print(poker_list)</code></pre></li><li><p>烧脑面试题</p><pre class="language-python" data-language="python"><code class="language-python">def num():    return [lambda x: i * x for i in range(4)]# 1. num()并获取返回值  [lambda0, lambda1, lambda2, lambda3] i&#x3D;3# 2. for循环返回值 lambda0(2) ...# 3. 返回值的每个元素(2)  6 result &#x3D; [m(2) for m in num()]  # [6,6,6,6]print(result)</code></pre><pre class="language-python" data-language="python"><code class="language-python">def num():    return (lambda x: i * x for i in range(4))# 1. num()并获取返回值  生成器对象(lambda x: i * x for i in range(4))中的循环没有执行# 2. for循环返回值  开始遍历生成器对象时(lambda x: i * x for i in range(4))中的循环开始执行# 3. 返回值的每个元素(2)result &#x3D; [m(2) for m in num()]  # [0,2,4,6 ]print(result)</code></pre></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>匿名函数，基于lambda表达式实现一行创建一个函数。一般用于编写简单的函数。</li><li>三元运算，用一行代码实现处理简单的条件判断和赋值。</li><li>生成器，函数中如果yield关键字<ul><li>生成器函数</li><li>生成器对象</li><li>执行生成器函数中的代码<ul><li>next</li><li>for（常用）</li><li>send</li></ul></li></ul></li><li>内置函数（36个）</li><li>推导式<ul><li>常规操作</li><li>小高级操作</li></ul></li></ol><h3 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h3><ol><li><p>看代码写结果</p><pre class="language-none"><code class="language-none">v &#x3D; [ lambda :x  for x in range(10)] print(v)print(v[0])print(v[0]())</code></pre><pre class="language-python" data-language="python"><code class="language-python"># [lambda0, lambda1, lambda2, ... lambda9] i &#x3D; 9# lambda0 i&#x3D;9# 9</code></pre></li><li><p>看代码写结果</p><pre class="language-none"><code class="language-none">v &#x3D; [i for i in range(10,0,-1) if i &gt; 5]print(v)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># [10, 9, 8, 7, 6]</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; [lambda x:x*i for i in range(10)]print(data)print(data[0](2))print(data[0](2) &#x3D;&#x3D; data[8](2))</code></pre><pre class="language-python" data-language="python"><code class="language-python"># [lambda0, lambda1, lambda2, ... lambda9] i &#x3D; 9# 18# True</code></pre></li><li><p>请用列表推导式实现，踢出列表中的字符串，最终生成一个新的列表保存。</p><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [11,22,33,&quot;alex&quot;,455,&#39;eirc&#39;]new_data_list &#x3D; [ ... ] # 请在[]中补充代码实现。# 提示：可以用type判断类型</code></pre><pre class="language-python" data-language="python"><code class="language-python">new_data_list &#x3D; [i for i in data_list if type(i) &#x3D;&#x3D; int]</code></pre></li><li><p>请用列表推导式实现，对data_list中的每个元素判断，如果是字符串类型，则计算长度作为元素放在新列表的元素中；如果是整型，则让其值+100 作为元素放在新的列表的元素中。</p><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [11,22,33,&quot;alex&quot;,455,&#39;eirc&#39;]new_data_list &#x3D; [ ... ] # 请在[]中补充代码实现。# 提示：可以基于三元运算实现</code></pre><pre class="language-python" data-language="python"><code class="language-python">new_list &#x3D; [len(i) if type(i) &#x3D;&#x3D; str else i+100 for i in data_list]</code></pre></li><li><p>请使用字典推导式实现，将如果列表构造成指定格式字典.</p><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [    (1,&#39;alex&#39;,19),    (2,&#39;老男&#39;,84),    (3,&#39;老女&#39;,73)]# 请使用推导式将data_list构造生如下格式：&quot;&quot;&quot;info_dict &#x3D; &#123;    1:(1,&#39;alex&#39;,19),    2:(2,&#39;老男&#39;,84),    3:(3,&#39;老女&#39;,73)&#125;&quot;&quot;&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">info_dic &#x3D; &#123;index: item for index, item in enumerate(data_list, 1)&#125;</code></pre></li><li><p>有4个人玩扑克牌比大小，请对比字典中每个人的牌的大小，并输入优胜者的姓名（值大的胜利，不必考虑A）。</p><pre class="language-python" data-language="python"><code class="language-python">player &#x3D; &#123;    &quot;武沛齐&quot;:[&quot;红桃&quot;,10],    &quot;alex&quot;:[&quot;红桃&quot;,8],    &#39;eric&#39;:[&quot;黑桃&quot;,3],    &#39;killy&#39;:[&quot;梅花&quot;,12],&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">player_sorted &#x3D; sorted(player, key&#x3D;lambda x: player[x][1], reverse&#x3D;True)print(player_sorted[0])</code></pre></li><li><p>尽量多的列举你记得的内置函数？【能记住多少就写多少，不强制去背，在此尽全力写即可，这种公共后续用的多了就自然而然就记住了】</p><pre class="language-python" data-language="python"><code class="language-python">abs(), pow(), max(), min(), len(), type(), sorted(), sum(), bin(), oct(), hex(), ord(), chr(), print(), input(), tuple(), list(), dict(), set(), str(), int(), float()</code></pre></li><li><p>请编写一个生成器函数实现生成n个斐波那契数列的值。</p><ul><li><p>什么是斐波那契数列？</p><pre class="language-none"><code class="language-none">前两个数相加的结果，就是下一个数。1 1 2 3 5 8 13 21 34 55 ...</code></pre></li><li><p>代码结构示例，请在此基础上补充代码实现。</p><pre class="language-python" data-language="python"><code class="language-python">def fib(max_count):    passcount &#x3D; input(&quot;请输入要生成斐波那契数列的个数：&quot;)count &#x3D; int(count)fib_generator &#x3D; fib(count)for num in fib_generator:    print(num) </code></pre><pre class="language-python" data-language="python"><code class="language-python">def fib(max_count):    count &#x3D; 0    while count &lt; max_count - 2:        list.append(list[-1] + list[-2])        for i in list:            yield i        count +&#x3D; 1count &#x3D; input(&quot;请输入要生成斐波那契数列的个数：&quot;)count &#x3D; int(count)fib_generator &#x3D; fib(count)for num in fib_generator:    print(num)</code></pre></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 第二阶段 </tag>
            
            <tag> 函数和模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块二day1</title>
      <link href="/2022/05/27/python-mo-kuai-er-day3/"/>
      <url>/2022/05/27/python-mo-kuai-er-day3/</url>
      
        <content type="html"><![CDATA[<p>​从今天开始，我们将进入系列课程第二模块的的学习。第一模块主要是学习python基础知识，从第二模块开始就可以通过程序去解决工作中实际的问题。</p><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201216140222926.png" class="" title="image-20201216140222926"><p>从今天开始，我们将进入第二模块的学习，此模块主要包含两大部分：</p><ul><li><p><font color="#dd0000">函数，一个用于专门实现某个功能的代码块（可重用）。</font></p><ul><li><p>内置函数</p><pre class="language-none"><code class="language-none">len、bin、oct、hex 等</code></pre></li><li><p>自定义函数</p><pre class="language-python" data-language="python"><code class="language-python"># 定义函数def send_email():    # 写了10行代码，实现了发送邮件。    pass# 调用函数send_email()</code></pre></li></ul></li><li><p><font color="#dd0000">模块，集成了很多功能的函数集合。</font></p><ul><li><p>内置模块，Python内部帮助我们提供好的。</p><pre class="language-python" data-language="python"><code class="language-python">import randomnum &#x3D; random.randint(0,19)</code></pre><pre class="language-python" data-language="python"><code class="language-python">import decimalv1 &#x3D; decimal.Decimal(&quot;0.1&quot;)v2 &#x3D; decimal.Decimal(&quot;0.2&quot;)v3 &#x3D; v1 + v2print(v3) # 0.3</code></pre></li><li><p>第三方模块，网上下载别人写好的模块（功能集合）。</p></li><li><p>自定义模块</p></li></ul></li></ul><h2 id="十、-文件操作相关"><a href="#十、-文件操作相关" class="headerlink" title="十、 文件操作相关"></a>十、 文件操作相关</h2><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201216175307239.png" class="" title="image-20201216175307239"><p>课程目标：</p><p>​掌握基于Python对文件相关操作。</p><p>课程概要：</p><ul><li>文件操作</li><li>文件夹和路径</li><li>csv格式文件</li><li>ini格式文件                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </li><li>xml格式文件</li><li>excel文件</li><li>压缩文件</li></ul><p>​注意：每种格式包含很多相关操作，大家在学习的过程中只要掌握知识点的用法，<font color="#dd0000">参考笔记可以实现相关的练习即可，不必背会（在企业开发过程中也是边搜边实现。）</font></p><h3 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1. 文件操作"></a>1. 文件操作</h3><p>​在学习文件操作之前，先来回顾一下编码的相关以及先关数据类型的知识。</p><ul><li><p>字符串类型（str），在程序中用于表示文字信息，<strong>本质上是unicode编码中的二进制</strong>。</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;</code></pre></li><li><p>字节类型（bytes）</p><ul><li><p>可表示文字信息，<strong>本质上是utf-8&#x2F;gbk等编码的二进制</strong>（对unicode进行压缩，方便文件存储和网络传输。）</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;data &#x3D; name.encode(&#39;utf-8&#39;)print(data) # b&#39;\xe6\xad\xa6\xe6\xb2\x9b\xe9\xbd\x90&#39;result &#x3D; data.decode(&#39;utf-8&#39;)print(result) # &quot;武沛齐&quot;</code></pre></li><li><p>可表示原始二进制（图片、文件等信息）</p></li></ul></li></ul><h4 id="1-1-读文件"><a href="#1-1-读文件" class="headerlink" title="1.1 读文件"></a>1.1 读文件</h4><ul><li><p>读文本文件</p><pre class="language-python" data-language="python"><code class="language-python"># 1.打开文件#- 路径：#相对路径：&#39;info.txt&#39;#绝对路径：&#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;info.txt&#39;# - 模式# rb，表示读取文件原始的二进制（r, 读 read；b, 二进制 binary；）# 1.打开文件file_object &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;rb&#39;)# 2.读取文件内容，并赋值给datadata &#x3D; file_object.read()# 3.关闭文件file_object.close()print(data) # b&#39;alex-123\n\xe6\xad\xa6\xe6\xb2\x9b\xe9\xbd\x90-123&#39;# 4.将unicode编码解码成&#39;utf-8&#39;text &#x3D; data.decode(&quot;utf-8&quot;)print(text)</code></pre><p><font color="#dd0000"><strong>上面代码的简化</strong></font></p><pre class="language-python" data-language="python"><code class="language-python"># 1.打开文件file_object &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;)# 2.读取文件内容，并赋值给datadata &#x3D; file_object.read()# 3.关闭文件file_object.close()print(data)</code></pre></li><li><p>读图片等非文本内容文件。</p><pre class="language-python" data-language="python"><code class="language-python">file_object &#x3D; open(&#39;a1.png&#39;, mode&#x3D;&#39;rb&#39;)data &#x3D; file_object.read()file_object.close()print(data) # \x91\xf6\xf2\x83\x8aQFfv\x8b7\xcc\xed\xc3&#125;\x7fT\x9d&#123;.3.\xf1&#123;\xe8\...</code></pre></li></ul><p>注意事项：</p><ul><li><p><font color="#dd0000">路径</font></p><ul><li><p><font color="#dd0000">相对路径，你的程序到底在哪里运行的？</font></p><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201217140130973-16547787758621.png" class=""></li></ul></li></ul><p>​    </p><ul><li><p><font color="#dd0000">绝对路径</font></p><pre class="language-python" data-language="python"><code class="language-python"># 1.打开文件file_object &#x3D; open(&#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;info.txt&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;)# 2.读取文件内容，并赋值给datadata &#x3D; file_object.read()# 3.关闭文件file_object.close()</code></pre><p>windows系统中写绝对路径容易出问题：</p><pre class="language-python" data-language="python"><code class="language-python"># file_object &#x3D; open(&#39;C:\\new\\info.txt&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;)file_object &#x3D; open(r&#39;C:\new\info.txt&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;)data &#x3D; file_object.read()file_object.close()print(data)</code></pre></li><li><p>读文件时，文件不存在程序会报错。</p><pre class="language-python" data-language="python"><code class="language-python">Traceback (most recent call last):  File &quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;2.读文件.py&quot;, line 2, in &lt;module&gt;    file_object &#x3D; open(&#39;infower.txt&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;)FileNotFoundError: [Errno 2] No such file or directory: &#39;infower.txt&#39;</code></pre><p>​<strong>判断路径是否存在？</strong></p><pre class="language-python" data-language="python"><code class="language-python">import osexists &#x3D; os.path.exists(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;info.txt&quot;)print(exists)  # 存在：True  不存在：False</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例import osfile_path &#x3D; &quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;info.txt&quot;exists &#x3D; os.path.exists(file_path)if exists:    # 1.打开文件    file_object &#x3D; open(&#39;infower.txt&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;)    # 2.读取文件内容，并赋值给data    data &#x3D; file_object.read()    # 3.关闭文件    file_object.close()    print(data)else:    print(&quot;文件不存在&quot;)</code></pre></li></ul><h4 id="1-2-写文件"><a href="#1-2-写文件" class="headerlink" title="1.2 写文件"></a>1.2 写文件</h4><ul><li><p>写文本文件</p><pre class="language-python" data-language="python"><code class="language-python"># 1.打开文件file_object &#x3D; open(&quot;t1.txt&quot;, mode&#x3D;&#39;wt&#39;, encoding&#x3D;&#39;utf-8&#39;)# 2.写入内容file_object.write(&quot;武沛齐&quot;)# 3.文件关闭file_object.close()</code></pre></li><li><p>写图片等文件</p><pre class="language-python" data-language="python"><code class="language-python">f1 &#x3D; open(&#39;a1.png&#39;,mode&#x3D;&#39;rb&#39;)content &#x3D; f1.read()f1.close()f2 &#x3D; open(&#39;a2.png&#39;,mode&#x3D;&#39;wb&#39;)f2.write(content)f2.close()</code></pre></li></ul><p>基础案例：</p><pre class="language-python" data-language="python"><code class="language-python"># 案例1：用户注册&quot;&quot;&quot;user &#x3D; input(&quot;请输入用户名：&quot;)pwd &#x3D; input(&quot;请输入密码：&quot;)data &#x3D; &quot;&#123;&#125;-&#123;&#125;&quot;.format(user, pwd)file_object &#x3D; open(&quot;files&#x2F;info.txt&quot;, mode&#x3D;&#39;wt&#39;, encoding&#x3D;&#39;utf-8&#39;)file_object.write(data)file_object.close()&quot;&quot;&quot;# 案例2：多用户注册&quot;&quot;&quot;# w写入文件，先清空文件；再在文件中写入内容。file_object &#x3D; open(&quot;files&#x2F;info.txt&quot;, mode&#x3D;&#39;wt&#39;, encoding&#x3D;&#39;utf-8&#39;)while True:    user &#x3D; input(&quot;请输入用户名（输入Q&#x2F;q退出）：&quot;)    if user.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    pwd &#x3D; input(&quot;请输入密码：&quot;)    data &#x3D; &quot;&#123;&#125;-&#123;&#125;\n&quot;.format(user, pwd)    file_object.write(data)file_object.close()&quot;&quot;&quot;</code></pre><p>小高级案例：（超前）</p><blockquote><p>利用Python想某个网址发送请求并获取结果（利用第三方的模块）</p><ul><li><p>下载第三方模块</p><pre class="language-none"><code class="language-none">pip install requests</code></pre><pre class="language-none"><code class="language-none">&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;pip3 install requests</code></pre><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201217152358142-16547787811552.png" class="" title="image-20201217152358142"></li><li><p>使用第三方模块</p><pre class="language-python" data-language="python"><code class="language-python">import requests                                    res &#x3D; requests.get(url&#x3D;&quot;网址&quot;)print(res)</code></pre></li></ul></blockquote><pre class="language-python" data-language="python"><code class="language-python"># 案例1：去网上下载一点文本，文本信息写入文件。import requestsres &#x3D; requests.get(    url&#x3D;&quot;https:&#x2F;&#x2F;movie.douban.com&#x2F;j&#x2F;search_subjects?type&#x3D;movie&amp;tag&#x3D;%E7%83%AD%E9%97%A8&amp;sort&#x3D;recommend&amp;page_limit&#x3D;20&amp;page_start&#x3D;20&quot;,    headers&#x3D;&#123;        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36&quot;    &#125;)# 网络传输的原始二进制信息（bytes）# res.contentfile_object &#x3D; open(&#39;files&#x2F;log1.txt&#39;, mode&#x3D;&#39;wb&#39;)file_object.write(res.content)file_object.close()# 案例2：去网上下载一张图片，图片写入本地文件。import requestsres &#x3D; requests.get(    url&#x3D;&quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;c7e1461e4b15735fbe625c4dc85bd19904d96daf6de9fb-tosv1r_fw1200&quot;,    headers&#x3D;&#123;        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36&quot;    &#125;)# 网络传输的原始二进制信息（bytes）# res.contentfile_object &#x3D; open(&#39;files&#x2F;美女.png&#39;, mode&#x3D;&#39;wb&#39;)file_object.write(res.content)file_object.close()</code></pre><p><strong>注意事项：</strong></p><ul><li>路径<ul><li>绝对路径</li><li>相对路径</li></ul></li><li>文件不存在时，w模式会新建然后再写入内容；文件存在时，w模式会清空文件再写入内容。</li></ul><h4 id="1-3-文件打开模式"><a href="#1-3-文件打开模式" class="headerlink" title="1.3 文件打开模式"></a>1.3 文件打开模式</h4><p>​上文我们基于文件操作基本实现了读、写的功能，其中涉及的文件操作模式：rt、rb、wt、wb，其实在文件操作中还有其他的很多模式。</p><pre class="language-none"><code class="language-none">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Character Meaning--------- ---------------------------------------------------------------&#39;r&#39;       open for reading (default)&#39;w&#39;       open for writing, truncating the file first&#39;x&#39;       create a new file and open it for writing&#39;a&#39;       open for writing, appending to the end of the file if it exists&#39;b&#39;       binary mode&#39;t&#39;       text mode (default)&#39;+&#39;       open a disk file for updating (reading and writing)The default mode is &#39;rt&#39; (open for reading text).</code></pre><p>关于文件的打开模式常见应用有：</p><ul><li><p>只读：<code>r</code>&#x3D;&#x3D;<code>rt</code>（读文本）、<code>rb</code> （读二进制）（用）</p><ul><li>存在，读</li><li>不存在，报错</li></ul></li><li><p>只写：<code>w</code>&#x3D;&#x3D;<code>wt</code>、<code>wb</code>（用）</p><ul><li>存在，清空再写</li><li>不存在，创建再写</li></ul></li><li><p>只写：<code>x</code>&#x3D;&#x3D;<code>xt</code>、<code>xb</code>（几乎不用）</p><ul><li>存在，报错</li><li>不存在，创建再写。</li></ul></li><li><p>只写：<code>a</code>&#x3D;&#x3D;<code>at</code>、<code>ab</code>【尾部追加】（用）</p><ul><li>存在，尾部追加。</li><li>不存在，创建再写。</li></ul></li><li><p>读写</p><ul><li><p>r+&#x3D;&#x3D;rt+、rb+，<font color="#dd0000"><strong>默认光标位置：起始位置</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;info.txtalex-666&#39;&#39;&#39;file_object &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;rt+&#39;, encoding&#x3D;&#39;utf-8&#39;)# 读取内容data &#x3D; file_object.read()print(data)  # &#39;alex-666&#39;# 写入内容file_object.write(&quot;你好呀&quot;)file_object.close()  # info.txt:alex-666你好呀</code></pre><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;info.txtalex-666你好啊&#39;&#39;&#39;file_object &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;rt+&#39;, encoding&#x3D;&#39;utf-8&#39;)# 写入内容file_object.write(&quot;eric&quot;)  # 读取内容data &#x3D; file_object.read()  print(data)  # alex-666你好呀file_object.close()  # info.txt:eric-666你好呀</code></pre></li><li><p>w+、wt+、wb+，<font color="#dd0000"><strong>默认光标位置：起始位置（清空文件）</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">file_object &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;wt+&#39;)# 读取内容data &#x3D; file_object.read()print(data)# 写入内容file_object.write(&quot;你好呀&quot;)# 将光标位置重置起始file_object.seek(0)# 读取内容data &#x3D; file_object.read()print(data)file_object.close()</code></pre></li><li><p>x+、xt+、xb+，默认光标位置：起始位置（新文件）</p></li><li><p>a+、at+、ab+，默认光标位置：<font color="#dd0000"><strong>末尾</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">file_object &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;at+&#39;)# 写入内容file_object.write(&quot;武沛齐&quot;)# 将光标位置重置起始file_object.seek(0)# 读取内容data &#x3D; file_object.read()print(data)file_object.close()</code></pre></li></ul></li></ul><p>多用户注册案例：<strong>解决<code>mode=wt</code>每次运行文件出创建新数据的问题</strong></p><pre class="language-python" data-language="python"><code class="language-python">file_object &#x3D; open(&quot;files&#x2F;info.txt&quot;, mode&#x3D;&#39;at&#39;, encoding&#x3D;&#39;utf-8&#39;)while True:    user &#x3D; input(&quot;请输入用户名（输入Q&#x2F;q退出）：&quot;)    if user.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    pwd &#x3D; input(&quot;请输入密码：&quot;)    data &#x3D; &quot;&#123;&#125;-&#123;&#125;\n&quot;.format(user, pwd)    file_object.write(data)    file_object.close()</code></pre><pre class="language-python" data-language="python"><code class="language-python">file_object &#x3D; open(&#39;files&#x2F;account.txt&#39;, mode&#x3D;&#39;a&#39;)while True:    user &#x3D; input(&quot;用户名：&quot;)    if user.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    pwd &#x3D; input(&quot;密码：&quot;)    data &#x3D; &quot;&#123;&#125;-&#123;&#125;\n&quot;.format(user, pwd)    file_object.write(data)file_object.close()</code></pre><h4 id="1-4-常见功能"><a href="#1-4-常见功能" class="headerlink" title="1.4 常见功能"></a>1.4 常见功能</h4><p>​在上述对文件的操作中，我们只使用了write和read来对文件进行读写，其实在文件操作中还有很多其他的功能来辅助实现更好的读写文件的内容。</p><ul><li><p>read，读</p><ul><li><p><font color="#dd0000"><strong>读所有【常用】</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;rt&#39;,encoding&#x3D;&#39;utf-8&#39;)data &#x3D; f.read()f.close()</code></pre><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;rb&#39;)data &#x3D; f.read()f.close()</code></pre></li><li><p><strong>读n个字符（rt）&#x2F;字节（rb）【会用到】</strong></p><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;)# 读1个字符data &#x3D; f.read(1)  # 只读取一个字符f.close()print(data， type(data)) # 武 &lt;class &#39;str&#39;&gt;</code></pre><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;rb&#39;)# 读1个字节data &#x3D; f.read(3)  # 只读取三个字节f.close()print(data, type(data))  # b&#39;\xe6\xad\xa6&#39; &lt;class &#39;bytes&#39;&gt;</code></pre></li></ul></li><li><p>readline，读一行</p><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;)v1 &#x3D; f.readline()print(v1)v2 &#x3D; f.readline()print(v2)f.close()</code></pre></li><li><p>readlines，读所有行，每行作为列表的一个元素</p><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;rb&#39;)data_list &#x3D; f.readlines()f.close()print(data_list)</code></pre></li><li><p><font color="#dd0000"><strong>循环，读大文件（readline加强版）【常见】</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;)for line in f:    print(line.strip())f.close()</code></pre></li><li><p>write，写</p><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;a&#39;,encoding&#x3D;&#39;utf-8&#39;)f.write(&quot;武沛齐&quot;)f.close()</code></pre><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;ab&#39;)f.write( &quot;武沛齐&quot;.encode(&quot;utf-8&quot;) )f.close()</code></pre></li><li><p>flush，刷到硬盘</p><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;a&#39;,encoding&#x3D;&#39;utf-8&#39;)while True:    # 不是写到了硬盘，而是写在缓冲区，系统会将缓冲区的内容刷到硬盘。f.write(&quot;武沛齐&quot;)        # 立即将缓冲区的数据刷到硬盘    f.flush()f.close()</code></pre><p>多用户注册案例：<strong>解决write不会立即将数据存到硬盘的问题(flush（）)。</strong></p><pre class="language-python" data-language="python"><code class="language-python">file_object &#x3D; open(&quot;files&#x2F;info.txt&quot;, mode&#x3D;&#39;at&#39;, encoding&#x3D;&#39;utf-8&#39;)while True:    user &#x3D; input(&quot;请输入用户名（输入Q&#x2F;q退出）：&quot;)    if user.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    pwd &#x3D; input(&quot;请输入密码：&quot;)    data &#x3D; &quot;&#123;&#125;-&#123;&#125;\n&quot;.format(user, pwd)    file_object.write(data)    # 立即将缓冲区的数据刷到硬盘    file_object.flush()     file_object.close()</code></pre></li><li><p>移动光标位置（<strong>字节：无论是wt还是wb</strong>）</p><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;r+&#39;, encoding&#x3D;&#39;utf-8&#39;)# 移动到指定字节的位置f.seek(3)f.write(&quot;武沛齐&quot;)f.close()</code></pre><p>​<font color="#dd0000"><strong>注意事项：在a模式下，调用write在文件中写入内容时，永远只能将内容写入到尾部，不会写到光标的位置。</strong></font></p></li><li><p><strong>获取当前光标字符（rt）&#x2F;字节（rb）位置</strong></p><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;)p1 &#x3D; f.tell()print(p1)  # 0f.read(3)  # 读3个字符 3*3&#x3D;9字节p2 &#x3D; f.tell()print(p2)  # 9f.close()</code></pre><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;info.txt&#39;, mode&#x3D;&#39;rb&#39;)p1 &#x3D; f.tell()print(p1)  # 0f.read(3)  # 读3个字节p2 &#x3D; f.tell()print(p2)  # 3f.close()</code></pre></li></ul><h4 id="1-5-上下文管理"><a href="#1-5-上下文管理" class="headerlink" title="1.5 上下文管理"></a>1.5 上下文管理</h4><p>​之前对文件进行操作时，每次都要打开和关闭文件，比较繁琐且容易忘记关闭文件。以后再进行文件操作时，推荐大家使用with上下文管理，它可以自动实现关闭文件。</p><pre class="language-python" data-language="python"><code class="language-python">with open(&quot;xxxx.txt&quot;, mode&#x3D;&#39;rb&#39;) as file_object:    data &#x3D; file_object.read()    print(data)</code></pre><p>​在Python 2.7 后，with又支持同时对多个文件的上下文进行管理，即：</p><pre class="language-python" data-language="python"><code class="language-python">with open(&quot;xxxx.txt&quot;, mode&#x3D;&#39;rb&#39;) as f1, open(&quot;xxxx.txt&quot;, mode&#x3D;&#39;rb&#39;) as f2:    pass</code></pre><h4 id="练习题（能根据以上笔记完成即可）"><a href="#练习题（能根据以上笔记完成即可）" class="headerlink" title="练习题（能根据以上笔记完成即可）"></a>练习题（能根据以上笔记完成即可）</h4><ol><li><p>补充代码：实现下载视频并保存到本地</p><pre class="language-python" data-language="python"><code class="language-python">import requestsres &#x3D; requests.get(    url&#x3D;&quot;https:&#x2F;&#x2F;vd2.bdstatic.com&#x2F;mda-jkucv7q3k8xxc2mu&#x2F;sc&#x2F;mda-jkucv7q3k8xxc2mu.mp4?playlist&#x3D;%5B%22hd%22%2C%22sc%22%5D&amp;v_from_s&#x3D;hkapp-haokan-tucheng&amp;auth_key&#x3D;1626679447-0-0-fd88b0974d0ee31107caee2b0147b945&amp;bcevod_channel&#x3D;searchbox_feed&amp;pd&#x3D;1&amp;pt&#x3D;3&amp;abtest&#x3D;&quot;,    headers&#x3D;&#123;        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36&quot;    &#125;)# 因为是视频文件，用&#39;wb&#39;打开with open(&#39;files&#x2F;video.mp4&#39;, mode&#x3D;&#39;wb&#39;) as f:    f.write(res.content)</code></pre></li><li><p>日志分析，计算某用户<code>223.73.89.192</code>访问次数。日志文件如下：<code>access.log</code></p><pre class="language-none"><code class="language-none">49.89.167.91 - - [17&#x2F;Dec&#x2F;2020:03:43:50 +0800] &quot;GET &#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40 HTTP&#x2F;1.1&quot; 301 0 &quot;-&quot; &quot;Mozilla&#x2F;5.0(Linux;Android 5.1.1;OPPO A33 Build&#x2F;LMY47V;wv) AppleWebKit&#x2F;537.36(KHTML,link Gecko) Version&#x2F;4.0 Chrome&#x2F;43.0.2357.121 Mobile Safari&#x2F;537.36 LieBaoFast&#x2F;4.51.3&quot; &quot;-&quot;49.89.167.91 - - [17&#x2F;Dec&#x2F;2020:03:44:11 +0800] &quot;GET &#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F; HTTP&#x2F;1.1&quot; 200 8033 &quot;-&quot; &quot;Mozilla&#x2F;5.0(Linux;Android 5.1.1;OPPO A33 Build&#x2F;LMY47V;wv) AppleWebKit&#x2F;537.36(KHTML,link Gecko) Version&#x2F;4.0 Chrome&#x2F;43.0.2357.121 Mobile Safari&#x2F;537.36 LieBaoFast&#x2F;4.51.3&quot; &quot;-&quot;203.208.60.66 - - [17&#x2F;Dec&#x2F;2020:03:47:58 +0800] &quot;GET &#x2F;media&#x2F;uploads&#x2F;2019&#x2F;11&#x2F;17&#x2F;pic&#x2F;s1.png HTTP&#x2F;1.1&quot; 200 710728 &quot;-&quot; &quot;Googlebot-Image&#x2F;1.0&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:26 +0800] &quot;GET &#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F; HTTP&#x2F;1.1&quot; 200 8033 &quot;-&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:26 +0800] &quot;GET &#x2F;static&#x2F;stark&#x2F;plugins&#x2F;font-awesome&#x2F;css&#x2F;font-awesome.css HTTP&#x2F;1.1&quot; 200 37414 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:26 +0800] &quot;GET &#x2F;static&#x2F;stark&#x2F;plugins&#x2F;bootstrap&#x2F;css&#x2F;bootstrap.css HTTP&#x2F;1.1&quot; 200 146010 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:26 +0800] &quot;GET &#x2F;static&#x2F;web&#x2F;css&#x2F;commons.css HTTP&#x2F;1.1&quot; 200 3674 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:26 +0800] &quot;GET &#x2F;static&#x2F;mdeditor&#x2F;editormd&#x2F;css&#x2F;editormd.preview.css HTTP&#x2F;1.1&quot; 200 60230 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:26 +0800] &quot;GET &#x2F;static&#x2F;stark&#x2F;js&#x2F;jquery-3.3.1.min.js HTTP&#x2F;1.1&quot; 200 86927 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:26 +0800] &quot;GET &#x2F;static&#x2F;stark&#x2F;plugins&#x2F;bootstrap&#x2F;js&#x2F;bootstrap.min.js HTTP&#x2F;1.1&quot; 200 37045 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:26 +0800] &quot;GET &#x2F;static&#x2F;mdeditor&#x2F;editormd&#x2F;lib&#x2F;marked.min.js HTTP&#x2F;1.1&quot; 200 19608 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:27 +0800] &quot;GET &#x2F;static&#x2F;mdeditor&#x2F;editormd&#x2F;lib&#x2F;prettify.min.js HTTP&#x2F;1.1&quot; 200 17973 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:27 +0800] &quot;GET &#x2F;static&#x2F;mdeditor&#x2F;editormd&#x2F;fonts&#x2F;fontawesome-webfont.woff2?v&#x3D;4.3.0 HTTP&#x2F;1.1&quot; 200 56780 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;static&#x2F;mdeditor&#x2F;editormd&#x2F;css&#x2F;editormd.preview.css&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:27 +0800] &quot;GET &#x2F;static&#x2F;mdeditor&#x2F;editormd&#x2F;editormd.js HTTP&#x2F;1.1&quot; 200 163262 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:28 +0800] &quot;GET &#x2F;static&#x2F;mdeditor&#x2F;mdeditor-preview-init.js HTTP&#x2F;1.1&quot; 200 261 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:29 +0800] &quot;GET &#x2F;static&#x2F;stark&#x2F;plugins&#x2F;font-awesome&#x2F;fonts&#x2F;fontawesome-webfont.woff2?v&#x3D;4.7.0 HTTP&#x2F;1.1&quot; 200 77160 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;static&#x2F;stark&#x2F;plugins&#x2F;font-awesome&#x2F;css&#x2F;font-awesome.css&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;223.73.89.192 - - [17&#x2F;Dec&#x2F;2020:03:48:29 +0800] &quot;GET &#x2F;media&#x2F;uploads&#x2F;2019&#x2F;02&#x2F;22&#x2F;Gobook&#x2F;_book&#x2F;ssl2.png HTTP&#x2F;1.1&quot; 200 203535 &quot;https:&#x2F;&#x2F;pythonav.com&#x2F;wiki&#x2F;detail&#x2F;3&#x2F;40&#x2F;&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 Edg&#x2F;87.0.664.60&quot; &quot;-&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">ip &#x3D; &#39;223.73.89.192&#39;total_count &#x3D; 0with open(&#39;files&#x2F;access.log&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as object_file:    for line in object_file:        if not line.startswith(ip):            continue                    total_count +&#x3D; 1print(total_count)  # 14</code></pre></li><li><p>日志分析升级，计算所有用户的访问次数。</p><pre class="language-python" data-language="python"><code class="language-python">result &#x3D; &#123;&#125;with open(&#39;files&#x2F;access.log&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as object_file:    for line in object_file:        # ip和其它文本用空格隔开了        ip &#x3D; line.split(&#39; &#39;)[0]                # 参考统计车牌部分代码        count &#x3D; result.get(ip, 0)        result[ip] &#x3D; count + 1print(result)</code></pre></li><li><p>筛选出股票 当前价大于 20 的所有股票数据。</p><pre class="language-none"><code class="language-none">股票代码,股票名称,当前价,涨跌额,涨跌幅,年初至今,成交量,成交额,换手率,市盈率(TTM),股息率,市值SH601778,N晶科,6.29,+1.92,+43.94%,+43.94%,259.66万,1625.52万,0.44%,22.32,-,173.95亿SH688566,吉贝尔,52.66,+6.96,+15.23%,+122.29%,1626.58万,8.09亿,42.29%,89.34,-,98.44亿SH688268,华特气体,88.80,+11.72,+15.20%,+102.51%,622.60万,5.13亿,22.87%,150.47,-,106.56亿SH600734,实达集团,2.60,+0.24,+10.17%,-61.71%,1340.27万,3391.14万,2.58%,亏损,0.00%,16.18亿SH900957,凌云B股,0.36,+0.033,+10.09%,-35.25%,119.15万,42.10万,0.65%,44.65,0.00%,1.26亿SZ000584,哈工智能,6.01,+0.55,+10.07%,-4.15%,2610.86万,1.53亿,4.36%,199.33,0.26%,36.86亿SH600599,熊猫金控,6.78,+0.62,+10.06%,-35.55%,599.64万,3900.23万,3.61%,亏损,0.00%,11.25亿SH600520,文一科技,8.21,+0.75,+10.05%,-24.05%,552.34万,4464.69万,3.49%,亏损,0.00%,13.01亿SH603682,锦和商业,11.73,+1.07,+10.04%,+48.29%,2746.63万,3.15亿,29.06%,29.62,-,55.42亿SZ300831,派瑞股份,12.27,+1.12,+10.04%,+208.29%,25.38万,311.41万,0.32%,60.59,-,39.26亿</code></pre><pre class="language-python" data-language="python"><code class="language-python">with open(&#39;files&#x2F;stock_data.txt&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as object_file:    # 读取全部文件    text &#x3D; object_file.read()      list_data &#x3D; text.split(&#39;\n&#39;)[1:]    for data in list_data:        target &#x3D; data.split(&#39;,&#39;)[2]        if float(target) &gt; 20:            print(data)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 答案：注意如何跳过第一行with open(&#39;files&#x2F;stock_data.txt&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as object_file:    # 1.先跳过一行(提供readline()将光标移动到下一行)    object_file.readline()    for line in object_file:        text &#x3D; line.split(&#39;,&#39;)[2]        price &#x3D; float(text)        if price &gt; 20:            print(line, end&#x3D;&#39;&#39;)</code></pre></li><li><p>根据要求修改文件的内容，原文件内容如下：<code>ha.conf</code></p><pre class="language-none"><code class="language-none">global               log 127.0.0.1 local2        daemon        maxconn 256        log 127.0.0.1 local2 infodefaults        log global        mode http        timeout connect 5000ms        timeout client 50000ms        timeout server 50000ms        option  dontlognulllisten stats :8888        stats enable        stats uri       &#x2F;admin        stats auth      admin:1234frontend oldboy.org        bind 0.0.0.0:80        option httplog        option httpclose        option  forwardfor        log global        acl www hdr_reg(host) -i www.luffycity.org        use_backend www.luffycity.com if wwwbackend www.luffycity.com        server 100.1.7.9 100.1.7.9 weight 20 maxconn 3000...</code></pre><p>请将文件中的 <code>luffycity</code>修改为 <code>pythonav</code> 。</p><pre class="language-python" data-language="python"><code class="language-python"># 适用于文件较小的情况with open(&#39;files&#x2F;ha.conf&#39;, mode&#x3D;&#39;r+&#39;, encoding&#x3D;&#39;utf-8&#39;) as object_file:    text &#x3D; object_file.read()    new_text &#x3D; text.replace(&#39;luffycity&#39;, &#39;pythonav&#39;)    print(new_text)    object_file.write(new_text)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 无论文件大小都适用# 同时打开两个文件一个读，一个写with open(&#39;files&#x2F;ha.conf&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as read_object_file, open(&#39;files&#x2F;new_ha.conf&#39;, mode&#x3D;&#39;wt&#39;, encoding&#x3D;&#39;utf-8&#39;) as write_object_file:        for line in read_object_file:        new_line &#x3D; line.replace(&#39;luffycity&#39;, &#39;pythonav&#39;)        write_object_file.write(new_line)</code></pre></li></ol><h3 id="2-csv格式文件"><a href="#2-csv格式文件" class="headerlink" title="2.csv格式文件"></a>2.csv格式文件</h3><p>​<strong>逗号分隔值</strong>（Comma-Separated Values，<strong>CSV</strong>，有时也称为<strong>字符分隔值</strong>，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。</p><p>对于这种格式的数据，我们需要利用open函数来读取文件并根据逗号分隔的特点来进行处理。</p><pre class="language-none"><code class="language-none">股票代码,股票名称,当前价,涨跌额,涨跌幅,年初至今SH601778,N晶科,6.29,+1.92,-43.94%,+43.94%SH688566,吉贝尔,52.66,+6.96,+15.23%,+122.29%...</code></pre><p>练习题案例：下载文档中的所有图片且以用户名为图片名称存储。</p><pre class="language-python" data-language="python"><code class="language-python">ID,用户名,头像26044585,Hush,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;51d46dc32abe7ac7f83b94c67bb88cacc46869954f478-aP4Q3V19318369,柒十一,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;703fdb063bdc37b11033ef794f9b3a7adfa01fd21a6d1-wTFbnO15529690,Law344,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;b438d8c61ed2abf50ca94e00f257ca7a223e3b364b471-xrzoQd18311394,Jennah·,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;4edba1ed6a71797f52355aa1de5af961b85bf824cb71-px1nZz18009711,可洛爱画画,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;03331ef39b5c7687f5cc47dbcbafd974403c962ae88ce-Co8AUI30574436,花姑凉~,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;2f5b657edb9497ff8c41132e18000edb082d158c2404-8rYHbw17740339,小巫師,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;dbc6fd49f1915545cc42c1a1492a418dbaebd2c21bb9-9aDqgl18741964,桐末tonmo,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;b60cee303f62aaa592292f45a1ed8d5be9873b2ed5c-gAJehO30535005,TANGZHIQI,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;bbd08ee168d54665bf9b07899a5c4a4d6bc1eb8af77a4-8Gz3K131078743,你的老杨,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;c46fbc3c9a01db37b8e786cbd7174bbd475e4cda220f4-F1u7MX25519376,尺尺寸,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;ee29ee198efb98f970e3dc2b24c40d89bfb6f911126b6-KGvKes21113978,C-CLong,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;7fa6b2a0d570e67246b34840a87d57c16a875dba9100-SXsSeY24674102,szaa,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;0716687b0df93e8c3a8e0925b6d2e4135449cd27597c4-gWdv2430508507,爱起床的小灰灰,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;4eafdbfa21b2f300a7becd8863f948e5e92ef789b5a5-1ozTKq12593664,yokozen,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;cd07bbaf052b752ed5c287602404ea719d7dd8161321b-cJtHss16899164,一阵疯,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;0940b557b28892658c3bcaf52f5ba8dc8402100e130b2-G966Uz847937,卩丬My㊊伴er彎,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;e2d6bb5bc8498c6f607492a8f96164aa2366b104e7a-kWaH6831010628,慢慢即漫漫,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;c4fb6718907a22f202e8dd14d52f0c369685e59cfea7-82FdsK13438168,海贼玩跑跑,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;1edae3ce6fe0f6e95b67b4f8b57c4cebf19c501b397e-BXwiW628593155,源稚生,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;626cfd89ca4c10e6f875f3dfe1005331e4c0fd7fd429-9SeJeQ28201821,合伙哼哼,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;f59d4780531aa1892b80e0ec94d4ec78dcba08ff18c416-769X6a28255146,漫步AAA,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;3c034c520594e38353a039d7e7a5fd5e74fb53eb1086-KnpLaL30537613,配䦹,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;efd81d22c1b1a2de77a0e0d8e853282b83b6bbc590fd-y3d4GJ22665880,日后必火,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;69f0f959979a4fada9e9e55f565989544be88164d2b-INWbaF16748980,keer521521,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;654953460733026a7ef6e101404055627ad51784a95c-B6OFs430536510,“西辞”,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;61cfffca6b2507bf51a507e8319d68a8b8c3a96968f-6IvMSk30986577,艺成背锅王,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;c381ecc43d6c69758a86a30ebf72976906ae6c53291f9-9zroHF26409800,CsysADk7,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;bf1d22092c2070d68ade012c588f2e410caaab1f58051-ahlgLm30469116,18啊全阿,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;654953460733026a7ef6e101404055627ad51784a95c-B6OFs415514336,椿の花,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;0e38d810e5a24f91ebb251fd3aaaed8bb37655b14844c-pgNJBP19165177,っ思忆゜♪,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;4815ea0e4905d0f3bb82a654b481811dadbfe5ce2673-vMVr0B16059616,格林熊丶,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;8760a2b08d87e6ed4b7a9715b1a668176dbf84fec5b-jx14tZ30734152,sCWVkJDG,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;f31a5305d1b8717bbfb897723f267d316e58e7b7dc40-GD3e2224019677,虚无本心,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;6fdfa9834abe362e978b517275b06e7f0d5926aa650-N1xCXE16670283,Y-雨后天空,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;a3bbb0045b536fc27a6d2effa64a0d43f9f5193c177f-I2vHaI21512483,汤姆2,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;98cc50a61a7cc9b49a8af754ffb26bd15764a82f1133-AkiU7D16441049,笑潇啸逍小鱼,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;ae8a70cd85aff3a8587ff6578d5cf7620f3691df13e46-lmrIi924795603,⁢⁢⁢⁢⁢v,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;a7183cc3a933aa129d7b3230bf1378fd8f5857846cc5-3tDtx329819152,妮玛士珍多,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;ca4ecb573bf1ff0415c7a873d64470dedc465ea1213c6-RAkArS19101282,陈勇敢❤,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;ab6d04ebaff3176e3570139a65155856871241b58bc6-Qklj2E28337572,爱意随风散,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;117ad8b6eeda57a562ac6ab2861111a793ca3d1d5543-SjWlk217342758,幸运instant,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;72b5f9042ec297ae57b83431123bc1c066cca90fa23-3MoJNj18483372,Beau染,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;077115cb622b1ff3907ec6932e1b575393d5aae720487-d1cdT922127102,栽花的小蜻蜓,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;6c3cbf9f27e17898083186fc51985e43269018cc1e1df-QfOIBG13802024,LoveHsu,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;f720a15f8b49b86a7c1ee4951263a8dbecfe3e43d2d-GPEauV22558931,白驹过隙丶梨花泪う,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;e49e1341dfe5144da5c71bd15f1052ef07ba7a0e1296b-jfyfDJ11762339,cojoy,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;5b27f876d5d391e7c4889bc5e8ba214419eb72b56822-83gYmB30711623,雪碧学长呀,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;2c288a1535048b05537ba523b3fc9eacc1e81273212d1-nr8M4t18906718,西霸王,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;7b02ad5e01bd8c0a29817e362814666a7800831c154a6-AvBDaG31037856,邵阳的小哥哥,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;654953460733026a7ef6e101404055627ad51784a95c-B6OFs426830711,稳健谭,https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;51547ade3f0aef134e8d268cfd4ad61110925aefec8a-NKPEYX</code></pre><pre class="language-python" data-language="python"><code class="language-python">import requestsimport oswith open(&#39;files&#x2F;mn.csv&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as read_object_file:    # 不读第一行    read_object_file.readline()        for line in read_object_file:        # 先strip()去掉末尾的换行符        user_id, user_name, url &#x3D; line.strip().split(&#39;,&#39;)        print(user_name, url)        # 下载所有图片        res &#x3D; requests.get(            url&#x3D;url,            headers&#x3D;&#123;                &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36&quot;            &#125;        )        # 判断files&#x2F;images文件目录是否存在        if not os.path.exists(&#39;files&#x2F;images&#39;):            # 不存在则创建目录            os.makedirs(&#39;files&#x2F;images&#39;)        # 将图片写入文件files&#x2F;images        with open(&#39;files&#x2F;images&#x2F;&#123;&#125;.png&#39;.format(user_name), mode&#x3D;&#39;wb&#39;) as write_object:            write_object.write(res.content)</code></pre><h3 id="3-ini格式文件"><a href="#3-ini格式文件" class="headerlink" title="3.ini格式文件"></a>3.ini格式文件</h3><p>​ini文件是Initialization File的缩写，平时用于存储软件的的配置文件。例如：MySQL数据库的配置文件。</p><pre class="language-ini" data-language="ini"><code class="language-ini">[mysqld]datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysqlsocket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.socklog-bin&#x3D;py-mysql-bincharacter-set-server&#x3D;utf8collation-server&#x3D;utf8_general_cilog-error&#x3D;&#x2F;var&#x2F;log&#x2F;mysqld.log# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links&#x3D;0[mysqld_safe]log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.logpid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mariadb&#x2F;mariadb.pid[client]default-character-set&#x3D;utf8</code></pre><p>​这种格式是可以直接使用open来出来，考虑到自己处理比较麻烦，所以Python为我们提供了更为方便的方式。</p><ul><li><p>读取所有节点</p><pre class="language-python" data-language="python"><code class="language-python">import configparserconfig &#x3D; configparser.ConfigParser()config.read(&#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;files&#x2F;my.conf&#39;, encoding&#x3D;&#39;utf-8&#39;)# config.read(&#39;my.conf&#39;, encoding&#x3D;&#39;utf-8&#39;)ret &#x3D; config.sections()print(ret) &gt;&gt;输出[&#39;mysqld&#39;, &#39;mysqld_safe&#39;, &#39;client&#39;]</code></pre></li><li><p>读取节点下的键值</p><pre class="language-python" data-language="python"><code class="language-python">import configparserconfig &#x3D; configparser.ConfigParser()config.read(&#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;files&#x2F;my.conf&#39;, encoding&#x3D;&#39;utf-8&#39;)# config.read(&#39;my.conf&#39;, encoding&#x3D;&#39;utf-8&#39;)item_list &#x3D; config.items(&quot;mysqld_safe&quot;)print(item_list) &gt;&gt;输出[(&#39;log-error&#39;, &#39;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log&#39;), (&#39;pid-file&#39;, &#39;&#x2F;var&#x2F;run&#x2F;mariadb&#x2F;mariadb.pid&#39;)]</code></pre></li><li><p>读取节点下值（根据 节点+键 ）</p><pre class="language-python" data-language="python"><code class="language-python">import configparserconfig &#x3D; configparser.ConfigParser()config.read(&#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;files&#x2F;my.conf&#39;, encoding&#x3D;&#39;utf-8&#39;)value &#x3D; config.get(&#39;mysqld&#39;, &#39;log-bin&#39;)print(value)&gt;&gt;输出py-mysql-bin</code></pre></li><li><p>检查、删除、添加节点</p><pre class="language-python" data-language="python"><code class="language-python">import configparserconfig &#x3D; configparser.ConfigParser()config.read(&#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;files&#x2F;my.conf&#39;, encoding&#x3D;&#39;utf-8&#39;)# config.read(&#39;my.conf&#39;, encoding&#x3D;&#39;utf-8&#39;)# 检查has_sec &#x3D; config.has_section(&#39;mysqld&#39;)print(has_sec)# 添加节点config.add_section(&quot;SEC_1&quot;)# 节点中设置键值config.set(&#39;SEC_1&#39;, &#39;k10&#39;, &quot;123&quot;)config.set(&#39;SEC_1&#39;, &#39;name&#39;, &quot;哈哈哈哈哈&quot;)config.add_section(&quot;SEC_2&quot;)config.set(&#39;SEC_2&#39;, &#39;k10&#39;, &quot;123&quot;)# 内容写入新文件config.write(open(&#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;files&#x2F;xxoo.conf&#39;, &#39;w&#39;))# 删除节点config.remove_section(&quot;SEC_2&quot;)# 删除节点中的键值config.remove_option(&#39;SEC_1&#39;, &#39;k10&#39;)config.write(open(&#39;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;files&#x2F;new.conf&#39;, &#39;w&#39;))</code></pre></li></ul><h3 id="4-XML格式文件"><a href="#4-XML格式文件" class="headerlink" title="4.XML格式文件"></a>4.XML格式文件</h3><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/2885849">可扩展标记语言</a>，是一种简单的数据存储语言，XML 被设计用来传输和存储数据。</p><ul><li>存储，可用来存放配置文件，例如：java的配置文件。</li><li>传输，网络传输时以这种格式存在，例如：早期ajax传输的数据、soap协议等。</li></ul><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>country</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Liechtenstein<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rank</span> <span class="token attr-name">updated</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rank</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>year</span><span class="token punctuation">></span></span>2023<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>year</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gdppc</span><span class="token punctuation">></span></span>141100<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gdppc</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>neighbor</span> <span class="token attr-name">direction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>E<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Austria<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>neighbor</span> <span class="token attr-name">direction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>W<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Switzerland<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>country</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>country</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Singapore<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rank</span> <span class="token attr-name">updated</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rank</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>year</span><span class="token punctuation">></span></span>2026<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>year</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gdppc</span><span class="token punctuation">></span></span>59900<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gdppc</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>neighbor</span> <span class="token attr-name">direction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>N<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Malaysia<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>country</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>country</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Panama<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rank</span> <span class="token attr-name">updated</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>69<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rank</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>year</span><span class="token punctuation">></span></span>2026<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>year</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gdppc</span><span class="token punctuation">></span></span>13600<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gdppc</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>neighbor</span> <span class="token attr-name">direction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>W<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Costa Rica<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>neighbor</span> <span class="token attr-name">direction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>E<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Colombia<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>country</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>data</span><span class="token punctuation">></span></span></code></pre><p>​注意：在Python开发中用的相对来比较少，大家作为了解即可（后期课程在讲解微信支付、微信公众号消息处理 时会用到基于xml传输数据）。</p><p>例如：<a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html">https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html</a></p><h4 id="4-1-读取文件和内容"><a href="#4-1-读取文件和内容" class="headerlink" title="4.1 读取文件和内容"></a>4.1 读取文件和内容</h4><p><strong>以xml文件存在</strong></p><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ET# ET去打开xml文件tree &#x3D; ET.parse(&quot;files&#x2F;xo.xml&quot;)# 获取根标签root &#x3D; tree.getroot()print(root) # &lt;Element &#39;data&#39; at 0x7f94e02763b0&gt;</code></pre><p><strong>通过网络获取或str格式</strong></p><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ETcontent &#x3D; &quot;&quot;&quot;&lt;data&gt;    &lt;country name&#x3D;&quot;Liechtenstein&quot;&gt;        &lt;rank updated&#x3D;&quot;yes&quot;&gt;2&lt;&#x2F;rank&gt;        &lt;year&gt;2023&lt;&#x2F;year&gt;        &lt;gdppc&gt;141100&lt;&#x2F;gdppc&gt;        &lt;neighbor direction&#x3D;&quot;E&quot; name&#x3D;&quot;Austria&quot; &#x2F;&gt;        &lt;neighbor direction&#x3D;&quot;W&quot; name&#x3D;&quot;Switzerland&quot; &#x2F;&gt;    &lt;&#x2F;country&gt;     &lt;country name&#x3D;&quot;Panama&quot;&gt;        &lt;rank updated&#x3D;&quot;yes&quot;&gt;69&lt;&#x2F;rank&gt;        &lt;year&gt;2026&lt;&#x2F;year&gt;        &lt;gdppc&gt;13600&lt;&#x2F;gdppc&gt;        &lt;neighbor direction&#x3D;&quot;W&quot; name&#x3D;&quot;Costa Rica&quot; &#x2F;&gt;        &lt;neighbor direction&#x3D;&quot;E&quot; name&#x3D;&quot;Colombia&quot; &#x2F;&gt;    &lt;&#x2F;country&gt;&lt;&#x2F;data&gt;&quot;&quot;&quot;root &#x3D; ET.XML(content)print(root)  # &lt;Element &#39;data&#39; at 0x7fdaa019cea0&gt;</code></pre><h4 id="4-2-读取节点数据"><a href="#4-2-读取节点数据" class="headerlink" title="4.2 读取节点数据"></a>4.2 读取节点数据</h4><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ETcontent &#x3D; &quot;&quot;&quot;&lt;data&gt;    &lt;country name&#x3D;&quot;Liechtenstein&quot;&gt;        &lt;rank&gt;2&lt;&#x2F;rank&gt;        &lt;year&gt;2023&lt;&#x2F;year&gt;        &lt;gdppc&gt;141100&lt;&#x2F;gdppc&gt;        &lt;neighbor direction&#x3D;&quot;E&quot; name&#x3D;&quot;Austria&quot; &#x2F;&gt;        &lt;neighbor direction&#x3D;&quot;W&quot; name&#x3D;&quot;Switzerland&quot; &#x2F;&gt;    &lt;&#x2F;country&gt;     &lt;country name&#x3D;&quot;Panama&quot;&gt;        &lt;rank&gt;69&lt;&#x2F;rank&gt;        &lt;year&gt;2026&lt;&#x2F;year&gt;        &lt;gdppc&gt;13600&lt;&#x2F;gdppc&gt;        &lt;neighbor direction&#x3D;&quot;W&quot; name&#x3D;&quot;Costa Rica&quot; &#x2F;&gt;        &lt;neighbor direction&#x3D;&quot;E&quot; name&#x3D;&quot;Colombia&quot; &#x2F;&gt;    &lt;&#x2F;country&gt;&lt;&#x2F;data&gt;&quot;&quot;&quot;# 获取根标签 dataroot &#x3D; ET.XML(content)# 获取data标签的孩子标签for child in root:    # child.tag &#x3D; country    # child.attrib &#x3D; &#123;&quot;name&quot;:&quot;Liechtenstein&quot;&#125;    print(child.tag, child.attrib)    for node in child:        print(node.tag, node.attrib, node.text)</code></pre><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ETcontent &#x3D; &quot;&quot;&quot;&lt;data&gt;    &lt;country name&#x3D;&quot;Liechtenstein&quot;&gt;        &lt;rank&gt;2&lt;&#x2F;rank&gt;        &lt;year&gt;2023&lt;&#x2F;year&gt;        &lt;gdppc&gt;141100&lt;&#x2F;gdppc&gt;        &lt;neighbor direction&#x3D;&quot;E&quot; name&#x3D;&quot;Austria&quot; &#x2F;&gt;        &lt;neighbor direction&#x3D;&quot;W&quot; name&#x3D;&quot;Switzerland&quot; &#x2F;&gt;    &lt;&#x2F;country&gt;     &lt;country name&#x3D;&quot;Panama&quot;&gt;        &lt;rank&gt;69&lt;&#x2F;rank&gt;        &lt;year&gt;2026&lt;&#x2F;year&gt;        &lt;gdppc&gt;13600&lt;&#x2F;gdppc&gt;        &lt;neighbor direction&#x3D;&quot;W&quot; name&#x3D;&quot;Costa Rica&quot; &#x2F;&gt;        &lt;neighbor direction&#x3D;&quot;E&quot; name&#x3D;&quot;Colombia&quot; &#x2F;&gt;    &lt;&#x2F;country&gt;&lt;&#x2F;data&gt;&quot;&quot;&quot;root &#x3D; ET.XML(content)# 在data的子子孙孙里面找第一个year标签for child in root.iter(&#39;year&#39;):    print(child.tag, child.text)</code></pre><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ETcontent &#x3D; &quot;&quot;&quot;&lt;data&gt;    &lt;country name&#x3D;&quot;Liechtenstein&quot;&gt;        &lt;rank&gt;2&lt;&#x2F;rank&gt;        &lt;year&gt;2023&lt;&#x2F;year&gt;        &lt;gdppc&gt;141100&lt;&#x2F;gdppc&gt;        &lt;neighbor direction&#x3D;&quot;E&quot; name&#x3D;&quot;Austria&quot; &#x2F;&gt;        &lt;neighbor direction&#x3D;&quot;W&quot; name&#x3D;&quot;Switzerland&quot; &#x2F;&gt;    &lt;&#x2F;country&gt;     &lt;country name&#x3D;&quot;Panama&quot;&gt;        &lt;rank&gt;69&lt;&#x2F;rank&gt;        &lt;year&gt;2026&lt;&#x2F;year&gt;        &lt;gdppc&gt;13600&lt;&#x2F;gdppc&gt;        &lt;neighbor direction&#x3D;&quot;W&quot; name&#x3D;&quot;Costa Rica&quot; &#x2F;&gt;        &lt;neighbor direction&#x3D;&quot;E&quot; name&#x3D;&quot;Colombia&quot; &#x2F;&gt;    &lt;&#x2F;country&gt;&lt;&#x2F;data&gt;&quot;&quot;&quot;root &#x3D; ET.XML(content)# 获取所有&#39;country&#39;v1 &#x3D; root.findall(&#39;country&#39;)print(v1)# 获取第一个&#39;country&#39;的第一个&#39;rank&#39;v2 &#x3D; root.find(&#39;country&#39;).find(&#39;rank&#39;)print(v2.text)</code></pre><h4 id="4-3-修改和删除节点"><a href="#4-3-修改和删除节点" class="headerlink" title="4.3 修改和删除节点"></a>4.3 修改和删除节点</h4><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ETcontent &#x3D; &quot;&quot;&quot;&lt;data&gt;    &lt;country name&#x3D;&quot;Liechtenstein&quot;&gt;        &lt;rank&gt;2&lt;&#x2F;rank&gt;        &lt;year&gt;2023&lt;&#x2F;year&gt;        &lt;gdppc&gt;141100&lt;&#x2F;gdppc&gt;        &lt;neighbor direction&#x3D;&quot;E&quot; name&#x3D;&quot;Austria&quot; &#x2F;&gt;        &lt;neighbor direction&#x3D;&quot;W&quot; name&#x3D;&quot;Switzerland&quot; &#x2F;&gt;    &lt;&#x2F;country&gt;     &lt;country name&#x3D;&quot;Panama&quot;&gt;        &lt;rank&gt;69&lt;&#x2F;rank&gt;        &lt;year&gt;2026&lt;&#x2F;year&gt;        &lt;gdppc&gt;13600&lt;&#x2F;gdppc&gt;        &lt;neighbor direction&#x3D;&quot;W&quot; name&#x3D;&quot;Costa Rica&quot; &#x2F;&gt;        &lt;neighbor direction&#x3D;&quot;E&quot; name&#x3D;&quot;Colombia&quot; &#x2F;&gt;    &lt;&#x2F;country&gt;&lt;&#x2F;data&gt;&quot;&quot;&quot;root &#x3D; ET.XML(content)# 修改节点内容和属性rank &#x3D; root.find(&#39;country&#39;).find(&#39;rank&#39;)print(rank.text)# 修改标签的值rank.text &#x3D; &quot;999&quot;# 给标签加属性rank.set(&#39;update&#39;, &#39;2020-11-11&#39;)print(rank.text, rank.attrib)############ 保存文件 ############上述对xml的操作是在内存中tree &#x3D; ET.ElementTree(root)tree.write(&quot;new.xml&quot;, encoding&#x3D;&#39;utf-8&#39;)# 删除节点root.remove( root.find(&#39;country&#39;) )print(root.findall(&#39;country&#39;))############ 保存文件 ############tree &#x3D; ET.ElementTree(root)tree.write(&quot;newnew.xml&quot;, encoding&#x3D;&#39;utf-8&#39;)</code></pre><h4 id="4-4-构建文档"><a href="#4-4-构建文档" class="headerlink" title="4.4 构建文档"></a>4.4 构建文档</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>home</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>grandson</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿11<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>grandson</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>grandson</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿12<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>grandson</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>home</span><span class="token punctuation">></span></span></code></pre><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ET# 创建根标签root &#x3D; ET.Element(&quot;home&quot;)# 创建节点大儿子son1 &#x3D; ET.Element(&#39;son&#39;, &#123;&#39;name&#39;: &#39;儿1&#39;&#125;)# 创建小儿子son2 &#x3D; ET.Element(&#39;son&#39;, &#123;&quot;name&quot;: &#39;儿2&#39;&#125;)# 在大儿子中创建两个孙子grandson1 &#x3D; ET.Element(&#39;grandson&#39;, &#123;&#39;name&#39;: &#39;儿11&#39;&#125;)grandson2 &#x3D; ET.Element(&#39;grandson&#39;, &#123;&#39;name&#39;: &#39;儿12&#39;&#125;)son1.append(grandson1)son1.append(grandson2)# 把儿子添加到根节点中root.append(son1)root.append(son2)tree &#x3D; ET.ElementTree(root)tree.write(&#39;oooo.xml&#39;, encoding&#x3D;&#39;utf-8&#39;, short_empty_elements&#x3D;False)</code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>famliy</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>grandson</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿11<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>grandson</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>grandson</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿12<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>grandson</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>famliy</span><span class="token punctuation">></span></span></code></pre><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ET# 创建根节点root &#x3D; ET.Element(&quot;famliy&quot;)# 创建大儿子son1 &#x3D; root.makeelement(&#39;son&#39;, &#123;&#39;name&#39;: &#39;儿1&#39;&#125;)# 创建小儿子son2 &#x3D; root.makeelement(&#39;son&#39;, &#123;&quot;name&quot;: &#39;儿2&#39;&#125;)# 在大儿子中创建两个孙子grandson1 &#x3D; son1.makeelement(&#39;grandson&#39;, &#123;&#39;name&#39;: &#39;儿11&#39;&#125;)grandson2 &#x3D; son1.makeelement(&#39;grandson&#39;, &#123;&#39;name&#39;: &#39;儿12&#39;&#125;)son1.append(grandson1)son1.append(grandson2)# 把儿子添加到根节点中root.append(son1)root.append(son2)tree &#x3D; ET.ElementTree(root)tree.write(&#39;oooo.xml&#39;,encoding&#x3D;&#39;utf-8&#39;)</code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>famliy</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>age</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿11<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>孙子<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>age</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>儿2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>famliy</span><span class="token punctuation">></span></span></code></pre><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ET# 创建根节点root &#x3D; ET.Element(&quot;famliy&quot;)# 创建节点大儿子son1 &#x3D; ET.SubElement(root, &quot;son&quot;, attrib&#x3D;&#123;&#39;name&#39;: &#39;儿1&#39;&#125;)# 创建小儿子son2 &#x3D; ET.SubElement(root, &quot;son&quot;, attrib&#x3D;&#123;&quot;name&quot;: &quot;儿2&quot;&#125;)# 在大儿子中创建一个孙子grandson1 &#x3D; ET.SubElement(son1, &quot;age&quot;, attrib&#x3D;&#123;&#39;name&#39;: &#39;儿11&#39;&#125;)grandson1.text &#x3D; &#39;孙子&#39;et &#x3D; ET.ElementTree(root)  #生成文档对象et.write(&quot;test.xml&quot;, encoding&#x3D;&quot;utf-8&quot;)</code></pre><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">></span></span>&lt;![CDATA[你好呀]]<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span></code></pre><pre class="language-python" data-language="python"><code class="language-python">from xml.etree import ElementTree as ET# 创建根节点root &#x3D; ET.Element(&quot;user&quot;)root.text &#x3D; &quot;&lt;![CDATA[你好呀]]&quot;et &#x3D; ET.ElementTree(root)  # 生成文档对象et.write(&quot;test.xml&quot;, encoding&#x3D;&quot;utf-8&quot;)</code></pre><p>案例：</p><pre class="language-python" data-language="python"><code class="language-python">content &#x3D; &quot;&quot;&quot;&lt;xml&gt;    &lt;ToUserName&gt;&lt;![CDATA[gh_7f083739789a]]&gt;&lt;&#x2F;ToUserName&gt;    &lt;FromUserName&gt;&lt;![CDATA[oia2TjuEGTNoeX76QEjQNrcURxG8]]&gt;&lt;&#x2F;FromUserName&gt;    &lt;CreateTime&gt;1395658920&lt;&#x2F;CreateTime&gt;    &lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;&#x2F;MsgType&gt;    &lt;Event&gt;&lt;![CDATA[TEMPLATESENDJOBFINISH]]&gt;&lt;&#x2F;Event&gt;    &lt;MsgID&gt;200163836&lt;&#x2F;MsgID&gt;    &lt;Status&gt;&lt;![CDATA[success]]&gt;&lt;&#x2F;Status&gt;&lt;&#x2F;xml&gt;&quot;&quot;&quot;from xml.etree import ElementTree as ETinfo &#x3D; &#123;&#125;root &#x3D; ET.XML(content)for node in root:    # print(node.tag,node.text)    info[node.tag] &#x3D; node.textprint(info)</code></pre><h3 id="5-Excel格式文件"><a href="#5-Excel格式文件" class="headerlink" title="5.Excel格式文件"></a>5.Excel格式文件</h3><p>Python内部未提供处理Excel文件的功能，想要在Python中操作Excel需要按照第三方的模块。</p><pre class="language-none"><code class="language-none">pip install openpyxl</code></pre><p>此模块中集成了Python操作Excel的相关功能，接下来我们就需要去学习该模块提供的相关功能即可。</p><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201218012118097.png" class=""><h4 id="5-1-读Excel"><a href="#5-1-读Excel" class="headerlink" title="5.1 读Excel"></a>5.1 读Excel</h4><ul><li><p>读sheet</p><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import load_workbookwb &#x3D; load_workbook(&quot;files&#x2F;p1.xlsx&quot;)# sheet相关操作# 1.获取excel文件中的所有sheet名称&quot;&quot;&quot;print(wb.sheetnames) # [&#39;数据导出&#39;, &#39;用户列表&#39;, &#39;Sheet1&#39;, &#39;Sheet2&#39;]&quot;&quot;&quot;# 2.选择sheet，基于sheet名称&quot;&quot;&quot;sheet &#x3D; wb[&quot;数据导出&quot;]cell &#x3D; sheet.cell(1, 2)print(cell.value)  # 读取对应单元格的值&quot;&quot;&quot;# 3.选择sheet，基于索引位置&quot;&quot;&quot;sheet &#x3D; wb.worksheets[0]cell &#x3D; sheet.cell(1,2)print(cell.value)&quot;&quot;&quot;# 4.循环所有的sheet&quot;&quot;&quot;for name in wb.sheetnames:    sheet &#x3D; wb[name]    cell &#x3D; sheet.cell(1, 1)    print(cell.value)&quot;&quot;&quot;&quot;&quot;&quot;for sheet in wb.worksheets:    cell &#x3D; sheet.cell(1, 1)    print(cell.value)&quot;&quot;&quot;&quot;&quot;&quot;for sheet in wb:    cell &#x3D; sheet.cell(1, 1)    print(cell.value)&quot;&quot;&quot;</code></pre></li><li><p>读sheet中单元格的数据</p><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import load_workbookwb &#x3D; load_workbook(&quot;files&#x2F;p1.xlsx&quot;)sheet &#x3D; wb.worksheets[0]# 1.获取第N行第N列的单元格(位置是从1开始）&quot;&quot;&quot;cell &#x3D; sheet.cell(1, 1)print(cell.value)  # 单元格的内容print(cell.style)  # 单元格的样式print(cell.font)  # 单元格的字体print(cell.alignment)  # 单元格的排列&quot;&quot;&quot;# 2.获取某个单元格&quot;&quot;&quot;c1 &#x3D; sheet[&quot;A2&quot;]print(c1.value)c2 &#x3D; sheet[&#39;D4&#39;]print(c2.value)&quot;&quot;&quot;# 3.第N行所有的单元格&quot;&quot;&quot;for cell in sheet[1]:    print(cell.value)&quot;&quot;&quot;# 4.所有行的数据（获取某一列数据）&quot;&quot;&quot;for row in sheet.rows:    print(row[0].value, row[1].value)&quot;&quot;&quot;# 5.获取所有列的数据&quot;&quot;&quot;for col in sheet.columns:    print(col[1].value)&quot;&quot;&quot;</code></pre></li><li><p>读合并的单元格</p><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201218011732755.png" class="" title="image-20201218011732755"><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import load_workbookwb &#x3D; load_workbook(&quot;files&#x2F;p1.xlsx&quot;)sheet &#x3D; wb.worksheets[2]# 获取第N行第N列的单元格(位置是从1开始）c1 &#x3D; sheet.cell(1, 1)print(c1)  # &lt;Cell &#39;Sheet1&#39;.A1&gt;print(c1.value) # 用户信息c2 &#x3D; sheet.cell(1, 2)print(c2)  # &lt;MergedCell &#39;Sheet1&#39;.B1&gt;print(c2.value) # None</code></pre><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import load_workbookwb &#x3D; load_workbook(&#39;files&#x2F;p1.xlsx&#39;)sheet &#x3D; wb.worksheets[2]for row in sheet.rows:    print(row)</code></pre><pre class="language-none"><code class="language-none">&gt;&gt;&gt; 输出结果(&lt;Cell &#39;Sheet1&#39;.A1&gt;, &lt;MergedCell &#39;Sheet1&#39;.B1&gt;, &lt;Cell &#39;Sheet1&#39;.C1&gt;)(&lt;Cell &#39;Sheet1&#39;.A2&gt;, &lt;Cell &#39;Sheet1&#39;.B2&gt;, &lt;Cell &#39;Sheet1&#39;.C2&gt;)(&lt;Cell &#39;Sheet1&#39;.A3&gt;, &lt;Cell &#39;Sheet1&#39;.B3&gt;, &lt;Cell &#39;Sheet1&#39;.C3&gt;)(&lt;MergedCell &#39;Sheet1&#39;.A4&gt;, &lt;Cell &#39;Sheet1&#39;.B4&gt;, &lt;Cell &#39;Sheet1&#39;.C4&gt;)(&lt;Cell &#39;Sheet1&#39;.A5&gt;, &lt;Cell &#39;Sheet1&#39;.B5&gt;, &lt;Cell &#39;Sheet1&#39;.C5&gt;)</code></pre></li></ul><h4 id="5-2-写Excel"><a href="#5-2-写Excel" class="headerlink" title="5.2 写Excel"></a>5.2 写Excel</h4><p>在Excel中想要写文件，大致要分为在：</p><ul><li><p>原Excel文件基础上写内容。</p><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import load_workbookwb &#x3D; load_workbook(&#39;files&#x2F;p1.xlsx&#39;)sheet &#x3D; wb.worksheets[0]# 找到单元格，并修改单元格的内容cell &#x3D; sheet.cell(1, 1)cell.value &#x3D; &quot;新的开始&quot;# 将excel文件保存到p2.xlsx文件中wb.save(&quot;files&#x2F;p2.xlsx&quot;)</code></pre></li><li><p>新创建Excel文件写内容。</p><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import workbook# 创建excel且默认会创建一个sheet（名称为Sheet）wb &#x3D; workbook.Workbook()sheet &#x3D; wb.worksheets[0] # 或 sheet &#x3D; wb[&quot;Sheet&quot;]# 找到单元格，并修改单元格的内容cell &#x3D; sheet.cell(1, 1)cell.value &#x3D; &quot;新的开始&quot;# 将excel文件保存到p2.xlsx文件中wb.save(&quot;files&#x2F;p2.xlsx&quot;)</code></pre></li></ul><p>在了解了如何读取Excel和创建Excel之后，后续对于Excel中的sheet和cell操作基本上都相同。</p><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import workbookwb &#x3D; workbook.Workbook() # Sheet# 1. 修改sheet名称&quot;&quot;&quot;sheet &#x3D; wb.worksheets[0]sheet.title &#x3D; &quot;数据集&quot;wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 2. 创建sheet并设置sheet颜色&quot;&quot;&quot;sheet &#x3D; wb.create_sheet(&quot;工作计划&quot;, 0)sheet.sheet_properties.tabColor &#x3D; &quot;1072BA&quot;wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 3. 默认打开的sheet&quot;&quot;&quot;wb.active &#x3D; 0wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 4. 拷贝sheet&quot;&quot;&quot;sheet &#x3D; wb.create_sheet(&quot;工作计划&quot;)sheet.sheet_properties.tabColor &#x3D; &quot;1072BA&quot;new_sheet &#x3D; wb.copy_worksheet(wb[&quot;Sheet&quot;])new_sheet.title &#x3D; &quot;新的计划&quot;wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 5.删除sheet&quot;&quot;&quot;del wb[&quot;用户列表&quot;]wb.save(&#39;files&#x2F;p2.xlsx&#39;)&quot;&quot;&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import load_workbookfrom openpyxl.styles import Alignment, Border, Side, Font, PatternFill, GradientFillwb &#x3D; load_workbook(&#39;files&#x2F;p1.xlsx&#39;)sheet &#x3D; wb.worksheets[1]# 1. 获取某个单元格，修改值&quot;&quot;&quot;cell &#x3D; sheet.cell(1, 1)cell.value &#x3D; &quot;开始&quot;wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 2.  获取某个单元格，修改值&quot;&quot;&quot;sheet[&quot;B3&quot;] &#x3D; &quot;Alex&quot;wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 3. 获取某些单元格，修改值&quot;&quot;&quot;cell_list &#x3D; sheet[&quot;B2&quot;:&quot;C3&quot;]for row in cell_list:    for cell in row:        cell.value &#x3D; &quot;新的值&quot;wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 4. 对齐方式&quot;&quot;&quot;cell &#x3D; sheet.cell(1, 1)# horizontal，水平方向对齐方式：&quot;general&quot;, &quot;left&quot;, &quot;center&quot;, &quot;right&quot;, &quot;fill&quot;, &quot;justify&quot;, &quot;centerContinuous&quot;, &quot;distributed&quot;# vertical，垂直方向对齐方式：&quot;top&quot;, &quot;center&quot;, &quot;bottom&quot;, &quot;justify&quot;, &quot;distributed&quot;# text_rotation，旋转角度。# wrap_text，是否自动换行。cell.alignment &#x3D; Alignment(horizontal&#x3D;&#39;center&#39;, vertical&#x3D;&#39;distributed&#39;, text_rotation&#x3D;45, wrap_text&#x3D;True)wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 5. 边框# side的style有如下：dashDot&#39;,&#39;dashDotDot&#39;, &#39;dashed&#39;,&#39;dotted&#39;,&#39;double&#39;,&#39;hair&#39;, &#39;medium&#39;, &#39;mediumDashDot&#39;, &#39;mediumDashDotDot&#39;,&#39;mediumDashed&#39;, &#39;slantDashDot&#39;, &#39;thick&#39;, &#39;thin&#39;&quot;&quot;&quot;cell &#x3D; sheet.cell(9, 2)cell.border &#x3D; Border(    top&#x3D;Side(style&#x3D;&quot;thin&quot;, color&#x3D;&quot;FFB6C1&quot;),     bottom&#x3D;Side(style&#x3D;&quot;dashed&quot;, color&#x3D;&quot;FFB6C1&quot;),    left&#x3D;Side(style&#x3D;&quot;dashed&quot;, color&#x3D;&quot;FFB6C1&quot;),    right&#x3D;Side(style&#x3D;&quot;dashed&quot;, color&#x3D;&quot;9932CC&quot;),    diagonal&#x3D;Side(style&#x3D;&quot;thin&quot;, color&#x3D;&quot;483D8B&quot;),  # 对角线    diagonalUp&#x3D;True,  # 左下 ~ 右上    diagonalDown&#x3D;True  # 左上 ~ 右下)wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 6.字体&quot;&quot;&quot;cell &#x3D; sheet.cell(5, 1)cell.font &#x3D; Font(name&#x3D;&quot;微软雅黑&quot;, size&#x3D;45, color&#x3D;&quot;ff0000&quot;, underline&#x3D;&quot;single&quot;)wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 7.背景色&quot;&quot;&quot;cell &#x3D; sheet.cell(5, 3)cell.fill &#x3D; PatternFill(&quot;solid&quot;, fgColor&#x3D;&quot;99ccff&quot;)wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 8.渐变背景色&quot;&quot;&quot;cell &#x3D; sheet.cell(5, 5)cell.fill &#x3D; GradientFill(&quot;linear&quot;, stop&#x3D;(&quot;FFFFFF&quot;, &quot;99ccff&quot;, &quot;000000&quot;))wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 9.宽高（索引从1开始）&quot;&quot;&quot;sheet.row_dimensions[1].height &#x3D; 50sheet.column_dimensions[&quot;E&quot;].width &#x3D; 100wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 10.合并单元格&quot;&quot;&quot;sheet.merge_cells(&quot;B2:D8&quot;)sheet.merge_cells(start_row&#x3D;15, start_column&#x3D;3, end_row&#x3D;18, end_column&#x3D;8)wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;&quot;&quot;&quot;sheet.unmerge_cells(&quot;B2:D8&quot;)wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 11.写入公式&quot;&quot;&quot;sheet &#x3D; wb.worksheets[3]sheet[&quot;D1&quot;] &#x3D; &quot;合计&quot;sheet[&quot;D2&quot;] &#x3D; &quot;&#x3D;B2*C2&quot;wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;&quot;&quot;&quot;sheet &#x3D; wb.worksheets[3]sheet[&quot;D3&quot;] &#x3D; &quot;&#x3D;SUM(B3,C3)&quot;wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 12.删除&quot;&quot;&quot;# idx，要删除的索引位置# amount，从索引位置开始要删除的个数（默认为1）sheet.delete_rows(idx&#x3D;1, amount&#x3D;20)sheet.delete_cols(idx&#x3D;1, amount&#x3D;3)wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 13.插入&quot;&quot;&quot;sheet.insert_rows(idx&#x3D;5, amount&#x3D;10)sheet.insert_cols(idx&#x3D;3, amount&#x3D;2)wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 14.循环写内容&quot;&quot;&quot;sheet &#x3D; wb[&quot;Sheet&quot;]cell_range &#x3D; sheet[&#39;A1:C2&#39;]for row in cell_range:    for cell in row:        cell.value &#x3D; &quot;xx&quot;for row in sheet.iter_rows(min_row&#x3D;5, min_col&#x3D;1, max_col&#x3D;7, max_row&#x3D;10):    for cell in row:        cell.value &#x3D; &quot;oo&quot;wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 15.移动&quot;&quot;&quot;# 将H2:J10范围的数据，向右移动15个位置、向上移动1个位置sheet.move_range(&quot;H2:J10&quot;,rows&#x3D;1, cols&#x3D;15)wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;&quot;&quot;&quot;sheet &#x3D; wb.worksheets[3]sheet[&quot;D1&quot;] &#x3D; &quot;合计&quot;sheet[&quot;D2&quot;] &#x3D; &quot;&#x3D;B2*C2&quot;sheet[&quot;D3&quot;] &#x3D; &quot;&#x3D;SUM(B3,C3)&quot;sheet.move_range(&quot;B1:D3&quot;,cols&#x3D;10, translate&#x3D;True) # 自动翻译公式wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 16.打印区域&quot;&quot;&quot;sheet.print_area &#x3D; &quot;A1:D200&quot;wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;# 17.打印时，每个页面的固定表头&quot;&quot;&quot;sheet.print_title_cols &#x3D; &quot;A:D&quot;sheet.print_title_rows &#x3D; &quot;1:3&quot;wb.save(&quot;p2.xlsx&quot;)&quot;&quot;&quot;</code></pre><p>6.压缩文件</p><p>基于Python内置的shutil模块可以实现对压缩文件的操作。</p><pre class="language-python" data-language="python"><code class="language-python">import shutil# 1. 压缩文件&quot;&quot;&quot;# base_name，压缩后的压缩包文件# format，压缩的格式，例如：&quot;zip&quot;, &quot;tar&quot;, &quot;gztar&quot;, &quot;bztar&quot;, or &quot;xztar&quot;.# root_dir，要压缩的文件夹路径&quot;&quot;&quot;# shutil.make_archive(base_name&#x3D;r&#39;datafile&#39;,format&#x3D;&#39;zip&#39;,root_dir&#x3D;r&#39;files&#39;)# 2. 解压文件&quot;&quot;&quot;# filename，要解压的压缩包文件# extract_dir，解压的路径# format，压缩文件格式&quot;&quot;&quot;# shutil.unpack_archive(filename&#x3D;r&#39;datafile.zip&#39;, extract_dir&#x3D;r&#39;xxxxxx&#x2F;xo&#39;, format&#x3D;&#39;zip&#39;)</code></pre><h3 id="7-路径相关"><a href="#7-路径相关" class="headerlink" title="7.路径相关"></a>7.路径相关</h3><h4 id="7-1-转义"><a href="#7-1-转义" class="headerlink" title="7.1  转义"></a>7.1  转义</h4><p>​windows路径使用的是\，linux路径使用的是&#x2F;。特别的，在windows系统中如果有这样的一个路径<code>D:\nxxx\txxx\x1</code>，程序会报错。因为在路径中存在特殊符 <code>\n</code>（换行符）和<code>\t</code>（制表符），Python解释器无法自动区分。</p><p>所以，在windows中编写路径时，一般有两种方式：</p><ul><li>加转义符，例如：<code>&quot;D:\\nxxx\\txxx\\x1&quot;</code></li><li>路径前加r，例如：<code>r&quot;D:\\nxxx\\txxx\\x1&quot;</code></li></ul><h4 id="7-2-程序当前路径"><a href="#7-2-程序当前路径" class="headerlink" title="7.2 程序当前路径"></a>7.2 程序当前路径</h4><p>​项目中如果使用了相对路径，那么一定要注意当前所在的位置。</p><p>​例如：在<code>/Users/wupeiqi/PycharmProjects/CodeRepository/</code>路径下编写 <code>demo.py</code>文件</p><pre class="language-python" data-language="python"><code class="language-python">with open(&quot;a1.txt&quot;, mode&#x3D;&#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:    f.write(&quot;你好呀&quot;)</code></pre><p>用以下两种方式去运行：</p><ul><li><p>方式1，文件会创建在 <code>/Users/wupeiqi/PycharmProjects/CodeRepository/</code> 目录下。</p><pre class="language-python" data-language="python"><code class="language-python">cd &#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;python demo.py</code></pre></li><li><p>方式2，文件会创建在 <code>/Users/wupeiqi</code>目录下。</p><pre class="language-none"><code class="language-none">cd &#x2F;Users&#x2F;wupeiqipython &#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;demo.py</code></pre></li></ul><pre class="language-python" data-language="python"><code class="language-python">import os&quot;&quot;&quot;# 1.获取当前运行的py脚本所在路径abs &#x3D; os.path.abspath(__file__)print(abs) # &#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&#x2F;20.路径相关.pypath &#x3D; os.path.dirname(abs)print(path) # &#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;luffyCourse&#x2F;day09&quot;&quot;&quot;base_dir &#x3D; os.path.dirname(os.path.abspath(__file__))file_path &#x3D; os.path.join(base_dir, &#39;files&#39;, &#39;info.txt&#39;)  # 不用\进行拼接是，因为不同系统的路径使用不同\或&#x2F;进行表示，因此使用os.path.join()print(file_path)if os.path.exists(file_path):    file_object &#x3D; open(file_path, mode&#x3D;&#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;)    data &#x3D; file_object.read()    file_object.close()    print(data)else:    print(&#39;文件路径不存在&#39;)</code></pre><h4 id="7-3-文件和路径相关"><a href="#7-3-文件和路径相关" class="headerlink" title="7.3 文件和路径相关"></a>7.3 文件和路径相关</h4><pre class="language-python" data-language="python"><code class="language-python">import shutilimport os# 1. 获取当前脚本绝对路径&quot;&quot;&quot;abs_path &#x3D; os.path.abspath(__file__)print(abs_path)&quot;&quot;&quot;# 2. 获取当前文件的上级目录&quot;&quot;&quot;# 找上n级就在前面嵌套n个os.path.dirname(),例如上两级os.path.dirname(os.path.dirname(路径) )base_path &#x3D; os.path.dirname(路径) print(base_path)&quot;&quot;&quot;# 3. 路径拼接&quot;&quot;&quot;p1 &#x3D; os.path.join(base_path, &#39;xx&#39;)print(p1)p2 &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;a1.png&#39;)print(p2)&quot;&quot;&quot;# 4. 判断路径是否存在&quot;&quot;&quot;exists &#x3D; os.path.exists(p1)print(exists)&quot;&quot;&quot;# 5. 创建文件夹&quot;&quot;&quot;path &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;uuuu&#39;)if not os.path.exists(path):    os.makedirs(path)&quot;&quot;&quot;# 6. 是否是文件夹&quot;&quot;&quot;file_path &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;uuuu.png&#39;)is_dir &#x3D; os.path.isdir(file_path)print(is_dir) # Falsefolder_path &#x3D; os.path.join(base_path, &#39;xx&#39;, &#39;oo&#39;, &#39;uuuu&#39;)is_dir &#x3D; os.path.isdir(folder_path)print(is_dir) # True&quot;&quot;&quot;# 7. 删除文件或文件夹&quot;&quot;&quot;os.remove(&quot;文件路径&quot;)&quot;&quot;&quot;&quot;&quot;&quot;path &#x3D; os.path.join(base_path, &#39;xx&#39;)shutil.rmtree(path)&quot;&quot;&quot;# 8. 拷贝文件夹&quot;&quot;&quot;shutil.copytree(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;Desktop&#x2F;图&#x2F;csdn&#x2F;&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;files&quot;)&quot;&quot;&quot;# 9.拷贝文件&quot;&quot;&quot;shutil.copy(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;Desktop&#x2F;图&#x2F;csdn&#x2F;WX20201123-112406@2x.png&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;&quot;)shutil.copy(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;Desktop&#x2F;图&#x2F;csdn&#x2F;WX20201123-112406@2x.png&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;x.png&quot;)&quot;&quot;&quot;# 10.文件或文件夹重命名&quot;&quot;&quot;shutil.move(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;x.png&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;xxxx.png&quot;)shutil.move(&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;files&quot;,&quot;&#x2F;Users&#x2F;wupeiqi&#x2F;PycharmProjects&#x2F;CodeRepository&#x2F;images&quot;)&quot;&quot;&quot;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​今天我们主要围绕着<code>文件</code> 相关的操作来展开进行讲解，让大家能够基于Python处理不同格式的文件。由于涉及的知识点比较多，所以今日的内容学起来会比较耗时，但都比较简单，只需要理解并编写好相关笔记以便后期开发时翻阅。</p><ol><li><p>文件相对路径，在使用相对路径时可能会执行程序的目录不同，导致路径出问题。所以，如若使用相对路径请务必清楚当前运行程序所在目录。</p></li><li><p>文件绝对路径（推荐），<font color="#dd0000"><strong>不要将文件路径写死，而是基于 os 模块中的相关功能自动化获取绝对路径</strong></font>，以方便项目移动到其他文件或电脑上。</p><pre class="language-python" data-language="python"><code class="language-python">import osbase_dir &#x3D; os.path.dirname(os.path.abspath(__file__))file_path &#x3D; os.path.join(base_dir, &#39;files&#39;, &#39;info.txt&#39;)</code></pre></li><li><p>路径转义</p><ul><li>手动写路径，需要自己在路径中添加 r 或 加入 \ 来进行处理。</li><li>基于os.path.join拼接，内部自动处理，不需要手动处理。</li></ul></li><li><p>内置函数、内置模块、第三方模块的区别？</p></li><li><p>如何去下载安装第三方模块？</p><pre class="language-python" data-language="python"><code class="language-python">pip install 模块名称</code></pre><ul><li>requests模块，可以用来发送网络请求。</li><li>openpyxl模块，处理Excel格式的文件。</li></ul></li><li><p>基本文件的读写、打开模式、上下文管理。</p></li><li><p>其他格式：csv、ini、xml、excel格式的处理（无序记忆，做好笔记即可）。</p></li></ol><h3 id="作业-参照笔记完成即可"><a href="#作业-参照笔记完成即可" class="headerlink" title="作业(参照笔记完成即可)"></a>作业(参照笔记完成即可)</h3><ol><li><p>基于csv格式实现 用户的注册 &amp; 登录认证。详细需求如下：</p><ul><li>用户注册时，新注册用户要写入文件csv文件中，输入Q或q则退出。</li><li>用户登录时，逐行读取csv文件中的用户信息并进行校验。</li><li>提示：文件路径须使用os模块构造的绝对路径的方式。</li></ul><pre class="language-python" data-language="python"><code class="language-python"># 补充知识：for循环同时获取索引和值num_list &#x3D; [111, 222, 333]for index in range(len(num_list)):    print(index, num_list[index])  # 当索引需要从1开始是print(index+1, num_list[index])# enumerate()for index, num in enumerate(num_list):  # 当索引需要从1开始是enumerate(num_list, 1)    print(index, num)</code></pre><pre class="language-python" data-language="python"><code class="language-python">  &#39;&#39;&#39;  本文件实现功能是，用户的注册 &amp; 登录认证，主要内容如下：  - 用户注册时，新注册用户要写入文件csv文件中，输入Q或q则退出。  - 用户登录时，逐行读取csv文件中的用户信息并进行校验。  - 提示：文件路径须使用os模块构造的绝对路径的方式。  &#39;&#39;&#39;    import os    base_dir &#x3D; os.path.dirname(os.path.abspath(__file__))  # 拼接文件路径  file_path &#x3D; os.path.join(base_dir)  print(file_path)    # 1.创建文件  file_name &#x3D; os.path.join(file_path, &#39;第一题.csv&#39;)    if not os.path.exists(file_name):  open(file_name, mode&#x3D;&#39;wt&#39;, encoding&#x3D;&#39;utf-8&#39;)    # 2.注册程序  with open(file_name, mode&#x3D;&#39;at&#39;, encoding&#x3D;&#39;utf-8&#39;) as register_object:  while True:  print(&#39;欢迎注册用户&#39;.center(50, &#39;*&#39;))  user_name &#x3D; input(&#39;please input your name(Q&#x2F;q to quit): &#39;).strip()  # 输入Q&#x2F;q退出  if user_name.upper() &#x3D;&#x3D; &#39;Q&#39;:      break    user_psd &#x3D; input(&#39;please input psd: &#39;).strip()    # 写入数据  data &#x3D; &quot;&#123;&#125;-&#123;&#125;\n&quot;.format(user_name, user_psd)  register_object.write(data)  register_object.flush()    # 3.登录程序  with open(file_name, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as login_object:  # 导入.csv数据,并将用户存为字典  user_dic &#x3D; &#123;&#125;  for line in login_object:  # 先strip()去掉末尾的换行符  user_name, user_psd &#x3D; line.strip().split(&#39;-&#39;)  user_dic[user_name] &#x3D; user_psd  # print(user_dic)    while True:  print(&#39;开始登录&#39;.center(50, &#39;*&#39;))  log_name &#x3D; input(&#39;please input your name(Q&#x2F;q to quit): &#39;).strip()  # 输入Q&#x2F;q退出  if log_name.upper() &#x3D;&#x3D; &#39;Q&#39;:      break  # 用户名不存在重新输入  if log_name not in user_dic:      print(&#39;&#123;&#125; not exist, please try again: &#39;)      continue    count &#x3D; 3  while count &gt; 0:      log_psd &#x3D; input(&#39;please input your psd: &#39;).strip()      if log_psd !&#x3D; user_dic[log_name]:          print(f&#39;password wrong, you have: &#123;count - 1&#125; times left&#39;)          count -&#x3D; 1          continue      else:      exit(&#39;login successful&#39;)  # TODO 尚未实现&#39;用户名已注册不让注册功能&#39;  </code></pre><p><font color="#dd0000"><strong>存在问题</strong></font></p>  <pre class="language-none"><code class="language-none">1.拼接文件路径过程，无用操作（去掉下面代码）file_path &#x3D; os.path.join(base_dir)print(file_path)2.open()打开文件时，文件不存在会自动创建，无需判断（去掉下面代码）if not os.path.exists(file_name):  open(file_name, mode&#x3D;&#39;wt&#39;, encoding&#x3D;&#39;utf-8&#39;)3.在程序开始时询问是否需要注册</code></pre><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能是，用户的注册 &amp; 登录认证，主要内容如下：- 用户注册时，新注册用户要写入文件csv文件中，输入Q或q则退出。- 用户登录时，逐行读取csv文件中的用户信息并进行校验。- 提示：文件路径须使用os模块构造的绝对路径的方式。&#39;&#39;&#39;import osbase_dir &#x3D; os.path.dirname(os.path.abspath(__file__))print(base_dir)# 1.创建文件file_name &#x3D; os.path.join(base_dir, &#39;第一题.csv&#39;)# if not os.path.exists(file_name):#     open(file_name, mode&#x3D;&#39;wt&#39;, encoding&#x3D;&#39;utf-8&#39;)# 2.注册程序while True:    user_input &#x3D; input(&#39;Whether user registration is required(Y&#x2F;N): &#39;)    if user_input.upper() !&#x3D; &#39;Y&#39; and user_input.upper() !&#x3D; &#39;N&#39;:        print(&#39;input Wrong&#39;)        continue    if user_input &#x3D;&#x3D; &#39;N&#39;:        break    else:        # 用户注册        with open(file_name, mode&#x3D;&#39;at&#39;, encoding&#x3D;&#39;utf-8&#39;) as register_object:            while True:                print(&#39;欢迎注册用户&#39;.center(50, &#39;*&#39;))                user_name &#x3D; input(&#39;please input your name(Q&#x2F;q to quit): &#39;).strip()                # 输入Q&#x2F;q退出                if user_name.upper() &#x3D;&#x3D; &#39;Q&#39;:                    break                user_psd &#x3D; input(&#39;please input psd: &#39;).strip()                # 写入数据                data &#x3D; &quot;&#123;&#125;-&#123;&#125;\n&quot;.format(user_name, user_psd)                register_object.write(data)                register_object.flush()# 3.登录程序with open(file_name, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as login_object:    # 导入.csv数据,并将用户存为字典    user_dic &#x3D; &#123;&#125;    for line in login_object:        # 先strip()去掉末尾的换行符        user_name, user_psd &#x3D; line.strip().split(&#39;-&#39;)        user_dic[user_name] &#x3D; user_psd    # print(user_dic)    while True:        print(&#39;开始登录&#39;.center(50, &#39;*&#39;))        log_name &#x3D; input(&#39;please input your name(Q&#x2F;q to quit): &#39;).strip()        # 输入Q&#x2F;q退出        if log_name.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        # 用户名不存在重新输入        if log_name not in user_dic:            print(&#39;&#123;&#125; not exist, please try again: &#39;)            continue        count &#x3D; 3        while count &gt; 0:            log_psd &#x3D; input(&#39;please input your psd: &#39;).strip()            if log_psd !&#x3D; user_dic[log_name]:                print(f&#39;password wrong, you have: &#123;count - 1&#125; times left&#39;)                count -&#x3D; 1                continue            else:                exit(&#39;login successful&#39;)# TODO 尚未实现&#39;用户名已注册不让注册功能&#39;</code></pre></li><li><p>补充代码：实现去网上获取指定地区的天气信息，并写入到Excel中。</p><pre class="language-python" data-language="python"><code class="language-python">import requestswhile True:    city &#x3D; input(&quot;请输入城市（Q&#x2F;q退出）：&quot;)    if city.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    url &#x3D; &quot;http:&#x2F;&#x2F;ws.webxml.com.cn&#x2F;&#x2F;WebServices&#x2F;WeatherWebService.asmx&#x2F;getWeatherbyCityName?theCityName&#x3D;&#123;&#125;&quot;.format(city)    res &#x3D; requests.get(url&#x3D;url)    print（res.text）    # 1.提取XML格式中的数据    # 2.为每个城市创建一个sheet，并将获取的xml格式中的数据写入到excel中。 </code></pre><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能是，去网上获取指定地区的天气信息，并写入到Excel中。&#39;&#39;&#39;import requestsimport osfrom xml.etree import ElementTree as ETfrom openpyxl import workbook# 处理文件路径base_dir &#x3D; os.path.dirname(os.path.abspath(__file__))target_excel_path &#x3D; os.path.join(base_dir, &#39;第二题.xlsx&#39;)# 创建excel且默认会创建一个sheet（名称为Sheet）wb &#x3D; workbook.Workbook()# 获取天气信息wb &#x3D; workbook.Workbook()while True:    city &#x3D; input(&quot;请输入城市（Q&#x2F;q退出）：&quot;)    if city.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    url &#x3D; &quot;http:&#x2F;&#x2F;ws.webxml.com.cn&#x2F;&#x2F;WebServices&#x2F;WeatherWebService.asmx&#x2F;getWeatherbyCityName?theCityName&#x3D;&#123;&#125;&quot;.format(city)    res &#x3D; requests.get(url&#x3D;url)    # print(res.text)    # 1.提取XML格式中的数据    root &#x3D; ET.XML(res.text)    # 2.为每个城市创建一个sheet，并将获取的xml格式中的数据写入到excel中。    # 创建excel且默认会创建一个sheet（名称为Sheet）    sheet &#x3D; wb.create_sheet(city)    # 3.将所有数据按列存储    for index, child in enumerate(root, 1):        #   print(index, child.text)        cell &#x3D; sheet.cell(index, 1)        cell.value &#x3D; child.text    del wb[&#39;Sheet&#39;]wb.save(target_excel_path)</code></pre></li><li><p>读取ini文件内容，按照规则写入到Excel中。</p><ul><li><p>ini文件内容如下：</p><pre class="language-ini" data-language="ini"><code class="language-ini">[mysqld]datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysqlsocket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.socklog-bin&#x3D;py-mysql-bincharacter-set-server&#x3D;utf8collation-server&#x3D;utf8_general_cilog-error&#x3D;&#x2F;var&#x2F;log&#x2F;mysqld.log# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links&#x3D;0[mysqld_safe]log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.logpid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mariadb&#x2F;mariadb.pid[client]default-character-set&#x3D;utf8</code></pre></li><li><p>读取ini格式的文件，并创建一个excel文件，且为每个节点创建一个sheet，然后将节点下的键值写入到excel中，按照如下格式。</p><img src="asserts/image-20201218204922898.png" alt="image-20201218204922898" style="zoom: 33%;" /><ul><li>首行，字体白色 &amp; 单元格背景色蓝色。</li><li>内容均居中。</li><li>边框。</li></ul><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能是，读取ini文件内容，按照规则写入到Excel中。规则：    - 读取ini格式的文件，并创建一个excel文件，且为每个节点创建一个sheet，然后将节点下的键值写入到excel中，按照如下格式。    - 首行，字体白色 &amp; 单元格背景色蓝色。    - 内容均居中。    - 边框。&#39;&#39;&#39;import configparserimport osfrom openpyxl import workbookfrom openpyxl.styles import Alignment, Border, Side, Font, PatternFill, GradientFill# 处理文件路径：找到脚本文件上级文件夹目录base_dir &#x3D; os.path.dirname(os.path.abspath(__file__))# 通过上级文件夹目录，找到数据源和文件存储位置source_file &#x3D; os.path.join(base_dir, &#39;作业三.ini&#39;)target_excel_path &#x3D; os.path.join(base_dir, &#39;第三题.xlsx&#39;)# 如果ini文件不在，则写入ini文件if not os.path.exists(source_file):    ini_file &#x3D; open(source_file, mode&#x3D;&#39;wt&#39;, encoding&#x3D;&#39;utf-8&#39;)    content &#x3D; &#39;&#39;&#39;[mysqld]    datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql    socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock    log-bin&#x3D;py-mysql-bin    character-set-server&#x3D;utf8    collation-server&#x3D;utf8_general_ci    log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mysqld.log    # Disabling symbolic-links is recommended to prevent assorted security risks    symbolic-links&#x3D;0        [mysqld_safe]    log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log    pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mariadb&#x2F;mariadb.pid        [client]    default-character-set&#x3D;utf8    &#39;&#39;&#39;    ini_file.write(content)    ini_file.close()# 读取ini文件config &#x3D; configparser.ConfigParser()config.read(source_file, encoding&#x3D;&#39;utf-8&#39;)sheets &#x3D; config.sections()# 将数据存入excelwb &#x3D; workbook.Workbook()  # 创建excel且默认会创建一个sheet（名称为Sheet）for item in sheets:    sheet &#x3D; wb.create_sheet(item)    keys &#x3D; []    values &#x3D; []    for index in range(len(config.items(item))):        keys.append(config.items(item)[index][0])        values.append(config.items(item)[index][1])    print(keys, values)    # 设置表头    ths &#x3D; [&#39;键&#39;, &#39;值&#39;]    for index, th in enumerate(ths, 1):  # excel 表格序号从1开始        cell &#x3D; sheet.cell(1, index)        cell.value &#x3D; th        # 首行，字体白色 &amp; 单元格背景色蓝色。        cell.font &#x3D; Font(name&#x3D;&quot;微软雅黑&quot;, color&#x3D;&quot;ffffff&quot;)        cell.fill &#x3D; PatternFill(&quot;solid&quot;, fgColor&#x3D;&quot;0080ff&quot;)        # 内容均居中        cell.alignment &#x3D; Alignment(horizontal&#x3D;&#39;center&#39;, vertical&#x3D;&#39;center&#39;, text_rotation&#x3D;0, wrap_text&#x3D;True)        # 边框        cell.border &#x3D; Border(            top&#x3D;Side(style&#x3D;&quot;thin&quot;, color&#x3D;&quot;000000&quot;),            bottom&#x3D;Side(style&#x3D;&quot;thin&quot;, color&#x3D;&quot;000000&quot;),            left&#x3D;Side(style&#x3D;&quot;thin&quot;, color&#x3D;&quot;000000&quot;),            right&#x3D;Side(style&#x3D;&quot;thin&quot;, color&#x3D;&quot;000000&quot;),            # diagonal&#x3D;Side(style&#x3D;&quot;thin&quot;, color&#x3D;&quot;000000&quot;),  # 对角线            # diagonalUp&#x3D;True,  # 左下 ~ 右上            # diagonalDown&#x3D;True  # 左上 ~ 右下        )    # 设置其它表格内容    for index, key in enumerate(keys):        cell_key &#x3D; sheet.cell(index+2, 1)        cell_key.value &#x3D; keys[index]        cell_value &#x3D; sheet.cell(index+2, 2)        cell_value.value &#x3D; values[index]del wb[&#39;Sheet&#39;]wb.save(target_excel_path)</code></pre><p><font color="#dd0000"><strong>存在问题</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">1. 文字居中和边框的设置表头和其它地方都有，可以写在创建sheet后2. 对于除表头外的其它表格可以优化</code></pre><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能是，读取ini文件内容，按照规则写入到Excel中。规则：    - 读取ini格式的文件，并创建一个excel文件，且为每个节点创建一个sheet，然后将节点下的键值写入到excel中，按照如下格式。    - 首行，字体白色 &amp; 单元格背景色蓝色。    - 内容均居中。    - 边框。&#39;&#39;&#39;import configparserimport osfrom openpyxl import workbookfrom openpyxl.styles import Alignment, Border, Side, Font, PatternFill, GradientFill# 处理文件路径：找到脚本文件上级文件夹目录base_dir &#x3D; os.path.dirname(os.path.abspath(__file__))# 通过上级文件夹目录，找到数据源和文件存储位置source_file &#x3D; os.path.join(base_dir, &#39;作业三.ini&#39;)target_excel_path &#x3D; os.path.join(base_dir, &#39;第三题.xlsx&#39;)# 如果ini文件不在，则写入ini文件if not os.path.exists(source_file):    ini_file &#x3D; open(source_file, mode&#x3D;&#39;wt&#39;, encoding&#x3D;&#39;utf-8&#39;)    content &#x3D; &#39;&#39;&#39;[mysqld]    datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql    socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock    log-bin&#x3D;py-mysql-bin    character-set-server&#x3D;utf8    collation-server&#x3D;utf8_general_ci    log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mysqld.log    # Disabling symbolic-links is recommended to prevent assorted security risks    symbolic-links&#x3D;0        [mysqld_safe]    log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log    pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mariadb&#x2F;mariadb.pid        [client]    default-character-set&#x3D;utf8    &#39;&#39;&#39;    ini_file.write(content)    ini_file.close()# 读取ini文件config &#x3D; configparser.ConfigParser()config.read(source_file, encoding&#x3D;&#39;utf-8&#39;)sections &#x3D; config.sections()# 将数据存入excelwb &#x3D; workbook.Workbook()  # 创建excel且默认会创建一个sheet（名称为Sheet）for section in sections:    # 文字居中和边框的设置表头和其它地方都有，可以写在创建sheet后    alignment &#x3D; Alignment(horizontal&#x3D;&#39;center&#39;, vertical&#x3D;&#39;center&#39;)    border &#x3D; Border(            top&#x3D;Side(style&#x3D;&quot;thin&quot;, color&#x3D;&quot;000000&quot;),            bottom&#x3D;Side(style&#x3D;&quot;thin&quot;, color&#x3D;&quot;000000&quot;),            left&#x3D;Side(style&#x3D;&quot;thin&quot;, color&#x3D;&quot;000000&quot;),            right&#x3D;Side(style&#x3D;&quot;thin&quot;, color&#x3D;&quot;000000&quot;),    )    sheet &#x3D; wb.create_sheet(section)    # 设置表头    ths &#x3D; [&#39;键&#39;, &#39;值&#39;]    for index, th in enumerate(ths, 1):  # excel 表格序号从1开始        cell &#x3D; sheet.cell(1, index)        cell.value &#x3D; th        # 首行，字体白色 &amp; 单元格背景色蓝色。        cell.font &#x3D; Font(name&#x3D;&quot;微软雅黑&quot;, color&#x3D;&quot;ffffff&quot;)        cell.fill &#x3D; PatternFill(&quot;solid&quot;, fgColor&#x3D;&quot;0080ff&quot;)        # 内容均居中        cell.alignment &#x3D; alignment        # 边框        cell.border &#x3D; border    # 设置表格其它区域    for row, tup in enumerate(config.items(section), 2):        # print(tup)  # tup:元组，第一个元素key，第二个元素value (&#39;datadir&#39;, &#39;&#x2F;var&#x2F;lib&#x2F;mysql&#39;)...        for col in range(len(tup)):  # &#39;datadir&#39;, &#39;&#x2F;var&#x2F;lib&#x2F;mysql&#39;            cell &#x3D; sheet.cell(row, col+1)            cell.value &#x3D; tup[col]            # 内容均居中            cell.alignment &#x3D; alignment            # 边框            cell.border &#x3D; borderdel wb[&#39;Sheet&#39;]wb.save(target_excel_path)</code></pre></li></ul></li><li><p>补充代码，实现如下功能。</p><pre class="language-python" data-language="python"><code class="language-python">import requests# 1.下载文件file_url &#x3D; &#39;https:&#x2F;&#x2F;files.cnblogs.com&#x2F;files&#x2F;wupeiqi&#x2F;HtmlStore.zip&#39;res &#x3D; requests.get(url&#x3D;file_url)print(res.content)# 2.将下载的文件保存到当前执行脚本同级目录下 &#x2F;files&#x2F;package&#x2F; 目录下（且文件名为HtmlStore.zip）# 3.在将下载下来的文件解压到 &#x2F;files&#x2F;html&#x2F; 目录下</code></pre><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能是，下载并解压文件。&#39;&#39;&#39;import osimport requestsimport shutil# 处理文件路径base_dir &#x3D; os.path.dirname(os.path.abspath(__file__))file_path &#x3D; os.path.join(base_dir, &#39;files&#39;, &#39;package&#39;)# 路劲不存在就创建if not os.path.exists(file_path):    os.makedirs(file_path)# 1.下载文件file_url &#x3D; &#39;https:&#x2F;&#x2F;files.cnblogs.com&#x2F;files&#x2F;wupeiqi&#x2F;HtmlStore.zip&#39;res &#x3D; requests.get(url&#x3D;file_url)# print(res.content)# 2.将下载的文件保存到当前执行脚本同级目录下 &#x2F;files&#x2F;package&#x2F; 目录下（且文件名为HtmlStore.zip）file_name &#x3D; os.path.join(file_path, file_url.split(&#39;&#x2F;&#39;)[-1])with open(file_name, mode&#x3D;&#39;wb&#39;) as file_object:    file_object.write(res.content)# 3.在将下载下来的文件解压到 &#x2F;files&#x2F;html&#x2F; 目录下unpack_file_name &#x3D; os.path.join(base_dir, &#39;files&#39;, &#39;html&#39;) shutil.unpack_archive(file_name, extract_dir&#x3D;unpack_file_name, format&#x3D;&#39;zip&#39;)  # unpack文件时文件路径不存在会自动创建不用if...</code></pre></li></ol><h2 id="十一、-函数入门"><a href="#十一、-函数入门" class="headerlink" title="十一、 函数入门"></a>十一、 函数入门</h2><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201220155910093.png" class="" title="image-20201220155910093"><p>目标：掌握函数的编写方式以及函数的基本使用。</p><p>今日概要：</p><ul><li>初识函数</li><li>函数的参数</li><li>函数的返回值</li></ul><h3 id="1-初识函数"><a href="#1-初识函数" class="headerlink" title="1. 初识函数"></a>1. 初识函数</h3><blockquote><p> 函数到底是个什么东西？</p></blockquote><p>​函数，可以当做是<strong>一大堆功能代码的集合。</strong></p><pre class="language-python" data-language="python"><code class="language-python">def 函数名():    函数内编写代码    ...    ...    函数名()</code></pre><p>例如：</p><pre class="language-python" data-language="python"><code class="language-python"># 定义名字叫info的函数def info():    print(&quot;第一行&quot;)    print(&quot;第二行&quot;)    print(&quot;第n行...&quot;)    info()</code></pre><blockquote><p>什么时候会用到函数？</p></blockquote><p>​什么时候会用到函数呢？一般在项目开发中有会有两种应用场景：</p><ul><li><p><font color="#dd0000"><strong>有重复代码，用函数增加代码的重用性。</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">def send_email():    # 10行代码print(&quot;欢迎使用计算机监控系统&quot;)if CPU占用率 &gt; 90%:    send_email()if 硬盘使用率 &gt; 99%:    send_email()    if 内存使用率 &gt; 98%:    send_email()...</code></pre></li><li><p><font color="#dd0000"><strong>代码太长，用函数增强代码的可读性。</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">def calculate_same_num_rule():    &quot;&quot;&quot;判断是否是豹子&quot;&quot;&quot;    passdef calculate_same_color_rule():    &quot;&quot;&quot;判断是否是同花&quot;&quot;&quot;    passdef calculate_straight_rule():    &quot;&quot;&quot;判断是否顺子&quot;&quot;&quot;passdef calculate_double_card_rule(poke_list):    &quot;&quot;&quot;判断是否对子&quot;&quot;&quot;passdef calculate_single_card_rule():    &quot;&quot;&quot;判断是否单牌&quot;&quot;&quot;    pass# 1. 生成一副扑克牌card_color_list &#x3D; [&quot;红桃&quot;, &quot;黑桃&quot;, &quot;方片&quot;, &quot;梅花&quot;]card_nums &#x3D; [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]  # Aall_card_list &#x3D; [[color, num] for color in card_color_list for num in card_nums]# 2.洗牌random.shuffle(all_card_list)# 3.给玩家发牌...# 4.判断牌是：豹子？同花顺？顺子？对子？单点？calculate_same_num_rule()calculate_same_color_rule()calculate_straight_rule()...</code></pre></li></ul><p>​以前我们变成是按照业务逻辑从上到下逐步完成，称为：<font color="#dd0000"><strong>面向过程编程。</strong></font>；现在学了函数之后，利用函数编程称为：<font color="#dd0000"><strong>函数式编程。</strong></font></p><h3 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="2. 函数的参数"></a>2. 函数的参数</h3><p>​之前说了很好多次发送邮件的案例，下面就来教大家用python发邮件，然后再由此引出函数的参数。</p><ul><li>注册邮箱</li><li>基础配置<ul><li>保存好授权码</li><li>记住SMTP服务器地址: smtp.126.com</li></ul></li><li>代码发送邮件</li></ul><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201220180545406.png" class="" title="image-20201220180545406"><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201220180613478.png" class="" title="image-20201220180613478"><p>以下是我为大家提供的发邮件的一个函数。</p><pre class="language-python" data-language="python"><code class="language-python">import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddr# ### 1.邮件内容配置 ###msg &#x3D; MIMEText(&quot;你好&quot;, &#39;html&#39;, &#39;utf-8&#39;) msg[&#39;From&#39;] &#x3D; formataddr([&quot;武沛齐&quot;, &quot;yangliangran@126.com&quot;])msg[&#39;Subject&#39;] &#x3D; &quot;交朋友&quot;# ### 2.发送邮件 ### server &#x3D; smtplib.SMTP_SSL(&quot;smtp.126.com&quot;)server.login(&quot;yangliangran@126.com&quot;, &quot;LAYEVIAPWQAVVDEP&quot;)server.sendmail(&quot;yangliangran@126.com&quot;, &quot;424662508@qq.com&quot;, msg.as_string())server.quit()</code></pre><p>那么需求来了，请求大家提一个需求：根据上述代码实现给3个用户发邮件。</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;424662508@qq.com&quot;v2 &#x3D; &quot;424662509@qq.com&quot;v3 &#x3D; &quot;wupeiqi@live.com&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddrdef send_email(xx):    # ### 1.邮件内容配置 ###    msg &#x3D; MIMEText(&quot;你好&quot;, &#39;html&#39;, &#39;utf-8&#39;)     msg[&#39;From&#39;] &#x3D; formataddr([&quot;武沛齐&quot;, &quot;yangliangran@126.com&quot;])    msg[&#39;Subject&#39;] &#x3D; &quot;交朋友&quot;    # ### 2.发送邮件 ###     server &#x3D; smtplib.SMTP_SSL(&quot;smtp.126.com&quot;)    server.login(&quot;yangliangran@126.com&quot;, &quot;LAYEVIAPWQAVVDEP&quot;)    server.sendmail(&quot;yangliangran@126.com&quot;, xx, msg.as_string())    server.quit()send_email(&quot;424662508@qq.com&quot;)send_email(&quot;424662509@qq.com&quot;)send_email(&quot;wupeiqi@live.com&quot;)</code></pre><ul><li><p>思路1</p><pre class="language-python" data-language="python"><code class="language-python">def send_email1():    # ### 1.邮件内容配置 ###    # 邮件文本    msg &#x3D; MIMEText(&quot;你好&quot;, &#39;html&#39;, &#39;utf-8&#39;)     # 邮件上显示的发件人    msg[&#39;From&#39;] &#x3D; formataddr([&quot;武沛齐&quot;, &quot;wptawy@126.com&quot;])    # 邮件上显示的主题    msg[&#39;Subject&#39;] &#x3D; &quot;邮件主题&quot;    # ### 2.发送邮件 ###     server &#x3D; smtplib.SMTP_SSL(&quot;smtp.126.com&quot;)    server.login(&quot;wptawy@126.com&quot;, &quot;WIYSAILOVUKPQGHY&quot;)    server.sendmail(&quot;wptawy@126.com&quot;, &quot;424662508@qq.com&quot;, msg.as_string())    server.quit()    def send_email2():    # ### 1.邮件内容配置 ###    # 邮件文本    msg &#x3D; MIMEText(&quot;你好&quot;, &#39;html&#39;, &#39;utf-8&#39;)     # 邮件上显示的发件人    msg[&#39;From&#39;] &#x3D; formataddr([&quot;武沛齐&quot;, &quot;wptawy@126.com&quot;])    # 邮件上显示的主题    msg[&#39;Subject&#39;] &#x3D; &quot;邮件主题&quot;    # ### 2.发送邮件 ###     server &#x3D; smtplib.SMTP_SSL(&quot;smtp.126.com&quot;)    server.login(&quot;wptawy@126.com&quot;, &quot;WIYSAILOVUKPQGHY&quot;)    server.sendmail(&quot;wptawy@126.com&quot;, &quot;424662509@qq.com&quot;, msg.as_string())    server.quit()def send_email3():    # ### 1.邮件内容配置 ###    # 邮件文本    msg &#x3D; MIMEText(&quot;你好&quot;, &#39;html&#39;, &#39;utf-8&#39;)     # 邮件上显示的发件人    msg[&#39;From&#39;] &#x3D; formataddr([&quot;武沛齐&quot;, &quot;wptawy@126.com&quot;])    # 邮件上显示的主题    msg[&#39;Subject&#39;] &#x3D; &quot;邮件主题&quot;    # ### 2.发送邮件 ###     server &#x3D; smtplib.SMTP_SSL(&quot;smtp.126.com&quot;)    server.login(&quot;wptawy@126.com&quot;, &quot;WIYSAILOVUKPQGHY&quot;)    server.sendmail(&quot;wptawy@126.com&quot;, &quot;wupeiqi@live.com&quot;, msg.as_string())    server.quit()    send_email1()send_email2()send_email3()</code></pre></li><li><p>思路2，基于函数的参数（将代码中动态部分提取到参数位置，让函数可以充分被重用）</p><pre class="language-python" data-language="python"><code class="language-python">def send_email(email):    # ### 1.邮件内容配置 ###    # 邮件文本    msg &#x3D; MIMEText(&quot;你好&quot;, &#39;html&#39;, &#39;utf-8&#39;)     # 邮件上显示的发件人    msg[&#39;From&#39;] &#x3D; formataddr([&quot;武沛齐&quot;, &quot;wptawy@126.com&quot;])    # 邮件上显示的主题    msg[&#39;Subject&#39;] &#x3D; &quot;邮件主题&quot;    # ### 2.发送邮件 ###     server &#x3D; smtplib.SMTP_SSL(&quot;smtp.126.com&quot;)    server.login(&quot;wptawy@126.com&quot;, &quot;WIYSAILOVUKPQGHY&quot;)    server.sendmail(&quot;wptawy@126.com&quot;, email, msg.as_string())    server.quit()    v1 &#x3D; &quot;424662508@qq.com&quot;send_email(v1)v2 &#x3D; &quot;424662509@qq.com&quot;send_email(v2)v3 &#x3D; &quot;wupeiqi@live.com&quot;send_email(v3)</code></pre></li></ul><h4 id="2-1-参数"><a href="#2-1-参数" class="headerlink" title="2.1 参数"></a>2.1 参数</h4><p>​在定义函数时，如果在括号中添加<code>变量</code>，我们称它为函数的<strong>形式参数</strong>：</p><pre class="language-python" data-language="python"><code class="language-python"># ###### 定义有三个参数的函数（a1&#x2F;a2&#x2F;a3一般称为形式参数-形参） #####def func(a1,a2,a3):    print(a1+a2+a3)# 执行函数并传入参数（执行函数传值时一般称为实际参数-实参）func(11,22,33)# 执行函数并传入参数func(9,2,103)</code></pre><ul><li><p>位置传参</p><pre class="language-python" data-language="python"><code class="language-python">def add(n1,n2):    print(n1+n2)    add(1,22)</code></pre></li><li><p>关键字传参</p><pre class="language-python" data-language="python"><code class="language-python">def add(n1,n2):    print(n1+n2)    add(n1&#x3D;1,n2&#x3D;22)</code></pre></li></ul><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;1. 形参2. 实参3. 位置传参4. 关键字传参&quot;&quot;&quot;# ###### 定义有三个参数的函数（a1&#x2F;a2&#x2F;a3一般称为形式参数-形参） #####def func(a1, a2, a3):    print(a1 + a2 + a3)# 执行函数并传入参数（执行函数传值时一般称为实际参数-实参）func(11, 22, 33)# 执行函数并传入参数func(9, 2, 103)# 执行函数func(a1&#x3D;99, a3&#x3D;1, a2&#x3D;88)</code></pre><p>​<font color="#dd0000"><strong>注意事项：当位置传参和关键词传参混合时，位置传参必须在关键字传参前面</strong></font></p><h4 id="2-2-默认参数"><a href="#2-2-默认参数" class="headerlink" title="2.2 默认参数"></a>2.2 默认参数</h4><pre class="language-python" data-language="python"><code class="language-python">def func(a1, a2, a3&#x3D;10):    print(a1 + a2 + a3)# 位置传参func(8, 19)func(1, 2, 99)# 关键字传参func(12, 9, a3&#x3D;90)func(12, a2&#x3D;9, a3&#x3D;90)func(a1&#x3D;12, a2&#x3D;9, a3&#x3D;90)</code></pre><pre class="language-python" data-language="python"><code class="language-python">file_object &#x3D; open(&quot;xxx.txt&quot;)</code></pre><h4 id="2-3-动态参数"><a href="#2-3-动态参数" class="headerlink" title="2.3 动态参数"></a>2.3 动态参数</h4><ul><li><p><code>*args</code></p><pre class="language-python" data-language="python"><code class="language-python">def func(*args):    print(args) # 元组类型 (22,)   (22,33,99,)  ()# 只能按照位置传参func(22)func(22,33)func(22,33,99)func()</code></pre></li><li><p><code>**kwargs</code></p><pre class="language-python" data-language="python"><code class="language-python">def func(**kwargs):    print(kwargs) # 字典类型 &#123;&quot;n1&quot;:&quot;武沛齐&quot;&#125;    &#123;&quot;n1&quot;:&quot;武沛齐&quot;,&quot;age&quot;:&quot;18&quot;,&quot;email&quot;:&quot;xxxx&quot;&#125;  &#123;&#125;    # 只能按关键字传参func(n1&#x3D;&quot;武沛齐&quot;)func(n1&#x3D;&quot;武沛齐&quot;,age&#x3D;18)func(n1&#x3D;&quot;武沛齐&quot;,age&#x3D;18,email&#x3D;&quot;xx@live.com&quot;)</code></pre></li><li><p><code>*args</code>,<code>**kwargs</code></p><pre class="language-python" data-language="python"><code class="language-python">def func(*args,**kwargs):    print(args,kwargs) func(22,33,99)  # args:(22,33,99) kwargs:&#123;&#125;func(n1&#x3D;&quot;武沛齐&quot;,age&#x3D;18)  # args:() kwargs:&#123;&#39;n1&#39;: &#39;武沛齐&#39;, &#39;age&#39;: &#39;18&#39;&#125;func(22,33,99,n1&#x3D;&quot;武沛齐&quot;,age&#x3D;18)  # args:(22,33,99) kwargs:&#123;&#39;n1&#39;: &#39;武沛齐&#39;, &#39;age&#39;: &#39;18&#39;&#125;func()  # args:() kwargs:&#123;&#125;</code></pre><p>提示：是否还记得字符串格式化时的format功能。</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;我叫&#123;&#125;,今年&#123;&#125;,性别&#123;&#125;&quot;.format(&quot;武沛齐&quot;,18,&quot;男&quot;)v2 &#x3D; &quot;我叫&#123;name&#125;,今年&#123;age&#125;,性别&#123;gender&#125;&quot;.format(name&#x3D;&quot;武沛齐&quot;,age&#x3D;18,gender&#x3D;&quot;男&quot;)</code></pre></li></ul><p>注意事项（不重要，听过一遍即可）</p><pre class="language-python" data-language="python"><code class="language-python"># 1. ** 必须放在 * 的后面def func1(*args, **kwargs):    print(args, **kwargs)# 2. 参数和动态参数混合时，动态参数只能放在最后。def func2(a1, a2, a3, *args, **kwargs):    print(a1, a2, a3, args, **kwargs)# 3. 默认值参数和动态参数同时存在def func3(a1, a2, a3, a4&#x3D;10, *args, a5&#x3D;20, **kwargs):    print(a1, a2, a3, a4, a5, args, kwargs)func3(11, 22, 33, 44, 55, 66, 77, a5&#x3D;10, a10&#x3D;123)</code></pre><h3 id="3-函数返回值"><a href="#3-函数返回值" class="headerlink" title="3. 函数返回值"></a>3. 函数返回值</h3><p>​在开发过程中，我们希望函数可以帮助我们实现某个功能，但让函数实现某功能之后有时也需要有一些结果需要反馈给我们，例如：</p><pre class="language-python" data-language="python"><code class="language-python">import requestsfrom xml.etree import ElementTree as ETdef xml_to_list(city):    data_list &#x3D; []    url &#x3D; &quot;http:&#x2F;&#x2F;ws.webxml.com.cn&#x2F;&#x2F;WebServices&#x2F;WeatherWebService.asmx&#x2F;getWeatherbyCityName?theCityName&#x3D;&#123;&#125;&quot;.format(city)    res &#x3D; requests.get(url&#x3D;url)    root &#x3D; ET.XML(res.text)    for node in root:        data_list.append(node.text)    return data_listresult &#x3D; xml_to_list(&quot;北京&quot;)print(result)</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func():    return 666res &#x3D; func()print(res) # 666</code></pre><pre class="language-python" data-language="python"><code class="language-python">def magic(num):    result &#x3D; num + 1000    return resultdata &#x3D; magic(9)print(data) # 1009</code></pre><p>在了解了返回值的基本使用之后，接下来在学3个关键知识：</p><ul><li><p>返回值可以是任意类型，如果函数中没写return，则默认返回None</p><pre class="language-python" data-language="python"><code class="language-python">def func():    return [1,True,(11,22,33)]result &#x3D; func()print(result)</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func():    value &#x3D; 1 + 1    ret &#x3D; func()print(ret) # None</code></pre><p>当在函数中<code>未写返回值</code> 或 <code>return</code> 或 <code>return None</code> ，执行函数获取的返回值都是None。</p><pre class="language-python" data-language="python"><code class="language-python">def func():    value &#x3D; 1 + 1    return  # 或 return Noneret &#x3D; func()print(ret) # None</code></pre></li><li><p>return后面的值如果有逗号，则默认会将返回值转换成元组再返回。</p><pre class="language-python" data-language="python"><code class="language-python">def func():    return 1,2,3value &#x3D; func()print(value) # (1,2,3)</code></pre></li><li><p>函数一旦遇到return就会立即退出函数（终止函数中的所有代码）</p><pre class="language-python" data-language="python"><code class="language-python">def func():    print(1)    return &quot;结束吧&quot;print(2)    ret &#x3D; func()print(ret)</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func():    print(1)    for i in range(10):        print(i)        return 999print(2)    result &#x3D; func()print(result)# 输出10999</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func():    print(1)    for i in range(10):        print(i)        for j in range(100):            print(j)        returnprint(2)    result &#x3D; func()print(result)# 输出100None</code></pre></li></ul><p>小结：</p><ul><li><p>完成某个结果并希望的到结果。</p><pre class="language-python" data-language="python"><code class="language-python">def send_email():    ...    return Truev1 &#x3D; send_email()</code></pre><pre class="language-python" data-language="python"><code class="language-python">def encrypt(old):    ...    return &quot;密文...&quot;data &#x3D; encrypt(&quot;武沛齐&quot;)print(data)</code></pre></li><li><p>基于return控制让函数终止执行</p><pre class="language-python" data-language="python"><code class="language-python">def foo():    while True:        num &#x3D; input(&quot;请输入数字（Q）：&quot;)        if num.upper() &#x3D;&#x3D; &quot;Q&quot;:            return        num &#x3D; int(num)        if num &#x3D;&#x3D; 99:            print(&quot;猜对了&quot;)else:            print(&quot;猜错了，请继续！&quot;)print(&quot;....&quot;)foo()</code></pre></li></ul><p><font color="#dd0000">注意事项：此处用return和break的区别。</font></p><ul><li><font color="#dd0000">return:结束掉函数，后面print()的内容也不会执行</font></li><li><font color="#dd0000">break:结束循环，后面print()的内容会执行</font></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li><p>如何定义一个函数？</p></li><li><p>函数名的规范。（同变量名规范）</p><ul><li><p>规范</p></li><li><p>建议</p><pre class="language-python" data-language="python"><code class="language-python">def change_num():    pass</code></pre></li></ul></li><li><p>函数的注释，说明函数的作用。</p><pre class="language-python" data-language="python"><code class="language-python">def encrypt(origin):    &quot;&quot;&quot; 用于数据加密和xxx &quot;&quot;&quot;pass</code></pre></li><li><p>定义函数时，参数一般有以下情况（形式参数）</p><ul><li><p>情景1</p><pre class="language-python" data-language="python"><code class="language-python">def func(a1,a2):    pass</code></pre></li><li><p>情景2：</p><pre class="language-python" data-language="python"><code class="language-python">def func(a1,a2&#x3D;123):    pass</code></pre></li><li><p>情景2：</p><pre class="language-python" data-language="python"><code class="language-python">def func(*args,**kwargs):    pass</code></pre></li></ul></li><li><p>函数的返回值，一般用于将函数执行的返回给调用者。</p><ul><li>默认返回None</li><li>遇到return则函数执行完毕</li></ul></li></ol><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol><li><p>请定义一个函数，用于计算一个字符串中字符<code>a</code>出现的次数并通过return返回。</p><ul><li>参数，字符串。</li><li>返回值，字符串中 a 出现的次数。</li></ul><pre class="language-python" data-language="python"><code class="language-python">def count_a(input_str):    &#39;&#39;&#39;    input_str:输入的字符串    :return:统计字符串中出现多少个a    &#39;&#39;&#39;    count &#x3D; 0    for item in input_str:        if item &#x3D;&#x3D; &#39;a&#39;:            count +&#x3D; 1    return countresult &#x3D; count_a(&#39;asasasaasdsdfsd&#39;)print(result)  # 5</code></pre></li><li><p>写函数，判断用户传入的一个值（字符串或列表或元组任意）长度是否大于5，并返回真假。</p><pre class="language-python" data-language="python"><code class="language-python">def if_true(user_input):    &#39;&#39;&#39;    :param user_input:    :return: 判断用户传入的一个值（字符串或列表或元组任意）长度是否大于5，并返回真假。    &#39;&#39;&#39;    return len(user_input) &gt; 5result1 &#x3D; if_true(&#39;asasasaasdsdfsd&#39;)result2 &#x3D; if_true([1, &#39;3&#39;, True])result3 &#x3D; if_true(([1, &#39;2&#39;], 3, False, &#123;&#125;, &#39;0000&#39;, &#39;sasasasasas&#39;))print(result1)  # Trueprint(result2)  # Falseprint(result3)  # True</code></pre></li><li><p>写函数，接收两个数字参数，返回比较大的那个数字（等于时返回两个中的任意一个都可以）。</p><pre class="language-python" data-language="python"><code class="language-python">def bigger(num1, num2):    &#39;&#39;&#39;    比较两个数大小    :param num1:    :param num2:    :return: 返回比较大的那个数字（等于时返回两个中的任意一个都可以）。    &#39;&#39;&#39;    if num1 &gt;&#x3D; num2:        return num1    return num2result &#x3D; bigger(2, 5)print(result)  # 5</code></pre></li><li><p>写函数，函数接收四个参数分别是：姓名，性别，年龄，学历，然后将这四个值通过”*”拼接起来并追加到一个student_msg.txt文件中。</p><pre class="language-python" data-language="python"><code class="language-python">import osdef save_msg(name, gender, age, education):    # 处理文件路径    base_dir &#x3D; os.path.dirname(os.path.abspath(__file__))    # print(base_dir)    target_path &#x3D; os.path.join(base_dir, &#39;files&#39;)    if not os.path.exists(target_path):        os.makedirs(target_path)    # 写入文件    file_name &#x3D; os.path.join(target_path, &#39;student_msg.txt&#39;)    with open(file_name, mode&#x3D;&#39;wt&#39;, encoding&#x3D;&#39;utf-8&#39;) as write_object:        msg &#x3D; &#39;*&#39;.join([name, gender, age, education])        write_object.write(msg)    return msgresult &#x3D; save_msg(&#39;耿天霸&#39;, &#39;男&#39;, &#39;24&#39;, &#39;硕士&#39;)print(result)</code></pre></li><li><p>补充代码，实现如下功能：</p><ul><li>【位置1】读取文件中的每一行数据，将包含特定关键的数据筛选出来，并以列表的形式返回。</li><li>【位置1】文件不存在，则返回None</li><li>【位置2】文件不存在，输出 “文件不存在”，否则循环输出匹配成功的每一行数据。</li></ul><pre class="language-python" data-language="python"><code class="language-python">def select_content(file_path,key):    # 补充代码【位置1】result &#x3D; select_content(&quot;files&#x2F;xxx.txt&quot;,&quot;股票&quot;)# 补充代码【位置2】</code></pre><pre class="language-python" data-language="python"><code class="language-python">import os&#39;&#39;&#39;本文件实现功能为，将包含特定关键的数据筛选出来，并以列表的形式返回&#39;&#39;&#39;def select_content(file_path, key):    # 文件不存在，则返回None    if not os.path.exists(file_path):        return    target_text &#x3D; []    # 读取文件中的每一行数据，将包含特定关键的数据筛选出来，并以列表的形式返回。    with open(file_path, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as read_object:        for line in read_object:            if key in line.strip():                target_text.append(line.strip())    return target_textresult &#x3D; select_content(&quot;files&#x2F;股票.txt&quot;, &quot;股票&quot;)if result:    print(result)else:    print(&#39;文件不存在&#39;)    </code></pre><p><font color="#dd0000"><strong>存在问题：</strong></font></p><pre class="language-none"><code class="language-none">if result:    print(result)else:    print(&#39;文件不存在&#39;)    当文件不存在是返回None，输出不存在；当文件中没有关键词时返回[]，还是输出不存在。</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 只有返回None才代表文件不存在，空列表[]就返回空列表[]if result &#x3D;&#x3D; None:      print(&#39;文件不存在&#39;)else:    print(result)    </code></pre></li><li><p>补充代码，实现敏感词替换的功能。</p><pre class="language-python" data-language="python"><code class="language-python">def change_string(origin):    # 补充代码，将字符串origin中中的敏感词替换为 **，最后将替换好的值返回。     data_list &#x3D; [&quot;苍老师&quot;,&quot;波多老师&quot;,&quot;大桥&quot;]    text &#x3D; input(&quot;请输入内容：&quot;)result &#x3D; change_string(text)print(result)</code></pre><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能为，实现敏感词替换&#39;&#39;&#39;def change_string(origin):    # 补充代码，将字符串origin中中的敏感词替换为 **，最后将替换好的值返回。    data_list &#x3D; [&quot;苍老师&quot;, &quot;波多老师&quot;, &quot;大桥&quot;]    for sen_word in data_list:        origin &#x3D; origin.replace(sen_word, &#39;**&#39;)    return origintext &#x3D; input(&quot;请输入内容：&quot;)result &#x3D; change_string(text)print(result)</code></pre></li><li><p>基于函数实现用户认证，要求：</p><ul><li><p>写函数，读取的用户信息并构造为字典（用户信息存放在<code>files/user.xlsx</code>文件中）</p><img src="asserts/image-20201220144654241-16538949131554.png" alt="image-20201220144654241" style="zoom:50%;" /><pre class="language-python" data-language="python"><code class="language-python"># 构造的字典格式如下user_dict &#x3D; &#123;    &quot;用户名&quot;:&quot;密码&quot;    ...&#125;</code></pre></li><li><p>用户输入用户名和密码，进行校验。（且密码都是密文，所以，需要将用户输入的密码进行加密，然后再与Excel中的密文密码进行比较）</p><pre class="language-python" data-language="python"><code class="language-python">import hashlibdef encrypt(origin):    origin_bytes &#x3D; origin.encode(&#39;utf-8&#39;)    md5_object &#x3D; hashlib.md5()    md5_object.update(origin_bytes)    return md5_object.hexdigest()p1 &#x3D; encrypt(&#39;admin&#39;)print(p1) # &quot;21232f297a57a5a743894a0e4a801fc3&quot;p2 &#x3D; encrypt(&#39;123123&#39;)print(p2) # &quot;4297f44b13955235245b2497399d7a93&quot;p3 &#x3D; encrypt(&#39;123456&#39;)print(p3) # &quot;e10adc3949ba59abbe56e057f20f883e&quot;</code></pre></li></ul></li></ol><p>扩展：密码都不是明文。</p><ul><li>注册京东，京东存储：用户名和密码（密文）</li><li>登录京东：用户名&amp; 密码。</li></ul><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能为，基于函数实现用户认证要求：- 写函数，读取的用户信息并构造为字典- 用户输入用户名和密码，进行校验。（且密码都是密文，所以，需要将用户输入的密码进行加密，然后再与Excel中的密文密码进行比较）&#39;&#39;&#39;import hashlibfrom openpyxl import load_workbook# 1.写函数，读取的用户信息并构造为字典def xlsx_to_dic(filepath):    wb &#x3D; load_workbook(filepath)    # print(wb.sheetnames)    sheet &#x3D; wb.worksheets[0]    user_dic &#x3D; &#123;        # &#39;wupeiqi&#39;: &#39;xxxxxxxxxxxxx&#39;    &#125;    count &#x3D; 0    for row in sheet.rows:        user_id, user_name, user_psd &#x3D; row        if count !&#x3D; 0:            user_dic[user_name.value] &#x3D; user_psd.value        count +&#x3D; 1    return user_dicdef encrypt(origin):    origin_bytes &#x3D; origin.encode(&#39;utf-8&#39;)    md5_object &#x3D; hashlib.md5()    md5_object.update(origin_bytes)    return md5_object.hexdigest()user_dic &#x3D; xlsx_to_dic(&#39;files&#x2F;user.xlsx&#39;)# 输入用户名和密码login_name &#x3D; input(&#39;please input your name: &#39;)login_psd &#x3D; input(&#39;please input your password: &#39;)# 比对密码psd_encrypt &#x3D; encrypt(login_psd)psd_true &#x3D; user_dic.get(login_name)if psd_encrypt &#x3D;&#x3D; psd_true:    print(&#39;登录成功&#39;)else:    print(&#39;登录失败&#39;)</code></pre><h2 id="十二、-函数进阶"><a href="#十二、-函数进阶" class="headerlink" title="十二、 函数进阶"></a>十二、 函数进阶</h2><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201222145103056.png" class="" title="image-20201222145103056"><p>目标：掌握函数相关易错点 &amp; 项目开发必备技能。</p><p>今日概要：</p><ul><li>参数的补充</li><li>函数名，函数名到底是什么？</li><li>返回值和print，傻傻分不清楚。</li><li>函数的作用域</li></ul><h3 id="1-参数的补充"><a href="#1-参数的补充" class="headerlink" title="1.参数的补充"></a>1.参数的补充</h3><p>​在函数基础部分，我们掌握函数和参数基础知识，掌握这些其实完全就可以进行项目的开发。</p><p>今天的补充的内容属于进阶知识，包含：<font color="#dd0000"><strong>内存地址相关、面试题相关等，在特定情况下也可以让代码更加简洁，提升开发效率。</strong></font></p><h4 id="1-1-【面试题】-参数内存地址相关"><a href="#1-1-【面试题】-参数内存地址相关" class="headerlink" title="1.1 【面试题】:参数内存地址相关"></a>1.1 <font color="#dd0000"><strong>【面试题】:参数内存地址相关</strong></font></h4><p>​在开始讲参数内存地址相关之前，我们先来学习一个技能：如果想要查看下某个值的在内存中的地址？</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;武沛齐&quot;addr &#x3D; id(v1)print(addr) # 140691049514160</code></pre><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; [11,22,33]v2 &#x3D; [11,22,33]print( id(v1) )print( id(v2) )</code></pre><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; [11,22,33]v2 &#x3D; v1print( id(v1) )print( id(v2) )</code></pre><p><font color="#dd0000"><strong>记住一句话：函数执行传参时，传递的是内存地址。</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">def func(data):    print(data, id(data))  # 武沛齐  140247057684592v1 &#x3D; &quot;武沛齐&quot;print(id(v1))  # 140247057684592func(v1)</code></pre><p><font color="#dd0000"><strong>面试题：请问Python的参数默认传递的是什么？</strong></font></p><p>Python参数的这一特性有两个好处：</p><ul><li><p>节省内存</p></li><li><p>对于可变类型且函数中修改元素的内容，所有的地方都会修改。可变类型：列表、字典、集合。</p><pre class="language-python" data-language="python"><code class="language-python"># 可变类型 &amp; 修改内部修改def func(data):    data.append(999)    v1 &#x3D; [11,22,33]func(v1)print(v1) # [11,22,33,666]</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 特殊情况：可变类型 &amp; 重新赋值def func(data):    data &#x3D; [&quot;武沛齐&quot;,&quot;alex&quot;]    v1 &#x3D; [11,22,33]func(v1)print(v1) # [11,22,33]</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 特殊情况：不可变类型，无法修改内部元素，只能重新赋值。def func(data):data &#x3D; &quot;alex&quot;    v1 &#x3D; &quot;武沛齐&quot;func(v1)</code></pre></li></ul><p>​其他很多编程语言执行函数时，<strong>默认传参时会将数据重新拷贝一份，会浪费内存</strong>。提示注意：其他语言也可以通过 ref 等关键字来实现传递内存地址。</p><p>​当然，如果你不想让外部的变量和函数内部参数的变量一致，也可以选择将外部值拷贝一份，再传给函数。</p><pre class="language-python" data-language="python"><code class="language-python">import copy# 可变类型 &amp; 修改内部修改def func(data):    data.append(999)v1 &#x3D; [11, 22, 33]new_v1 &#x3D; copy.deepcopy(v1) # 拷贝一份数据func(new_v1)print(v1)  # [11,22,33]</code></pre><h4 id="1-2-函数的返回值是内存地址"><a href="#1-2-函数的返回值是内存地址" class="headerlink" title="1.2 函数的返回值是内存地址"></a>1.2 函数的返回值是<font color="#dd0000"><strong>内存地址</strong></font></h4><pre class="language-python" data-language="python"><code class="language-python">def func():    data &#x3D; [11, 22, 33]    return datav1 &#x3D; func()print(v1) # [11,22,33]</code></pre><p>上述代码的执行过程：</p><ul><li>执行func函数</li><li><code>data = [11, 22, 33]</code> 创建一块内存区域，内部存储<code>[11,22,33]</code>，data变量指向这块内存地址。</li><li><code>return data</code> 返回data指向的内存地址</li><li>v1接收返回值，所以 v1 和 data 都指向  <code>[11,22,33]</code> 的内存地址（两个变量指向此内存，引用计数器为2）</li><li>由函数执行完毕之后，函数内部的变量都会被释放。（即：删除data变量，内存地址的引用计数器-1）</li></ul><p>所以，最终v1指向的函数内部创建的那块内存地址。</p><pre class="language-python" data-language="python"><code class="language-python">def func():    data &#x3D; [11, 22, 33]    return datav1 &#x3D; func()print(v1) # [11,22,33]v2 &#x3D; func()print(v2) # [11,22,33]</code></pre><p>上述代码的执行过程：</p><ul><li>执行func函数</li><li><code>data = [11, 22, 33]</code> 创建一块内存区域，内部存储<code>[11,22,33]</code>，data变量指向这块内存地址  1000001110。</li><li><code>return data</code> 返回data指向的内存地址</li><li>v1接收返回值，所以 v1 和 data 都指向  <code>[11,22,33]</code> 的内存地址（两个变量指向此内存，引用计数器为2）</li><li>由函数执行完毕之后，函数内部的变量都会被释放。（即：删除data变量，内存地址的引用计数器-1）</li></ul><p>所以，最终v1指向的函数内部创建的那块内存地址。(v1指向的1000001110内存地址)</p><ul><li>执行func函数</li><li><code>data = [11, 22, 33]</code> 创建一块内存区域，内部存储<code>[11,22,33]</code>，data变量指向这块内存地址  11111001110（一块新地址）。</li><li><code>return data</code> 返回data指向的内存地址</li><li>v2接收返回值，所以 v2 和 data 都指向  <code>[11,22,33]</code> 的内存地址（两个变量指向此内存，引用计数器为2）</li><li>由函数执行完毕之后，函数内部的变量都会被释放。（即：删除data变量，内存地址的引用计数器-1）</li></ul><p>所以，最终v2指向的函数内部创建的那块内存地址。(v2指向的11111001110内存地址)</p><pre class="language-python" data-language="python"><code class="language-python">def func():    data &#x3D; [11, 22, 33]    print(id(data))  # 第一次打印 2027873865280                     # 第二次打印 2027827944512    return datav1 &#x3D; func()print(v1, id(v1))  # [11, 22, 33] 2027873865280v2 &#x3D; func()print(v2, id(v2))  # [11, 22, 33] 2027827944512</code></pre><p><font color="#dd0000"><strong>注意事项：字符串和数字在运行上述代码时两次内存地址相同，这是因为Python内部的缓存和驻留机制。</strong></font></p><h4 id="1-3-参数的默认值【面试题】"><a href="#1-3-参数的默认值【面试题】" class="headerlink" title="1.3 参数的默认值【面试题】"></a>1.3 参数的默认值<font color="#dd0000"><strong>【面试题】</strong></font></h4><p>这个知识点在面试题中出现的概率比较高，但真正实际开发中用的比较少。</p><pre class="language-python" data-language="python"><code class="language-python">def func(a1,a2&#x3D;18):    print(a1,a2)</code></pre><blockquote><p> 原理：Python在创建函数（未执行）时，如果发现函数的参数中有默认值，则在函数内部会创建一块区域并维护这个默认值。</p><ul><li>执行函数未传值时，则让a2指向 函数维护的那个值的地址。</li></ul>  <pre class="language-python" data-language="python"><code class="language-python">func(&quot;root&quot;)</code></pre><ul><li>执行函数传值时，则让a2指向新传入的值的地址。</li></ul>  <pre class="language-python" data-language="python"><code class="language-python">func(&quot;admin&quot;,20)</code></pre></blockquote><p>在特定情况<span style="color:red;">【默认参数的值是可变类型 list&#x2F;dict&#x2F;set】 &amp; 【函数内部会修改这个值】</span>下，参数的默认值 有坑 。</p><ul><li><p><font color="#dd0000"><strong>坑</strong></font></p><pre class="language-python" data-language="python"><code class="language-python"># 在函数内部内存中会维护一块区域存储 [1,2,666,666,666] 100010001def func(a1,a2&#x3D;[1,2]):    a2.append(666)    print(a1,a2)# a1&#x3D;100# a2 -&gt; 100010001func(100) # 100  [1,2,666]# a1&#x3D;200# a2 -&gt; 100010001func(200) # 200 [1,2,666,666]# a1&#x3D;99# a2 -&gt; 1111111101func(99,[77,88]) # 66 [77,88,666]# a1&#x3D;300# a2 -&gt; 100010001func(300) # 300 [1,2,666,666,666] </code></pre></li><li><p><font color="#dd0000"><strong>大坑</strong></font></p><pre class="language-python" data-language="python"><code class="language-python"># 在函数内部内存会维护一块区域存储 [1, 2, 10, 20,40 ] ,内存地址 1010101010def func(a1, a2&#x3D;[1, 2]):    a2.append(a1)    return a2# a1&#x3D;10# a2 -&gt; 1010101010# v1 -&gt; 1010101010v1 &#x3D; func(10)print(v1) # [1, 2, 10]# a1&#x3D;20# a2 -&gt; 1010101010# v2 -&gt; 1010101010v2 &#x3D; func(20)print(v2) # [1, 2, 10, 20 ]# a1&#x3D;30# a2 -&gt; 11111111111        [11, 22,30]# v3 -&gt; 11111111111v3 &#x3D; func(30, [11, 22])print(v3) #  [11, 22,30]# a1&#x3D;40# a2 -&gt; 1010101010# v4 -&gt; 1010101010v4 &#x3D; func(40)print(v4) # [1, 2, 10, 20,40 ] </code></pre></li><li><p><font color="#dd0000"><strong>深坑</strong></font></p><pre class="language-python" data-language="python"><code class="language-python"># 内存中创建空间存储 [1, 2, 10, 20, 40] 地址：1010101010def func(a1, a2&#x3D;[1, 2]):    a2.append(a1)    return a2# a1&#x3D;10# a2 -&gt; 1010101010# v1 -&gt; 1010101010v1 &#x3D; func(10)# a1&#x3D;20# a2 -&gt; 1010101010# v2 -&gt; 1010101010v2 &#x3D; func(20)# a1&#x3D;30# a2 -&gt; 11111111111   [11,22,30]# v3 -&gt; 11111111111v3 &#x3D; func(30, [11, 22])# a1&#x3D;40# a2 -&gt; 1010101010# v4 -&gt; 1010101010v4 &#x3D; func(40)print(v1) # [1, 2, 10, 20, 40]print(v2) # [1, 2, 10, 20, 40]print(v3) # [11,22,30]print(v4) # [1, 2, 10, 20, 40] </code></pre></li></ul><h4 id="1-4-动态参数"><a href="#1-4-动态参数" class="headerlink" title="1.4 动态参数"></a>1.4 动态参数</h4><p>动态参数，定义函数时在形参位置用 <code>*或**</code> 可以接任意个参数。</p><pre class="language-python" data-language="python"><code class="language-python">def func(*args,**kwargs):    print(args,kwargs)    func(&quot;宝强&quot;,&quot;杰伦&quot;,n1&#x3D;&quot;alex&quot;,n2&#x3D;&quot;eric&quot;)</code></pre><p>在定义函数时可以用 <code>*和**</code>，其实在执行函数时，也可以用。</p><ul><li><p>形参固定，实参用<code>*和**</code></p><pre class="language-python" data-language="python"><code class="language-python">def func(a1,a2):    print(a1,a2)    func( 11, 22 )func( a1&#x3D;1, a2&#x3D;2 )func( *[11,22] )func( **&#123;&quot;a1&quot;:11,&quot;a2&quot;:22&#125; )</code></pre></li><li><p>形参用<code>*和**</code>，实参也用 <code>*和**</code></p><pre class="language-python" data-language="python"><code class="language-python">def func(*args,**kwargs):    print(args,kwargs)    func( 11, 22 )func( 11, 22, name&#x3D;&quot;武沛齐&quot;, age&#x3D;18 )# 小坑，([11,22,33], &#123;&quot;k1&quot;:1,&quot;k2&quot;:2&#125;), &#123;&#125;func( [11,22,33], &#123;&quot;k1&quot;:1,&quot;k2&quot;:2&#125; )# args&#x3D;(11,22,33),kwargs&#x3D;&#123;&quot;k1&quot;:1,&quot;k2&quot;:2&#125;func( *[11,22,33], **&#123;&quot;k1&quot;:1,&quot;k2&quot;:2&#125; ) # 值得注意：按照这个方式将数据传递给args和kwargs时，数据是会重新拷贝一份的（可理解为内部循环每个元素并设置到args和kwargs中）。</code></pre></li></ul><p>所以，在使用format字符串格式化时，可以可以这样：</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;我是&#123;&#125;,年龄：&#123;&#125;。&quot;.format(&quot;武沛齐&quot;,18)v2 &#x3D; &quot;我是&#123;name&#125;,年龄：&#123;age&#125;。&quot;.format(name&#x3D;&quot;武沛齐&quot;,age&#x3D;18)v3 &#x3D; &quot;我是&#123;&#125;,年龄：&#123;&#125;。&quot;.format(*[&quot;武沛齐&quot;,18])v4 &#x3D; &quot;我是&#123;name&#125;,年龄：&#123;age&#125;。&quot;.format(**&#123;&quot;name&quot;:&quot;武沛齐&quot;,&quot;age&quot;:18&#125;)</code></pre><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><ol><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(*args,**kwargs):    print(args,kwargs)    params &#x3D; &#123;&quot;k1&quot;:&quot;v2&quot;,&quot;k2&quot;:&quot;v2&quot;&#125;func(params)    # (&#123;&quot;k1&quot;:&quot;v2&quot;,&quot;k2&quot;:&quot;v2&quot;&#125;, ) &#123;&#125;func(**params)  # (), &#123;&quot;k1&quot;:&quot;v2&quot;,&quot;k2&quot;:&quot;v2&quot;&#125;</code></pre></li><li><p>读取文件中的 URL 和 标题，根据URL下载视频到本地（以标题作为文件名）。</p><pre class="language-csv" data-language="csv"><code class="language-csv">模仿,https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300f570000bvbmace0gvch7lo53oog&amp;ratio&#x3D;720p&amp;line&#x3D;0卡特,https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f3e0000bv52fpn5t6p007e34q1g&amp;ratio&#x3D;720p&amp;line&#x3D;0罗斯,https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&amp;ratio&#x3D;720p&amp;line&#x3D;0</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 下载视频示例import requestsres &#x3D; requests.get(    url&#x3D;&quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&amp;ratio&#x3D;720p&amp;line&#x3D;0&quot;,    headers&#x3D;&#123;        &quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 FS&quot;    &#125;)with open(&#39;rose.mp4&#39;, mode&#x3D;&#39;wb&#39;) as f:    f.write(res.content)</code></pre><pre class="language-python" data-language="python"><code class="language-python">import requestsdef download_move(title, url):    &#39;&#39;&#39;    根据url下载视频，并将文件名保存为title.mp4    :param title:    :param url:    :return:    &#39;&#39;&#39;    res &#x3D; requests.get(        url&#x3D;url,        headers&#x3D;&#123;            &quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 FS&quot;        &#125;    )    with open(&#39;files&#x2F;&#123;&#125;.mp4&#39;.format(title), mode&#x3D;&#39;wb&#39;) as f:        f.write(res.content)# 打开文件with open(&#39;files&#x2F;视频.csv&#39;, mode&#x3D;&#39;rt&#39;, encoding&#x3D;&#39;utf-8&#39;) as file_object:    for line in file_object:        line &#x3D; line.strip()        data_list &#x3D; line.split(&#39;,&#39;)  # [&#39;模仿&#39;, &#39;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300f570000bvbmace0gvch7lo53oog&amp;ratio&#x3D;720p&amp;line&#x3D;0&#39;]        # 使用*传参        download_move(*data_list)</code></pre></li></ol><h3 id="2-函数和函数名"><a href="#2-函数和函数名" class="headerlink" title="2. 函数和函数名"></a>2. 函数和函数名</h3><p>​函数名其实就是一个<strong>变量</strong>，这个变量只不过代指的函数而已。</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">def add(n1,n2):    return n1 + n2</code></pre><p>注意：函数必须先定义才能被调用执行（解释型语言）。</p><pre class="language-python" data-language="python"><code class="language-python"># 正确def add(n1,n2):    return n1 + n2ret &#x3D; add(1,2)print(ret) </code></pre><pre class="language-python" data-language="python"><code class="language-python"># 错误ret &#x3D; add(1,2)print(ret) def add(n1,n2):    return n1 + n2</code></pre><h4 id="2-1-函数做元素"><a href="#2-1-函数做元素" class="headerlink" title="2.1 函数做元素"></a>2.1 函数做元素</h4><p>​既然函数就相当于是一个变量，那么在列表等元素中是否可以把函数当做元素呢？</p><pre class="language-python" data-language="python"><code class="language-python">def func():    return 123data_list &#x3D; [&quot;武沛齐&quot;, &quot;func&quot;, func , func() ]print( data_list[0] ) # 字符串&quot;武沛齐&quot;print( data_list[1] ) # 字符串 &quot;func&quot;print( data_list[2] ) # 函数 funcprint( data_list[3] ) # 整数 123res &#x3D; data_list[2]()print( res ) # 执行函数 func，并获取返回值；print再输出返回值。print( data_list[2]() ) # 123</code></pre><p>注意：函数同时也<font color="#dd0000"><strong>可被哈希</strong></font>，所以函数名同时也可以当做 集合的元素、字典的键。</p><p>掌握这个知识之后，对后续的项目开发有很大的帮助，例如，在项目中遇到根据选择做不同操作时：</p><ul><li><p>情景1，例如：要开发一个类似于微信的功能。</p><pre class="language-python" data-language="python"><code class="language-python">def send_message():    &quot;&quot;&quot;发送消息&quot;&quot;&quot;    passdef send_image():    &quot;&quot;&quot;发送图片&quot;&quot;&quot;    passdef send_emoji():    &quot;&quot;&quot;发送表情&quot;&quot;&quot;    passdef send_file():    &quot;&quot;&quot;发送文件&quot;&quot;&quot;    passprint(&quot;欢迎使用xx系统&quot;)print(&quot;请选择：1.发送消息；2.发送图片；3.发送表情；4.发送文件&quot;)choice &#x3D; input(&quot;输入选择的序号&quot;)if choice &#x3D;&#x3D; &quot;1&quot;:    send_message()elif choice &#x3D;&#x3D; &quot;2&quot;:    send_image()elif choice &#x3D;&#x3D; &quot;3&quot;:    send_emoji()elif choice &#x3D;&#x3D; &quot;4&quot;:    send_file()else:    print(&quot;输入错误&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">def send_message():    &quot;&quot;&quot;发送消息&quot;&quot;&quot;    passdef send_image():    &quot;&quot;&quot;发送图片&quot;&quot;&quot;    passdef send_emoji():    &quot;&quot;&quot;发送表情&quot;&quot;&quot;    passdef send_file():    &quot;&quot;&quot;发送文件&quot;&quot;&quot;    passdef xxx():    &quot;&quot;&quot;收藏&quot;&quot;&quot;    passfunction_dict &#x3D; &#123;    &quot;1&quot;: send_message,    &quot;2&quot;: send_image,    &quot;3&quot;: send_emoji,    &quot;4&quot;: send_file,    &quot;5&quot;: xxx&#125;print(&quot;欢迎使用xx系统&quot;)print(&quot;请选择：1.发送消息；2.发送图片；3.发送表情；4.发送文件&quot;)choice &#x3D; input(&quot;输入选择的序号&quot;) # &quot;1&quot;func &#x3D; function_dict.get(choice)if not func:    print(&quot;输入错误&quot;)else:    # 执行函数    func()</code></pre></li><li><p>情景2，例如：某个特定情况，要实现发送短信、微信、邮件。</p><pre class="language-python" data-language="python"><code class="language-python">def send_msg():    &quot;&quot;&quot;发送短信&quot;&quot;&quot;    passdef send_email():    &quot;&quot;&quot;发送图片&quot;&quot;&quot;    passdef send_wechat():    &quot;&quot;&quot;发送微信&quot;&quot;&quot;    # 执行函数send_msg()send_email()send_wechat()</code></pre><pre class="language-python" data-language="python"><code class="language-python">def send_msg():    &quot;&quot;&quot;发送短信&quot;&quot;&quot;    passdef send_email():    &quot;&quot;&quot;发送图片&quot;&quot;&quot;    passdef send_wechat():    &quot;&quot;&quot;发送微信&quot;&quot;&quot;    pass        func_list &#x3D; [ send_msg, send_email, send_wechat ]for item in func_list:    item()</code></pre></li></ul><p>​上述两种情景，在参数相同时才可用，如果参数不一致，会出错。所以，在项目设计时就要让程序满足这一点，如果无法满足，也可以通过其他手段时间，例如：</p><p>情景1：</p><pre class="language-python" data-language="python"><code class="language-python">def send_message(phone,content):    &quot;&quot;&quot;发送消息&quot;&quot;&quot;    passdef send_image(img_path, content):    &quot;&quot;&quot;发送图片&quot;&quot;&quot;    passdef send_emoji(emoji):    &quot;&quot;&quot;发送表情&quot;&quot;&quot;    passdef send_file(path):    &quot;&quot;&quot;发送文件&quot;&quot;&quot;    passfunction_dict &#x3D; &#123;    &quot;1&quot;: [ send_message,  [&#39;15131255089&#39;, &#39;你好呀&#39;]],    &quot;2&quot;: [ send_image,  [&#39;xxx&#x2F;xxx&#x2F;xx.png&#39;, &#39;消息内容&#39;]],    &quot;3&quot;: [ send_emoji, [&quot;😁&quot;]],    &quot;4&quot;: [ send_file, [&#39;xx.zip&#39;] ]&#125;print(&quot;欢迎使用xx系统&quot;)print(&quot;请选择：1.发送消息；2.发送图片；3.发送表情；4.发送文件&quot;)choice &#x3D; input(&quot;输入选择的序号&quot;) # 1item &#x3D; function_dict.get(choice) # [ send_message,  [&#39;15131255089&#39;, &#39;你好呀&#39;]],if not item:    print(&quot;输入错误&quot;)else:    # 执行函数    func &#x3D; item[0] # send_message    param_list &#x3D; item[1] #  [&#39;15131255089&#39;, &#39;你好呀&#39;]        func(*param_list) # send_message(*[&#39;15131255089&#39;, &#39;你好呀&#39;])</code></pre><p>情景2：</p><pre class="language-python" data-language="python"><code class="language-python">def send_msg(mobile, content):    &quot;&quot;&quot;发送短信&quot;&quot;&quot;    passdef send_email(to_email, subject, content):    &quot;&quot;&quot;发送图片&quot;&quot;&quot;    passdef send_wechat(user_id, content):    &quot;&quot;&quot;发送微信&quot;&quot;&quot;    passfunc_list &#x3D; [    &#123;&quot;name&quot;: send_msg, &quot;params&quot;: &#123;&#39;mobile&#39;: &quot;15131255089&quot;, &quot;content&quot;: &quot;你有新短消息&quot;&#125;&#125;,    &#123;&quot;name&quot;: send_email, &quot;params&quot;: &#123;&#39;to_email&#39;: &quot;wupeiqi@live.com&quot;, &quot;subject&quot;: &quot;报警消息&quot;, &quot;content&quot;: &quot;硬盘容量不够用了&quot;&#125;&#125;,    &#123;&quot;name&quot;: send_wechat, &quot;params&quot;: &#123;&#39;user_id&#39;: 1, &#39;content&#39;: &quot;约吗&quot;&#125;&#125;,]#  &#123;&quot;name&quot;: send_msg, &quot;params&quot;: &#123;&#39;mobile&#39;: &quot;15131255089&quot;, &quot;content&quot;: &quot;你有新短消息&quot;&#125;&#125;,for item in func_list:    func &#x3D; item[&#39;name&#39;] # send_msg    param_dict &#x3D; item[&#39;params&#39;] # &#123;&#39;mobile&#39;: &quot;15131255089&quot;, &quot;content&quot;: &quot;你有新短消息&quot;&#125;    func(**param_dict) # send_msg(**&#123;&#39;mobile&#39;: &quot;15131255089&quot;, &quot;content&quot;: &quot;你有新短消息&quot;&#125;)</code></pre><h4 id="2-2-函数名赋值"><a href="#2-2-函数名赋值" class="headerlink" title="2.2 函数名赋值"></a>2.2 函数名赋值</h4><ul><li><p>将函数名赋值给其他变量，函数名其实就个变量，代指某函数；如果将函数名赋值给另外一个变量，则此变量也会代指该函数，例如：</p><pre class="language-python" data-language="python"><code class="language-python">def func(a1,a2):    print(a1,a2)xxxxx &#x3D; func# 此时，xxxxx和func都代指上面的那个函数，所以都可以被执行。func(1,1)xxxxx(2,2)</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func(a1,a2):    print(a1,a2)    func_list &#x3D; [func,func,func]func(11,22)func_list[0](11,22)func_list[1](33,44)func_list[2](55,66)</code></pre></li><li><p>对函数名重新赋值，如果将函数名修改为其他值，函数名便不再代指函数，例如：</p><pre class="language-python" data-language="python"><code class="language-python">def func(a1,a2):    print(a1,a2)# 执行func函数func(11,22)# func重新赋值成一个字符串func &#x3D; &quot;武沛齐&quot;print(func)  # &quot;武沛齐&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func(a1,a2):    print(a1+a2)    func(1,2)def func():    print(666)    func()</code></pre><p>注意：由于函数名被重新定义之后，就会变量新被定义的值，所以大家在自定义函数时，<font color="#dd0000"><strong>不要与python内置的函数同名，否则会覆盖内置函数的功能，</strong></font>例如：</p><pre class="language-python" data-language="python"><code class="language-python">id,bin,hex,oct,len...</code></pre><pre class="language-python" data-language="python"><code class="language-python"># len内置函数用于计算值得长度v1 &#x3D; len(&quot;武沛齐&quot;)print(v1) # 3# len重新定义成另外一个函数def len(a1,a2):    return a1 + a2# 以后执行len函数，只能按照重新定义的来使用v3 &#x3D; len(1,2)print(v3)</code></pre></li></ul><h4 id="2-3-函数名做参数和返回值"><a href="#2-3-函数名做参数和返回值" class="headerlink" title="2.3 函数名做参数和返回值"></a>2.3 函数名做参数和返回值</h4><p>​函数名其实就一个变量，代指某个函数，所以，他和其他的数据类型一样，<font color="#dd0000"><strong>函数也可以当做函数的参数和返回值。</strong></font></p><ul><li><p>参数</p><pre class="language-python" data-language="python"><code class="language-python">def plus(num):    return num + 100def handler(func):    res &#x3D; func(10) # 110    msg &#x3D; &quot;执行func，并获取到的结果为:&#123;&#125;&quot;.format(res)    print(msg) # 执行func，并获取到的结果为:110   # 执行handler函数，将plus作为参数传递给handler的形式参数funchandler(plus)</code></pre></li><li><p>返回值</p><pre class="language-python" data-language="python"><code class="language-python">def plus(num):    return num + 100def handler():print(&quot;执行handler函数&quot;)    return plus    result &#x3D; handler()data &#x3D; result(20) # 120print(data)</code></pre></li></ul><h3 id="3-返回值和print"><a href="#3-返回值和print" class="headerlink" title="3.返回值和print"></a>3.返回值和print</h3><p>​对于初学者的同学，很多人都对print和返回值分不清楚，例如：</p><pre class="language-python" data-language="python"><code class="language-python">def add(n1,n2):    print(n1 + n2)v1 &#x3D; add(1,3)print(v1)# 输出4Nonedef plus(a1,a2):    return a1 + a2v2 &#x3D; plus(1,2)print(v2)# 输出3</code></pre><p>这两个函数是完全不同的</p><ul><li>在函数中使用print，只是用于在某个位置输出内容而已。</li><li>在函数中使用return，是为了将函数的执行结果返回给调用者，以便于后续其他操作。</li></ul><p>在调用并执行函数时，要学会分析函数的执行步骤。</p><pre class="language-python" data-language="python"><code class="language-python">def f1():    print(123)def f2(arg):    ret &#x3D; arg()    return retv1 &#x3D; f2(f1)print(v1)# 输出123None</code></pre><pre class="language-python" data-language="python"><code class="language-python">def f1():    print(123)def f2(arg):    ret &#x3D; arg()    return f1v1 &#x3D; f2(f1)v2 &#x3D; v1()print(v2)# 输出123123None</code></pre><h3 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4. 作用域"></a>4. 作用域</h3><p>​作用域，<strong>可以理解为一块空间，这块空间的数据是可以共享的。</strong>通俗点来说，作用域就类似于一个房子，房子中的东西归里面的所有人共享，其他房子的人无法获取。</p><h4 id="4-1-函数为作用域"><a href="#4-1-函数为作用域" class="headerlink" title="4.1 函数为作用域"></a>4.1 函数为作用域</h4><p>​Python以函数为作用域，所以在函数内创建的所有数据，可以此函数中被使用，无法在其他函数中被使用。</p><pre class="language-python" data-language="python"><code class="language-python">def func():    name &#x3D; &quot;武沛齐&quot;    data_list &#x3D; [11,22,33,44]    print(name,data_list)    age &#x3D; 20    print(age)def handler():    age &#x3D; 18    print(age)func()handler()</code></pre><p>​学会分析代码，了解变量到底属于哪个作用域且是否可以被调用：</p><pre class="language-python" data-language="python"><code class="language-python">def func():    name &#x3D; &quot;武沛齐&quot;    age &#x3D; 29    print(age)    data_list &#x3D; [11,22,33,44]    print(name,data_list)        for num in range(10):        print(num)            print(num)        if 1 &#x3D;&#x3D; 1:        value &#x3D; &quot;admin&quot;        print(value)print(value)        if 1 &gt; 2:        max_num &#x3D; 10        print(max_num)print(max_num)    def handler():    age &#x3D; 18    print(age)handler()func()</code></pre><h4 id="4-2-全局和局部"><a href="#4-2-全局和局部" class="headerlink" title="4.2 全局和局部"></a>4.2 全局和局部</h4><p>Python中以函数为作用域，函数的作用域其实是一个局部作用域。</p><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201223022803940.png" class="" title="image-20201223022803940"><pre class="language-python" data-language="python"><code class="language-python">goods &#x3D; [    &#123;&quot;name&quot;: &quot;电脑&quot;, &quot;price&quot;: 1999&#125;,    &#123;&quot;name&quot;: &quot;鼠标&quot;, &quot;price&quot;: 10&#125;,    &#123;&quot;name&quot;: &quot;游艇&quot;, &quot;price&quot;: 20&#125;,    &#123;&quot;name&quot;: &quot;美女&quot;, &quot;price&quot;: 998&#125;]for index in range(len(goods)):    item &#x3D; goods[index]    print(index + 1, item[&#39;name&#39;], item[&#39;price&#39;])while True:    num &#x3D; input(&quot;请输入要选择的商品序号(Q&#x2F;q)：&quot;)  # &quot;1&quot;    if num.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    if not num.isdecimal():        print(&quot;用输入的格式错误&quot;)        break    num &#x3D; int(num)    send_email()    if num &gt; 4 or num &lt; 0:        print(&quot;范围选择错误&quot;)        break    target_index &#x3D; num - 1    choice_item &#x3D; goods[target_index]    print(choice_item[&quot;name&quot;], choice_item[&#39;price&#39;])    send_email()</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 全局变量（变量名大写）COUNTRY &#x3D; &quot;中国&quot;CITY_LIST &#x3D; [&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;]def download():    # 局部变量    url &#x3D; &quot;http:&#x2F;&#x2F;www.xxx.com&quot;    ...    def upload():    file_name &#x3D; &quot;rose.zip&quot;    ...    </code></pre><p>​<code>COUNTRY</code>和<code>CITY_LIST</code>是在全局作用域中，全局作用域中创建的变量称之为<strong>【全局变量】</strong>，<font color="#dd0000"><strong>可以在全局作用域中被使用，也可以在其局部作用域中被使用。</strong></font></p><p>​<code>download</code>和<code>upload</code>函数内部维护的就是一个局部作用域，在各自函数内部创建变量称之为<strong>【局部变量】</strong>，<font color="#dd0000"><strong>且局部变量只能在此作用域中被使用。局部作用域中想使用某个变量时，寻找的顺序为：<code>优先在局部作用域中寻找，如果没有则去上级作用域中寻找</code>。</strong></font></p><p><strong>注意：全局变量一般都是大写。</strong></p><p>示例1：在局部作用域中读取全局作用域的变量。</p><pre class="language-python" data-language="python"><code class="language-python">COUNTRY &#x3D; &quot;中国&quot;CITY_LIST &#x3D; [&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;]def download():    url &#x3D; &quot;http:&#x2F;&#x2F;www.xxx.com&quot;    print(url)    print(COUNTRY)    print(CITY_LIST)    def upload():    file_name &#x3D; &quot;rose.zip&quot;    print(file_name)    print(COUNTRY)    print(CITY_LIST)    print(COUNTRY)print(CITY_LIST)downlowd()upload()print(file_name) # 报错print(url) # 报错</code></pre><p>示例2：局部作用域和全局作用域变量同名，这算啥？</p><pre class="language-python" data-language="python"><code class="language-python">COUNTRY &#x3D; &quot;中国&quot;CITY_LIST &#x3D; [&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;]def download():    url &#x3D; &quot;http:&#x2F;&#x2F;www.xxx.com&quot;    CITY_LIST &#x3D; [&quot;河北&quot;,&quot;河南&quot;,&quot;山西&quot;]    print(url)    print(COUNTRY)    print(CITY_LIST)    def upload():    file_name &#x3D; &quot;rose.zip&quot;    print(COUNTRY)    print(CITY_LIST)    print(COUNTRY)print(CITY_LIST)download()upload()</code></pre><pre class="language-python" data-language="python"><code class="language-python">COUNTRY &#x3D; &quot;中国&quot;CITY_LIST &#x3D; [&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;]def download():    url &#x3D; &quot;http:&#x2F;&#x2F;www.xxx.com&quot;    CITY_LIST &#x3D; [&quot;河北&quot;,&quot;河南&quot;,&quot;山西&quot;]    print(url)    print(COUNTRY)    print(CITY_LIST)    def upload():    file_name &#x3D; &quot;rose.zip&quot;    print(COUNTRY)    print(CITY_LIST)    print(COUNTRY)print(CITY_LIST)download()upload()COUNTRY &#x3D; &quot;中华人民共和共国&quot;CITY_LIST &#x3D; [11,22,33]download()upload()# 输出中国[&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;]http:&#x2F;&#x2F;www.xxx.com中国[&quot;河北&quot;,&quot;河南&quot;,&quot;山西&quot;]中国 [&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;]http:&#x2F;&#x2F;www.xxx.com中华人民共和共国[&quot;河北&quot;,&quot;河南&quot;,&quot;山西&quot;]中华人民共和共国[11,22,33]</code></pre><h4 id="4-3-global关键字"><a href="#4-3-global关键字" class="headerlink" title="4.3 global关键字"></a>4.3 global关键字</h4><img src="/2022/05/27/python-mo-kuai-er-day3/image-20201223022803940-16547788868353.png" class="" title="image-20201223022803940"><p>​<strong>默认情况下，在局部作用域对全局变量只能进行：读取和修改内部元素（可变类型），无法对全局变量进行重新赋值。</strong></p><ul><li><p>读取</p><pre class="language-python" data-language="python"><code class="language-python">COUNTRY &#x3D; &quot;中国&quot;CITY_LIST &#x3D; [&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;]def download():    url &#x3D; &quot;http:&#x2F;&#x2F;www.xxx.com&quot;    print(COUNTRY)    print(CITY_LIST)    download()</code></pre></li><li><p>修改内部元素（可变类型）</p><pre class="language-python" data-language="python"><code class="language-python">COUNTRY &#x3D; &quot;中国&quot;CITY_LIST &#x3D; [&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;]def download():    url &#x3D; &quot;http:&#x2F;&#x2F;www.xxx.com&quot;    print(CITY_LIST)        CITY_LIST.append(&quot;广州&quot;)    CITY_LIST[0] &#x3D; &quot;南京&quot;    print(CITY_LIST)    download()</code></pre></li><li><p>无法对全局变量重新赋值</p><pre class="language-python" data-language="python"><code class="language-python">COUNTRY &#x3D; &quot;中国&quot;CITY_LIST &#x3D; [&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;]def download():    url &#x3D; &quot;http:&#x2F;&#x2F;www.xxx.com&quot;    # 不是对全部变量赋值，而是在局部作用域中又创建了一个局部变量 CITY_LIST 。    CITY_LIST &#x3D;  [&quot;河北&quot;,&quot;河南&quot;,&quot;山西&quot;]    print(CITY_LIST)def upload():    file_name &#x3D; &quot;rose.zip&quot;    print(COUNTRY)    print(CITY_LIST)    download()upload()</code></pre></li></ul><p>如果想要在局部作用域中对全局变量重新赋值，则可以基于 <code>global</code>关键字实现，例如：</p><pre class="language-python" data-language="python"><code class="language-python">COUNTRY &#x3D; &quot;中国&quot;CITY_LIST &#x3D; [&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;]def download():    url &#x3D; &quot;http:&#x2F;&#x2F;www.xxx.com&quot;    global CITY_LIST    CITY_LIST &#x3D;  [&quot;河北&quot;,&quot;河南&quot;,&quot;山西&quot;]    print(CITY_LIST)        global COUNTRY    COUNTRY &#x3D; &quot;中华人民共和国&quot;    print(COUNTRY)def upload():    file_name &#x3D; &quot;rose.zip&quot;    print(COUNTRY)    print(CITY_LIST)    download()  #upload()</code></pre><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol><li><p>函数参数传递的是内存地址。</p><ul><li><p>想重新创建一份数据再传递给参数，可以手动拷贝一份。</p></li><li><p>特殊：参数是动态参数时，通过*或**传参时，会将数据循环添加到参数中（类似于拷贝一份）</p><pre class="language-python" data-language="python"><code class="language-python">def fun(*args, **kwargs):    print(args, kwargs)fun(*[11, 22, 33], **&#123;&quot;k1&quot;: 1, &quot;k2&quot;: 2&#125;)</code></pre></li></ul></li><li><p>函数的返回值也是内存地址。（函数执行完毕后，其内部的所有变量都会被销毁，引用计数器为0时，数据也销毁）</p><pre class="language-python" data-language="python"><code class="language-python">def func():    name &#x3D; [11,22,33]    data &#x3D; name    func()</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func():    name &#x3D; [11,22,33]    return namedata &#x3D; func()while True:print(data)</code></pre></li><li><p>当函数的参数有默认值 &amp; 默认值是可变类型 &amp; 函数内部会修改内部元素（有坑）</p><pre class="language-python" data-language="python"><code class="language-python"># 内部会维护一个列表 []，只要b不传值则始终使用都是这个列表。def func(a,b&#x3D;[]):    b.append(a)</code></pre></li><li><p>定义函数写形式参数时可以使用<code>*</code>和<code>**</code>，执行函数时也可以使用。</p></li><li><p>函数名其实也是个变量，他也可以做列表、字典、集合等元素</p></li><li><p>函数名可哈希，可以作为集合的元素和字典的key</p></li><li><p>函数名可以被重新赋值，也可以做另外一个函数的参数和返回值。</p></li><li><p>掌握 print 和 return的区别，学会分析代码的执行流程。</p></li><li><p>python是以函数为作用域。</p></li><li><p>在局部作用域中寻找某数据时，优先用自己的，自己没有就在上级作用域中寻找。</p></li><li><p>基于 global关键字可以在局部作用域中实现对全局作用域中的变量（全局变量）重新赋值。</p></li></ol><h3 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h3><ol><li><p>如何查看一个值得内存地址？</p><p>​<code>id()</code></p></li><li><p>函数的参数传递的是引用（内存地址）还是值（拷贝一份）？</p><p>​值：拷贝一份（<font color="#dd0000"><strong>错误</strong></font>）</p><p>​<font color="#dd0000"><strong>引用：内存地址</strong></font></p></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#123;&#125;v2 &#x3D; v1v1[&quot;k1&quot;] &#x3D; 123print(v1,v2)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 输出&#123;&#39;k1&#39;: 123&#125; &#123;&#39;k1&#39;: 123&#125;</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(k,v,info&#x3D;&#123;&#125;):    info[k] &#x3D; vreturn infov1 &#x3D; func(1,2)print(v1)v2 &#x3D; func(4,5,&#123;&#125;)print(v2)v3 &#x3D; func(5,6)print(v3)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 分析def func(k,v,info&#x3D;&#123;&#125;):     info[k] &#x3D; v  return info # info -&gt; id1 &#123;&#125;# info -&gt; id1 &#123;1: 2&#125;# id1 &#123;1: 2&#125;v1 &#x3D; func(1,2)  # v1 -&gt; id1 &#123;1: 2&#125;print(v1)# info -&gt; id2 &#123;&#125;# info -&gt; id2 &#123;4: 5&#125;# id2 &#123;4: 5&#125;v2 &#x3D; func(4,5,&#123;&#125;)  # v2 -&gt; id2 &#123;4: 5&#125;print(v2)# info -&gt; id1 &#123;1: 2&#125;# info -&gt; id1 &#123;1: 2, 5:6&#125;# id1 &#123;1: 2, 5:6&#125;v3 &#x3D; func(5,6)  # v3 -&gt; id1 &#123;1: 2, 5:6&#125;print(v3)# 输出&#123;1: 2&#125;&#123;4: 5&#125;&#123;1: 2, 5:6&#125;</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(k,v,info&#x3D;&#123;&#125;):    info[k] &#x3D; vreturn infov1 &#x3D; func(1,2)v2 &#x3D; func(4,5,&#123;&#125;)v3 &#x3D; func(5,6)print(v1,v2,v3)</code></pre><pre class="language-python" data-language="python"><code class="language-python">def func(k,v,info&#x3D;&#123;&#125;):    info[k] &#x3D; vreturn info# info -&gt; id1 &#123;&#125;# info -&gt; id1 &#123;1：2&#125;# id1 &#123;1： 2&#125;v1 &#x3D; func(1,2)  # v1 -&gt; id1 &#123;1： 2&#125;# info -&gt; id2 &#123;&#125;# info -&gt; id2 &#123;4：5&#125;# id1 &#123;4：5&#125;v2 &#x3D; func(4,5,&#123;&#125;)  # v2 -&gt; id2 &#123;4：5&#125;# info -&gt; id1 &#123;1： 2&#125;# info -&gt; id1 &#123;1：2, 5: 6&#125;v3 &#x3D; func(5,6)  # v3 -&gt; id1 &#123;1：2, 5: 6&#125;# v1 -&gt; id1 &#123;1：2, 5: 6&#125;# v2 -&gt; id1 &#123;4：5&#125;# v3 -&gt; id1 &#123;1：2, 5: 6&#125;print(v1,v2,v3)# 输出&#123;1：2, 5: 6&#125; &#123;4：5&#125; &#123;1：2, 5: 6&#125;</code></pre></li><li><p>简述第5题、第6题的结果为何结果不同。</p><pre class="language-python" data-language="python"><code class="language-python">因为v1和v3引用同一内存地址，执行到代码v3 &#x3D; func(5,6)时，对该内存地址的值进行了更改，所以，在运行代码v3 &#x3D; func(5,6)之前打印v1就显示更改之前的值，而在运行代码v3 &#x3D; func(5,6)之后打印v1就显示更改之后的值。</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(*args, **kwargs):    print(args, kwargs)    return &quot;完毕&quot;v1 &#x3D; func(11, 22, 33)print(v1)v2 &#x3D; func([11, 22, 33])print(v2)v3 &#x3D; func(*[11, 22, 33])print(v3)v4 &#x3D; func(k1&#x3D;123, k2&#x3D;456)print(v4)v5 &#x3D; func(&#123;&quot;k1&quot;: 123, &quot;k2&quot;: 456&#125;)print(v5)v6 &#x3D; func(**&#123;&quot;k1&quot;: 123, &quot;k2&quot;: 456&#125;)print(v6)v7 &#x3D; func([11, 22, 33], **&#123;&quot;k1&quot;: 123, &quot;k2&quot;: 456&#125;)print(v7)v8 &#x3D; func(*[11, 22, 33], **&#123;&quot;k1&quot;: 123, &quot;k2&quot;: 456&#125;)print(v8)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 输出(11, 22, 33) &#123;&#125;完毕([11, 22, 33]) &#123;&#125;完毕(11, 22, 33) &#123;&#125;完毕() &#123;&#39;k1&#39;: 123, &#39;k2&#39;: 456&#125;完毕() &#123;&#123;&quot;k1&quot;: 123, &quot;k2&quot;: 456&#125;&#125;  # 错误 (&#123;&quot;k1&quot;: 123, &quot;k2&quot;: 456&#125;,) &#123;&#125;完毕() &#123;&#39;k1&#39;: 123, &#39;k2&#39;: 456&#125;完毕([11, 22, 33]) &#123;&#39;k1&#39;: 123, &#39;k2&#39;: 456&#125;  # 不规范([11, 22, 33],) &#123;&#39;k1&#39;: 123, &#39;k2&#39;: 456&#125;完毕(11, 22, 33) &#123;&#39;k1&#39;: 123, &#39;k2&#39;: 456&#125;完毕</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(*args,**kwargs):    prev &#x3D; &quot;-&quot;.join(args)    data_list &#x3D; []    for k,v in kwargs.items():        item &#x3D; &quot;&#123;&#125;-&#123;&#125;&quot;.format(k,v)        data_list.append(item)content &#x3D; &quot;*&quot;.join(data_list)        return prev,contentv1 &#x3D; func(&quot;北京&quot;,&quot;上海&quot;,city&#x3D;&quot;深圳&quot;,count&#x3D;99)print(v1)v2 &#x3D; func(*[&quot;北京&quot;,&quot;上海&quot;],**&#123;&quot;city&quot;:&quot;深圳&quot;,&quot;count&quot;:99&#125;)print(v2)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 分析# 1、func(&quot;北京&quot;,&quot;上海&quot;,city&#x3D;&quot;深圳&quot;,count&#x3D;99)def func(*args,**kwargs):  # args：(&quot;北京&quot;,&quot;上海&quot;)  kwargs:&#123;city: &quot;深圳&quot;, count: 99&#125;    prev &#x3D; &quot;-&quot;.join(args)  # prev -&gt; id1 &#39;北京-上海&#39;    data_list &#x3D; []  # data_list -&gt; id2 []    for k,v in kwargs.items():        item &#x3D; &quot;&#123;&#125;-&#123;&#125;&quot;.format(k,v)          data_list.append(item)  # [city-&quot;深圳&quot;, count-99]content &#x3D; &quot;*&quot;.join(data_list)  # id2 &#39;city-深圳*count-99&#39;        return prev,content# 2、v1 &#x3D; func(&quot;北京&quot;,&quot;上海&quot;,city&#x3D;&quot;深圳&quot;,count&#x3D;99) print(v1) # v1 -&gt; id1 &#39;北京-上海&#39;, v1 -&gt; id2 &#39;city-深圳*count-99&#39;    # 3、func(*[&quot;北京&quot;,&quot;上海&quot;],**&#123;&quot;city&quot;:&quot;深圳&quot;,&quot;count&quot;:99&#125;)def func(*args,**kwargs):  # args：(&quot;北京&quot;,&quot;上海&quot;)  kwargs:&#123;city: &quot;深圳&quot;, count: 99&#125;    prev &#x3D; &quot;-&quot;.join(args)  # prev -&gt; id3 &#39;北京-上海&#39;    data_list &#x3D; []  # data_list -&gt; id4 []    for k,v in kwargs.items():        item &#x3D; &quot;&#123;&#125;-&#123;&#125;&quot;.format(k,v)          data_list.append(item)  # [city-&quot;深圳&quot;, count-99]content &#x3D; &quot;*&quot;.join(data_list)  # id4 &#39;city-深圳*count-99&#39;    # 4、v2 &#x3D; func(*[&quot;北京&quot;,&quot;上海&quot;],**&#123;&quot;city&quot;:&quot;深圳&quot;,&quot;count&quot;:99&#125;) print(v2) # v2 -&gt; id3 &#39;北京-上海&#39;, v2 -&gt; id4 &#39;city-深圳*count-99&#39;        # 输出&#39;北京-上海&#39; &#39;city-深圳*count-99&#39;&#39;北京-上海&#39; &#39;city-深圳*count-99&#39;</code></pre><p><font color="#dd0000"><strong>答案</strong></font></p><pre class="language-python" data-language="python"><code class="language-python"># return A, B # 函数会返回元组(A, B)# 输出(&#39;北京-上海&#39;, &#39;city-深圳*count-99&#39;)(&#39;北京-上海&#39;,  &#39;city-深圳*count-99&#39;)</code></pre></li><li><p>补充代码，实现获取天气信息并按照指定格式写入到文件中。</p><pre class="language-python" data-language="python"><code class="language-python"># 获取天气信息示例import requestsres &#x3D; requests.get(url&#x3D;&quot;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;data&#x2F;ks&#x2F;101010100.html&quot;)res.encoding &#x3D; &quot;utf-8&quot;weather_dict &#x3D; res.json()# 获取的天气信息是个字典类型，内容如下：print(weather_dict)&quot;&quot;&quot;&#123;&#39;weatherinfo&#39;: &#123;&#39;city&#39;: &#39;北京&#39;, &#39;cityid&#39;: &#39;101010100&#39;, &#39;temp&#39;: &#39;18&#39;, &#39;WD&#39;: &#39;东南风&#39;, &#39;WS&#39;: &#39;1级&#39;, &#39;SD&#39;: &#39;17%&#39;, &#39;WSE&#39;: &#39;1&#39;, &#39;time&#39;: &#39;17:05&#39;, &#39;isRadar&#39;: &#39;1&#39;, &#39;Radar&#39;: &#39;JC_RADAR_AZ9010_JB&#39;, &#39;njd&#39;: &#39;暂无实况&#39;, &#39;qy&#39;: &#39;1011&#39;, &#39;rain&#39;: &#39;0&#39;&#125;&#125;&quot;&quot;&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">import requestsdef write_file(**kwargs):    &quot;&quot;&quot;将天气信息拼接起来，并写入到文件    格式要求：    1. 每个城市的天气占一行    2. 每行的格式为：city-北京,cityid-101010100,temp-18...    &quot;&quot;&quot;    # 补充代码def get_weather(code):    &quot;&quot;&quot; 获取天气信息 &quot;&quot;&quot;    url &#x3D; &quot;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;data&#x2F;ks&#x2F;&#123;&#125;.html&quot;.format(code)    res &#x3D; requests.get(url&#x3D;url)    res.encoding &#x3D; &quot;utf-8&quot;    weather_dict &#x3D; res.json()    return weather_dictcity_list &#x3D; [    &#123;&#39;code&#39;: &quot;101020100&quot;, &#39;title&#39;: &quot;上海&quot;&#125;,    &#123;&#39;code&#39;: &quot;101010100&quot;, &#39;title&#39;: &quot;北京&quot;&#125;,]# 补充代码</code></pre><p><strong>自己版本</strong></p><pre class="language-python" data-language="python"><code class="language-python">import requestsfrom openpyxl import workbookdef write_file(**kwargs):    &quot;&quot;&quot;将天气信息拼接起来，并写入到文件    格式要求：    1. 每个城市的天气占一行    2. 每行的格式为：city-北京,cityid-101010100,temp-18...    &quot;&quot;&quot;    # 补充代码    info &#x3D; kwargs[&#39;weatherinfo&#39;]  # &#123;&#39;city&#39;: &#39;上海&#39;, &#39;cityid&#39;: &#39;101020100&#39;,...&#125;    wb &#x3D; workbook.Workbook()    sheet &#x3D; wb.worksheets[0]    count &#x3D; 1    for index, k in enumerate(info, 1):  # 1 city 2 cityid ...        cell &#x3D; sheet.cell(count, index)        cell.value &#x3D; &#39;&#123;&#125;-&#123;&#125;&#39;.format(k, info[k])    count +&#x3D; 1    wb.save(&#39;files&#x2F;weather.xlsx&#39;)def get_weather(code):    &quot;&quot;&quot; 获取天气信息 &quot;&quot;&quot;    url &#x3D; &quot;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;data&#x2F;ks&#x2F;&#123;&#125;.html&quot;.format(code)    res &#x3D; requests.get(url&#x3D;url)    res.encoding &#x3D; &quot;utf-8&quot;    weather_dict &#x3D; res.json()    return weather_dictcity_list &#x3D; [    &#123;&#39;code&#39;: &quot;101020100&quot;, &#39;title&#39;: &quot;上海&quot;&#125;,    &#123;&#39;code&#39;: &quot;101010100&quot;, &#39;title&#39;: &quot;北京&quot;&#125;,]# 补充代码result &#x3D; get_weather(&quot;101020100&quot;)write_file(**result)</code></pre><p><font color="#dd0000"><strong>存在问题</strong></font></p><pre class="language-python" data-language="python"><code class="language-python"># 1、使用text存储数据，方便追加# 2、调用时，可以通过循环传入city_list的code</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 修改后版本import requestsfrom openpyxl import workbookdef write_file(**kwargs):    &quot;&quot;&quot;将天气信息拼接起来，并写入到文件    格式要求：    1. 每个城市的天气占一行    2. 每行的格式为：city-北京,cityid-101010100,temp-18...    &quot;&quot;&quot;    # 补充代码    info &#x3D; kwargs[&#39;weatherinfo&#39;]  # &#123;&#39;city&#39;: &#39;上海&#39;, &#39;cityid&#39;: &#39;101020100&#39;,...&#125;    # 拼接字符串    data_list &#x3D; []  # [&#39;city-上海&#39;, ...]    for item in info:        k, v &#x3D; item, info[item]        data_list.append(&#39;&#123;&#125;-&#123;&#125;&#39;.format(k, v))    text &#x3D; &#39;,&#39;.join(data_list)    # 保持文件    with open(&#39;files&#x2F;weather.txt&#39;, mode&#x3D;&#39;at&#39;, encoding&#x3D;&#39;utf-8&#39;) as file_object:        file_object.write(&#39;&#123;&#125;\n&#39;.format(text))def get_weather(code):    &quot;&quot;&quot; 获取天气信息 &quot;&quot;&quot;    url &#x3D; &quot;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;data&#x2F;ks&#x2F;&#123;&#125;.html&quot;.format(code)    res &#x3D; requests.get(url&#x3D;url)    res.encoding &#x3D; &quot;utf-8&quot;    weather_dict &#x3D; res.json()    return weather_dictcity_list &#x3D; [    &#123;&#39;code&#39;: &quot;101020100&quot;, &#39;title&#39;: &quot;上海&quot;&#125;,    &#123;&#39;code&#39;: &quot;101010100&quot;, &#39;title&#39;: &quot;北京&quot;&#125;,]# 补充代码for city in city_list:    code &#x3D; city[&#39;code&#39;]    result &#x3D; get_weather(code)    write_file(**result)</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func():    return 1,2,3val &#x3D; func()print( type(val) &#x3D;&#x3D; tuple )print( type(val) &#x3D;&#x3D; list )</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 分析# 1、func()def func():    return 1,2,3  # (1, 2, 3)# 2、val &#x3D; func()  val -&gt; id1 (1, 2, 3)# 输出TrueFalse</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(users,name):users.append(name)    print(users)result &#x3D; func([&#39;武沛齐&#39;,&#39;李杰&#39;],&#39;alex&#39;)print(result)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 分析# 1、func([&#39;武沛齐&#39;,&#39;李杰&#39;],&#39;alex&#39;)def func(users,name): users.append(name)  # [&#39;武沛齐&#39;,&#39;李杰&#39;, &#39;alex&#39;]    print(users)  # [&#39;武沛齐&#39;,&#39;李杰&#39;, &#39;alex&#39;]# 2、result &#x3D; func([&#39;武沛齐&#39;,&#39;李杰&#39;],&#39;alex&#39;)  # 由于函数没有返回值 result -&gt; None# 输出[&#39;武沛齐&#39;,&#39;李杰&#39;, &#39;alex&#39;]None</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(v1):    return v1 * 2def bar(arg):    return &quot;%s 是什么玩意？&quot; %(arg,)val &#x3D; func(&#39;你&#39;)data &#x3D; bar(val)print(data)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 分析# 1、func(&#39;你&#39;)def func(v1): # v1 &#39;你&#39;    return v1 * 2  # return -&gt; id1 &#39;你你&#39;# 2、val &#x3D; func(&#39;你&#39;)  # val -&gt; id1 &#39;你你&#39;# 3、bar(val)def bar(arg):  # arg &#39;你你&#39;    return &quot;%s 是什么玩意？&quot; %(arg,)  # return -&gt; id2 &quot;你你 是什么玩意？&quot;# 4、data &#x3D; bar(val)  # data -&gt; id2 &quot;你你 是什么玩意？&quot;# 输出&quot;你你 是什么玩意？&quot;</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func(v1):    return v1* 2def bar(arg):    msg &#x3D; &quot;%s 是什么玩意？&quot; %(arg,)    print(msg) val &#x3D; func(&#39;你&#39;)data &#x3D; bar(val)print(data)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 分析# 1、func(&#39;你&#39;)def func(v1):  # v1 &#39;你&#39;    return v1* 2  # return id1 &#39;你你&#39;# 2、val &#x3D; func(&#39;你&#39;)  # val -&gt; id1 &#39;你你&#39;# 3、bar(val)def bar(arg):  # arg &#39;你你&#39;    msg &#x3D; &quot;%s 是什么玩意？&quot; %(arg,)  # msg -&gt; id2 &quot;你你 是什么玩意？&quot;    print(msg)  # 4、data &#x3D; bar(val)  # data -&gt; None# 输出&quot;你你 是什么玩意？&quot;None</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">def func():    data &#x3D; 2 * 2    return datadata_list &#x3D; [func,func,func]for item in data_list:    v &#x3D; item()    print(v)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 分析data_list &#x3D; [func,func,func]for item in data_list:    v &#x3D; item()  # v -&gt; id1 4, v -&gt; id2 4, v -&gt; id3 4    print(v)# 输出44    4&#123;&quot;code&quot;: 123, &quot;name&quot;: &quot;武沛齐&quot;&#125;</code></pre></li><li><p>分析代码，写结果：</p><pre class="language-python" data-language="python"><code class="language-python">def func(handler, **kwargs):    extra &#x3D; &#123;        &quot;code&quot;: 123,        &quot;name&quot;: &quot;武沛齐&quot;    &#125;    kwargs.update(extra)    return handler(**kwargs)def something(**kwargs):    return len(kwargs)def killer(**kwargs):    key_list &#x3D; []    for key in kwargs.keys():        key_list.append(key)    return key_listv1 &#x3D; func(something, k1&#x3D;123, k2&#x3D;456)print(v1)v2 &#x3D; func(killer, **&#123;&quot;name&quot;: &quot;武沛齐&quot;, &quot;age&quot;: 18&#125;)print(v2)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 分析# 1、func(something,k1&#x3D;123,k2&#x3D;456)def func(handler,**kwargs):  # hander something, kwargs &#123;&#39;k1&#39;: 123,&#39;k2&#39;: 456&#125;    extra &#x3D; &#123;        &quot;code&quot;:123,        &quot;name&quot;:&quot;武沛齐&quot;    &#125;  # extra -&gt; id1 &#123;&quot;code&quot;:123,&quot;name&quot;:&quot;武沛齐&quot;&#125;    kwargs.update(extra)  # kwargs &#123;&#39;k1&#39;: 123,&#39;k2&#39;: 456, &quot;code&quot;:123, &quot;name&quot;:&quot;武沛齐&quot;&#125;    return handler(**kwargs)  # something(**kwargs)  return -&gt; id2 4# 2、v2 &#x3D; func(killer,**&#123;&quot;name&quot;:&quot;武沛齐&quot;,&quot;age&quot;:18&#125;)def func(handler,**kwargs):  # hander killer, kwargs &#123;&quot;name&quot;:&quot;武沛齐&quot;,&quot;age&quot;:18&#125;    extra &#x3D; &#123;        &quot;code&quot;:123,        &quot;name&quot;:&quot;武沛齐&quot;    &#125;  # extra -&gt; id3 &#123;&quot;code&quot;:123,&quot;name&quot;:&quot;武沛齐&quot;&#125;    kwargs.update(extra)  # kwargs &#123;&quot;name&quot;:&quot;武沛齐&quot;,&quot;age&quot;:18, &quot;code&quot;:123&#125;    return handler(**kwargs)  # killer(**kwargs)  return -&gt; id4 [&quot;code&quot;, &quot;name&quot;]# 输出4[&quot;name&quot;, &quot;code&quot;, &quot;name&quot;]</code></pre></li><li><p>两个结果输出的分别是什么？并简述其原因。</p><pre class="language-python" data-language="python"><code class="language-python">def func():    return 123v1 &#x3D; [func,func,func,func,]print(v1)v2 &#x3D; [func(),func(),func(),func()]print(v2)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 输出[func,func,func,func,][123, 123, 123, 123]# 原因：第一个没有加括号，传入的是内存地址，第二个加了括号进行了调用，返回123</code></pre></li><li><p>看代码结果</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#39;武沛齐&#39;def func():    print(v1)    func()func()</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 输出&#39;武沛齐&#39;&#39;武沛齐&#39;</code></pre></li><li><p>看代码结果</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#39;武沛齐&#39;def func():    print(v1)    func()v1 &#x3D; &#39;老男人&#39;func()</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 输出&#39;武沛齐&#39;&#39;老男人&#39;</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">NUM_LIST &#x3D; []  # NUM_LIST id1 []SIZE &#x3D; 18  # SIZE id2 18def f1():    NUM_LIST.append(8)  # NUM_LIST -&gt; id1 [8]    SIZE &#x3D; 19  # SIZE id3 19    def f2():    print(NUM_LIST)  # NUM_LIST -&gt; id1 [8]    print(SIZE)  # SIZE id2 18    f2()f1()f2()</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 输出[]18[8]18</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">NUM_LIST &#x3D; []  # NUM_LIST -&gt; id1 []SIZE &#x3D; 18  # SIZE -&gt; id2 18def f1():    global NUM_LIST  # NUM_LIST -&gt; id1 []    global SIZE  # SIZE -&gt; id2 18    NUM_LIST.append(8)  # NUM_LIST -&gt; id1 [8]    SIZE &#x3D; 19  # SIZE -&gt; id2 19    def f2():    print(NUM_LIST)    print(SIZE)    f2()f1()f2()</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 输出[]18[8]19</code></pre></li><li><p>根据要求实现资源下载器。</p><ul><li><p>启动后，让用户选择专区，每个专区用单独的函数实现，提供的专区如下：</p><ul><li>下载 花瓣网图片专区</li><li>下载 抖音短视频专区</li><li>下载 NBA锦集 专区</li></ul></li><li><p>在用户选择了某个功能之后，表示进入某下载专区，在里面循环提示用户可以下载的内容选项（已下载过的则不再提示下载）<br>提醒：可基于全部变量保存已下载过得资源。</p></li><li><p>在某个专区中，如果用户输入（Q&#x2F;q）表示 退出上一级，即：选择专区。</p></li><li><p>在选择专区如果输入Q&#x2F;q则退出整个程序。</p></li><li><p>每个专区实现下载的案例如下：</p><ul><li><p>图片</p><pre class="language-python" data-language="python"><code class="language-python"># 可供用户下载的图片如下image_dict &#x3D; &#123;    &quot;1&quot;:(&quot;吉他男神&quot;,&quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;51d46dc32abe7ac7f83b94c67bb88cacc46869954f478-aP4Q3V&quot;),    &quot;2&quot;:(&quot;漫画美女&quot;,&quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;703fdb063bdc37b11033ef794f9b3a7adfa01fd21a6d1-wTFbnO&quot;),    &quot;3&quot;:(&quot;游戏地图&quot;,&quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;b438d8c61ed2abf50ca94e00f257ca7a223e3b364b471-xrzoQd&quot;),    &quot;4&quot;:(&quot;alex媳妇&quot;,&quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;4edba1ed6a71797f52355aa1de5af961b85bf824cb71-px1nZz&quot;),&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 下载图片示例import requestres &#x3D; requests.get(    url&#x3D;&quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;4edba1ed6a71797f52355aa1de5af961b85bf824cb71-px1nZz&quot;,    headers&#x3D;&#123;        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36&quot;    &#125;)with open(&quot;alex媳妇.png&quot;,mode&#x3D;&quot;wb&quot;) as f:    f.write(res.content)</code></pre></li><li><p>短视频</p><pre class="language-python" data-language="python"><code class="language-python"># 可供用户下载的短视频如下video_dict &#x3D; &#123;&quot;1&quot;:&#123;&quot;title&quot;:&quot;东北F4模仿秀&quot;,&#39;url&#39;:&quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300f570000bvbmace0gvch7lo53oog&quot;&#125;,&quot;2&quot;:&#123;&quot;title&quot;:&quot;卡特扣篮&quot;,&#39;url&#39;:&quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f3e0000bv52fpn5t6p007e34q1g&quot;&#125;,&quot;3&quot;:&#123;&quot;title&quot;:&quot;罗斯mvp&quot;,&#39;url&#39;:&quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&quot;&#125;,&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 下载视频示例import requestsres &#x3D; requests.get(    url&#x3D;&quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&quot;,    headers&#x3D;&#123;        &quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 FS&quot;    &#125;)with open(&#39;罗斯mvp.mp4&#39;, mode&#x3D;&#39;wb&#39;) as f:    f.write(res.content)</code></pre></li><li><p>NBA</p><pre class="language-python" data-language="python"><code class="language-python"># 可供用户下载的NBA视频如下nba_dict &#x3D; &#123;    &quot;1&quot;:&#123;&quot;title&quot;:&quot;威少奇才首秀三双&quot;,&quot;url&quot;:&quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300fc20000bvi413nedtlt5abaa8tg&amp;ratio&#x3D;720p&amp;line&#x3D;0&quot;&#125;,    &quot;2&quot;:&#123;&quot;title&quot;:&quot;塔图姆三分准绝杀&quot;,&quot;url&quot;:&quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0d00fb60000bvi0ba63vni5gqts0uag&amp;ratio&#x3D;720p&amp;line&#x3D;0&quot;&#125;&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 下载示例import requestsres &#x3D; requests.get(    url&#x3D;&quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0d00fb60000bvi0ba63vni5gqts0uag&amp;ratio&#x3D;720p&amp;line&#x3D;0&quot;,    headers&#x3D;&#123;        &quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 FS&quot;    &#125;)with open(&#39;塔图姆三分准绝杀.mp4&#39;, mode&#x3D;&#39;wb&#39;) as f:    f.write(res.content)</code></pre><p><font color="#dd0000"><strong>自己版本</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能资源下载器功能&#39;&#39;&#39;import requestsdef images_zone():    image_dict &#x3D; &#123;        &quot;1&quot;: (&quot;吉他男神&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;51d46dc32abe7ac7f83b94c67bb88cacc46869954f478-aP4Q3V&quot;),        &quot;2&quot;: (&quot;漫画美女&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;703fdb063bdc37b11033ef794f9b3a7adfa01fd21a6d1-wTFbnO&quot;),        &quot;3&quot;: (&quot;游戏地图&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;b438d8c61ed2abf50ca94e00f257ca7a223e3b364b471-xrzoQd&quot;),        &quot;4&quot;: (&quot;alex媳妇&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;4edba1ed6a71797f52355aa1de5af961b85bf824cb71-px1nZz&quot;),    &#125;    print(&#39;欢迎进入花瓣网图片专区&#39;.center(50, &#39;*&#39;))    while True:        print(&#39;目前可下载的资源有： &#39;)        # 构造目前可下载的资源有：        # 1 吉他男神        # 2 漫画美女        # 3 游戏地图        # 4 alex媳妇        for k in image_dict:            name, url &#x3D; image_dict[k]            print(k, name)        image_choice &#x3D; input(&#39;输入数字以进行选择(输入Q&#x2F;q 退出)： &#39;).strip()        if image_choice.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        if not image_choice.isdecimal():            print(&#39;，请重新输入，请重新输入&#39;)            continue        if not image_dict.get(image_choice, 0):            print(&#39;专区不存在，请重新输入&#39;)            continue        # 开始下载图片        choice_name, choice_url &#x3D; image_dict.get(image_choice)        res &#x3D; requests.get(            url&#x3D;choice_url,            headers&#x3D;&#123;                &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36&quot;            &#125;        )        with open(f&quot;files&#x2F;&#123;choice_name&#125;.png&quot;, mode&#x3D;&quot;wb&quot;) as f:            f.write(res.content)        print(&#39;&#123;&#125;以下载完毕&#39;.format(choice_name))        del image_dict[image_choice]def short_video_zone():    video_dict &#x3D; &#123;        &quot;1&quot;: &#123;&quot;title&quot;: &quot;东北F4模仿秀&quot;,              &#39;url&#39;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300f570000bvbmace0gvch7lo53oog&quot;&#125;,        &quot;2&quot;: &#123;&quot;title&quot;: &quot;卡特扣篮&quot;,              &#39;url&#39;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f3e0000bv52fpn5t6p007e34q1g&quot;&#125;,        &quot;3&quot;: &#123;&quot;title&quot;: &quot;罗斯mvp&quot;,              &#39;url&#39;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&quot;&#125;,    &#125;    print(&#39;欢迎进入抖音短视频专区&#39;.center(50, &#39;*&#39;))    while True:        print(&#39;目前可下载的资源有： &#39;)        for index in video_dict:            title &#x3D; video_dict[index][&#39;title&#39;]            print(index, title)        video_choice &#x3D; input(&#39;输入数字以进行选择(输入Q&#x2F;q 退出)： &#39;).strip()        if video_choice.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        if not video_choice.isdecimal():            print(&#39;，请重新输入，请重新输入&#39;)            continue        if not video_dict.get(video_choice, 0):            print(&#39;专区不存在，请重新输入&#39;)            continue        # 开始下载视频        choice_name &#x3D; video_dict[video_choice][&#39;title&#39;]        choice_url &#x3D; video_dict[video_choice][&#39;url&#39;]        res &#x3D; requests.get(            url&#x3D;choice_url,            headers&#x3D;&#123;                &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36&quot;            &#125;        )        with open(f&quot;files&#x2F;&#123;choice_name&#125;.mp4&quot;, mode&#x3D;&quot;wb&quot;) as f:            f.write(res.content)        print(&#39;&#123;&#125;以下载完毕&#39;.format(choice_name))        del video_dict[video_choice]def nba_zone():    nba_dict &#x3D; &#123;        &quot;1&quot;: &#123;&quot;title&quot;: &quot;威少奇才首秀三双&quot;,              &quot;url&quot;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300fc20000bvi413nedtlt5abaa8tg&amp;ratio&#x3D;720p&amp;line&#x3D;0&quot;&#125;,        &quot;2&quot;: &#123;&quot;title&quot;: &quot;塔图姆三分准绝杀&quot;,              &quot;url&quot;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0d00fb60000bvi0ba63vni5gqts0uag&amp;ratio&#x3D;720p&amp;line&#x3D;0&quot;&#125;    &#125;    print(&#39;欢迎进入NBA集锦专区&#39;.center(50, &#39;*&#39;))    while True:        print(&#39;目前可下载的资源有： &#39;)        for index in nba_dict:            title &#x3D; nba_dict[index][&#39;title&#39;]            print(index, title)        nba_choice &#x3D; input(&#39;输入数字以进行选择(输入Q&#x2F;q 退出)： &#39;).strip()        if nba_choice.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        if not nba_choice.isdecimal():            print(&#39;，请重新输入，请重新输入&#39;)            continue        if not nba_dict.get(nba_choice, 0):            print(&#39;专区不存在，请重新输入&#39;)            continue        # 开始下载图片        choice_name &#x3D; nba_dict[nba_choice][&#39;title&#39;]        choice_url &#x3D; nba_dict[nba_choice][&#39;url&#39;]        res &#x3D; requests.get(            url&#x3D;choice_url,            headers&#x3D;&#123;                &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36&quot;            &#125;        )        with open(f&quot;files&#x2F;&#123;choice_name&#125;.mp4&quot;, mode&#x3D;&quot;wb&quot;) as f:            f.write(res.content)        print(&#39;&#123;&#125;以下载完毕&#39;.format(choice_name))        del nba_dict[nba_choice]# 1、启动后，让用户选择专区，每个专区用单独的函数实现，提供的专区如下：function_dict &#x3D; &#123;    &quot;1&quot;: images_zone,    &quot;2&quot;: short_video_zone,    &quot;3&quot;: nba_zone,&#125;while True:    print(&#39;欢迎来到天霸资源下载器,请输入对应数字进入下载专区（输入Q&#x2F;q退出）： &#39;)    zone_choice &#x3D; input(&#39;请输入对应数字：1. 花瓣网图片专区, 2. 抖音短视频专区, 3. NBA锦集专区: &#39;).strip()    if zone_choice.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    zone &#x3D; function_dict.get(zone_choice)    if not zone:        print(&#39;输入类型错误，请重新输入&#39;)        continue    zone()</code></pre><p><font color="#dd0000"><strong>存在问题</strong></font></p><ul><li>下载部分基本重复，考虑封装成函数</li><li>没有保存下载文件信息，当视频已下载后，无法进行提示(使用全局变量)</li></ul><p><font color="#dd0000"><strong>老师版本</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能资源下载器功能&#39;&#39;&#39;import requestsSELECT_IMAGE &#x3D; set()SELECT_VIDEO &#x3D; set()SELECT_NBA &#x3D; set()def download(file_name, url):    res &#x3D; requests.get(        url&#x3D;url,        headers&#x3D;&#123;            &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36&quot;        &#125;    )    with open(file_name, mode&#x3D;&quot;wb&quot;) as f:        f.write(res.content)    print(&#39;&#123;&#125;以下载完毕&#39;.format(file_name))def images_zone():    image_dict &#x3D; &#123;        &quot;1&quot;: (&quot;吉他男神&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;51d46dc32abe7ac7f83b94c67bb88cacc46869954f478-aP4Q3V&quot;),        &quot;2&quot;: (&quot;漫画美女&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;703fdb063bdc37b11033ef794f9b3a7adfa01fd21a6d1-wTFbnO&quot;),        &quot;3&quot;: (&quot;游戏地图&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;b438d8c61ed2abf50ca94e00f257ca7a223e3b364b471-xrzoQd&quot;),        &quot;4&quot;: (&quot;alex媳妇&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;4edba1ed6a71797f52355aa1de5af961b85bf824cb71-px1nZz&quot;),    &#125;    print(&#39;欢迎进入花瓣网图片专区&#39;.center(50, &#39;*&#39;))    while True:        global SELECT_IMAGE        if len(SELECT_IMAGE) &#x3D;&#x3D; len(image_dict):            print(&#39;暂无可下载资源&#39;)            break        print(&#39;目前可下载的资源有： &#39;)        # 构造目前可下载的资源有：        # 1 吉他男神        # 2 漫画美女        # 3 游戏地图        # 4 alex媳妇        for k in image_dict:            if k not in SELECT_IMAGE:                name, url &#x3D; image_dict[k]                print(k, name)        image_choice &#x3D; input(&#39;输入数字以进行选择(输入Q&#x2F;q 退出)： &#39;).strip()        if image_choice.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        if not image_choice.isdecimal():            print(&#39;，请重新输入，请重新输入&#39;)            continue        if not image_dict.get(image_choice, 0):            print(&#39;专区不存在，请重新输入&#39;)            continue        if image_choice in SELECT_IMAGE:            print(&#39;图像已下载，无法再此下载&#39;)            continue        # 开始下载图片        choice_name, url &#x3D; image_dict.get(image_choice)        file_name &#x3D; choice_name + &#39;.png&#39;        download(file_name, url)        SELECT_IMAGE.add(image_choice)def short_video_zone():    video_dict &#x3D; &#123;        &quot;1&quot;: &#123;&quot;title&quot;: &quot;东北F4模仿秀&quot;,              &#39;url&#39;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300f570000bvbmace0gvch7lo53oog&quot;&#125;,        &quot;2&quot;: &#123;&quot;title&quot;: &quot;卡特扣篮&quot;,              &#39;url&#39;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f3e0000bv52fpn5t6p007e34q1g&quot;&#125;,        &quot;3&quot;: &#123;&quot;title&quot;: &quot;罗斯mvp&quot;,              &#39;url&#39;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&quot;&#125;,    &#125;    print(&#39;欢迎进入抖音短视频专区&#39;.center(50, &#39;*&#39;))    while True:        global SELECT_VIDEO        if len(SELECT_VIDEO) &#x3D;&#x3D; len(video_dict):            print(&#39;暂无可下载资源&#39;)            break        print(&#39;目前可下载的资源有： &#39;)        for index in video_dict:            if index not in SELECT_VIDEO:                title &#x3D; video_dict[index][&#39;title&#39;]                print(index, title)        video_choice &#x3D; input(&#39;输入数字以进行选择(输入Q&#x2F;q 退出)： &#39;).strip()        if video_choice.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        if not video_choice.isdecimal():            print(&#39;，请重新输入，请重新输入&#39;)            continue        if not video_dict.get(video_choice, 0):            print(&#39;专区不存在，请重新输入&#39;)            continue        if video_choice in SELECT_VIDEO:            print(&#39;视频已下载，无法再次下载&#39;)            continue        # 开始下载图片        choice_name &#x3D; video_dict.get(video_choice)[&#39;title&#39;]        url &#x3D; video_dict.get(video_choice)[&#39;url&#39;]        file_name &#x3D; choice_name + &#39;.mp4&#39;        download(file_name, url)        SELECT_VIDEO.add(video_choice)def nba_zone():    nba_dict &#x3D; &#123;        &quot;1&quot;: &#123;&quot;title&quot;: &quot;威少奇才首秀三双&quot;,              &quot;url&quot;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300fc20000bvi413nedtlt5abaa8tg&amp;ratio&#x3D;720p&amp;line&#x3D;0&quot;&#125;,        &quot;2&quot;: &#123;&quot;title&quot;: &quot;塔图姆三分准绝杀&quot;,              &quot;url&quot;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0d00fb60000bvi0ba63vni5gqts0uag&amp;ratio&#x3D;720p&amp;line&#x3D;0&quot;&#125;    &#125;    print(&#39;欢迎进入NBA集锦专区&#39;.center(50, &#39;*&#39;))    while True:        global SELECT_NBA        if len(SELECT_NBA) &#x3D;&#x3D; len(nba_dict):            print(&#39;暂无可下载资源&#39;)            break        print(&#39;目前可下载的资源有： &#39;)        for index in nba_dict:            if index not in SELECT_NBA:                title &#x3D; nba_dict[index][&#39;title&#39;]                print(index, title)        nba_choice &#x3D; input(&#39;输入数字以进行选择(输入Q&#x2F;q 退出)： &#39;).strip()        if nba_choice.upper() &#x3D;&#x3D; &#39;Q&#39;:            break        if not nba_choice.isdecimal():            print(&#39;，请重新输入，请重新输入&#39;)            continue        if not nba_dict.get(nba_choice, 0):            print(&#39;专区不存在，请重新输入&#39;)            continue        if nba_choice in SELECT_NBA:            print(&#39;视频已下载，无法重新下载&#39;)        # 开始下载图片        choice_name &#x3D; nba_dict.get(nba_choice)[&#39;title&#39;]        url &#x3D; nba_dict.get(nba_choice)[&#39;url&#39;]        file_name &#x3D; choice_name + &#39;.mp4&#39;        download(file_name, url)        SELECT_NBA.add(nba_choice)# 1、启动后，让用户选择专区，每个专区用单独的函数实现，提供的专区如下：function_dict &#x3D; &#123;    &quot;1&quot;: images_zone,    &quot;2&quot;: short_video_zone,    &quot;3&quot;: nba_zone,&#125;while True:    print(&#39;欢迎来到天霸资源下载器,请输入对应数字进入下载专区（输入Q&#x2F;q退出）： &#39;)    zone_choice &#x3D; input(&#39;请输入对应数字：1. 花瓣网图片专区, 2. 抖音短视频专区, 3. NBA锦集专区: &#39;).strip()    if zone_choice.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    zone &#x3D; function_dict.get(zone_choice)    if not zone:        print(&#39;输入类型错误，请重新输入&#39;)        continue    zone()</code></pre><p><font color="#dd0000"><strong>答案进阶版</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;import requestsDB &#x3D; &#123;    &quot;1&quot;: &#123;        &quot;area&quot;: &quot;花瓣网图片专区&quot;,        &quot;total_dict&quot;: &#123;            &quot;1&quot;: (&quot;吉他男神&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;51d46dc32abe7ac7f83b94c67bb88cacc46869954f478-aP4Q3V&quot;),            &quot;2&quot;: (&quot;漫画美女&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;703fdb063bdc37b11033ef794f9b3a7adfa01fd21a6d1-wTFbnO&quot;),            &quot;3&quot;: (&quot;游戏地图&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;b438d8c61ed2abf50ca94e00f257ca7a223e3b364b471-xrzoQd&quot;),            &quot;4&quot;: (&quot;alex媳妇&quot;, &quot;https:&#x2F;&#x2F;hbimg.huabanimg.com&#x2F;4edba1ed6a71797f52355aa1de5af961b85bf824cb71-px1nZz&quot;),        &#125;,        &quot;ext&quot;: &quot;png&quot;,        &quot;selected&quot;: set()    &#125;,    &quot;2&quot;: &#123;        &quot;area&quot;: &quot;抖音短视频专区&quot;,        &quot;total_dict&quot;: &#123;            &quot;1&quot;: &#123;&quot;title&quot;: &quot;东北F4模仿秀&quot;,                  &#39;url&#39;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300f570000bvbmace0gvch7lo53oog&quot;&#125;,            &quot;2&quot;: &#123;&quot;title&quot;: &quot;卡特扣篮&quot;,                  &#39;url&#39;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f3e0000bv52fpn5t6p007e34q1g&quot;&#125;,            &quot;3&quot;: &#123;&quot;title&quot;: &quot;罗斯mvp&quot;,                  &#39;url&#39;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0200f240000buuer5aa4tij4gv6ajqg&quot;&#125;,        &#125;,        &quot;ext&quot;: &quot;mp4&quot;,        &quot;selected&quot;: set()    &#125;,    &quot;3&quot;: &#123;        &quot;area&quot;: &quot;NBA锦集专区&quot;,        &quot;total_dict&quot;: &#123;            &quot;1&quot;: &#123;&quot;title&quot;: &quot;威少奇才首秀三双&quot;,                  &quot;url&quot;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0300fc20000bvi413nedtlt5abaa8tg&amp;ratio&#x3D;720p&amp;line&#x3D;0&quot;&#125;,            &quot;2&quot;: &#123;&quot;title&quot;: &quot;塔图姆三分准绝杀&quot;,                  &quot;url&quot;: &quot;https:&#x2F;&#x2F;aweme.snssdk.com&#x2F;aweme&#x2F;v1&#x2F;playwm&#x2F;?video_id&#x3D;v0d00fb60000bvi0ba63vni5gqts0uag&amp;ratio&#x3D;720p&amp;line&#x3D;0&quot;&#125;        &#125;,        &quot;ext&quot;: &quot;mp4&quot;,        &quot;selected&quot;: set()    &#125;,&#125;def download(file_path, url):    res &#x3D; requests.get(        url&#x3D;url,        headers&#x3D;&#123;            &quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36 FS&quot;        &#125;    )    with open(file_path, mode&#x3D;&#39;wb&#39;) as f:        f.write(res.content)def handler(area_info):    # 进入专区提醒    summary &#x3D; &quot;欢迎进入&#123;&#125;&quot;.format(area_info[&#39;area&#39;])    print(summary)    # 专区中选择下载    while True:        text_list &#x3D; []        for num, item in area_info[&#39;total_dict&#39;].items():            if num in area_info[&#39;selected&#39;]:                continue            if type(item) &#x3D;&#x3D; tuple:                data &#x3D; &quot;&#123;&#125;.&#123;&#125;&quot;.format(num, item[0])            else:                data &#x3D; &quot;&#123;&#125;.&#123;&#125;&quot;.format(num, item[&quot;title&quot;])            text_list.append(data)        if text_list:            text &#x3D; &quot;;&quot;.join(text_list)        else:            text &#x3D; &quot;无可下载选项&quot;        print(text)        index &#x3D; input(&quot;请输入要选择的序号(Q&#x2F;q退出）：&quot;)        if index.upper() &#x3D;&#x3D; &quot;Q&quot;:            return        if index in area_info[&#39;selected&#39;]:            print(&quot;已下载，无法再继续下载，请重新选择！&quot;)            continue        group &#x3D; area_info[&#39;total_dict&#39;].get(index)        if not group:            print(&quot;序号不存在，请重新选择&quot;)            continue        if type(group) &#x3D;&#x3D; tuple:            title, url &#x3D; group        else:            title, url &#x3D; group[&#39;title&#39;], group[&#39;url&#39;]        file_path &#x3D; &quot;&#123;&#125;.&#123;&#125;&quot;.format(title, area_info[&#39;ext&#39;])        download(file_path, url)        area_info[&#39;selected&#39;].add(index)print(&quot;欢迎使用xxx系统&quot;)while True:    print(&quot;1.花瓣网图片专区;2.抖音短视频专区;3.NBA锦集 专区 &quot;)    choice &#x3D; input(&quot;请选择序号（Q&#x2F;q退出）：&quot;)    if choice.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    # 选择序号： 去db中找对应的字典信息    area_dict &#x3D; DB.get(choice)    if not area_dict:        print(&quot;输入错误，请重新选择！&quot;)        continue    # 进入专区（area_dict选择的专区信息）    handler(area_dict)&quot;&quot;&quot;</code></pre></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 第二阶段 </tag>
            
            <tag> 函数和模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2022/05/26/bo-ke-da-jian/"/>
      <url>/2022/05/26/bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、hexo本地部署和github部署"><a href="#一、hexo本地部署和github部署" class="headerlink" title="一、hexo本地部署和github部署"></a>一、hexo本地部署和github部署</h2><ul><li>过程：<br>参考<a href="https://www.bilibili.com/video/BV1Yb411a7ty?share_source=copy_web">b站程序羊</a></li><li>主要问题：windos系统 hexo d 报错<br>参考弹幕<a href="https://www.bilibili.com/video/BV1Yb411a7ty?share_source=copy_web">b站程序羊</a></li></ul><blockquote><p>win10记得hexo 之前敲<br>git config –global user.email “xxx”<br>git config –global user.name “xxx”</p></blockquote><h2 id="二、matery主题使用"><a href="#二、matery主题使用" class="headerlink" title="二、matery主题使用"></a>二、matery主题使用</h2><p>​参考<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">blinkfox</a></p><h2 id="三、markdown编辑器（Typora）"><a href="#三、markdown编辑器（Typora）" class="headerlink" title="三、markdown编辑器（Typora）"></a>三、markdown编辑器（Typora）</h2><img src="/2022/05/26/bo-ke-da-jian/image-20201011095314682.png" class="" title="image-20201011095314682"><h2 id="四、图片的插入"><a href="#四、图片的插入" class="headerlink" title="四、图片的插入"></a>四、图片的插入</h2><ol><li><p>修改<code>_config.yml</code>中的<code>post_asset_folder: true</code></p></li><li><p>安装 <code>cnpm</code> 来下载插件 <code>hexo-image-link</code> (用国内下载源来下载，速度快)</p><blockquote><p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p><p>cnpm install hexo-image-link –save</p></blockquote></li><li><p>设置Typora的图片存放路径，这样就会在当前<code>md</code>下，生成同名的<code>文件夹</code></p><img src="/2022/05/26/bo-ke-da-jian/9d26623134394c8f964a6f0328a1aaed.png" class="" title="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一阶段考试</title>
      <link href="/2022/05/26/di-yi-jie-duan-kao-shi/"/>
      <url>/2022/05/26/di-yi-jie-duan-kao-shi/</url>
      
        <content type="html"><![CDATA[<ol><li><p>简述解释型语言和编译型语言的区别。</p><pre class="language-python" data-language="python"><code class="language-python">解释型语言：实时翻译，运行一行翻译一行编译型语言：全文翻译，将代码文件翻译后进行存储，运行时直接运行翻译好的零时文件</code></pre></li><li><p>罗列你听说过的编程语言。</p><pre class="language-none"><code class="language-none">python, C, C++, Ruby, Java, PHP, Javascript, Ada</code></pre></li><li><p>简述位和字节的关系？</p><pre class="language-none"><code class="language-none">位(bit):计算机最小表示单位，表示共有多少个0101字节(bety)：计算机最小的存储单位，8bit &#x3D; 1bety</code></pre></li><li><p>简述你理解的 ascii、unicode、utf-8、gbk 编码。</p><pre class="language-none"><code class="language-none">编码就是一个密码本，建立了文字和数字之间的映射关系， ascii、unicode、utf-8、gbk是不同的编码系统  - ascii编码：建立了英文和数字之间的映射关系，取值范围0~255，不支持中文  - gbk 编码：建立了汉字（韩语、日语等亚洲语言）和数字之间的映射关系，一个中文字符由两个字节表示  - unicode 编码：建立了世界上大多数语言与数字的映射关系，向下兼容ascii编码，由于其适宜性广，数据的存储一般使用该编码，但其数据量相对较大，不利于网络传输  - utf-8 编码：本质上是对unicode编码的压缩，规定了对应的unicode码号使用多少字节进行表示，减少了数据量。</code></pre></li><li><p>py2和py3默认解释器编码分别是什么？如何在代码中修改解释器的编码？</p><pre class="language-pyth" data-language="pyth"><code class="language-pyth">- py2的默认解释器编码为ascii- py3的默认解释器编码为utf-8- 默认解释器修改方法  文件写入如下代码： # -*- coding：utf-8 ——*-</code></pre></li><li><p>pass的作用？</p><pre class="language-none"><code class="language-none">起到站位符的作用，当代码不完整时，保证Python语法的完整性</code></pre></li><li><p>is和&#x3D;&#x3D;的区别？</p><pre class="language-python" data-language="python"><code class="language-python">- is:判断内存地址是否相等- &#x3D;&#x3D;:判读取值是否相等示例：a &#x3D; []    b &#x3D; []    print(a &#x3D;&#x3D; b)  # True    print(a is b)  # False</code></pre></li><li><p>列举你了解的Python2和Python3的区别。</p><pre class="language-python" data-language="python"><code class="language-python">1. 默认编码：python2使用ascii，python3使用utf-82. 整型：python2分为长整型和短整型，python3只有整型(长整型)修改：3. 地板除：Python2取整，python3取小数4. python2字典无序，py3.6+字典有序5. 字典的keys()&#x2F;valies()&#x2F;items(): python2列表，python3高仿列表</code></pre></li><li><p>变量名的命名规范有哪些？</p><pre class="language-python" data-language="python"><code class="language-python">三条规范：1. 只能使用字母，下划线和数字的组合2. 不能以数字开头3. 不能使用系统保留关键字两条建议：1. 多个字母使用下划线进行链接2. 全局变量使用大写字母，局部变量使用小写3. 见名之意</code></pre></li><li><p>都有那些值转换为布尔值时为False？</p><pre class="language-none"><code class="language-none">0&#39;&#39;[]()set()&#123;&#125;None</code></pre></li><li><p>简述如下三个变量的区别。</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; (1)v2 &#x3D; (1,)v3 &#x3D; 1</code></pre><pre class="language-none"><code class="language-none">v1 &#x3D; v3 数据类型：intv2 数据类型：tuple 内部元素 1</code></pre></li><li><p>你所学的数据类型中哪些是可变的类型？</p><pre class="language-none"><code class="language-none">- list- set- dict</code></pre></li><li><p>你所学的数据类型中哪些是可哈希的类型？</p><pre class="language-python" data-language="python"><code class="language-python">- int- str- bool- float- tuple</code></pre></li><li><p>你所学的数据类型（容器）中哪些是有序的</p><pre class="language-none"><code class="language-none">- list- tuple- dict(python3.6+)</code></pre></li><li><p>列举你能记得的如下数据类型的方法（独有功能）。</p><ul><li><p>str</p><pre class="language-none"><code class="language-none">startswith()， endswith(), replace(), upper(), lower(), strip(), split(), isdecimal(), join(), center(), ljust(), rjust()</code></pre></li><li><p>list</p><pre class="language-python" data-language="python"><code class="language-python">增：append(), insert(), extend()删：remove(), pop(), del , claer()改：sort(), reverse()查:index()</code></pre></li><li><p>dict</p><pre class="language-python" data-language="python"><code class="language-python">增：setdefault()删：popitem(), del 改：update()查：get(), keys(), values(), items() </code></pre></li></ul></li><li><p>请将字符 <code>name = &quot;wupeiqi&quot;</code> 翻转。</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;wupeiqi&quot;new_name &#x3D; name[::-1]</code></pre></li><li><p>进制之间如何进行转换？</p><pre class="language-python" data-language="python"><code class="language-python">- 由十进制(int)转出  - 二进制 bin()  - 八进制 oct()  - 十六进制 hex()- 转为十进制(int)  - 二进制 int(&#39;&#39;, base&#x3D;2)  - 八进制 int(&#39;&#39;, base&#x3D;8)  - 十六进制 int(&#39;&#39;, base&#x3D;16)</code></pre></li><li><p>循环过程中 break和continue的作用是什么？</p><pre class="language-python" data-language="python"><code class="language-python">- break:终止循环，当循环内部代码块遇到break后会立刻停止下方代码执行，并结束循环- continue：跳出本次循环，当循环内部代码块遇到break后会停止下方代码执行，直接开始下次循环</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 1 or 9 and 88 or [11,22] and (1,2,3)v2 &#x3D; 1&gt;5 or &quot;alex&quot; and &#123;&quot;K1&quot;:&quot;v1&quot;&#125; or 888print(v1,v2)  #1， &#123;&quot;K1&quot;:&quot;v1&quot;&#125;</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python"> info &#x3D; [      &#123;&#39;k1&#39;:(1),&#39;k2&#39;:&#123;&#39;k9&#39;:&#39;luffy&#39;,&#39;k10&#39;:&#39;武沛齐&#39;&#125;&#125;,      (11,22,33,44),     &#123;199,2,3,4,5&#125;,     True,      [&#39;李杰&#39;,&#39;alex&#39;, &#123; &#39;extra&#39;: (&quot;alex&quot;,[18,20],&#39;eric&#39;) &#125; ]] </code></pre><ul><li><p>利用索引获取 “luffy” </p><pre class="language-python" data-language="python"><code class="language-python">info[0][&#39;k2&#39;][&#39;k9&#39;]</code></pre></li><li><p>利用索引获取 44</p><pre class="language-python" data-language="python"><code class="language-python">info[1][3]</code></pre></li><li><p>删除k10对应的键值对</p><pre class="language-python" data-language="python"><code class="language-python">del info[0][&#39;k2&#39;][&#39;k10&#39;]</code></pre></li><li><p>在 <code>&#123; &#39;extra&#39;: (&quot;alex&quot;,[18,20],&#39;eric&#39;) &#125;</code> 字典中添加一个键值对 <code>&quot;name&quot;:&quot;武沛齐&quot;</code></p><pre class="language-python" data-language="python"><code class="language-python">info[4][2][&#39;name&#39;] &#x3D; &quot;武沛齐&quot;</code></pre></li><li><p>在集合<code>&#123;199,2,3,4,5&#125;</code>中添加一个 “北京”</p><pre class="language-python" data-language="python"><code class="language-python">info[2].add(&#39;北京&#39;)</code></pre></li><li><p>将列表中的True修改为 “真”</p><pre class="language-python" data-language="python"><code class="language-python">info[3] &#x3D; &#39;真&#39;</code></pre></li><li><p>在列表 <code>[18,20]</code>的第0个索引位置插入 666</p><pre class="language-python" data-language="python"><code class="language-python">info[4][2][&#39;extra&#39;][1].insert(0, 666)</code></pre></li></ul></li><li><p>判断下面的代码是否正确？正确的话则写出结果，否则标明错误。</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; (11,22,33)  # (11,22,33)v2 &#x3D; (11)  # 11v3 &#x3D; &#123;11,2,33&#125;  # &#123;11,2,33&#125;v4 &#x3D; &#123;11,2,(&quot;alex&quot;,&quot;eric&quot;),33&#125;  # &#123;11,2,(&quot;alex&quot;,&quot;eric&quot;),33&#125;v5 &#x3D; &#123;11,2,(&quot;alex&quot;,&#123;&quot;北京&quot;,&quot;上海&quot;&#125;,&quot;eric&quot;),33&#125;  # 集合v5内部子孙中存在不可哈希元素&#123;&quot;北京&quot;,&quot;上海&quot;&#125;</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; [11,22,33]v2 &#x3D; [11,22,33]v1.append(666)print(v1)  # [11,22,33,66]print(v2)  # [11,22,33]</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; [11,22,33]v2 &#x3D; v1v1.append(666)print(v1)  # [11,22,33,66]print(v2)  # [11,22,33,66]</code></pre></li><li><p><font color="#dd0000">看代码写结果</font></p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; [1,2,3,4,5]v2 &#x3D; [v1,v1,v1]  # [[1,2,3,4,5], [1,2,3,4,5], [1,2,3,4,5]]v2[1][0] &#x3D; 111v2[2][0] &#x3D; 222print(v1)  #  v1 &#x3D; [1,2,3,4,5]print(v2)  # [[1,2,3,4,5], [111,2,3,4,5], [222,2,3,4,5]]</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 答案# v1, v2指向同一块内存[1,2,3,4,5]，v2[1][0]将[1,2,3,4,5]改为[111,2,3,4,5]，v2[2][0]将[111,222,3,4,5]print(v1)  # [111,222,3,4,5]print(v2)  # [[111,222,3,4,5], [111,222,3,4,5], [111,222,3,4,5]]</code></pre></li><li><p>写代码实现，循环提示用户输入内容（Q或q终止），并将内容用 “_” 连接起来。</p><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件功能为：循环提示用户输入内容（Q或q终止），并将内容用 &quot;_&quot; 连接起来。&#39;&#39;&#39;while True:    user_input &#x3D; input(&#39;please input something,(Q&#x2F;q to quit): &#39;)    if user_input.upper() &#x3D;&#x3D; &#39;Q&#39;:  # 输入Q&#x2F;q退出        break            print(&#39;_&#39;.join(user_input))</code></pre></li><li><p>写代码实现，将IP转换为整数。</p><blockquote><p>如 10.3.9.12 转换规则为：<br>  10            00001010<br>   3             00000011<br>   9             00001001<br>  12            00001100<br>再将以上二进制拼接起来，然后再进行一次翻转。</p><p>最终将翻转之后的二进制转换为整型。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能为，将IP转换为整数。如 10.3.9.12 转换规则为：     10            00001010      3            00000011      9            00001001     12            00001100再将以上二进制拼接起来，然后再进行一次翻转。最终将翻转之后的二进制转换为整型。&#39;&#39;&#39;ip_str &#x3D; &#39;10.3.9.12&#39;ip_list &#x3D; ip_str.split(&#39;.&#39;)  # [&#39;10&#39;, &#39;3&#39;, &#39;9&#39;, &#39;12&#39;]# 1、将ip_list按转换规则进行转换bin_list &#x3D; []for item in ip_list:    bin_ip &#x3D; bin(int(item))  # &#39;0b1010&#39; ...    data &#x3D; bin_ip[2:].zfill(8)  # 00001010 ...    bin_list.append(data)# 2、再将以上二进制拼接起来，然后再进行一次翻转result_reverse &#x3D; &#39;&#39;.join(bin_list)  # 拼接result_bin &#x3D; result_reverse[::-1]  # 翻转# 3、最终将翻转之后的二进制转换为整型result &#x3D; int(result_bin, base&#x3D;2)print(result)</code></pre></li><li><p>写代码实现，车牌的区域划分。</p><pre class="language-python" data-language="python"><code class="language-python">car_list &#x3D; [&#39;鲁A32444&#39;, &#39;沪B12333&#39;, &#39;京B8989M&#39;, &#39;京C49678&#39;, &#39;黑C46555&#39;, &#39;晋B25041&#39;, &#39;沪C34567&#39;]# 根据以上代码获取各省车牌数量，例如：info &#x3D; &#123;&quot;沪&quot;:2,&quot;京&quot;:2 ...&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能为，根据以上车牌号码获取各省车牌数量。如 car_list &#x3D;[&#39;鲁A32444&#39;, &#39;沪B12333&#39;, &#39;京B8989M&#39;, &#39;京C49678&#39;, &#39;黑C46555&#39;, &#39;晋B25041&#39;, &#39;沪C34567&#39;]输出：info &#x3D; &#123;&quot;沪&quot;:2,&quot;京&quot;:2 ...&#125;&#39;&#39;&#39;car_list &#x3D; [&#39;鲁A32444&#39;, &#39;沪B12333&#39;, &#39;京B8989M&#39;, &#39;京C49678&#39;, &#39;黑C46555&#39;, &#39;晋B25041&#39;, &#39;沪C34567&#39;]info_list &#x3D; &#123;    # &quot;沪&quot;:[沪B12333, 沪C34567] ...&#125;for car in car_list:    location &#x3D; car[0]    info_list[location] &#x3D; []  # &#123;&#39;鲁&#39;: [], &#39;沪&#39;: [], &#39;京&#39;: [], &#39;黑&#39;: [], &#39;晋&#39;: []&#125;for car in car_list:    location &#x3D; car[0]    info_list[location].append(car)  # &#123;&#39;鲁&#39;: [&#39;鲁A32444&#39;], ...&#125;info &#x3D; &#123;&#125;for location in info_list:    info[location] &#x3D; len(info_list[location])  # &#123;&#39;鲁&#39;: 1, &#39;沪&#39;: 2, &#39;京&#39;: 2, &#39;黑&#39;: 1, &#39;晋&#39;: 1&#125;print(info)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 答案 1car_list &#x3D; [&#39;鲁A32444&#39;, &#39;沪B12333&#39;, &#39;京B8989M&#39;, &#39;京C49678&#39;, &#39;黑C46555&#39;, &#39;晋B25041&#39;, &#39;沪C34567&#39;]result &#x3D; &#123;&#125;for item in car_list:    location &#x3D; item[0]    if location not in result:        result[location] &#x3D; 1  # 车牌号不在里面，value&#x3D;1（初始化）    else:        result[location] +&#x3D; 1  # 车牌号在里面，value +&#x3D; 1print(result)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 答案 2car_list &#x3D; [&#39;鲁A32444&#39;, &#39;沪B12333&#39;, &#39;京B8989M&#39;, &#39;京C49678&#39;, &#39;黑C46555&#39;, &#39;晋B25041&#39;, &#39;沪C34567&#39;]result &#x3D; &#123;&#125;for item in car_list:    location &#x3D; item[0]    num &#x3D; result.get(location, 0)  # 如果没有num &#x3D; 0    result[location] &#x3D; num + 1  # value &#x3D; 0 + 1print(result)</code></pre></li><li><p>写代码实现，数据格式化处理。</p><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; &quot;&quot;&quot;id,name,age,phone,job1,alex,22,13651054608,IT 2,wusir,23,13304320533,Tearcher3,老男孩,18,1333235322,IT&quot;&quot;&quot;# 将上述数据处理为如下格式的结果：#    info &#x3D; [&#123;&#39;id&#39;:&#39;1&#39;,&#39;name&#39;:&#39;alex&#39;,&#39;age&#39;:&#39;22&#39;,&#39;phone&#39;:&#39;13651054608&#39;,&#39;job&#39;:&#39;IT&#39;&#125;,.... ..]# 提示：text的内容是根据 \n 分割（\n表示回车换行）。</code></pre><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能为，数据格式化处理。。如   text &#x3D; &quot;&quot;&quot;id,name,age,phone,job    1,alex,22,13651054608,IT    2,wusir,23,13304320533,Tearcher    3,老男孩,18,1333235322,IT&quot;&quot;&quot;输出为：info &#x3D; [&#123;&#39;id&#39;:&#39;1&#39;,&#39;name&#39;:&#39;alex&#39;,&#39;age&#39;:&#39;22&#39;,&#39;phone&#39;:&#39;13651054608&#39;,&#39;job&#39;:&#39;IT&#39;&#125;,                .... ,                ....                ]&#39;&#39;&#39;text &#x3D; &quot;&quot;&quot;id,name,age,phone,job          1,alex,22,13651054608,IT          2,wusir,23,13304320533,Tearcher          3,老男孩,18,1333235322,IT        &quot;&quot;&quot;text_list &#x3D; text.strip().split(&#39;\n&#39;)  # [&#39;id,name,age,phone,job&#39;, &#39;1,alex,22,13651054608,IT &#39;, ...]keys &#x3D; text_list[0].split(&#39;,&#39;)  # [&#39;id&#39;, &#39;name&#39;, &#39;age&#39;, &#39;phone&#39;, &#39;job&#39;]values_list &#x3D; text_list[1:]  # [&#39;1,alex,22,13651054608,IT&#39;, ...]info &#x3D; []for i in range(len(values_list)):    info.append(&#123;&#125;)    values &#x3D; values_list[i].split(&#39;,&#39;)  # [&#39;1&#39;, &#39;alex&#39;, &#39;22&#39;, &#39;13651054608&#39;, &#39;IT&#39;] ...    for j in range(len(keys)):        key &#x3D; keys[j].strip()        value &#x3D; values[j].strip()        info[i][key] &#x3D; valueprint(info)</code></pre></li><li><p>写代码实现 累乘计算器。</p><pre class="language-python" data-language="python"><code class="language-python">content &#x3D; input(&quot;请输入内容:&quot;) # 用户可能输入 5*9*99.... 或 5* 9 * 10 * 99 或 5 * 9 * 99...# 补充代码实现</code></pre><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能为，实现累乘计算器。&#39;&#39;&#39;while True:    result &#x3D; 1    content &#x3D; input(&quot;请输入内容(Q&#x2F;q退出):&quot;)  # 用户可能输入 5*9*99.... 或 5* 9 * 10 * 99 或 5 * 9 * 99...    if content.strip().upper() &#x3D;&#x3D; &#39;Q&#39;:        break    num_list &#x3D; content.split(&#39;*&#39;)  # [&#39;5&#39;, &#39; 9 &#39;, &#39; 10 &#39;, &#39; 99&#39;]    for num in num_list:        num &#x3D; int(num.strip())        result *&#x3D; num    print(result)</code></pre></li><li><p>使用for循环实现输出 9*9 乘法表</p><pre class="language-none"><code class="language-none">1*12*1 2*23*1 3*2 3*34*1 4*2 4*3 4*45*1 5*2 5*3 5*4 5*56*1 6*2 6*3 6*4 6*5 6*67*1 7*2 7*3 7*4 7*5 7*6 7*78*1 8*2 8*3 8*4 8*5 8*6 8*7 8*89*1 9*2 9*3 9*4 9*5 9*6 9*7 9*8 9*9</code></pre><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能为，for循环实现输出 9*9 乘法表。&#39;&#39;&#39;for i in range(1, 10):    for j in range(1, i+1):        print(&#39;&#123;&#125;*&#123;&#125;&#39;.format(i, j), end&#x3D;&#39; &#39;)    if i &#x3D;&#x3D; 9:        continue    print()</code></pre></li><li><p>补充代码实现《棋牌游戏11点》</p><p>需求：</p><ul><li><p>生成一副扑克牌（自己设计扑克牌的结构，小王和大王可以分别用14、15表示 ）</p></li><li><p>3个玩家</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;alex&quot;,&quot;武沛齐&quot;,&quot;李路飞&quot;]</code></pre></li><li><p>发牌规则</p><ul><li>默认先给用户发一张牌，其中 J、Q、K、小王、大王代表的值为0.5，其他就是则就是当前的牌面值。</li><li>用户根据自己的情况判断是否继续要牌。<ul><li>要，则再给他发一张。</li><li>不要，则开始给下个玩家发牌。</li></ul></li><li>如果用户手中的所有牌相加大于11，则表示爆了，此人的分数为0，并且自动开始给下个人发牌。</li></ul></li><li><p>最终计算并获得每个玩家的分值，例如：</p><pre class="language-python" data-language="python"><code class="language-python">result &#x3D; &#123;    &quot;alex&quot;:8,    &quot;武沛齐&quot;:9,    &quot;李路飞&quot;:0&#125;</code></pre></li></ul><p>必备技术点：随机抽排</p><pre class="language-python" data-language="python"><code class="language-python">import randomtotal_poke_list &#x3D; [(&quot;红桃&quot;, 1), (&quot;黑桃&quot;, 2), (&quot;大王&quot;, 15), (&quot;小王&quot;, 14)]# 随机生成一个数，当做索引。index &#x3D; random.randint(0, len(total_poke_list) - 1)# 获取牌print(&quot;抽到的牌为：&quot;, total_poke_list[index])# 踢除这张牌total_poke_list.pop(index)print(&quot;抽完之后，剩下的牌为：&quot;, total_poke_list)</code></pre><p>代码示例：（请补充实现）</p><pre class="language-python" data-language="python"><code class="language-python">result &#x3D; &#123;&#125;user_list &#x3D; [&quot;alex&quot;,&quot;武沛齐&quot;,&quot;李路飞&quot;]# 补充代码print(result)</code></pre><pre class="language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;本文件实现功能为，《棋牌游戏11点》。- 生成一副扑克牌（自己设计扑克牌的结构，小王和大王可以分别用14、15表示 ）- 3个玩家  user_list &#x3D; [&quot;alex&quot;,&quot;武沛齐&quot;,&quot;李路飞&quot;]- 发牌规则  - 默认先给用户发一张牌，其中 J、Q、K、小王、大王代表的值为0.5，其他就是则就是当前的牌面值。  - 用户根据自己的情况判断是否继续要牌。    - 要，则再给他发一张。    - 不要，则开始给下个玩家发牌。  - 如果用户手中的所有牌相加大于11，则表示爆了，此人的分数为0，并且自动开始给下个人发牌。- 最终计算并获得每个玩家的分值，例如：result &#x3D; &#123;&quot;alex&quot;:8,&quot;武沛齐&quot;:9,&quot;李路飞&quot;:0&#125;&#39;&#39;&#39;import random# 1.生成一副扑克牌cards_num &#x3D; []for i in range(1, 11):    cards_num.append(str(i))cards_num.extend([&#39;J&#39;, &#39;Q&#39;, &#39;K&#39;])  # 12345678910JQKcards_col &#x3D; [&#39;♠&#39;, &#39;♥&#39;, &#39;♦&#39;, &#39;♣&#39;]cards_list &#x3D; []for color in cards_col:    for index in range(len(cards_num)):        # 将得分附到牌的后面 [&#39;♠&#39;, &#39;1&#39;, 1]        if index &gt; 9:            cards &#x3D; [color, cards_num[index], 0.5]            cards_list.append(cards)            continue        cards &#x3D; [color, cards_num[index], index + 1]        cards_list.append(cards)# 加入大小王cards_list.extend([[&#39;大&#39;, &#39;王&#39;, 0.5], [&#39;小&#39;, &#39;王&#39;, 0.5]])user_list &#x3D; [&quot;alex&quot;, &quot;武沛齐&quot;, &quot;李路飞&quot;]result &#x3D; &#123;&#125;for player in user_list:    # 每一个玩家，重置分数，打印提示语句    score &#x3D; 0    print(&#39;hello,&#123;&#125;! welcome to our game&#39;.center(50, &#39;*&#39;).format(player))    while True:        # 给该玩家发牌，打印提示，加上分数，删除该牌        draw_card &#x3D; random.sample(cards_list, 1)[0]        print(&#39;The cards you draw are:&#123;&#125;&#39;.format(draw_card[:2]))        score +&#x3D; draw_card[-1]        cards_list.remove(draw_card)        print(score)        if score &gt; 11:            score &#x3D; 0            break        # 询问是否继续        user_input &#x3D; input(&#39;do you want to continue(输入要或不要): &#39;)        # 非法输入退出        if user_input !&#x3D; &#39;不要&#39; and user_input !&#x3D; &#39;要&#39;:            exit(&#39;input wrong&#39;)        # 输入不要结束本次循环        if user_input &#x3D;&#x3D; &#39;不要&#39;:            break        # 输入要，抽排，计算得分，去掉抽到的牌        else:            continue    result[player] &#x3D; scoreprint(result)</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 第一阶段 </tag>
            
            <tag> python基础 </tag>
            
            <tag> 考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块1--day2</title>
      <link href="/2022/05/23/python-mo-kuai-yi-day2/"/>
      <url>/2022/05/23/python-mo-kuai-yi-day2/</url>
      
        <content type="html"><![CDATA[<h2 id="六、-数据类型（上）"><a href="#六、-数据类型（上）" class="headerlink" title="六、 数据类型（上）"></a>六、 数据类型（上）</h2><p>接下来的3天的课程都是来讲解数据类型的知识点，常见的数据类型：</p><ul><li>int，整数类型（整形）</li><li>bool，布尔类型</li><li>str，字符串类型</li><li>list，列表类型</li><li>tuple，元组类型</li><li>dict，字典类型</li><li>set，集合类型</li><li>float，浮点类型（浮点型）</li></ul><p>每种数据类型都有自己的特点及应用场景，以后的开发中需要根据实际的开发情况选择合适的数据类型。</p><img src="/2022/05/23/python-mo-kuai-yi-day2/image-20201102172217820.png" class=""><p>每种数据类型的讲解，会按照以下4个维度来进行：</p><ol><li>定义</li><li>独有功能</li><li>公共功能</li><li>类型转换</li><li>其他</li></ol><p>今日课程目标：掌握整形、布尔类型、字符串的必备知识。</p><p>今日课程概要：</p><ul><li>整形</li><li>布尔类型</li><li>字符串类型</li></ul><h3 id="1-整型"><a href="#1-整型" class="headerlink" title="1.整型"></a>1.整型</h3><p>​整型其实就是十进制整数的统称，比如：1、68、999都属于整型。他一般用于表示 年龄、序号等。</p><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><pre class="language-python" data-language="python"><code class="language-python">number &#x3D; 10age &#x3D; 99</code></pre><h4 id="1-2-独有功能"><a href="#1-2-独有功能" class="headerlink" title="1.2 独有功能"></a>1.2 独有功能</h4><p>无</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 5print(bin(v1))  # 0b101# 调用v1（int）的独有功能，获取v1的二进制有多少个位组成。result1 &#x3D; v1.bit_length()print(result1)  # 3v2 &#x3D; 10print(bin(10))  # 0b1010# 调用v2（int）的独有功能，获取v2的二进制有多少个位组成。result2 &#x3D; v2.bit_length()print(result2)  # 4</code></pre><h4 id="1-3-公共功能"><a href="#1-3-公共功能" class="headerlink" title="1.3 公共功能"></a>1.3 公共功能</h4><p>加减乘除</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 4v2 &#x3D; 8v3 &#x3D; v1 + v2</code></pre><h4 id="1-4-转换"><a href="#1-4-转换" class="headerlink" title="1.4 转换"></a>1.4 转换</h4><p>在项目开发和面试题中经常会出现一些<font color="#dd0000">“字符串” 和 布尔值 </font> 转换为 整型的情况。</p><pre class="language-python" data-language="python"><code class="language-python"># 布尔值转整型n1 &#x3D; int(True)  # True转换为整数 1n2 &#x3D; int(False) # False转换为整数 0# 字符串转整型v1 &#x3D; int(&quot;186&quot;,base&#x3D;10) # 把字符串看成十进制的值，然后再转换为 十进制整数，结果：v1 &#x3D; 186v2 &#x3D; int(&quot;0b1001&quot;,base&#x3D;2) # 把字符串看成二进制的值，然后再转换为 十进制整数，结果：v1 &#x3D; 9 (0b表示二进制)v3 &#x3D; int(&quot;0o144&quot;,base&#x3D;8)  # 把字符串看成八进制的值，然后转换为 十进制整数，结果：v1 &#x3D; 100 (0o表示八进制)v4 &#x3D; int(&quot;0x59&quot;,base&#x3D;16)  # 把字符串看成十六进制的值，然后转换为 十进制整数，结果：v1 &#x3D; 89 （0x表示十六进制）# 浮点型（小数）v1 &#x3D; int(8.7) # 8</code></pre><p>​所以，如果以后别人给你一个按 二进制、八进制、十进制、十六进制 规则存储的字符串时，可以轻松的通过int转换为十进制的整数。</p><h4 id="1-5-其他"><a href="#1-5-其他" class="headerlink" title="1.5 其他"></a>1.5 其他</h4><h5 id="1-5-1-长整型"><a href="#1-5-1-长整型" class="headerlink" title="1.5.1 长整型"></a>1.5.1 长整型</h5><ul><li>Python3：整型（无限制）</li><li>Python2：整型、长整形</li></ul><p>在python2中跟整数相关的数据类型有两种：int(整型)、long（长整型），他们都是整数只不过能表示的值范围不同。</p><img src="Python模块一day2/image-20201102190227431.png" alt="image-20201102190227431" style="zoom:50%;" /><ul><li>int，可表示的范围：-9223372036854775808～9223372036854775807</li><li>long，整数值超出int范围之后自动会转换为long类型（无限制）。</li></ul><p>在python3中去除了long只剩下：int（整型），并且 int 长度不在限制。</p><h5 id="1-5-2-地板除"><a href="#1-5-2-地板除" class="headerlink" title="1.5.2 地板除"></a>1.5.2 地板除</h5><ul><li><p>Py3：</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 9&#x2F;2 print(v1) # 4.5</code></pre></li><li><p>py2:</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 9&#x2F;2 print(v1) # 4</code></pre><pre class="language-python" data-language="python"><code class="language-python">from __future__ import division v1 &#x3D; 9&#x2F;2 print(v1) # 4.5</code></pre></li></ul><h3 id="2-布尔类型"><a href="#2-布尔类型" class="headerlink" title="2. 布尔类型"></a>2. 布尔类型</h3><p>​布尔值，其实就是 “真”、“假” 。</p><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; Falsealex_is_sb &#x3D; True</code></pre><h4 id="2-2-独有功能"><a href="#2-2-独有功能" class="headerlink" title="2.2 独有功能"></a>2.2 独有功能</h4><p>无</p><h4 id="2-3-公共功能"><a href="#2-3-公共功能" class="headerlink" title="2.3 公共功能"></a>2.3 公共功能</h4><p>无</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; True + Trueprint(v1) # 2</code></pre><h4 id="2-4-转换"><a href="#2-4-转换" class="headerlink" title="2.4 转换"></a>2.4 转换</h4><p>​在以后的项目开发中，会经常使用其他类型转换为布尔值的情景，此处只要记住一个规律即可。</p><pre class="language-python" data-language="python"><code class="language-python">整数0、空字符串、空列表、空元组、空字典转换为布尔值时均为False其他均为True</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 练习题：查看一些变量为True还是Falsev1 &#x3D; bool(0)  v2 &#x3D; bool(-10)v3 &#x3D; bool(10)v4 &#x3D; bool(&quot;武沛齐&quot;)v5 &#x3D; bool(&quot;&quot;)v6 &#x3D; bool(&quot; &quot;)v7 &#x3D; bool([]) # [] 表示空列表v8 &#x3D; bool([11，22，33]) # [11，22，33] 表示非空列表v9 &#x3D; bool(&#123;&#125;) # &#123;&#125; 表示空字典v10 &#x3D; bool(&#123;&quot;name&quot;:&quot;武沛齐&quot;,&quot;age&quot;:18&#125;) # &#123;&quot;name&quot;:&quot;武沛齐&quot;,&quot;age&quot;:18&#125; 表示非空字典</code></pre><h4 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="2.5 其他"></a>2.5 其他</h4><h5 id="2-5-1-做条件自动转换"><a href="#2-5-1-做条件自动转换" class="headerlink" title="2.5.1 做条件自动转换"></a>2.5.1 做条件自动转换</h5><p>​如果在 <code>if</code> 、<code>while</code> 条件后面写一个值当做条件时，他会默认转换为布尔类型，然后再做条件判断。</p><pre class="language-python" data-language="python"><code class="language-python">if 0:print(&quot;太六了&quot;)else:  print(999)if &quot;武沛齐&quot;:print(&quot;你好&quot;)if &quot;alex&quot;:print(&quot;你是傻逼？&quot;)else:print(&quot;你是逗比？&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">if 值:  passwhile 值:  pass</code></pre><h3 id="3-字符串类型"><a href="#3-字符串类型" class="headerlink" title="3.字符串类型"></a>3.字符串类型</h3><p>​字符串，我们平时会用他来表示文本信息。例如：姓名、地址、自我介绍等。</p><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;包治百病&quot;v2 &#x3D; &#39;包治百病&#39;v3 &#x3D; &quot;包&#39;治百病&quot;v4 &#x3D; &#39;包&quot;治百病&#39;v5 &#x3D; &quot;&quot;&quot;吵架都是我的错，因为大家打不过。&quot;&quot;&quot;# 三个引号，可以支持多行&#x2F;换行表示一个字符串，其他的都只能在一行中表示一个字符串。</code></pre><h4 id="3-2-独有功能（18-x2F-48）"><a href="#3-2-独有功能（18-x2F-48）" class="headerlink" title="3.2 独有功能（18&#x2F;48）"></a>3.2 独有功能（18&#x2F;48）</h4><pre class="language-python" data-language="python"><code class="language-python">&quot;xxxxx&quot;.功能(...)v1 &#x3D; &quot;xxxxx&quot;v1.功能(...)</code></pre><ol><li><p>str.startswith()  判断字符串是否以 XX 开头？得到一个布尔值</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;叨逼叨的一天，烦死了&quot;# Trueresult &#x3D; v1.startswith(&quot;叨逼叨的一天&quot;)print(result) # 值为True</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例v1 &#x3D; input(&quot;请输入住址：&quot;)if v1.startswith(&quot;北京市&quot;):print(&quot;北京人口&quot;)else:print(&quot;非北京人口&quot;)</code></pre></li><li><p>str.endswith()  判断字符串是否以 XX 结尾？得到一个布尔值</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;叨逼叨的一天，烦死了&quot;result &#x3D; v1.endswith(&quot;烦死了&quot;)print(result) # 值为True</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例address &#x3D; input(&quot;请输入地址：&quot;)if address.endswith(&#39;村&#39;):print(&quot;农业户口&quot;)else:print(&quot;非农户口&quot;)</code></pre></li><li><p>str.isdecimal()  判断字符串是否为十进制数？得到一个布尔值</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;1238871&quot;result &#x3D; v1.isdecimal()print(result) # True</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例,两个数相加。v1 &#x3D; input(&quot;请输入值：&quot;) # ”666“v2 &#x3D; input(&quot;请输入值：&quot;) # ”999“if v1.isdecimal() and v2.isdecimal():data &#x3D; int(v1) + int(v2)print(data)else:print(&quot;请正确输入数字&quot;)</code></pre><p><font color="#dd0000">为什么不用isdigit() </font></p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;123&quot;print(v1.isdecimal()) # Truev2 &#x3D; &quot;①&quot;print(v2.isdecimal()) # Falsev3 &#x3D; &quot;123&quot;print(v3.isdigit()) # Truev4 &#x3D; &quot;①&quot;print(v4.isdigit()) # True</code></pre></li><li><p>str.strip()  去除字符串两边的 空格、换行符、制表符，得到一个新字符串</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; input(&quot;请输入内容：&quot;) # &#39;武沛齐   &#39; print(data)</code></pre><pre class="language-python" data-language="python"><code class="language-python">msg &#x3D; &quot; H e ll o啊，树哥 &quot;data &#x3D; msg.strip()print(data) # 将msg两边的空白去掉，得到&quot;H e ll o啊，树哥&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">msg &#x3D; &quot; H e ll o啊，树哥 &quot;data &#x3D; msg.lstrip()print(data) # 将msg两边的空白去掉，得到&quot;H e ll o啊，树哥 &quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">msg &#x3D; &quot; H e ll o啊，树哥 &quot;data &#x3D; msg.rstrip()print(data) # 将msg两边的空白去掉，得到&quot; H e ll o啊，树哥&quot;</code></pre><p><strong>补充：去除 空格、换行符、制表符。</strong></p><pre class="language-python" data-language="python"><code class="language-python"># 案例code &#x3D; input(&quot;请输入4位验证码：&quot;) #&#39; FB87 &#39;   data &#x3D; code.strip()if data &#x3D;&#x3D; &quot;FB87&quot;:print(&#39;验证码正确&#39;)else:print(&quot;验证码错误&quot;)</code></pre><p><strong>再补充：str.lstrip()  去除字符串两边指定的内容</strong></p><pre class="language-python" data-language="python"><code class="language-python">msg &#x3D; &quot;哥H e ll o啊，树哥&quot;data &#x3D; msg.strip(&quot;哥&quot;)print(data) # 将msg两边的空白去掉，得到&quot;H e ll o啊，树&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">msg &#x3D; &quot;哥H e ll o啊，树哥&quot;data &#x3D; msg.lstrip(&quot;哥&quot;)print(data) # 将msg两边的空白去掉，得到&quot;H e ll o啊，树哥&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">msg &#x3D; &quot;哥H e ll o啊，树哥&quot;data &#x3D; msg.rstrip(&quot;哥&quot;)print(data) # 将msg两边的空白去掉，得到&quot;哥H e ll o啊，树&quot;</code></pre></li><li><p>str.upper()  字符串变大写，得到一个新字符串</p><pre class="language-python" data-language="python"><code class="language-python">msg &#x3D; &quot;my name is oliver queen&quot;data &#x3D; msg.upper()print(msg) # my name is oliver queenprint(data) # 输出为：MY NAME IS OLIVER QUEEN</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例code &#x3D; input(&quot;请输入4位验证码：&quot;) #  &#39; FB88 &#39;   &#39;  fb88&#39; value &#x3D; code.upper() #  &#39;  FB88&#39;  data &#x3D; value.strip() # &#39;FB88&#39;if data &#x3D;&#x3D; &quot;FB87&quot;:print(&#39;验证码正确&#39;)else:print(&quot;验证码错误&quot;)  # 注意事项&quot;&quot;&quot;code的值&quot;  fb88&quot;value的值&quot;  FB88&quot;data的值&quot;FB88&quot;&quot;&quot;&quot;</code></pre></li><li><p>str.lower()  字符串变小写，得到一个新字符串</p><pre class="language-python" data-language="python"><code class="language-python">msg &#x3D; &quot;My Name Is Oliver Queen&quot;data &#x3D; msg.lower()print(data) # 输出为：my name is oliver queen</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例code &#x3D; input(&quot;请输入4位验证码：&quot;)value &#x3D; code.strip().lower()if value &#x3D;&#x3D; &quot;fb87&quot;:print(&#39;验证码正确&#39;)else:print(&quot;验证码错误&quot;)</code></pre></li><li><p>str.replace()  字符串内容替换，得到一个新的字符串</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &quot;你是个好人，但是好人不合适我&quot;value &#x3D; data.replace(&quot;好人&quot;,&quot;贱人&quot;)print(data)  # &quot;你是个好人，但是好人不合适我&quot;print(value) # &quot;你是个贱人，但是贱人不合适我&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例video_file_name &#x3D; &quot;高清无码爱情动作片.mp4&quot;new_file_name &#x3D; video_file_name.replace(&quot;mp4&quot;,&quot;avi&quot;) # &quot;高清无码爱情动作片.avi&quot;final_file_name &#x3D; video_file_name.replace(&quot;无码&quot;,&quot;步兵&quot;) # &quot;高清步兵爱情动作片.mp4&quot;print(final_file_name)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例content &#x3D; input(&quot;请输入评论信息&quot;) # alex是一个草包content &#x3D; content.replace(&quot;草&quot;,&quot;**&quot;) # alex是一个**包content &#x3D; content.replace(&quot;泥马&quot;,&quot;***&quot;) # alex是一个**包print(content) # alex是一个**包</code></pre><pre class="language-python" data-language="python"><code class="language-python">char_list &#x3D; [&quot;草拟吗&quot;,&quot;逗比&quot;,&quot;二蛋&quot;,&quot;钢球&quot;]content &#x3D; input(&quot;请输入评论信息&quot;)for item in char_list:  content &#x3D; content.repalce(item,&quot;**&quot;)print(content)</code></pre></li><li><p>str.split()  字符串切割，得到一个列表</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &quot;武沛齐|root|wupeiqi@qq.com&quot;result &#x3D; data.split(&#39;|&#39;) # [&quot;武沛齐&quot;,&quot;root&quot;,&quot;wupeiqi@qq.com&quot;]print(data) # &quot;武沛齐|root|wupeiqi@qq.com&quot;print(result) # 输出 [&quot;武沛齐&quot;,&quot;root&quot;,&quot;wupeiqi@qq.com&quot;] 根据特定字符切开之后保存在列表中，方便以后的操作</code></pre><pre class="language-python" data-language="python"><code class="language-python">&lt;font color&#x3D;&quot;#dd0000&quot;&gt;&quot;字符串&quot; 和 布尔值 &lt;&#x2F;font&gt; # 案例：判断用户名密码是否正确info &#x3D; &quot;武沛齐,root&quot;   # 备注：字符串中存储了用户名和密码user_list &#x3D; info.split(&#39;,&#39;)    # 得到一个包含了2个元素的列表 [ &quot;武沛齐&quot; , &quot;root&quot; ]user &#x3D; input(&quot;请输入用户名：&quot;)pwd &#x3D; input(&quot;请输入密码：&quot;)if user &#x3D;&#x3D; user_list[0] and pwd &#x3D;&#x3D; user_list[1]:print(&quot;登录成功&quot;)else:print(&quot;用户名或密码错误&quot;)</code></pre><p><font color="#dd0000">扩展：只切遇到的前第n个 </font> </p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &quot;武沛齐|root|wupeiqi@qq.com&quot;v1 &#x3D; data.split(&quot;|&quot;)   # [&#39;武沛齐&#39;, &#39;root&#39;, &#39;wupeiqi@qq.com&#39;]print(v1)v2 &#x3D; data.split(&quot;|&quot;, 1) # [&#39;武沛齐&#39;, &#39;root|wupeiqi@qq.com&#39;]print(v2)</code></pre><p><font color="#dd0000">再扩展：从右向左切 </font> </p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &quot;武沛齐,root,wupeiqi@qq.com&quot;v1 &#x3D; data.rsplit(&#39;,&#39;)print(v1) # [&#39;武沛齐&#39;, &#39;root&#39;, &#39;wupeiqi@qq.com&#39;]v2 &#x3D; data.rsplit(&#39;,&#39;,1)print(v2) # [&#39;武沛齐,root&#39;, &#39;wupeiqi@qq.com&#39;]</code></pre><p><strong>应用场景：找路径拓展名</strong></p><pre class="language-python" data-language="python"><code class="language-python">file_path &#x3D; &quot;xxx&#x2F;xxxx&#x2F;xx.xx&#x2F;xxx.mp4&quot;data_list &#x3D; file_path.rsplit(&quot;.&quot;,1) # [&quot;xxx&#x2F;xxxx&#x2F;xx.xx&#x2F;xxx&quot;,&quot;mp4&quot;]data_list[1]  # 路径拓展名</code></pre></li><li><p>str.join()  字符串拼接，得到一个新的字符串</p><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [&quot;alex&quot;,&quot;是&quot;,&quot;大烧饼&quot;]v1 &#x3D; &quot;_&quot;.join(data_list) # alex_是_大烧饼print(v1)</code></pre></li><li><p>str.format()  格式化字符串，得到新的字符串</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;&#123;0&#125;的喜欢干很多行业，例如有：&#123;1&#125;、&#123;2&#125; 等&quot;data &#x3D; name.format(&quot;老王&quot;,&quot;护士&quot;,&quot;嫩模&quot;)print(data) # 老王的喜欢干很多行业，例如有：护士、嫩模 等print(name) # &quot;&#123;0&#125;的喜欢干很多行业，例如有：&#123;1&#125;、&#123;2&#125; 等&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;&#123;&#125;的喜欢干很多行业，例如有：&#123;&#125;、&#123;&#125; 等&quot;data &#x3D; name.format(&quot;老王&quot;,&quot;护士&quot;,&quot;嫩模&quot;)print(data) # 老王的喜欢干很多行业，例如有：护士、嫩模 等</code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;&#123;name&#125;的喜欢干很多行业，例如有：&#123;h1&#125;、&#123;h2&#125; 等&quot;data &#x3D; name.format(name&#x3D;&quot;老王&quot;,h1&#x3D;&quot;护士&quot;,h2&#x3D;&quot;嫩模&quot;)print(data) # 老王的喜欢干很多行业，例如有：护士、嫩模 等</code></pre></li><li><p>str.encode()  字符串转换为字节类型</p><p>str.decode()  字节类型转换为字符串</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &quot;嫂子&quot;  # unicode，字符串类型v1 &#x3D; data.encode(&quot;utf-8&quot;)  # utf-8，字节类型v2 &#x3D; data.encode(&quot;gbk&quot;)  # gbk，字节类型print(v1)  # b&#39;\xe5\xab\x82 \xe5\xad\x90&#39;print(v2)  # b&#39;\xc9\xa9 \xd7\xd3&#39;s1 &#x3D; v1.decode(&quot;utf-8&quot;)s2 &#x3D; v2.decode(&quot;gbk&quot;)print(s1)  # 嫂子print(s2)  # 嫂子</code></pre></li><li><p>str.center()  str.ljust()  str.rjust()  将字符串内容居中、居左、居右展示</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;王老汉&quot;# data &#x3D; v1.center(21, &quot;-&quot;)# print(data) #---------王老汉---------# data &#x3D; v1.ljust(21, &quot;-&quot;)# print(data) # 王老汉------------------# data &#x3D; v1.rjust(21, &quot;-&quot;)# print(data) # ------------------王老汉</code></pre></li><li><p>str.zfill() 帮助你填充0</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &quot;alex&quot;v1 &#x3D; data.zfill(10)print(v1) # 000000alex</code></pre><p><strong>应用场景：处理二进制数据</strong></p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &quot;101&quot; # &quot;00000101&quot;v1 &#x3D; data.zfill(8)print(v1) # &quot;00000101&quot;</code></pre></li></ol><p><strong>练习题</strong></p><ol><li><p>写代码实现判断用户输入的值否以 “al”开头,如果是则输出 “是的” 否则 输出 “不是的”</p><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; input(&#39;please input a name: &#39;)data &#x3D; text.strip().startswith(&#39;al&#39;)if data:    print(&#39;Yes&#39;)else:    print(&#39;Noo&#39;)</code></pre></li><li><p>写代码实现判断用户输入的值否以”Nb”结尾,如果是则输出 “是的” 否则 输出 “不是的”</p><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; input(&#39;please input a name: &#39;)data &#x3D; text.strip().endswith(&#39;NB&#39;)if data:    print(&#39;Yes&#39;)else:    print(&#39;Noo&#39;)</code></pre></li><li><p>将 name 变量对应的值中的 所有的”l”替换为 “p”,并输出结果</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &#39;耿|天|霸&#39;new_name &#x3D; name.replace(&#39;|&#39;, &#39;p&#39;)print(new_name)</code></pre></li><li><p>写代码实现对用户输入的值判断，是否为整数，如果是则转换为整型并输出，否则直接输出”请输入数字”</p><pre class="language-python" data-language="python"><code class="language-python">user_input &#x3D; input(&#39;please input a number: &#39;)data &#x3D; user_input.strip()if data.isdecimal():    print(int(data))else:    print(&#39;wrong type&#39;)</code></pre></li><li><p>对用户输入的数据使用”+”切割，判断输入的值是否都是数字？<br>提示：用户输入的格式必须是以下+连接的格式，如 5+9 、alex+999</p><pre class="language-python" data-language="python"><code class="language-python">user_input &#x3D; input(&#39;please input a string link with &quot;+&quot;: &#39;)data &#x3D; user_input.strip().split(&#39;+&#39;)  # [&#39;5&#39;, &#39;9&#39;]if data[0].isdecimal and data[1].isdecimal():    print(data)else:    print(&#39;wrong type&#39;)</code></pre></li><li><p>写代码实现一个整数加法计算器(两个数相加)<br>需求：提示用户输入：5 + 9 ,计算出两个值的和（提示：先分割再去空白再转换为整型，再相加）</p><pre class="language-python" data-language="python"><code class="language-python">user_input &#x3D; input(&#39;please input a string link with &quot;+&quot;: &#39;)data &#x3D; user_input.split(&#39;+&#39;)data[0] &#x3D; data[0].strip()data[1] &#x3D; data[1].strip()if data[0].isdecimal and data[1].isdecimal():    print(int(data[0]) + int(data[1]))else:    print(&#39;wrong type&#39;)</code></pre></li><li><p>补充代码实现用户认证。<br>需求：提示用户输入手机号、验证码，全都验证通过之后才算登录成功（验证码大小写不敏感）</p><pre class="language-python" data-language="python"><code class="language-python">import randomcode &#x3D; random.randrange(1000,9999) # 生成动态验证码msg &#x3D; &quot;欢迎登录PythonAV系统，您的验证码为：&#123;&#125;,手机号为：&#123;&#125;&quot;.format(code,&quot;15131266666&quot;)print(msg)# 请补充代码log_phone &#x3D; input(&#39;please input your phone: &#39;).strip()log_code &#x3D; input(&#39;please input your code: &#39;).strip()if log_phone &#x3D;&#x3D; &quot;15131266666&quot; and log_code &#x3D;&#x3D; str(code):    print(&#39;login successful&#39;)else:    print(&#39;phone_number or code wrong&#39;)</code></pre></li><li><p>补充代码实现数据拼接</p><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; []while True:    hobby &#x3D; input(&quot;请输入你的爱好（Q&#x2F;q退出）：&quot;)    if hobby.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    # 把输入的值添加到 data_list 中，如：data_list &#x3D; [&quot;小姨子&quot;,&quot;哥们的女朋友&quot;]    data_list.append(hobby)     # 将所有的爱好通过符号 &quot;、&quot;拼接起来并输出print(&#39;、&#39;.join(data_list))</code></pre></li></ol><h4 id="3-3-公共功能"><a href="#3-3-公共功能" class="headerlink" title="3.3 公共功能"></a>3.3 公共功能</h4><ol><li><p>相加：字符串 + 字符串</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;alex&quot; + &quot;大sb&quot;print(v1)</code></pre></li><li><p>相乘：字符串 * 整数</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &quot;嫂子&quot; * 3print(data) # 嫂子嫂子嫂子</code></pre></li><li><p>运算符in包含<br>由于字符串内部是由多个元素组成，可以通过in来判断元素是否在字符串中。</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &quot;嫂子满身大汉&quot;print(&#39;子&#39; in data)  # True</code></pre></li><li><p>长度</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &quot;嫂子满身大汉&quot;value &#x3D; len(data) print(value) # 6</code></pre></li><li><p>获取字符串中的字符，索引</p><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;来做点py交易呀&quot;#          0 1 2345 6 7#           ... -3 -2 -1print(message[0]) # &quot;来&quot;print(message[1]) # &quot;做&quot;print(message[2]) # &quot;点&quot;print(message[-1]) # 呀print(message[-2]) # 易print(message[-3]) # 交</code></pre><p>​<font color="#dd0000">注意：字符串中是能通过索引取值，无法修改值。【字符串在内部存储时不允许对内部元素修改，想修改只能重新创建。】 </font> </p><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;来做点py交易呀&quot;index &#x3D; 0while index &lt; len(message):value &#x3D; message[index]    print(value)    index +&#x3D; 1</code></pre><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;来做点py交易呀&quot;index &#x3D; len(message) - 1  # 索引号比长度小1，索引号从0开始，长度从1开始while index &gt;&#x3D;0:    value &#x3D; message[index]    print(value)    index -&#x3D; 1</code></pre></li><li><p>获取字符串中的子序列，切片</p><pre class="language-python" data-language="python"><code class="language-python">xxxxxxxxxx message &#x3D; &quot;来做点py交易呀&quot;print(message[0:2]) # &quot;来做&quot;print(message[3:7]) # &quot;py交易&quot;print( message[3:] ) # &quot;py交易呀&quot;print( message[:5] ) # &quot;来做点py&quot;print(message[4:-1]) # &quot;y交易&quot;print(message[4:-2]) # &quot;y交&quot;print( message[4:len(message)] ) # &quot;y交易呀&quot;</code></pre><p>​<font color="#dd0000">注意：字符串中的切片只能读取数据，无法修改数据。【字符串在内部存储时不允许对内部元素修改，想要修改只能重新创建】 </font> </p><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;来做点py交易呀&quot;value &#x3D; message[:3] + &quot;Python&quot; + message[5:]print(value)</code></pre></li><li><p>步长，跳着去字符串的内容</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;生活不是电影，生活比电影苦&quot;print( name[ 0:5:2 ] )   # 输出：生不电 【前两个值表示区间范围，最有一个值表示步长】print( name[ :8:2 ] )    # 输出：生不电，  【区间范围的前面不写则表示起始范围为0开始】、print( name[ 2::3 ] )    # 输出：不影活影print( name[ 2::3 ] )    # 输出：不电，活电苦 【区间范围的后面不写则表示结束范围为最后】print( name[ ::2 ] )     # 输出：生不电，活电苦 【区间范围不写表示整个字符串】print( name[ 8:1:-1 ] )  # 输出：活生，影电是不 【倒序】</code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;生活不是电影，生活比电影苦&quot;print(name[8:1:-1])  # 输出：活生，影电是不 【倒序】print(name[-1:1:-1])  # 输出：苦影电比活生，影电是不 【倒序】# 面试题：给你一个字符串，请将这个字符串翻转。</code></pre><p>​<font color="#dd0000"><strong>面试题：给你一个字符串，请将这个字符串翻转</strong> </font> </p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;生活不是电影，生活比电影苦&quot;value &#x3D; name[-1::-1]print(value)  # 苦影电比活生，影电是不活生</code></pre></li><li><p>循环</p><ul><li><p>while循环</p><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;来做点py交易呀&quot;index &#x3D; 0while index &lt; len(message):value &#x3D; message[index]    print(value)    index +&#x3D; 1</code></pre></li><li><p>for循环</p><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;来做点py交易呀&quot;for char in message:    print(char)</code></pre></li><li><p>range，帮助我们创建一系列的数字</p><pre class="language-python" data-language="python"><code class="language-python">range(10) # [0,1,2,3,4,5,6,7,8,9]range(1,10) # [1,2,3,4,5,6,7,8,9]range(1,10,2) # [1,3,5,7,9]range(10,1,-1) # [10,9,8,7,6,5,4,3,2]</code></pre></li><li><p>for + range</p><pre class="language-python" data-language="python"><code class="language-python">for i in range(10):    print(i)</code></pre><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;来做点py交易呀&quot;for i in range(5): # [0,1,2,3,4]    print(message[i])</code></pre><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;来做点py交易呀&quot;for i in range( len(message) ): # [0,1,2,3,4,5,6,7]    print(message[i])</code></pre></li></ul><p>一般应用场景：</p><ul><li><p><font color="#dd0000"><strong>while，一般在做无限制（未知）循环此处时使用.</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">while True:    ...</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 用户输入一个值，如果不是整数则一直输入，直到是整数了才结束。num &#x3D; 0while True:    data &#x3D; input(&quot;请输入内容:&quot;)    if data.isdecimal():        num &#x3D; int(data)        breakelse:        print(&quot;输入错误，请重新输入！&quot;)</code></pre></li><li><p><font color="#dd0000"><strong>for循环，一般应用在已知的循环数量的场景。</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;来做点py交易呀&quot;for char in message:    print(char)</code></pre><pre class="language-python" data-language="python"><code class="language-python">for i in range(30):    print(message[i])</code></pre></li><li><p>break和continue关键字</p><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;来做点py交易呀&quot;for char in message:    if char &#x3D;&#x3D; &quot;p&quot;:        continue    print(char)# 输出：来做点y交易呀</code></pre><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;来做点py交易呀&quot;for char in message:    if char &#x3D;&#x3D; &quot;p&quot;:        break    print(char)# 输出：来做点</code></pre><pre class="language-python" data-language="python"><code class="language-python">for i in range(5):    print(i)# 0 1 2 3 4    for j in range(3):               print(j) # 0 1 2  # 0 1 2  # 0 1 2  # 0 1 2  # 0 1 2  </code></pre></li></ul></li></ol><h4 id="3-4-转换"><a href="#3-4-转换" class="headerlink" title="3.4 转换"></a>3.4 转换</h4><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 999data &#x3D; str(num)print(data) # &quot;999&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [&quot;alex&quot;,&quot;eric&quot;,999]data &#x3D; str(data_list)print(data) # &#39;[&quot;alex&quot;,&quot;eric&quot;,999]&#39;</code></pre><p>​<font color="#dd0000">一般情况下，只有整型转字符串才有意义。</font></p><h4 id="3-5-其他-字符串不可被修改"><a href="#3-5-其他-字符串不可被修改" class="headerlink" title="3.5 其他-字符串不可被修改"></a>3.5 其他-字符串不可被修改</h4><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;name[1]name[1:2]</code></pre><pre class="language-python" data-language="python"><code class="language-python">num_list &#x3D; [11,22,33]num_list[0]num_list[0] &#x3D; 666</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>整型在Python2和Python3中的区别？</p><pre class="language-python" data-language="python"><code class="language-python">Python2中的整型- 长整型    - 短整型Python3中的整型：所有整数</code></pre></li><li><p>进制之间的转换。</p><pre class="language-python" data-language="python"><code class="language-python">- 其它进制转为十进制- 二进制转十进制： int(&#39;0b...&#39;, base&#x3D;2)    - 八进制转十进制： int(&#39;0o...&#39;, base&#x3D;8)    - 十六进制转十进制： int(&#39;0x...&#39;, base&#x3D;16)- 十进制转其它进制    - 十进制转二进制： bin()    - 十进制转八进制： oct()    - 十进制转十六进制： hex()   </code></pre></li><li><p>其他类型转换为布尔类型时，空和0为False，其他均为True。</p></li><li><p>条件语句中可自动化转换布尔类型来做判断。</p><pre class="language-python" data-language="python"><code class="language-python">if &quot;武沛齐&quot;:    print(666)else:    print(999)</code></pre></li><li><p>字符串中常见的独有功能。</p><pre class="language-python" data-language="python"><code class="language-python">str.startswith()  # 判断字符串是否以 XX 开头？得到一个布尔值str.endswith()  # 判断字符串是否以 XX 结尾？得到一个布尔值str.isdecimal()  # 判断字符串是否为十进制数？得到一个布尔值str.strip()  # 去除字符串两边的 空格、换行符、制表符，得到一个新字符串    lstrip()、rstrip()str.upper()  # 字符串变大写，得到一个新字符串    str.lower()str.replace()  # 字符串内容替换，得到一个新的字符串str.split()  # 字符串切割，得到一个列表    lsplit()、rsplit()str.join()  # 字符串拼接，得到一个新的字符串str.format()  # 格式化字符串，得到新的字符串str.encode()  # 字符串转换为字节类型str.decode()  # 字节类型转换为字符串str.center()  str.ljust()  str.rjust()  # 将字符串内容居中、居左、居右展示str.zfill() # 帮助你填充0</code></pre></li><li><p>字符串中常见的公共功能。</p><pre class="language-python" data-language="python"><code class="language-python">1、相加：字符串 + 字符串2、相乘：字符串 * 整数3、长度4、获取字符串中的字符，索引5、获取字符串中的子序列，切片6、步长，跳着去字符串的内容7、循环</code></pre></li><li><p><font color="#dd0000">字符串创建之后是不可以被修改的。</font></p></li></ol><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol><li><p>请用代码实现如下进制的转换。</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 675          # 请将v1转换为二进制（字符串类型）。v2 &#x3D; &quot;0b11000101&quot; # 请将二进制v2转换为十进制（整型）v3 &#x3D; &quot;11000101&quot;   # 请将二进制v3转换为十进制（整型）</code></pre><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 675v1_bin &#x3D; bin(675)print(v1_bin)  # 1010100011v2 &#x3D; &quot;0b11000101&quot;v2_int &#x3D; int(v2, base&#x3D;2)print(v2_int)  # 197v3 &#x3D; &quot;11000101&quot;v3_int &#x3D; int(v3, base&#x3D;2)print(v3_int)  # 197</code></pre></li><li><p>按要求实现</p><blockquote><p>现有 <code>v1=123</code> 和 <code>v2=456</code>，请将这两个值转换为二进制，并将其二进制中的前缀 0b 去掉，然后将两个二进制拼接起来，最终再转换为整型（十进制）。</p><p>例如：</p><p>​123  对应二进制为  “0b1111011” ，去除前缀0b之后的二进制为 “1111011”</p><p>​456  对应二进制为  “0b111001000” ，去除前缀0b之后的二进制为 “111001000”</p><p>​将两个二进制拼接起来的值为：”1111011111001000”，再将此值转换为整型为：63432</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 123v2 &#x3D; 456v1_bin &#x3D; bin(v1)v2_bin &#x3D; bin(v2)value &#x3D; v1_bin.lstrip(&#39;0b&#39;) + v2_bin.lstrip(&#39;0b&#39;)  # 使用lstrip()、strip()会报错value_int &#x3D; int(value, base&#x3D;2)print(value_int)  # 63432# 使用切片去除&#39;0b&#39;更便捷</code></pre></li><li><p>按要求实现</p><blockquote><p>现有 <code>v1=123</code> 和 <code>v2=456</code>，请将这两个值转换为二进制，并将其二进制中的前缀 0b 去掉，再补足为2个字节（16位），然后将两个二进制拼接起来，最终再转换为整型（十进制）。</p><p>例如：</p><p>​123  对应二进制为  “0b1111011” ，去除前缀0b之后的二进制为 “1111011” ，补足16位为  “00000000 01111011”</p><p>​456  对应二进制为  “0b111001000” ，去除前缀0b之后的二进制为 “111001000”，，补足16位为  “00000001 11001000”</p><p>​将两个二进制拼接起来的值为：”00000000 0111101100000001 11001000”，再将此值转换为整型为：8061384</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 123v2 &#x3D; 456v1_2byte &#x3D; bin(v1).lstrip(&#39;0b&#39;).zfill(16)v2_2byte &#x3D; bin(v2).lstrip(&#39;0b&#39;).zfill(16)value &#x3D; v1_2byte + v2_2bytevalue_int &#x3D; int(value, base&#x3D;2)print(value_int)  # 8061384</code></pre></li><li><p>列举你了解的哪些数据类型的值转换为布尔值为False。</p><pre class="language-python" data-language="python"><code class="language-python">空值和0</code></pre></li><li><p>看代码写结果：</p><pre class="language-python" data-language="python"><code class="language-python">if &quot;&quot;:    print(123)else:    print(456)    # 456</code></pre><pre class="language-python" data-language="python"><code class="language-python">if 0:    print(999)else:    print(666)    # 666</code></pre><pre class="language-python" data-language="python"><code class="language-python">if &quot;武沛齐&quot;:    print(345)else:    print(110)# 345</code></pre></li><li><p>让用户输入一段文本，请实现将文本中的敏感词 <code>苍老师</code>、<code>波波老师</code>替换为 <code>***</code>，最后并输入替换后的文本。</p><pre class="language-python" data-language="python"><code class="language-python"># 自己的版本sensitive_words &#x3D; [&#39;苍老师&#39;, &#39;波波老师&#39;]text &#x3D; input(&#39;please input a text: &#39;)for sw in sensitive_words:    if sw in text:        text &#x3D; text.replace(sw, &#39;***&#39;)print(text)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 老师的版本text &#x3D; input(&#39;please input a text: &#39;)text &#x3D; text.replace(&#39;苍老师&#39;, &#39;***&#39;)text &#x3D; text.replace(&#39;波波老师&#39;, &#39;***&#39;)print(text)</code></pre></li><li><p>有变量name &#x3D; “aleX leNb “ 完成如下操作： </p><ul><li>移除 name 变量对应的值两边的空格,并输出处理结果</li><li>判断 name 变量是否以 “al” 开头,并输出结果（用切片 或 startswith实现）</li><li>判断name变量是否以”Nb”结尾,并输出结果（用切片 或 endswith实现）</li><li>将 name 变量对应的值中的 所有的”l” 替换为 “p”,并输出结果 </li><li>将 name 变量对应的值根据 所有的”l” 分割,并输出结果</li><li>将name变量对应的值根据第一个”l”分割,并输出结果</li><li>将 name 变量对应的值变大写,并输出结果</li><li>将 name 变量对应的值变小写,并输出结果</li></ul><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;aleX leNb &quot;print(name.strip())print(name.startswith(&#39;al&#39;))print(name[:2] &#x3D;&#x3D; &#39;al&#39;)print(name.endswith(&#39;NB&#39;))print(name[-2:] &#x3D;&#x3D; &#39;NB&#39;)print(name.replace(&#39;l&#39;, &#39;p&#39;))print(name.split(&#39;l&#39;))print(name.split(&#39;l&#39;,1))print(name.upper())print(name.lower())</code></pre></li><li><p>如何实现字符串的翻转？</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;aleX leNb &quot;new_name &#x3D; name[::-1]print(new_name)</code></pre></li><li><p>有字符串s &#x3D; “123a4b5c”</p><ul><li>通过对s切片形成新的字符串 “123”</li><li>通过对s切片形成新的字符串 “a4b”</li><li>通过对s切片形成字符串 “c”</li><li>通过对s切片形成字符串 “ba2”</li></ul><pre class="language-python" data-language="python"><code class="language-python">s &#x3D; &quot;123a4b5c&quot;print(s[:3])print(s[3:-2])print(s[-1:])print(s[-3::-2])</code></pre></li><li><p>使用while循环实现对字符串 message &#x3D; “伤情最是晚凉天，憔悴厮人不堪言” 中每个字符进行输出。</p><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;伤情最是晚凉天，憔悴厮人不堪言&quot;count &#x3D; 0while count &lt; len(message):    print(message[count])    count +&#x3D; 1</code></pre></li><li><p>使用for循环实现对字符串 message &#x3D; “伤情最是晚凉天，憔悴厮人不堪言” 中每个字符进行输出。</p><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;伤情最是晚凉天，憔悴厮人不堪言&quot;for char in message:    print(char)</code></pre></li><li><p>使用for循环和range实现对字符串 message &#x3D; “伤情最是晚凉天，憔悴厮人不堪言” 中每个字符进行倒叙输出。</p><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;伤情最是晚凉天，憔悴厮人不堪言&quot;for index in range(1, len(message)+1):    print(message[-1 * index])</code></pre></li><li><p>使用for循环实现输出倒计时效果，例如：输出内容依次是：”倒计时3秒”，”倒计时2秒”，”倒计时1秒”。</p><pre class="language-python" data-language="python"><code class="language-python"># 我的版本for i in range(3):    print(&#39;倒计时&#123;n&#125;秒&#39;.format(n&#x3D;3-i))</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 老师的版本for i in range(3, 0, -1):    print(&#39;倒计时&#123;n&#125;秒&#39;.format(n&#x3D;i))</code></pre></li><li><p>让用户输入一段文本，请计算文本中 “浪” 出现的次数，并输入结果。</p><pre class="language-python" data-language="python"><code class="language-python">msg &#x3D; input(&#39;please input a text: &#39;)count &#x3D; 0for char in msg:    if char &#x3D;&#x3D; &#39;浪&#39;:        count +&#x3D; 1print(count)</code></pre></li><li><p>获取用户两次输入的内容，并提取其中的数字，然后实现数字的相加（转换为整型再相加）：</p><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;要求：将num1中的的所有数字找到并拼接起来：1232312将num1中的的所有数字找到并拼接起来：1218323然后将两个数字进行相加。&quot;&quot;&quot;num1 &#x3D; input(&quot;请输入：&quot;) # asdfd123sf2312num2 &#x3D; input(&quot;请输入：&quot;) # a12dfd183sf23# 请补充代码</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 请补充代码num1_dec &#x3D; &#39;&#39;for char in num1:    if char.isdecimal():        num1_dec +&#x3D; charnum2_dec &#x3D; &#39;&#39;for char in num2:    if char.isdecimal():        num2_dec +&#x3D; charprint(int(num1_dec) + int(num2_dec))</code></pre></li></ol><h2 id="七-、数据类型（中）"><a href="#七-、数据类型（中）" class="headerlink" title="七 、数据类型（中）"></a>七 、数据类型（中）</h2><p>常见的数据类型：</p><ul><li><span style="color:gray">int，整数类型（整形）</span></li><li><span style="color:gray">bool，布尔类型</span></li><li><span style="color:gray">str，字符串类型</span></li><li><strong>list，列表类型</strong></li><li><strong>tuple，元组类型</strong></li><li><span style="color:gray">dict，字典类型</span></li><li><span style="color:gray">set，集合类型</span></li><li><span style="color:gray">float，浮点类型（浮点型）</span></li></ul><p>目标：掌握列表和元组数据类型的各种操作（知识点应用案例）。</p><p>课程概要：</p><ul><li>list，列表类型，用于存储一些数据的容器（有序 &amp; 可修改）。【80%】</li><li>tuple，元组类型，用于存储一些数据的容器（有序 &amp; 不可修改）。【20%】</li></ul><h3 id="1-列表（list）"><a href="#1-列表（list）" class="headerlink" title="1.列表（list）"></a>1.列表（list）</h3><p>​列表（list），是一个<strong>有序</strong>且<strong>可变</strong>的容器，在里面可以存放<strong>多个不同类型</strong>的元素。</p><h4 id="1-1-定义-1"><a href="#1-1-定义-1" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; []user_list.append(&quot;铁锤&quot;)  # 可变user_list.append(123)  # 可变user_list.append(True)  # 可变print(user_list) # [&quot;铁锤&quot;,123,True] 有序、可存放多种数据类型</code></pre><p>​<font color="#dd0000">不可变类型：字符串、布尔、整型（已最小，内部数据无法进行修改）</font></p><p>​<font color="#dd0000">可变类型：列表（内部数据元素可以修改）</font></p><h4 id="1-2-独有功能-1"><a href="#1-2-独有功能-1" class="headerlink" title="1.2 独有功能"></a>1.2 独有功能</h4><p>​Python中为所有的列表类型的数据提供了一批独有的功能。在开始学习列表的独有功能之前，先来做一个可变类型（字符串）和不可变类型（列表）的对比：</p><ul><li><p>字符串，不可变，即：创建好之后内部就无法修改。【独有功能都是新创建一份数据】</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;alex&quot;data &#x3D; name.upper()  # 需要新变量进行接收print(name)print(data)</code></pre></li><li><p>列表，可变，即：创建好之后内部元素可以修改。【独有功能基本上都是直接操作列表内部，不会创建新的一份数据】</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;车子&quot;,&quot;妹子&quot;]user_list.append(&quot;嫂子&quot;)print(user_list) # [&quot;车子&quot;,&quot;妹子&quot;,&quot;嫂子&quot;]</code></pre></li></ul><p>列表中的常见独有功能如下：</p><ol><li><p><code>list.append()</code>  追加，在原<font color="#dd0000">列表中尾部追加值。</font></p><pre class="language-python" data-language="python"><code class="language-python"># 案例1user_list &#x3D; []while True:    user &#x3D; input(&quot;请输入用户名(Q退出)：&quot;)    if user &#x3D;&#x3D; &quot;Q&quot;:        break    user_list.append(user)    print(user_list) </code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例2welcome &#x3D; &quot;欢迎使用NB游戏&quot;.center(30, &#39;*&#39;)print(welcome)user_count &#x3D; 0while True:    count &#x3D; input(&quot;请输入游戏人数：&quot;)    if count.isdecimal():        user_count &#x3D; int(count)        break    else:        print(&quot;输入格式错误，人数必须是数字。&quot;)message &#x3D; &quot;&#123;&#125;人参加游戏NB游戏。&quot;.format(user_count)print(message)user_name_list &#x3D; []for i in range(1, user_count + 1):    tips &#x3D; &quot;请输入玩家姓名（&#123;&#125;&#x2F;&#123;&#125;）：&quot;.format(i, user_count)    name &#x3D; input(tips)    user_name_list.append(name)print(user_name_list)</code></pre></li><li><p><code>list.extend()</code>  批量追加，将<font color="#dd0000">一个列表中的元素逐一添加另外一个列表。</font></p><pre class="language-python" data-language="python"><code class="language-python">tools &#x3D; [&quot;搬砖&quot;,&quot;菜刀&quot;,&quot;榔头&quot;]weapon &#x3D; [&quot;AK47&quot;,&quot;M6&quot;]#tools.extend(weapon) # weapon中的值逐一追加到tools中#print(tools) # [&quot;搬砖&quot;,&quot;菜刀&quot;,&quot;榔头&quot;,&quot;AK47&quot;,&quot;M6&quot;]weapon.extend(tools)print(tools) # [&quot;搬砖&quot;,&quot;菜刀&quot;,&quot;榔头&quot;]print(weapon) # [&quot;AK47&quot;,&quot;M6&quot;,&quot;搬砖&quot;,&quot;菜刀&quot;,&quot;榔头&quot;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">tools &#x3D; [&quot;搬砖&quot;,&quot;菜刀&quot;,&quot;榔头&quot;]weapon &#x3D; [&quot;AK47&quot;,&quot;M6&quot;]for item in weapon:    tools.append(item)  print(tools) # [&quot;搬砖&quot;,&quot;菜刀&quot;,&quot;榔头&quot;,&quot;AK47&quot;,&quot;M6&quot;]</code></pre></li><li><p><code>list.insert()</code>  插入，在原列表的<font color="#dd0000">指定索引位置插入值</font></p><pre class="language-python" data-language="python"><code class="language-python"># 案例name_list &#x3D; []while True:    name &#x3D; input(&quot;请输入购买火车票用户姓名（Q&#x2F;q退出）：&quot;)    if name.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    if name.startswith(&quot;刁&quot;):        name_list.insert(0, name)    else:        name_list.append(name)print(name_list)</code></pre></li><li><p><code>list.remove</code>在原列表中<font color="#dd0000">根据值删除（从左到右找到第一个删除）【慎用，里面没有会报错】</font></p><pre class="language-python" data-language="python"><code class="language-python"># 怎样在使用remove()时，不报错（if item in ...:）user_list &#x3D; [&quot;王宝强&quot;,&quot;陈羽凡&quot;,&quot;Alex&quot;,&quot;贾乃亮&quot;,&quot;Alex&quot;]if &quot;Alex&quot; in user_list:user_list.remove(&quot;Alex&quot;)print(user_list)# 怎样在使用remove()时，不报错且能删除所有目标值（循环）user_list &#x3D; [&quot;王宝强&quot;,&quot;陈羽凡&quot;,&quot;Alex&quot;,&quot;贾乃亮&quot;,&quot;Alex&quot;]while True:    if &quot;Alex&quot; in user_list:        user_list.remove(&quot;Alex&quot;)else:        breakprint(user_list)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例：自动抽奖程序import randomdata_list &#x3D; [&quot;iphone12&quot;, &quot;二手充气女友&quot;, &quot;大保健一次&quot;, &quot;泰国5日游&quot;, &quot;避孕套&quot;]while data_list:    name &#x3D; input(&quot;自动抽奖程序，请输入自己的姓名：&quot;)    # 随机从data_list抽取一个值出来    value &#x3D; random.choice(data_list) # &quot;二手充气女友&quot;    print( &quot;恭喜&#123;&#125;，抽中&#123;&#125;.&quot;.format(name, value) )        data_list.remove(value) # &quot;二手充气女友&quot;</code></pre></li><li><p><code>list.pop()</code>在原列表中<font color="#dd0000">根据索引踢出某个元素（根据索引位置删除）</font></p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;王宝强&quot;,&quot;陈羽凡&quot;,&quot;Alex&quot;,&quot;贾乃亮&quot;,&quot;Alex&quot;]#               0       1      2      3       4user_list.pop(1)print(user_list) #  [&quot;王宝强&quot;,&quot;Alex&quot;,&quot;贾乃亮&quot;,&quot;Alex&quot;]user_list.pop() # 默认删除最后一个元素print(user_list) # [&quot;王宝强&quot;,&quot;Alex&quot;,&quot;贾乃亮&quot;]item &#x3D; user_list.pop(1)print(item) # &quot;Alex&quot;print(user_list) # [&quot;王宝强&quot;,&quot;贾乃亮&quot;]</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例：排队买火车票# [&quot;alex&quot;,&quot;李杰&quot;,&quot;eric&quot;,&quot;武沛齐&quot;,&quot;老妖&quot;,&quot;肝胆&quot;]user_queue &#x3D; []while True:    name &#x3D; input(&quot;北京~上海火车票，购买请输入姓名排队(Q退出)：&quot;)    if name &#x3D;&#x3D; &quot;Q&quot;:        break    user_queue.append(name)ticket_count &#x3D; 3for i in range(ticket_count):    username &#x3D; user_queue.pop(0)    message &#x3D; &quot;恭喜&#123;&#125;,购买火车票成功。&quot;.format(username)    print(message)# user_queue &#x3D; [&quot;武沛齐&quot;,&quot;老妖&quot;,&quot;肝胆&quot;]faild_user &#x3D; &quot;、&quot;.join(user_queue) # &quot;武沛齐、老妖、肝胆&quot;faild_message &#x3D; &quot;非常抱歉，票已售完，以下几位用户请选择其他出行方式，名单：&#123;&#125;。&quot;.format(faild_user)print(faild_message)</code></pre></li><li><p><code>list.clear()</code>清空原列表</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;王宝强&quot;,&quot;陈羽凡&quot;,&quot;Alex&quot;,&quot;贾乃亮&quot;,&quot;Alex&quot;]user_list.clear()print(user_list) # []</code></pre></li><li><p><code>list.index()</code>根据值<font color="#dd0000">获取索引（从左到右找到第一个）【慎用，找不到报错】</font></p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;王宝强&quot;,&quot;陈羽凡&quot;,&quot;Alex&quot;,&quot;贾乃亮&quot;,&quot;Alex&quot;]#               0       1      2       3      4# 解决index()不存在报错问题if &quot;Alex&quot; in user_list:index &#x3D; user_list.index(&quot;Alex&quot;)print(index) # 2else:    print(&quot;不存在&quot;)</code></pre></li><li><p><code>list.sort()</code>列表元素排序</p><pre class="language-python" data-language="python"><code class="language-python"># 数字排序num_list &#x3D; [11, 22, 4, 5, 11, 99, 88]print(num_list)num_list.sort()  # 让num_list从小到大排序print(num_list)num_list.sort(reverse&#x3D;True)  # 让num_list从大到小排序print(num_list)# 字符串排序user_list &#x3D; [&quot;王宝强&quot;, &quot;Ab陈羽凡&quot;, &quot;Alex&quot;, &quot;贾乃亮&quot;, &quot;贾乃&quot;, &quot;1&quot;]#       [29579, 23453,24378]#       [65, 98, 38472, 32701, 20961]#       [65, 108, 101, 120]#       [49]print(ord(&#39;王&#39;))  # 29579  十进制表示print(hex(ord(&#39;王&#39;)))  # 0x738b  十六进制表示  对应十六进制表达查找见下方网站print(user_list)user_list.sort()print(user_list)</code></pre><p><font color="#dd0000">注意：</font></p><ul><li><a href="https://unicode-table.com/en/blocks/">unicode编码网站</a></li><li>字符串排序原理，会将字符串转化为unicode的编码，再按字符顺序进行排序</li><li>获取字符的unicode编码，ord()方法</li><li><font color="#dd0000">排序时内部元素无法进行比较时，程序会报错（尽量数据类型统一）。</font></li></ul></li><li><p><code>list.reverse</code>反转原列表</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;王宝强&quot;,&quot;陈羽凡&quot;,&quot;Alex&quot;,&quot;贾乃亮&quot;,&quot;Alex&quot;]user_list.reverse()print(user_list)</code></pre></li></ol><h4 id="1-3-公共功能-1"><a href="#1-3-公共功能-1" class="headerlink" title="1.3 公共功能"></a>1.3 公共功能</h4><ol><li><p>相加，两个列表相加获取生成一个新的列表。</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; [&quot;赵四&quot;,&quot;刘能&quot;] + [&quot;宋晓峰&quot;,&quot;范德彪&quot;]print(data) # [&quot;赵四&quot;,&quot;刘能&quot;,&quot;宋晓峰&quot;,&quot;范德彪&quot;]</code></pre></li><li><p>相乘，列表*整型 将列表中的元素再创建N份并生成一个新的列表。</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; [&quot;赵四&quot;,&quot;刘能&quot;] * 2print(data) # [&quot;赵四&quot;,&quot;刘能&quot;,&quot;赵四&quot;,&quot;刘能&quot;]</code></pre></li><li><p>运算符in包含<br>由于列表内部是由多个元素组成，可以通过in来判断元素是否在列表中。</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;狗子&quot;,&quot;二蛋&quot;,&quot;沙雕&quot;,&quot;alex&quot;] if &quot;alex&quot; in user_list:    print(&quot;在，把他删除&quot;)    user_list.remove(&quot;alex&quot;)else:    print(&quot;不在&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;狗子&quot;,&quot;二蛋&quot;,&quot;沙雕&quot;,&quot;alex&quot;] if &quot;alex&quot; in user_list:    print(&quot;在，把他删除&quot;)    user_list.remove(&quot;alex&quot;)else:    print(&quot;不在&quot;)text &#x3D; &quot;打倒小日本&quot;data &#x3D; &quot;日&quot; in text</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例user_list &#x3D; [&quot;狗子&quot;,&quot;二蛋&quot;,&quot;沙雕&quot;,&quot;alex&quot;] if &quot;alex&quot; in user_list:    print(&quot;在，把他删除&quot;)    user_list.remove(&quot;alex&quot;)else:    print(&quot;不在&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例user_list &#x3D; [&quot;王宝强&quot;,&quot;陈羽凡&quot;,&quot;Alex&quot;,&quot;贾乃亮&quot;,&quot;Alex&quot;]if &quot;Alex&quot; in user_list:index &#x3D; user_list.index(&quot;Alex&quot;)user_list.pop(index)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例：敏感词替换text &#x3D; input(&quot;请输入文本内容：&quot;) # 按时打发第三方科技爱普生豆腐啊；了深刻的房价破阿偶打飞机forbidden_list &#x3D; [&quot;草&quot;,&quot;欧美&quot;,&quot;日韩&quot;]for item in forbidden_list:    text &#x3D; text.replace(item,&quot;**&quot;)print(text)</code></pre><p>注意：<font color="#dd0000"><strong>列表检查元素是否存在时，是采用逐一比较的方式，效率会比较低。</strong></font></p></li><li><p>获取长度</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;]print( len(user_list) )</code></pre></li><li><p>索引，一个元素的操作</p><pre class="language-python" data-language="python"><code class="language-python"># 读user_list &#x3D; [&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;]print( user_list[0] )print( user_list[2] )print( user_list[3] ) # 报错</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 改user_list &#x3D; [&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;]user_list[0] &#x3D; &quot;武沛齐&quot;print(user_list) # [&quot;武沛齐&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 删user_list &#x3D; [&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;]del user_list[1]user_list.remove(&quot;刘华强&quot;)ele &#x3D; user_list.pop(1)</code></pre><p>注意：超出索引范围会报错。<br>提示：<font color="#dd0000"><strong>由于字符串是不可变类型，所以他只有索引读的功能，而列表可以进行 读、改、删</strong></font></p></li><li><p>切片，多个元素的操作（很少用）</p><pre class="language-python" data-language="python"><code class="language-python"># 读user_list &#x3D; [&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;]print( user_list[0:2] ) # [&quot;范德彪&quot;,&quot;刘华强&quot;]print( user_list[1:] )print( user_list[:-1] )</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 改user_list &#x3D; [&quot;范德彪&quot;, &quot;刘华强&quot;, &#39;尼古拉斯赵四&#39;]user_list[0:2] &#x3D; [11, 22, 33, 44]print(user_list) # 输出 [11, 22, 33, 44, &#39;尼古拉斯赵四&#39;]user_list &#x3D; [&quot;范德彪&quot;, &quot;刘华强&quot;, &#39;尼古拉斯赵四&#39;]user_list[2:] &#x3D; [11, 22, 33, 44]print(user_list) # 输出 [&#39;范德彪&#39;, &#39;刘华强&#39;, 11, 22, 33, 44]user_list &#x3D; [&quot;范德彪&quot;, &quot;刘华强&quot;, &#39;尼古拉斯赵四&#39;]user_list[10000:] &#x3D; [11, 22, 33, 44]print(user_list) # 输出 [&#39;范德彪&#39;, &#39;刘华强&#39;, &#39;尼古拉斯赵四&#39;, 11, 22, 33, 44]user_list &#x3D; [&quot;范德彪&quot;, &quot;刘华强&quot;, &#39;尼古拉斯赵四&#39;]user_list[-10000:1] &#x3D; [11, 22, 33, 44]print(user_list) # 输出 [11, 22, 33, 44, &#39;刘华强&#39;, &#39;尼古拉斯赵四&#39;]</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 删user_list &#x3D; [&quot;范德彪&quot;, &quot;刘华强&quot;, &#39;尼古拉斯赵四&#39;]del user_list[1:]print(user_list) # 输出 [&#39;范德彪&#39;]</code></pre></li><li><p>步长</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,&quot;宋小宝&quot;,&quot;刘能&quot;]#              0        1        2          3       4print( user_list[1:4:2] )print( user_list[0::2] )print( user_list[1::2] )print( user_list[4:1:-1] )</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例：实现列表的翻转user_list &#x3D; [&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,&quot;宋小宝&quot;,&quot;刘能&quot;]new_data &#x3D; user_list[::-1]print(new_data)data_list &#x3D; [&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,&quot;宋小宝&quot;,&quot;刘能&quot;]data_list.reverse()print(data_list)# 给你一个字符串请实现字符串的翻转？name &#x3D; &quot;武沛齐&quot;name[::-1]</code></pre></li><li><p>for循环</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,&quot;宋小宝&quot;,&quot;刘能&quot;]for item in user_list:print(item)</code></pre><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,&quot;宋小宝&quot;,&quot;刘能&quot;]for index in range(len(user_list)):    item &#x3D; user_index[index]    print(item)</code></pre></li></ol><h4 id="【面试题】：切记，循环的过程中对数据进行删除会踩坑。"><a href="#【面试题】：切记，循环的过程中对数据进行删除会踩坑。" class="headerlink" title="【面试题】：切记，循环的过程中对数据进行删除会踩坑。"></a><font color="#dd0000"><strong>【面试题】：切记，循环的过程中对数据进行删除会踩坑。</strong></font></h4><pre class="language-python" data-language="python"><code class="language-python"># 错误方式， 有坑，结果不是你想要的。user_list &#x3D; [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &#39;刘尼古拉斯赵四&#39;, &quot;宋小宝&quot;, &quot;刘能&quot;]for item in user_list:    if item.startswith(&quot;刘&quot;):        user_list.remove(item)        print(user_list)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 正确方式，倒着删除user_list &#x3D; [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &#39;刘尼古拉斯赵四&#39;, &quot;宋小宝&quot;, &quot;刘能&quot;]for index in range(len(user_list) - 1, -1, -1):    item &#x3D; user_list[index]    if item.startswith(&quot;刘&quot;):        user_list.remove(item)        print(user_list)# 实现原理：倒着取无论删不删后面的数据，都不会改变前面索引的顺序# [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &#39;刘尼古拉斯赵四&#39;, &quot;宋小宝&quot;, &quot;刘能&quot;]# 5 &quot;刘能&quot; [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &#39;刘尼古拉斯赵四&#39;, &quot;宋小宝&quot;]# 4 &quot;宋小宝&quot; [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &#39;刘尼古拉斯赵四&#39;, &quot;宋小宝&quot;]# 3 &#39;刘尼古拉斯赵四&#39; [&quot;刘的话&quot;, &quot;范德彪&quot;, &quot;刘华强&quot;, &quot;宋小宝&quot;]# 2 &quot;刘华强&quot; [&quot;刘的话&quot;, &quot;范德彪&quot;,&quot;宋小宝&quot;]# 1 &quot;范德彪&quot; [&quot;刘的话&quot;, &quot;范德彪&quot;,&quot;宋小宝&quot;]# 0 &quot;刘的话&quot; [&quot;范德彪&quot;,&quot;宋小宝&quot;]</code></pre><h4 id="1-4-转换-1"><a href="#1-4-转换-1" class="headerlink" title="1.4 转换"></a>1.4 转换</h4><ul><li><p>int、bool无法转换成列表</p></li><li><p>str</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;data &#x3D; list(name)  # [&quot;武&quot;,&quot;沛&quot;,&quot;齐&quot;]print(data)</code></pre></li><li><p>超前</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; (11,22,33,44) # 元组vv1 &#x3D; list(v1)     # 列表 [11,22,33,44]v2 &#x3D; &#123;&quot;alex&quot;,&quot;eric&quot;,&quot;dsb&quot;&#125; # 集合vv2 &#x3D; list(v2) # 列表 [&quot;alex&quot;,&quot;eric&quot;,&quot;dsb&quot;]</code></pre></li></ul><h4 id="1-5-其他-1"><a href="#1-5-其他-1" class="headerlink" title="1.5. 其他"></a>1.5. 其他</h4><h5 id="1-5-1-嵌套"><a href="#1-5-1-嵌套" class="headerlink" title="1.5.1 嵌套"></a>1.5.1 嵌套</h5><p>​列表属于容器，内部可以存放各种数据，所以他也支持列表的嵌套，对于嵌套的值，可以根据之前学习的索引知识点来进行学习，例如：</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; [ &quot;谢广坤&quot;,[&quot;海燕&quot;,&quot;赵本山&quot;],True,[11,22,33,44],&quot;宋小宝&quot; ]print( data[0] ) # &quot;谢广坤&quot;print( data[1] ) # [&quot;海燕&quot;,&quot;赵本山&quot;]print( data[0][2] ) # &quot;坤&quot;print( data[1][-1] ) # &quot;赵本山&quot;data.append(666)print(data) # [ &quot;谢广坤&quot;,[&quot;海燕&quot;,&quot;赵本山&quot;],True,[11,22,33,44],&quot;宋小宝&quot;,666]data[1].append(&quot;谢大脚&quot;)print(data) # [ &quot;谢广坤&quot;,[&quot;海燕&quot;,&quot;赵本山&quot;,&quot;谢大脚&quot;],True,[11,22,33,44],&quot;宋小宝&quot;,666 ]del data[-2]print(data) # [ &quot;谢广坤&quot;,[&quot;海燕&quot;,&quot;赵本山&quot;,&quot;谢大脚&quot;],True,[11,22,33,44],666 ]data[-2][1] &#x3D; &quot;alex&quot;print(data) # [ &quot;谢广坤&quot;,[&quot;海燕&quot;,&quot;赵本山&quot;,&quot;谢大脚&quot;],True,[11,&quot;alex&quot;,33,44],666 ]data[1][0:2] &#x3D; [999,666]print(data) # [ &quot;谢广坤&quot;,[999,666,&quot;谢大脚&quot;],True,[11,&quot;alex&quot;,33,44],666 ]</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 创建用户列表#    用户列表应该长： [ [&quot;alex&quot;,&quot;123&quot;],[&quot;eric&quot;,&quot;666&quot;] ]# user_list &#x3D; [[&quot;alex&quot;,&quot;123&quot;],[&quot;eric&quot;,&quot;666&quot;],]# user_list.append([&quot;alex&quot;,&quot;123&quot;])# user_list.append([&quot;eric&quot;,&quot;666&quot;])user_list &#x3D; []while True:    user &#x3D; input(&quot;请输入用户名(Q退出)：&quot;)    if user &#x3D;&#x3D; &quot;Q&quot;:        break    pwd &#x3D; input(&quot;请输入密码：&quot;)    data &#x3D; [user,pwd]    user_list.append(data)print(user_list)</code></pre><h4 id="1-6-列表阶段作业"><a href="#1-6-列表阶段作业" class="headerlink" title="1.6 列表阶段作业"></a>1.6 列表阶段作业</h4><ol><li><p>写代码，有如下列表，按照要求实现每一个功能。</p><pre class="language-python" data-language="python"><code class="language-python">li &#x3D; [&quot;alex&quot;, &quot;WuSir&quot;, &quot;ritian&quot;, &quot;barry&quot;, &quot;武沛齐&quot;]</code></pre><ul><li><p>计算列表的长度并输出</p><pre class="language-python" data-language="python"><code class="language-python">  list_len &#x3D; 0  for item in li:      list_len +&#x3D; 1        print(list_len)- 列表中追加元素&quot;seven&quot;,并输出添加后的列表  &#96;&#96;&#96;python  li.append(&#39;seven&#39;)    print(li)  # li &#x3D; [&quot;alex&quot;, &quot;WuSir&quot;, &quot;ritian&quot;, &quot;barry&quot;, &quot;武沛齐&quot;, &#39;seven&#39;]</code></pre></li><li><p>请在列表的第1个索引位置插入元素”Tony”,并输出添加后的列表</p><pre class="language-python" data-language="python"><code class="language-python">li.insert(1, &quot;Tony&quot;)print(li)  # [&#39;alex&#39;, &#39;Tony&#39;, &#39;WuSir&#39;, &#39;ritian&#39;, &#39;barry&#39;, &#39;武沛齐&#39;]</code></pre></li><li><p>请修改列表第2个索引位置的元素为”Kelly”,并输出修改后的列表</p><pre class="language-python" data-language="python"><code class="language-python">li[2] &#x3D; &quot;Kelly&quot;print(li)  # [&#39;alex&#39;, &#39;WuSir&#39;, &#39;Kelly&#39;, &#39;barry&#39;, &#39;武沛齐&#39;]</code></pre></li><li><p>请将列表的第3个位置的值改成 “妖怪”，并输出修改后的列表</p><pre class="language-python" data-language="python"><code class="language-python">li[2] &#x3D; &quot;妖怪&quot;print(li)  # [&#39;alex&#39;, &#39;WuSir&#39;, &#39;妖怪&#39;, &#39;barry&#39;, &#39;武沛齐&#39;]</code></pre></li><li><p>请将列表 <code>data=[1,&quot;a&quot;,3,4,&quot;heart&quot;]</code> 的每一个元素追加到列表 <code>li</code> 中，并输出添加后的列表</p><pre class="language-python" data-language="python"><code class="language-python">data&#x3D;[1,&quot;a&quot;,3,4,&quot;heart&quot;]li.extend(data)print(li)  # [&#39;alex&#39;, &#39;WuSir&#39;, &#39;ritian&#39;, &#39;barry&#39;, &#39;武沛齐&#39;, 1, &#39;a&#39;, 3, 4, &#39;heart&#39;]</code></pre></li><li><p>请将字符串 <code>s = &quot;qwert&quot;</code>的每一个元素到列表 <code>li</code> 中。</p><pre class="language-python" data-language="python"><code class="language-python">li &#x3D; [&quot;alex&quot;, &quot;WuSir&quot;, &quot;ritian&quot;, &quot;barry&quot;, &quot;武沛齐&quot;]li.extend(&quot;qwert&quot;)print(li)  # [&#39;alex&#39;, &#39;WuSir&#39;, &#39;ritian&#39;, &#39;barry&#39;, &#39;武沛齐&#39;, &#39;q&#39;, &#39;w&#39;, &#39;e&#39;, &#39;r&#39;, &#39;t&#39;]</code></pre></li><li><p>请删除列表中的元素”barry”,并输出添加后的列表</p><pre class="language-python" data-language="python"><code class="language-python">li &#x3D; [&quot;alex&quot;, &quot;WuSir&quot;, &quot;ritian&quot;, &quot;barry&quot;, &quot;武沛齐&quot;]li.remove(&quot;barry&quot;)print(li)  # [&#39;alex&#39;, &#39;WuSir&#39;, &#39;ritian&#39;, &#39;武沛齐&#39;]</code></pre></li><li><p>请删除列表中的第2个元素，并输出删除元素后的列表</p><pre class="language-python" data-language="python"><code class="language-python">li &#x3D; [&quot;alex&quot;, &quot;WuSir&quot;, &quot;ritian&quot;, &quot;barry&quot;, &quot;武沛齐&quot;]li.pop(1)print(li)  # [&#39;alex&#39;, &#39;ritian&#39;, &#39;barry&#39;, &#39;武沛齐&#39;]</code></pre></li><li><p>请删除列表中的第2至第4个元素，并输出删除元素后的列表</p><pre class="language-python" data-language="python"><code class="language-python">del li[1:4]print(li)  # [&#39;alex&#39;, &#39;武沛齐&#39;]</code></pre></li></ul></li><li><p>写代码，有如下列表，利用切片实现每一个功能</p><pre class="language-python" data-language="python"><code class="language-python">li &#x3D; [1, 3, 2, &quot;a&quot;, 4, &quot;b&quot;, 5,&quot;c&quot;]</code></pre><ul><li><p>通过对li列表的切片形成新的列表 [1,3,2]</p><pre class="language-python" data-language="python"><code class="language-python">print(li[:3])</code></pre></li><li><p>通过对li列表的切片形成新的列表 [“a”,4,”b”] </p><pre class="language-python" data-language="python"><code class="language-python">print(li[3:6])</code></pre></li><li><p>通过对li列表的切片形成新的列表  [1,2,4,5]</p><pre class="language-python" data-language="python"><code class="language-python">print(li[::2])</code></pre></li><li><p>通过对li列表的切片形成新的列表 [3,”a”,”b”]</p><pre class="language-python" data-language="python"><code class="language-python">print(li[1:-2:2])</code></pre></li><li><p>通过对li列表的切片形成新的列表 [3,”a”,”b”,”c”]</p><pre class="language-python" data-language="python"><code class="language-python">print(li[1::2])</code></pre></li><li><p>通过对li列表的切片形成新的列表  [“c”]</p><pre class="language-python" data-language="python"><code class="language-python">print(li[-1:])</code></pre></li><li><p>通过对li列表的切片形成新的列表 [“b”,”a”,3]</p><pre class="language-python" data-language="python"><code class="language-python">print(li[-3::-2])</code></pre></li></ul></li><li><p>写代码，有如下列表，按照要求实现每一个功能。</p><pre class="language-python" data-language="python"><code class="language-python">lis &#x3D; [2, 3, &quot;k&quot;, [&quot;qwe&quot;, 20, [&quot;k1&quot;, [&quot;tt&quot;, 3, &quot;1&quot;]], 89], &quot;ab&quot;, &quot;adv&quot;]</code></pre><ul><li><p>将列表lis中的第2个索引位置的值变成大写，并打印列表。</p><pre class="language-python" data-language="python"><code class="language-python"># 错误(字符串无法更改，需要对upper()后的值进行保存再更改)lis[2].upper()print(lis)</code></pre><pre class="language-python" data-language="python"><code class="language-python">lis[2] &#x3D; lis[2].upper()print(lis)</code></pre></li><li><p>将列表中的数字3变成字符串”100”</p><pre class="language-python" data-language="python"><code class="language-python">lis[1] &#x3D; &#39;100&#39;lis[3][2][1][1] &#x3D; &#39;100&#39;print(lis)</code></pre></li><li><p>将列表中的字符串”tt”变成数字 101</p><pre class="language-python" data-language="python"><code class="language-python">lis[3][2][1][0] &#x3D; 101print(lis)</code></pre></li><li><p>在 “qwe”前面插入字符串：”火车头”</p><pre class="language-python" data-language="python"><code class="language-python">(lis[3]).insert(0, &#39;火车头&#39;)print(lis)</code></pre></li></ul></li><li><p>请用代码实现循环输出元素和值：users &#x3D; [“武沛齐”,”景女神”,”肖大侠”] ，如：</p><pre class="language-python" data-language="python"><code class="language-python">0 武沛齐1 景女神2 肖大侠</code></pre><pre class="language-python" data-language="python"><code class="language-python">for i in range(len(users)):    print(&#39;&#123;&#125; &#123;&#125;&#39;.format(i, users[i]))</code></pre></li><li><p>请用代码实现循环输出元素和值：users &#x3D; [“武沛齐”,”景女神”,”肖大侠”] ，如：</p><pre class="language-python" data-language="python"><code class="language-python">1 武沛齐2 景女神3 肖大侠</code></pre><pre class="language-python" data-language="python"><code class="language-python">for i in range(len(users)):    print(&#39;&#123;&#125; &#123;&#125;&#39;.format(i+1, users[i]))</code></pre></li><li><p>写代码实现以下功能</p><ul><li><p>如有变量 goods &#x3D; [‘汽车’,’飞机’,’火箭’] 提示用户可供选择的商品：</p><pre class="language-python" data-language="python"><code class="language-python">0,汽车1,飞机2,火箭</code></pre></li><li><p>用户输入索引后，将指定商品的内容拼接打印，如：用户输入0，则打印 您选择的商品是汽车。</p><pre class="language-python" data-language="python"><code class="language-python">index &#x3D; []for i in range(len(goods)):    print(&#39;&#123;&#125; &#123;&#125;&#39;.format(i, goods[i]))    index.append(i)user_input &#x3D; int(input(&#39;please choice a goods: &#39;))if user_input in index:    print(&#39;您所选择的交通工具是&#123;&#125;&#39;.format(goods[user_input]))else:    print(&#39;input wrong&#39;)</code></pre></li></ul></li><li><p>利用for循环和range 找出 0 ~ 50 以内能被3整除的数，并追加到一个列表。</p><pre class="language-python" data-language="python"><code class="language-python"># 我的版本num_list &#x3D; []for num in range(51):    if num % 3 &#x3D;&#x3D; 0:        num_list.append(num)print(num_list)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 老师版本（去掉0）num_list &#x3D; []for num in range(51):    if num &#x3D;&#x3D; 0:        continue    if num % 3 &#x3D;&#x3D; 0:        num_list.append(num)print(num_list)</code></pre></li><li><p>利用for循环和range 找出 0 ~ 50 以内能被3整除的数，并插入到列表的第0个索引位置，最终结果如下：</p><pre class="language-python" data-language="python"><code class="language-python">[48,45,42...]</code></pre><pre class="language-python" data-language="python"><code class="language-python">num_list &#x3D; []for num in range(51):    if num % 3 &#x3D;&#x3D; 0:        num_list.insert(0, num)print(num_list)</code></pre></li><li><p>查找列表li中的元素，移除每个元素的空格，并找出以”a”开头，并添加到一个新列表中,最后循环打印这个新列表。</p><pre class="language-python" data-language="python"><code class="language-python">li &#x3D; [&quot;alexC&quot;, &quot;AbC &quot;, &quot;egon&quot;, &quot; riTiAn&quot;, &quot;WuSir&quot;, &quot;  aqc&quot;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">a_str &#x3D; []for item in li:    item &#x3D; item.strip()    # item &#x3D; item.lower()  # 大小写不敏感    if item.startswith(&#39;a&#39;):        a_str.append(item)print(a_str)</code></pre></li><li><p>将以下车牌中所有 <code>京 </code>的车牌搞到一个列表中，并输出京牌车辆的数量。</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; [&quot;京1231&quot;, &quot;冀8899&quot;, &quot;京166631&quot;, &quot;晋989&quot;]</code></pre><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; [&quot;京1231&quot;, &quot;冀8899&quot;, &quot;京166631&quot;, &quot;晋989&quot;]choice_num &#x3D; []for car_num in data:    if car_num.startswith(&#39;京&#39;):        choice_num.append(car_num)print(choice_num)print(len(choice_num))</code></pre></li></ol><h3 id="2-元组-tuple"><a href="#2-元组-tuple" class="headerlink" title="2.元组(tuple)"></a>2.元组(tuple)</h3><p>​列表（list），是一个<strong>有序</strong>且<strong>可变</strong>的容器，在里面可以存放<strong>多个不同类型</strong>的元素。</p><p>​元组（tuple），是一个<strong>有序</strong>且<strong>不可变</strong>的容器，在里面可以存放<strong>多个不同类型</strong>的元素。<font color="#dd0000"><strong>如何体现不可变呢？记住一句话：《”我儿子永远不能换成是别人，但我儿子可以长大”》</strong></font></p><pre class="language-python" data-language="python"><code class="language-python"># 元组是不可变的，但元组的元素中嵌套有可变的数据类型时，元组中该元素可以改变v1 &#x3D; (True,123,&quot;Alex&quot;,[11,22,33,44])data &#x3D; v1[-1]data.append(3)print(v1)  # (True, 123, &#39;Alex&#39;, [11, 22, 33, 44, 3])</code></pre><h4 id="2-1-定义-1"><a href="#2-1-定义-1" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>​<strong>建议：议在元组的最后多加一个逗v1 &#x3D; (“李杰”,”Alex”,)，用于标识他是一个元组。当元组只有一个元素时，元组的符号不会被当成运算符中的括号</strong></p><pre class="language-python" data-language="python"><code class="language-python">d1 &#x3D; (1)  # int 1d2 &#x3D; (1,) # tuple (1,)</code></pre><h4 id="【面试题】"><a href="#【面试题】" class="headerlink" title="【面试题】"></a><font color="#dd0000"><strong>【面试题】</strong></font></h4><pre class="language-python" data-language="python"><code class="language-python">1. 比较值 v1 &#x3D; (1) 和 v2 &#x3D; 1 和 v3 &#x3D; (1,) 有什么区别？2. 比较值 v1 &#x3D; ( (1),(2),(3) ) 和 v2 &#x3D; ( (1,) , (2,) , (3,),) 有什么区别？              (1,2,3)</code></pre><h4 id="2-2-独有功能-1"><a href="#2-2-独有功能-1" class="headerlink" title="2.2 独有功能"></a>2.2 独有功能</h4><p>无</p><h4 id="2-3-公共功能-1"><a href="#2-3-公共功能-1" class="headerlink" title="2.3 公共功能"></a>2.3 公共功能</h4><ol><li><p>相加，两个列表相加获取生成一个新的列表。</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; (&quot;赵四&quot;,&quot;刘能&quot;) + (&quot;宋晓峰&quot;,&quot;范德彪&quot;)print(data) # (&quot;赵四&quot;,&quot;刘能&quot;,&quot;宋晓峰&quot;,&quot;范德彪&quot;)</code></pre></li><li><p>相乘，列表*整型 将列表中的元素再创建N份并生成一个新的列表。</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; (&quot;赵四&quot;,&quot;刘能&quot;) * 2print(data) # (&quot;赵四&quot;,&quot;刘能&quot;,&quot;赵四&quot;,&quot;刘能&quot;)</code></pre></li><li><p>获取长度</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; (&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,)print( len(user_list) )</code></pre></li><li><p>索引</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; (&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,)print( user_list[0] )print( user_list[2] )print( user_list[3] )  # 超出范围报错</code></pre></li><li><p>切片</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; (&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,)print( user_list[0:2] )print( user_list[1:] )print( user_list[:-1] )</code></pre></li><li><p>步长</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; (&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,&quot;宋小宝&quot;,&quot;刘能&quot;)print( user_list[1:4:2] )print( user_list[0::2] )print( user_list[1::2] )print( user_list[4:1:-1] )</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 字符串 &amp; 元组。user_list &#x3D; (&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,&quot;宋小宝&quot;,&quot;刘能&quot;)data &#x3D; user_list[::-1]# 列表user_list &#x3D; [&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,&quot;宋小宝&quot;,&quot;刘能&quot;]data &#x3D; user_list[::-1]user_list.reverse()print(user_list)</code></pre></li><li><p>for循环</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; (&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,&quot;宋小宝&quot;,&quot;刘能&quot;)for item in user_list:print(item)</code></pre><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; (&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,&quot;宋小宝&quot;,&quot;刘能&quot;)for item in user_list: if item &#x3D;&#x3D; &#39;刘华强&#39;: continue print(name)</code></pre><p>目前：只有 str、list、tuple 可以被for循环。 “xxx”  [11,22,33]  (111,22,33)</p><pre class="language-python" data-language="python"><code class="language-python"># len + range + for + 索引user_list &#x3D; (&quot;范德彪&quot;,&quot;刘华强&quot;,&#39;尼古拉斯赵四&#39;,&quot;宋小宝&quot;,&quot;刘能&quot;)for index in range(len(user_list)):    item &#x3D; user_list[index]    print(item)</code></pre></li></ol><h4 id="2-4-转换-1"><a href="#2-4-转换-1" class="headerlink" title="2.4 转换"></a>2.4 转换</h4><p>其他类型转换为元组，使用<code>tuple(其他类型)</code>，目前只有字符串和列表可以转换为元组。</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; tuple(其他)# str &#x2F; list </code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;data &#x3D; tuple(name)print(data) # 输出 (&quot;武&quot;,&quot;沛&quot;,&quot;齐&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; [&quot;武沛齐&quot;,18,&quot;pythonav&quot;]data &#x3D; tuple(name)print(data) # 输出 (&quot;武沛齐&quot;,18,&quot;pythonav&quot;)</code></pre><h4 id="2-5-其他-1"><a href="#2-5-其他-1" class="headerlink" title="2.5 其他"></a>2.5 其他</h4><h5 id="2-5-1-嵌套"><a href="#2-5-1-嵌套" class="headerlink" title="2.5.1 嵌套"></a>2.5.1 嵌套</h5><p>由于元组和列表都可以充当<code>容器</code>，他们内部可以放很多元素，并且也支持元素内的各种嵌套。</p><pre class="language-python" data-language="python"><code class="language-python">tu &#x3D; ( &#39;今天姐姐不在家&#39;, &#39;姐夫和小姨子在客厅聊天&#39;, (&#39;姐夫问小姨子税后多少钱&#39;,&#39;小姨子低声说道说和姐夫还提钱&#39;) )tu1 &#x3D; tu[0]tu2 &#x3D; tu[1]tu3 &#x3D; tu[2][0]tu4 &#x3D; tu[2][1]tu5 &#x3D; tu[2][1][3]print(tu1) # 今天姐姐不在家print(tu2) # 姐夫和小姨子在客厅聊天print(tu3) # 姐夫问小姨子税后多少钱print(tu4) # 小姨子低声说道说和姐夫还提钱</code></pre><p>练习题1：判断是否可以实现，如果可以请写代码实现。</p><pre class="language-python" data-language="python"><code class="language-python">li &#x3D; [&quot;alex&quot;, [11,22,(88,99,100,),33],  &quot;WuSir&quot;,  (&quot;ritian&quot;, &quot;barry&quot;,),  &quot;wenzhou&quot;]#        0               1                 2                3                4# 1.请将 &quot;WuSir&quot; 修改成 &quot;武沛齐&quot;li[2] &#x3D; &quot;武沛齐&quot;index &#x3D; li.index(&quot;Wusir&quot;)li[index] &#x3D; &quot;武沛齐&quot;# 2.请将 (&quot;ritian&quot;, &quot;barry&quot;,) 修改为 [&#39;日天&#39;,&#39;日地&#39;]li[3] &#x3D; [&#39;日天&#39;,&#39;日地&#39;]# 3.请将 88 修改为 87li[1][2][0] &#x3D; 87 # (报错，)# 4.请将 &quot;wenzhou&quot; 删除，然后再在列表第0个索引位置插入 &quot;周周&quot;# li.remove(&quot;wenzhou&quot;)# del li[-1]li.insert(0,&quot;周周&quot;)</code></pre><p>练习题2：记住一句话：《”我儿子永远不能换成是别人，但我儿子可以长大”》</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; (&quot;123&quot;,666,[11,22,33], (&quot;alex&quot;,&quot;李杰&quot;,[999,666,(5,6,7)]) )# 1.将 “123” 替换成 9   报错# 2.将 [11,22,33] 换成 &quot;武沛齐&quot;    报错# 3.将 11 换成 99data[2][0] &#x3D; 99print(data)  # (&quot;123&quot;,666,[99,22,33], (&quot;alex&quot;,&quot;李杰&quot;,[999,666,(5,6,7)]) )# 4.在列表 [11,22,33] 追加一个44data[2].append(44)print(data) # (&quot;123&quot;,666,[11,22,33,44], (&quot;alex&quot;,&quot;李杰&quot;,[999,666,(5,6,7)]) )</code></pre><p>练习题3：动态的创建用户并添加到用户列表中。</p><pre class="language-python" data-language="python"><code class="language-python"># 创建用户 5个# user_list &#x3D; [] # 用户信息user_list &#x3D; [ (&quot;alex&quot;,&quot;132&quot;),(&quot;admin&quot;,&quot;123&quot;),(&quot;eric&quot;,&quot;123&quot;) ]while True:    user &#x3D; input(&quot;请输入用户名：&quot;)    if user &#x3D;&#x3D; &quot;Q&quot;:        break    pwd &#x3D; input(&quot;请输入密码：&quot;)    item &#x3D; (user,pwd,)    user_list.append(item)    # 实现：用户登录案例print(&quot;登录程序&quot;)username &#x3D; input(&quot;请输入用户名：&quot;)password &#x3D; input(&quot;请输入密码：&quot;)is_success &#x3D; Falsefor item in user_list:    # item &#x3D; (&quot;alex&quot;,&quot;132&quot;)   (&quot;admin&quot;,&quot;123&quot;)    (&quot;eric&quot;,&quot;123&quot;)    if username &#x3D;&#x3D; item[0] and password &#x3D;&#x3D; item[1]:        is_success &#x3D; True        breakif is_success:    print(&quot;登录成功&quot;)else:    print(&quot;登录失败&quot;)</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>概述<ul><li>列表，以后写程序会用的非常多，要多写多练。</li><li>元组，以后写程序用的不是很多，主要以了解其特殊和用法为主。</li></ul></li><li>列表和元组的区别。</li><li>可变类型和不可变类型。</li><li>列表独有功能 &amp; 公共功能（不用特地去记，多做题目去用，以后每天都会有相关的练习题）。</li><li>列表和元组等数据的嵌套</li><li>元组中 (1) 和 (1,) 的区别。</li><li>元组的元素不能被替换，但元组的元素如果是可变类型，可变类型内部是可以修改的。</li></ol><h3 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h3><ol><li><p>以下哪些数据类型转换为布尔值为False</p><pre class="language-python" data-language="python"><code class="language-python">1 &quot;&quot;  # F-19[]  # F[11,22](1)(1,2,3)()  # F</code></pre></li><li><p>运算符操作</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; [] or &quot;alex&quot;  # &#39;alex&#39;v2 &#x3D; [11,22] and (1,2,)  # (1, 2,)</code></pre></li><li><p>比较：<code>a = [1,2,3]</code>和 <code>b = [(1),(2),(3) ]</code> 以及 <code>c = [(1,),(2,),(3,) ]</code> 的区别？</p></li><li><p>将字符串<code>text = &quot;wupeiqi|alex|eric&quot;</code>根据 <code>|</code> 分割为列表，然后列表转换为元组类型。</p></li><li><p>根据如下规则创建一副扑克牌（排除大小王）。</p><pre class="language-python" data-language="python"><code class="language-python"># 花色列表color_list &#x3D; [&quot;红桃&quot;,&quot;黑桃&quot;,&quot;方片&quot;,&quot;梅花&quot;]# 牌值num_list &#x3D; []for num in range(1,14):    num_list.append(num)    result &#x3D; []# 请根据以上的花色和牌值创建一副扑克牌（排除大小王）# 最终result的结果格式为： [ (&quot;红桃&quot;,1), (&quot;红桃&quot;,2) ... ]</code></pre></li></ol><h2 id="八、数据类型（下）"><a href="#八、数据类型（下）" class="headerlink" title="八、数据类型（下）"></a>八、数据类型（下）</h2><p>常见的数据类型：</p><ul><li><span style="color:gray">int，整数类型（整形）</span></li><li><span style="color:gray">bool，布尔类型</span></li><li><span style="color:gray">str，字符串类型</span></li><li><span style="color:gray">list，列表类型</span></li><li><span style="color:gray">tuple，元组类型</span></li><li><strong>dict，字典类型</strong></li><li><strong>set，集合类型</strong></li><li><strong>float，浮点类型（浮点型）</strong></li></ul><p>目标：掌握字典、集合、浮点类型相关知识。</p><p>课程概要：</p><ul><li>set集合，一个不允许重复重复 &amp; 可变类型（元素可哈希）。</li><li>dict字典，一个容器且元素必须是键值对。</li><li>float类型，我们生活中常见的小数。</li></ul><h3 id="1-集合（set）"><a href="#1-集合（set）" class="headerlink" title="1.集合（set）"></a>1.集合（set）</h3><p>集合是一个 <strong>无序 、可变、不允许数据重复</strong>的容器。</p><h4 id="1-1-定义-2"><a href="#1-1-定义-2" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#123; 11, 22, 33, &quot;alex&quot; &#125;</code></pre><ul><li><p>无序，无法通过索引取值。</p></li><li><p>可变，可以添加和删除元素。</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#123;11,22,33,44&#125;v1.add(55)print(v1) # &#123;11,22,33,44,55&#125;</code></pre></li><li><p>不允许数据重复。</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#123;11,22,33,44&#125;v1.add(22)print(v1) # &#123;11,22,33,44&#125;</code></pre></li></ul><p>一般什么时候用集合呢？</p><blockquote><p>​就是想要维护一大堆不重复的数据时，就可以用它。比如：做爬虫去网上找图片的链接，为了避免链接重复，可以选择用集合去存储链接地址。</p></blockquote><p><font color="#dd0000"><strong>注意：定义空集合时，只能使用<code>v = set()</code>，不能使用 <code>v=&#123;&#125;</code>（这样是定义一个空字典）。</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; []v11 &#x3D; list()v2 &#x3D; ()v22 &#x3D; tuple()v3 &#x3D; set()v4 &#x3D; &#123;&#125; # 空字典v44 &#x3D; dict()</code></pre><h4 id="1-2-独有功能-2"><a href="#1-2-独有功能-2" class="headerlink" title="1.2 独有功能"></a>1.2 独有功能</h4><ol><li><p><code>set.add() </code> 添加元素</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; set()data.add(&quot;周杰伦&quot;)data.add(&quot;林俊杰&quot;)print(data)</code></pre></li><li><p><code>set.discard()</code>  删除元素</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &#123;&quot;刘嘉玲&quot;, &#39;关之琳&#39;, &quot;王祖贤&quot;,&quot;张曼⽟&quot;, &quot;李若彤&quot;&#125;data.discard(&quot;关之琳&quot;) print(data)</code></pre></li><li><p><code>set.intersection()</code> 交集</p><pre class="language-python" data-language="python"><code class="language-python">s1 &#x3D; &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;⽪⻓⼭&quot;&#125;s2 &#x3D; &#123;&quot;刘科⻓&quot;, &quot;冯乡⻓&quot;, &quot;⽪⻓⼭&quot;&#125;s4 &#x3D; s1.intersection(s2)  # 方式一. 取两个集合的交集 print(s4) # &#123;&quot;⽪⻓⼭&quot;&#125;s3 &#x3D; s1 &amp; s2     # 方式二. 取两个集合的交集print(s3)</code></pre></li><li><p><code>set.union </code> 并集</p><pre class="language-python" data-language="python"><code class="language-python">s1 &#x3D; &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;⽪⻓⼭&quot;&#125;s2 &#x3D; &#123;&quot;刘科⻓&quot;, &quot;冯乡⻓&quot;, &quot;⽪⻓⼭&quot;&#125;s4 &#x3D; s1.union(s2) # 方式一. 取两个集合的并集  &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;⽪⻓⼭&quot;,&quot;刘科⻓&quot;, &quot;冯乡⻓&quot;, &#125;print(s4)s3 &#x3D; s1 | s2   # 方式二. 取两个集合的并集print(s3)</code></pre></li><li><p><code>set.difference</code>  补集</p><pre class="language-python" data-language="python"><code class="language-python">s1 &#x3D; &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;⽪⻓⼭&quot;&#125;s2 &#x3D; &#123;&quot;刘科⻓&quot;, &quot;冯乡⻓&quot;, &quot;⽪⻓⼭&quot;&#125;s4 &#x3D; s1.difference(s2) # 方式一. 补集，s1中有且s2中没有的值 &#123;&quot;刘能&quot;, &quot;赵四&quot;&#125;s6 &#x3D; s2.difference(s1)   #        补集，s2中有且s1中没有的值 &#123;&quot;刘科⻓&quot;, &quot;冯乡⻓&quot;&#125;s3 &#x3D; s1 - s2      # 方式二. 补集，s1中有且s2中没有的值s5 &#x3D; s2 - s1      #        补集，s2中有且s1中没有的值print(s5,s6)</code></pre></li></ol><h4 id="1-3-公共功能-2"><a href="#1-3-公共功能-2" class="headerlink" title="1.3 公共功能"></a>1.3 公共功能</h4><ol><li><p>减，计算补集</p><pre class="language-python" data-language="python"><code class="language-python">s1 &#x3D; &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;⽪⻓⼭&quot;&#125;s2 &#x3D; &#123;&quot;刘科⻓&quot;, &quot;冯乡⻓&quot;, &quot;⽪⻓⼭&quot;&#125;s3 &#x3D; s1 - s2 s4 &#x3D; s2 - s1print(s3)print(s4)</code></pre></li><li><p>&amp;，计算交集</p><pre class="language-python" data-language="python"><code class="language-python">s1 &#x3D; &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;⽪⻓⼭&quot;&#125;s2 &#x3D; &#123;&quot;刘科⻓&quot;, &quot;冯乡⻓&quot;, &quot;⽪⻓⼭&quot;&#125;s3 &#x3D; s1 &amp; s2print(s3)</code></pre></li><li><p>|，计算并集</p><pre class="language-python" data-language="python"><code class="language-python">s1 &#x3D; &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;⽪⻓⼭&quot;&#125;s2 &#x3D; &#123;&quot;刘科⻓&quot;, &quot;冯乡⻓&quot;, &quot;⽪⻓⼭&quot;&#125;s3 &#x3D; s1 | s2print(s3)</code></pre></li><li><p>长度</p><pre class="language-python" data-language="python"><code class="language-python">v &#x3D; &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;尼古拉斯&quot;&#125;data &#x3D; len(v)print(data)</code></pre></li><li><p>for循环</p><pre class="language-python" data-language="python"><code class="language-python">v &#x3D; &#123;&quot;刘能&quot;, &quot;赵四&quot;, &quot;尼古拉斯&quot;&#125;for item in v:print(item)</code></pre></li></ol><h4 id="1-4-转换-2"><a href="#1-4-转换-2" class="headerlink" title="1.4 转换"></a>1.4 转换</h4><p>​<font color="#dd0000"><strong>int&#x2F;list&#x2F;tuple&#x2F;dict都可以转换为集合</strong></font>其他类型如果想要转换为集合类型，可以通过set进行转换，并且<font color="#dd0000"><strong>如果数据有重复自动剔除。</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &quot;武沛齐&quot;v2 &#x3D; set(v1)print(v2) # &#123;&quot;武&quot;,&quot;沛&quot;,&quot;齐&quot;&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; [11,22,33,11,3,99,22]v2 &#x3D; set(v1)print(v2) # &#123;11,22,33,3,99&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; (11,22,3,11)v2 &#x3D; set(v1)print(v2) # &#123;11,22,3&#125;</code></pre><p>​提示：这其实也是<strong>去重</strong>的一个手段。</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &#123;11,22,33,3,99&#125;v1 &#x3D; list(data) # [11,22,33,3,99]v2 &#x3D; tuple(data) # (11,22,33,3,99)</code></pre><h4 id="1-5-其他-2"><a href="#1-5-其他-2" class="headerlink" title="1.5 其他"></a>1.5 其他</h4><h5 id="1-5-1-集合的存储原理"><a href="#1-5-1-集合的存储原理" class="headerlink" title="1.5.1 集合的存储原理"></a>1.5.1 集合的存储原理</h5><img src="Python模块一day2/image-20201120193837492.png" alt="image-20201120193837492" style="zoom:50%;" /><h5 id="1-5-2-元素必须可哈希"><a href="#1-5-2-元素必须可哈希" class="headerlink" title="1.5.2 元素必须可哈希"></a>1.5.2 元素必须可哈希</h5><p>因存储原理，集合的元素必须是可哈希的值，即：内部通过哈希函数把值转换成一个数字。</p><img src="Python模块一day2/image-20201120190454120.png" alt="image-20201120190454120" style="zoom: 25%;" /><p>​<font color="#dd0000"><strong>目前可哈希的数据类型：int、bool、str、tuple，而list、set是不可哈希的，因此集合的元素只能是 int、bool、str、tuple 。</strong></font></p><ul><li><p>转换成功</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; [11,22,33,11,3,99,22]v2 &#x3D; set(v1)print(v2) # &#123;11,22,33,3,99&#125;</code></pre></li><li><p>转换失败</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; [11,22,[&quot;alex&quot;,&quot;eric&quot;],33]v2 &#x3D; set(v1) # 报错 print(v2) </code></pre></li></ul><h5 id="1-5-3-查找速度特别快"><a href="#1-5-3-查找速度特别快" class="headerlink" title="1.5.3 查找速度特别快"></a>1.5.3 查找速度特别快</h5><p>因存储原理特殊，集合的查找效率非常高（数据量大了才明显）。</p><ul><li><p>低</p><pre class="language-python" data-language="python"><code class="language-python">user_list &#x3D; [&quot;武沛齐&quot;,&quot;alex&quot;,&quot;李璐&quot;]if &quot;alex&quot; in user_list:    print(&quot;在&quot;)else:    print(&quot;不在&quot;)        user_tuple &#x3D; (&quot;武沛齐&quot;,&quot;alex&quot;,&quot;李璐&quot;)if &quot;alex&quot; in user_tuple:    print(&quot;在&quot;)else:    print(&quot;不在&quot;)</code></pre></li><li><p>效率高</p><pre class="language-python" data-language="python"><code class="language-python">user_set &#x3D; &#123;&quot;武沛齐&quot;,&quot;alex&quot;,&quot;李璐&quot;&#125;if &quot;alex&quot; in user_set:    print(&quot;在&quot;)else:    print(&quot;不在&quot;)</code></pre></li></ul><h5 id="1-5-4-对比和嵌套"><a href="#1-5-4-对比和嵌套" class="headerlink" title="1.5.4 对比和嵌套"></a>1.5.4 <font color="#dd0000"><strong>对比和嵌套</strong></font></h5><table><thead><tr><th>是否可变</th><th>类型</th><th>是否有序</th><th>元素要求</th><th>是否可哈希</th><th>转换</th><th>定义空</th></tr></thead><tbody><tr><td>是</td><td>list</td><td>是</td><td>无</td><td>否</td><td>list(其他)</td><td><code>v=[]或v=list()</code></td></tr><tr><td>否</td><td>tuple</td><td>是</td><td>无</td><td>是</td><td>tuple(其他)</td><td><code>v=()或v=tuple()</code></td></tr><tr><td>是</td><td>set</td><td>否</td><td>可哈希</td><td>否</td><td>set(其他)</td><td><code>v=set()</code></td></tr></tbody></table><p>​<font color="#dd0000"><strong>注意：集合中的所有元素，包括元素里的子子孙孙都必须是可哈希的</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">data_list &#x3D; [    &quot;alex&quot;,    11,    (11, 22, 33, &#123;&quot;alex&quot;, &quot;eric&quot;&#125;, 22),    [11, 22, 33, 22],    &#123;11, 22, (True, [&quot;中国&quot;, &quot;北京&quot;], &quot;沙河&quot;), 33&#125;]</code></pre><p>​注意：由于True和False本质上存储的是 1 和 0 ，而集合又不允许重复，所以在整数 0、1和False、True出现在集合中会有如下现象：</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#123;True, 1&#125;print(v1)  # &#123;True&#125;v2 &#x3D; &#123;1, True&#125;print(v2)  # &#123;1&#125;v3 &#x3D; &#123;0, False&#125;print(v3)  # &#123;0&#125;v4 &#x3D; &#123;False, 0&#125;print(v4)  # &#123;False&#125;</code></pre><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><ol><li><p>写代码实现</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#123;&#39;alex&#39;,&#39;武sir&#39;,&#39;肖大&#39;&#125;v2 &#x3D; []# 循环提示用户输入，如果输入值在v1中存在，则追加到v2中，如果v1中不存在，则添加到v1中。（如果输入N或n则停止循环）while True:    name &#x3D; input(&quot;请输入姓名(N&#x2F;n退出)：&quot;)    if name.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    if name in v1:        v2.append(name)else:        v1.add(name)</code></pre></li><li><p>下面那些值不能做集合的元素</p><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;0[11,22,33]   # 不能[]           # 不能(123)&#123;1,2,3&#125;      # 不能</code></pre></li><li><p>模拟用户信息录入程序，已录入则不再创建。</p><pre class="language-python" data-language="python"><code class="language-python">user_info_set &#x3D; set()while True:    name &#x3D; input(&quot;请输入姓名：&quot;)    age &#x3D; input(&quot;请输入年龄：&quot;)item &#x3D; (name,age,)    if item in user_info_set:        print(&quot;该用户已录入&quot;)else:    user_info_set.add(item)</code></pre></li><li><p>给你个列表去重。</p><pre class="language-python" data-language="python"><code class="language-python">v &#x3D; [11,22,11,22,44455]data &#x3D; set(v) # &#123;11,22,44455&#125;result &#x3D; list(data) # [11,22,44455]</code></pre></li></ol><h3 id="强插：None类型"><a href="#强插：None类型" class="headerlink" title="强插：None类型"></a>强插：None类型</h3><p>Python的数据类型中有一个特殊的值None，意味着这个值啥都不是 或 表示空。 相当于其他语言中 <code>null</code>作用一样。</p><p>在一定程度上可以帮助我们去节省内存。例如：</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; Nonev2 &#x3D; None..v1 &#x3D; [11,22,33,44]v2 &#x3D; [111,22,43]</code></pre><pre class="language-python" data-language="python"><code class="language-python">v3 &#x3D; []v4 &#x3D; []...v3 &#x3D; [11,22,33,44]v4 &#x3D; [111,22,43]</code></pre><p>​注意：暂不要考虑Python内部的缓存和驻留机制。</p><p>​<font color="#dd0000"><strong>目前所有转换为布尔值为False的值有：</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">0&quot;&quot;[] or list()() or tuple()set()None</code></pre><pre class="language-python" data-language="python"><code class="language-python">if None:    pass</code></pre><h3 id="2-字典（dict"><a href="#2-字典（dict" class="headerlink" title="2.字典（dict)"></a>2.字典（dict)</h3><p>​字典是 <strong>无序</strong>、<strong>键不重复</strong> 且 元素只能是<strong>键值对</strong>的<strong>可变的</strong>  <strong>容器</strong>。</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &#123; &quot;k1&quot;:1,  &quot;k2&quot;:2 &#125;</code></pre><ul><li><p>容器</p></li><li><p>元素必须键值对</p></li><li><p>键不重复，重复则会被覆盖</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &#123; &quot;k1&quot;:1, &quot;k1&quot;:2 &#125;print(data) # &#123;&quot;k1&quot;:2&#125;</code></pre></li><li><p>无序（在Python3.6+字典就是有序了，之前的字典都是无序。）</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &#123; &quot;k1&quot;:1,  &quot;k2&quot;:2 &#125;print(data)</code></pre></li></ul><h4 id="2-1-定义-2"><a href="#2-1-定义-2" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#123;&#125;v2 &#x3D; dict()</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;     &quot;age&quot;:12,     &quot;status&quot;:True,      &quot;name&quot;:&quot;wupeiqi&quot;,       &quot;hobby&quot;:[&#39;篮球&#39;,&#39;足球&#39;]  &#125;</code></pre><p><font color="#dd0000"><strong>字典中对键值得要求：</strong></font></p><ul><li><font color="#dd0000"><strong>键：必须可哈希。</strong></font> 目前为止学到的可哈希的类型：<font color="#dd0000"><strong>int&#x2F;bool&#x2F;str&#x2F;tuple；</strong></font>不可哈希的类型：<font color="#dd0000"><strong>list&#x2F;set&#x2F;dict。</strong></font>（集合）</li><li><font color="#dd0000"><strong>值：任意类型。</strong></font></li></ul><pre class="language-python" data-language="python"><code class="language-python">data_dict &#x3D; &#123;&quot;武沛齐&quot;:29, True:5,123:5,    (11,22,33):[&quot;alex&quot;,&quot;eric&quot;]&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 不合法v1 &#x3D; &#123;    [1, 2, 3]: &#39;周杰伦&#39;,    &quot;age&quot; : 18&#125; v2 &#x3D; &#123;    &#123;1,2,3&#125;: &quot;哈哈哈&quot;,    &#39;name&#39;:&quot;alex&quot;&#125; v3 &#x3D; &#123;    &#123;&quot;k1&quot;:123,&quot;k2&quot;:456&#125;: &#39;呵呵呵&#39;,    &quot;age&quot;:999&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">data_dict &#x3D; &#123;    1: 29,    True: 5&#125;print(data_dict) # &#123;1: 5&#125;</code></pre><blockquote><p>一般在什么情况下会用到字典呢？当我们想要表示一组固定信息时，用字典可以更加的直观，例如：</p></blockquote><pre class="language-python" data-language="python"><code class="language-python"># 用户列表user_list &#x3D; [ &#123;&quot;name&quot;:&quot;alex&quot;,&quot;pwd&quot;:&quot;123&quot;&#125;, &#123;&quot;name&quot;:&quot;eric&quot;,&quot;pwd&quot;:&quot;123&quot;&#125; ]</code></pre><h4 id="2-2-独有功能-2"><a href="#2-2-独有功能-2" class="headerlink" title="2.2 独有功能"></a>2.2 独有功能</h4><ol><li><p><code>dict.get()</code>获取值</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;     &quot;age&quot;:12,     &quot;status&quot;:True,     &quot;name&quot;:&quot;武沛齐&quot;,    &quot;data&quot;:None&#125;data1 &#x3D; info.get(&quot;name&quot;)print(data1) # 输出：武沛齐data2 &#x3D; info.get(&quot;age&quot;)print(data2) # 输出：12data &#x3D; info.get(&quot;email&quot;) # 键不存在，默认返回 None&quot;&quot;&quot;if data &#x3D;&#x3D; None:    print(&quot;此键不存在&quot;)else:    print(data)if data:    print(data)else:    print(&quot;键不存在&quot;)&quot;&quot;&quot;&quot;&quot;&quot;# 字典的键中是否存在 emailif &quot;email&quot; in info:    data &#x3D; info.get(&quot;email&quot;)    print(data)else:print(&quot;不存在&quot;)&quot;&quot;&quot;data &#x3D; info.get(&quot;hobby&quot;,123)print(data) # 输出：123</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例：user_list &#x3D; &#123;    &quot;wupeiqi&quot;: &quot;123&quot;,    &quot;alex&quot;: &quot;uk87&quot;,&#125;username &#x3D; input(&quot;请输入用户名：&quot;)password &#x3D; input(&quot;请输入密码：&quot;)# None，用户名不存在# 密码，接下来比较密码pwd &#x3D; user_list.get(username)if pwd &#x3D;&#x3D; None:    print(&quot;用户名不存在&quot;)else:    if password &#x3D;&#x3D; pwd:        print(&quot;登录成功&quot;)else:        print(&quot;密码错误&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例：user_list &#x3D; &#123;    &quot;wupeiqi&quot;: &quot;123&quot;,    &quot;alex&quot;: &quot;uk87&quot;,&#125;username &#x3D; input(&quot;请输入用户名：&quot;)password &#x3D; input(&quot;请输入密码：&quot;)# None，用户名不存在# 密码，接下来比较密码pwd &#x3D; user_list.get(username)if pwd:    if password &#x3D;&#x3D; pwd:        print(&quot;登录成功&quot;)else:        print(&quot;密码错误&quot;)else:    print(&quot;用户名不存在&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 案例：user_list &#x3D; &#123;    &quot;wupeiqi&quot;: &quot;123&quot;,    &quot;alex&quot;: &quot;uk87&quot;,&#125;username &#x3D; input(&quot;请输入用户名：&quot;)password &#x3D; input(&quot;请输入密码：&quot;)# None，用户名不存在# 密码，接下来比较密码pwd &#x3D; user_list.get(username)if not pwd:    print(&quot;用户名不存在&quot;)else:    if password &#x3D;&#x3D; pwd:        print(&quot;登录成功&quot;)else:        print(&quot;密码错误&quot;)        # 写代码的准则：简单的逻辑处理放在前面；复杂的逻辑放在后面。</code></pre></li><li><p><code>dict.keys()</code>所有的键</p><pre class="language-python" data-language="python"><code class="language-python">xxxxxxxxxx info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True, &quot;name&quot;:&quot;wupeiqi&quot;,&quot;email&quot;:&quot;xx@live.com&quot;&#125;data &#x3D; info.keys()print(data) # 输出：dict_keys([&#39;age&#39;, &#39;status&#39;, &#39;name&#39;, &#39;email&#39;])    py2 -&gt; [&#39;age&#39;, &#39;status&#39;, &#39;name&#39;, &#39;email&#39;]result &#x3D; list(data)print(result) # [&#39;age&#39;, &#39;status&#39;, &#39;name&#39;, &#39;email&#39;]</code></pre><p>​注意：在Python2中 字典.keys()直接获取到的是列表，而Python3中返回的是<code>高仿列表</code>，这个高仿的列表可以被循环显示。</p><pre class="language-python" data-language="python"><code class="language-python"># 循环info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True, &quot;name&quot;:&quot;wupeiqi&quot;,&quot;email&quot;:&quot;xx@live.com&quot;&#125;for ele in info.keys():    print(ele)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 是否存在info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True, &quot;name&quot;:&quot;wupeiqi&quot;,&quot;email&quot;:&quot;xx@live.com&quot;&#125;# info.keys() # dict_keys([&#39;age&#39;, &#39;status&#39;, &#39;name&#39;, &#39;email&#39;])if &quot;age&quot; in info.keys():    print(&quot;age是字典的键&quot;)else:    print(&quot;age不是&quot;)</code></pre></li><li><p><code>dict.values()</code>所有的值</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True, &quot;name&quot;:&quot;wupeiqi&quot;,&quot;email&quot;:&quot;xx@live.com&quot;&#125;data &#x3D; info.values()print(data) # 输出：dict_values([12, True, &#39;wupeiqi&#39;, &#39;xx@live.com&#39;])</code></pre><p>注意：在Python2中 字典.values()直接获取到的是列表，而Python3中返回的是高仿列表，这个高仿的列表可以被循环显示。</p><pre class="language-python" data-language="python"><code class="language-python"># 循环info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True, &quot;name&quot;:&quot;wupeiqi&quot;,&quot;email&quot;:&quot;xx@live.com&quot;&#125;for val in info.values():    print(val) </code></pre><pre class="language-python" data-language="python"><code class="language-python"># 是否存在info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True, &quot;name&quot;:&quot;wupeiqi&quot;,&quot;email&quot;:&quot;xx@live.com&quot;&#125;if 12 in info.values():    print(&quot;12是字典的值&quot;)else:    print(&quot;12不是&quot;)</code></pre></li><li><p><code>dict.items()</code>所有的键值</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True, &quot;name&quot;:&quot;wupeiqi&quot;,&quot;email&quot;:&quot;xx@live.com&quot;&#125;data &#x3D; info.items()print(data) # 输出 dict_items([ (&#39;age&#39;, 12),  (&#39;status&#39;, True),  (&#39;name&#39;, &#39;wupeiqi&#39;),  (&#39;email&#39;, &#39;xx@live.com&#39;)  ])</code></pre><pre class="language-python" data-language="python"><code class="language-python">for item in info.items():    print(item[0],item[1]) # item是一个元组 (键，值)</code></pre><pre class="language-python" data-language="python"><code class="language-python">for key,value in info.items():    print(key,value) # key代表键，value代表值，将兼职从元组中直接拆分出来了。</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True, &quot;name&quot;:&quot;wupeiqi&quot;,&quot;email&quot;:&quot;xx@live.com&quot;&#125;data &#x3D; info.items()if (&#39;age&#39;, 12) in data:    print(&quot;在&quot;)else:    print(&quot;不在&quot;)</code></pre></li><li><p><code>dict.setdefault()=</code>设置值</p><pre class="language-python" data-language="python"><code class="language-python">data &#x3D; &#123;    &quot;name&quot;: &quot;武沛齐&quot;,    &quot;email&quot;: &#39;xxx@live.com&#39;&#125;data.setdefault(&quot;age&quot;, 18)print(data)  # &#123;&#39;name&#39;: &#39;武沛齐&#39;, &#39;email&#39;: &#39;xxx@live.com&#39;, &#39;age&#39;: 18&#125;data.setdefault(&quot;name&quot;, &quot;alex&quot;)print(data)  # &#123;&#39;name&#39;: &#39;武沛齐&#39;, &#39;email&#39;: &#39;xxx@live.com&#39;, &#39;age&#39;: 18&#125;</code></pre></li><li><p><code>dict.update()</code>更新字典键值对</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True&#125;info.update( &#123;&quot;age&quot;:14,&quot;name&quot;:&quot;武沛齐&quot;&#125; )   # info中没有的键直接添加；有的键则更新值print(info) # 输出：&#123;&quot;age&quot;:14, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;</code></pre></li><li><p><code>dict.pop()</code>移除指定键值对</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;data &#x3D; info.pop(&quot;age&quot;)print(info) # &#123;&quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;print(data) # 12</code></pre></li><li><p><code>dict.popitem()</code>按照顺序移除（后进先出）</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;data &#x3D; info.popitem() # (&quot;name&quot;,&quot;武沛齐&quot; )print(info) # &#123;&quot;age&quot;:12, &quot;status&quot;:True&#125;print(data) # (&quot;name&quot;,&quot;武沛齐&quot;)</code></pre><ul><li>py3.6后，popitem移除最后的值。</li><li>py3.6之前，popitem随机删除。</li></ul></li></ol><pre class="language-python" data-language="python"><code class="language-python"># 练习题&quot;&quot;&quot; 结合下面的两个变量 header 和 stock_dict实现注意输出股票信息，格式如下：SH601778，股票名称:中国晶科、当前价:6.29、涨跌额:+1.92。    SH688566，股票名称:吉贝尔、当前价:...               。...&quot;&quot;&quot;header &#x3D; [&#39;股票名称&#39;, &#39;当前价&#39;, &#39;涨跌额&#39;]stock_dict &#x3D; &#123;    &#39;SH601778&#39;: [&#39;中国晶科&#39;, &#39;6.29&#39;, &#39;+1.92&#39;],     &#39;SH688566&#39;: [&#39;吉贝尔&#39;, &#39;52.66&#39;, &#39;+6.96&#39;],     &#39;SH688268&#39;: [&#39;华特气体&#39;, &#39;88.80&#39;, &#39;+11.72&#39;],     &#39;SH600734&#39;: [&#39;实达集团&#39;, &#39;2.60&#39;, &#39;+0.24&#39;]&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">for stock in stock_dict.keys():    msg &#x3D; &#39;&#123;&#125;,&#39;.format(stock)  # &#39;SH601778，&#39;...    for i in range(len(header)):        if i &#x3D;&#x3D; len(header)-1:            msg +&#x3D; &#39;&#123;&#125;:&#123;&#125;。&#39;.format(header[i], stock_dict[stock][i])  # &#39;SH601778,股票名称:中国晶科、当前价:6.29、涨跌额:+1.92。&#39;...            continue        msg +&#x3D; &#39;&#123;&#125;:&#123;&#125;、&#39;.format(header[i], stock_dict[stock][i])  # &#39;SH688566,股票名称:吉贝尔、当前价:52.66、涨跌额:+6.96、&#39;...    print(msg)</code></pre><h4 id="2-3-公共功能-2"><a href="#2-3-公共功能-2" class="headerlink" title="2.3 公共功能"></a>2.3 公共功能</h4><ol><li><p>求<code>并集</code>（Python3.9新加入）</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; &#123;&quot;k1&quot;: 1, &quot;k2&quot;: 2&#125;v2 &#x3D; &#123;&quot;k2&quot;: 22, &quot;k3&quot;: 33&#125;v3 &#x3D; v1 | v2print(v3) # &#123;&#39;k1&#39;: 1, &#39;k2&#39;: 22, &#39;k3&#39;: 33&#125;</code></pre></li><li><p>长度</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;data &#x3D; len(info)print(data) # 输出：3</code></pre></li><li><p>是否包含</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123; &quot;age&quot;:12,  &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot; &#125;v1 &#x3D; &quot;age&quot; in info()print(v1)</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;v1 &#x3D; &quot;武佩奇&quot; in info.values()print(v1)</code></pre></li></ol><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;: 12, &quot;status&quot;: True, &quot;name&quot;: &quot;武沛齐&quot;&#125;# 输出info.items()获取到的 dict_items([ (&#39;age&#39;, 12),  (&#39;status&#39;, True),  (&#39;name&#39;, &#39;wupeiqi&#39;),  (&#39;email&#39;, &#39;xx@live.com&#39;)  ])v1 &#x3D; (&quot;age&quot;, 12) in info.items()print(v1)</code></pre><ol start="4"><li><p>索引（键）<br>字典不同于元组和列表，字典的索引是<code>键</code>，而列表和元组则是 <code>0、1、2等数值</code> 。</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123; &quot;age&quot;:12,  &quot;status&quot;:True, &quot;name&quot;:&quot;武沛齐&quot;&#125;print( info[&quot;age&quot;] )      # 输出：12print( info[&quot;name&quot;] )# 输出：武沛齐print( info[&quot;status&quot;] )    # 输出：Trueprint( info[&quot;xxxx&quot;] )   # 报错，通过键为索引去获取之后时，键不存在会报错（以后项目开发时建议使用get方法根据键去获取值）value &#x3D; info.get(&quot;xxxxx&quot;) # Noneprint(value)</code></pre></li><li><p>根据键 修改值 和 添加值 和 删除键值对<br>上述示例通过键可以找到字典中的值，通过键也可以对字典进行添加和更新操作</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;info[&quot;gender&quot;] &#x3D; &quot;男&quot;print(info) # 输出： &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;,&quot;gender&quot;:&quot;男&quot;&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;info[&quot;age&quot;] &#x3D; &quot;18&quot; print(info) # 输出： &#123;&quot;age&quot;:&quot;18&quot;, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;del info[&quot;age&quot;]  # 删除info字典中键为age的那个键值对（键不存在则报错）print(info) # 输出： &#123;&quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;: 12, &quot;status&quot;: True, &quot;name&quot;: &quot;武沛齐&quot;&#125;if &quot;agea&quot; in info:    # del info[&quot;age&quot;]    data &#x3D; info.pop(&quot;age&quot;)    print(info)    print(data)else:    print(&quot;键不存在&quot;)</code></pre></li><li><p>for循环<br>由于字典也属于是容器，内部可以包含多个键值对，可以通过循环对其中的：键、值、键值进行循环；</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;for item in info:print(item)  # 所有键</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;for item in info.keys():print(item)</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;for item in info.values():print(item)</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&quot;age&quot;:12, &quot;status&quot;:True,&quot;name&quot;:&quot;武沛齐&quot;&#125;for key,value in info.items():print(key,value)</code></pre></li></ol><h4 id="2-4-转换-2"><a href="#2-4-转换-2" class="headerlink" title="2.4 转换"></a>2.4 转换</h4><p>想要转换为字典.</p><pre class="language-python" data-language="python"><code class="language-python">v &#x3D; dict( [ (&quot;k1&quot;, &quot;v1&quot;), [&quot;k2&quot;, &quot;v2&quot;] ] )print(v) # &#123; &quot;k1&quot;:&quot;v1&quot;, &quot;k2&quot;:&quot;v2&quot; &#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123; &quot;age&quot;:12, &quot;status&quot;:True, &quot;name&quot;:&quot;武沛齐&quot; &#125;v1 &#x3D; list(info)        # [&quot;age&quot;,&quot;status&quot;,&quot;name&quot;]v2 &#x3D; list(info.keys()) # [&quot;age&quot;,&quot;status&quot;,&quot;name&quot;]v3 &#x3D; list(info.values()) # [12,True,&quot;武沛齐&quot;]v4 &#x3D; list(info.items()) # [ (&quot;age&quot;,12), (&quot;status&quot;,True), (&quot;name&quot;,&quot;武沛齐&quot;) ]</code></pre><h4 id="2-5-其他-2"><a href="#2-5-其他-2" class="headerlink" title="2.5 其他"></a>2.5 其他</h4><h5 id="2-5-1-存储原理"><a href="#2-5-1-存储原理" class="headerlink" title="2.5.1 存储原理"></a>2.5.1 存储原理</h5><img src="/2022/05/23/python-mo-kuai-yi-day2/image-20201121131221807.png" class=""><h5 id="2-5-2-速度快"><a href="#2-5-2-速度快" class="headerlink" title="2.5.2 速度快"></a>2.5.2 速度快</h5><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;    &quot;alex&quot;:[&quot;肝胆&quot;,&quot;铁锤&quot;], &quot;老男孩&quot;:[&quot;二蛋&quot;,&quot;缺货&quot;]&#125;for &quot;alex&quot; in info:    print(&quot;在&quot;）</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;    &quot;alex&quot;:[&quot;肝胆&quot;,&quot;铁锤&quot;], &quot;老男孩&quot;:[&quot;二蛋&quot;,&quot;缺货&quot;]&#125;v1 &#x3D; info[&quot;alex&quot;]v2 &#x3D; info.get(&quot;alex&quot;)</code></pre><h5 id="2-5-3-嵌套"><a href="#2-5-3-嵌套" class="headerlink" title="2.5.3 嵌套"></a>2.5.3 嵌套</h5><p>我们已学了很多数据类型，在涉及多种数据类型之间的嵌套时，需注意一下几点：</p><ul><li><p><font color="#dd0000"><strong>字典的键必须可哈希，且它的子子孙孙都必须是可哈希的。（list&#x2F;set&#x2F;dict不可哈希）。</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;    (11,22):123&#125;# 错误info &#x3D; &#123;    (11,[11,22,],22):&quot;alex&quot;&#125;</code></pre></li><li><p>字典的值可以是任意类型。</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;    &quot;k1&quot;:&#123;12,3,5&#125;,&quot;k2&quot;:&#123;&quot;xx&quot;:&quot;x1&quot;&#125;&#125;</code></pre></li><li><p>字典的键和集合的元素在遇到  布尔值 和 1、0 时，需注意重复的情况。</p></li><li><p>元组的元素不可以被替换。</p></li></ul><pre class="language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;name&#39;:&#39;汪峰&#39;,&#39;age&#39;:48,&#39;wife&#39;:[ &#123;&#39;name&#39;:&#39;国际章&#39;,&#39;age&#39;:38&#125;,&#123;&#39;name&#39;:&#39;李杰&#39;,&#39;age&#39;:48&#125; ],&#39;children&#39;:[&#39;第一个娃&#39;,&#39;第二个娃&#39;]&#125;&quot;&quot;&quot;1. 获取汪峰的妻子名字d1 &#x3D; dic[&#39;wife&#39;][0][&#39;name&#39;]print(d1)2. 获取汪峰的孩子们d2 &#x3D; dic[&#39;children&#39;]print(d2)3. 获取汪峰的第一个孩子d3 &#x3D; dic[&#39;children&#39;][0]print(d3)4. 汪峰的媳妇姓名变更为 章子怡dic[&#39;wife&#39;][0][&#39;name] &#x3D; &quot;章子怡&quot;print(dic)5. 汪峰再娶一任妻子dic[&#39;wife&#39;].append( &#123;&quot;name&quot;:&quot;铁锤&quot;,&quot;age&quot;:19&#125; )print(dic)6. 给汪峰添加一个爱好：吹牛逼dic[&#39;hobby&#39;] &#x3D; &quot;吹牛逼&quot;print(dic)7. 删除汪峰的年龄del dic[&#39;age&#39;]或dic.pop(&#39;age&#39;)print(dic)&quot;&quot;&quot;</code></pre><h3 id="3-浮点型（float）"><a href="#3-浮点型（float）" class="headerlink" title="3.浮点型（float）"></a>3.浮点型（float）</h3><p>浮点型，一般在开发中用于表示小数。</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 3.14v2 &#x3D; 9.89</code></pre><p>关于浮点型的其他知识点如下：</p><ul><li><p>在类型转换时需要，在浮点型转换为整型时，会将小数部分去掉。</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 3.14 data &#x3D; int(v1)print(data) # 3</code></pre></li><li><p>想要保留小数点后N位</p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 3.1415926result &#x3D; round(v1,3)print(result) # 3.142</code></pre></li><li><p>浮点型的坑（所有语言中）</p><img src="Python模块一day2/image-20201121190846593.png" alt="image-20201121190846593" style="zoom: 33%;" /><p>底层原理视频：<a href="https://www.bilibili.com/video/BV1354y1B7o1/">https://www.bilibili.com/video/BV1354y1B7o1/</a></p><p>在项目中如果遇到精确的小数计算应该怎么办？</p></li></ul><pre class="language-python" data-language="python"><code class="language-python">import decimalv1 &#x3D; decimal.Decimal(&quot;0.1&quot;)v2 &#x3D; decimal.Decimal(&quot;0.2&quot;)v3 &#x3D; v1 + v2print(v3) # 0.3</code></pre><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ol><li><p>集合，是 无序、不重复、元素必须可哈希、可变的一个容器（子孙元素都必须是可哈希）。</p></li><li><p>集合的查找速度比较快（底层是基于哈希进行存储）</p></li><li><p>集合可以具有 交并差 的功能。</p></li><li><p>字典是 无序、键不重复 且 元素只能是键值对的可变的一个容器（键子孙元素都必须是可哈希）。</p></li><li><p>py3.6+之后字典就变为有序了。</p></li><li><p>py3.9 新增了一个 <code>&#123;&#125; | &#123;&#125; </code>运算。</p></li><li><p>字典的常见功能。</p></li><li><p>在python2和python3中，字典的 keys() 、values()、items() 三个功能获取的数据类型不一样。</p></li><li><p>None是代表内存中的一个空值。</p><pre class="language-python" data-language="python"><code class="language-python">0&quot;&quot;[] or list()() or tuple()set()None&#123;&#125; or dict()</code></pre></li><li><p>浮点型用于表示小数，但是由于其内部存储原理可能会引发数据存储不够精准。</p></li></ol><h3 id="作业-2"><a href="#作业-2" class="headerlink" title="作业"></a>作业</h3><ol><li><p>根据需求写代码</p><pre class="language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;k1&#39;: &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;, &quot;k3&quot;: [11,22,33]&#125;# 请在字典中添加一个键值对，&quot;k4&quot;: &quot;v4&quot;，输出添加后的字典# 请在修改字典中 &quot;k1&quot; 对应的值为 &quot;alex&quot;，输出修改后的字典# 请在k3对应的值中追加一个元素 44，输出修改后的字典# 请在k3对应的值的第 1 个位置插入个元素 18，输出修改后的字典</code></pre><pre class="language-python" data-language="python"><code class="language-python"># dic.setdefault(&#39;k4&#39;, &#39;v4&#39;)dic[&#39;k4&#39;] &#x3D; &#39;v4&#39;print(dic)# dic.update(&#123;&#39;k1&#39;: &#39;alex&#39;&#125;)dic[&#39;k1&#39;] &#x3D; &#39;alex&#39;print(dic)dic[&#39;k3&#39;].append(44)print(dic)dic[&#39;k3&#39;].insert(0, 18)print(dic)</code></pre></li><li><p>根据需求写代码</p><pre class="language-python" data-language="python"><code class="language-python">dic1 &#x3D; &#123; &#39;name&#39;:[&#39;alex&#39;,2,3,5], &#39;job&#39;:&#39;teacher&#39;, &#39;oldboy&#39;:&#123;&#39;alex&#39;:[&#39;python1&#39;,&#39;python2&#39;,100]&#125;&#125;# 1，将name对应的列表追加⼀个元素’wusir’。# 2，将name对应的列表中的alex全变成大写。# 3，oldboy对应的字典加⼀个键值对’⽼男孩’:’linux’。# 4，将oldboy对应的字典中的alex对应的列表中的python2删除</code></pre><pre class="language-python" data-language="python"><code class="language-python">dic1[&#39;name&#39;].append(&#39;wusir&#39;)print(dic1)dic1[&#39;name&#39;][0] &#x3D; dic1[&#39;name&#39;][0].upper()print(dic1)dic1[&#39;oldboy&#39;][&#39;老男孩&#39;] &#x3D; &#39;linux&#39;print(dic1)dic1[&#39;oldboy&#39;][&#39;alex&#39;].remove(&#39;python2&#39;)print(dic1)</code></pre></li><li><p>循环提示用户输入，并将输入内容添加到字典中（如果输入N或n则停止循环）</p><pre class="language-python" data-language="python"><code class="language-python">例如：用户输入 x1|wupeiqi ,则需要再字典中添加键值对 &#123;&#39;x1&#39;:&quot;wupeiqi&quot;&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">result &#x3D; &#123;    # &#39;x1&#39;:&quot;wupeiqi&quot;,    # ...&#125;while True:    user_input &#x3D; input(&#39;please input a text like &quot;x1|wupeiqi&quot;,input (Q&#x2F;q) to quit: &#39;)    if user_input.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    info_list &#x3D; user_input.split(&#39;|&#39;)  # [x1, wupeiqi]    result[info_list[0]] &#x3D; info_list[1]print(result)</code></pre></li><li><p>判断以下值那个能做字典的key ？那个能做集合的元素？</p><ul><li>1  # key,value</li><li>-1  # key,value</li><li>“”  # key,value</li><li>None  # key,value</li><li>[1,2]  # value</li><li>(1,)  # key,value</li><li>{11,22,33,4}  # value</li><li>{‘name’:’wupeiq’,’age’:18}  # value</li></ul></li><li><p>将字典的键和值分别追加到 key_list 和 value_list 两个列表中，如：</p><pre class="language-python" data-language="python"><code class="language-python">key_list &#x3D; []value_list &#x3D; []info &#x3D; &#123;&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;,&#39;k3&#39;:&#39;v3&#39;&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">for key in info:    key_list.append(key)    value_list.append(info[key])print(key_list)print(value_list)</code></pre></li><li><p>字典dic &#x3D; {‘k1’: “v1”, “k2”: “v2”, “k3”: [11,22,33]}</p><pre class="language-python" data-language="python"><code class="language-python">a. 请循环输出所有的keyb. 请循环输出所有的valuec. 请循环输出所有的key和value</code></pre><pre class="language-python" data-language="python"><code class="language-python">for k in dic:    print(k)for k in dic:    print(dic[k])for k in dic:    print(k, dic[k])</code></pre></li><li><p>请循环打印k2对应的值中的每个元素。</p><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;    &#39;k1&#39;:&#39;v1&#39;,    &#39;k2&#39;:[(&#39;alex&#39;),(&#39;wupeiqi&#39;),(&#39;oldboy&#39;)],&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">for item in info.get(&#39;k2&#39;):    print(item)</code></pre></li><li><p>有字符串”k: 1|k1:2|k2:3  |k3 :4” 处理成字典 {‘k’:1,’k1’:2….} </p><pre class="language-python" data-language="python"><code class="language-python"># 自己版本msg &#x3D; &quot;k: 1|k1:2|k2:3  |k3 :4&quot;result &#x3D; &#123;&#125;msg_list &#x3D; msg.split(&#39;|&#39;)  # [&#39;k: 1&#39;, &#39;k1:2&#39;, &#39;k2:3  &#39;, &#39;k3 :4&#39;]for item in msg_list:    data &#x3D; item.split(&#39;:&#39;)  # [&#39;k&#39;, &#39;1&#39;]...    result[data[0].strip()] &#x3D; int(data[1].strip())  # &#123;&#39;k&#39;:1&#125;...print(result)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 老师版本msg &#x3D; &quot;k: 1|k1:2|k2:3  |k3 :4&quot;result &#x3D; &#123;&#125;msg_list &#x3D; msg.split(&#39;|&#39;)  # [&#39;k: 1&#39;, &#39;k1:2&#39;, &#39;k2:3  &#39;, &#39;k3 :4&#39;]for item in msg_list:    v1, v2 &#x3D; item.split(&#39;:&#39;)  # [&#39;k&#39;, &#39;1&#39;]...    result[v1.strip()] &#x3D; int(v2.strip())  # &#123;&#39;k&#39;:1&#125;...print(result)</code></pre></li><li><p>写代码</p><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;有如下值 li&#x3D; [11,22,33,44,55,66,77,88,99,90] ,将所有大于 66 的值保存至字典的第一个key对应的列表中，将小于 66 的值保存至第二个key对应的列表中。   result &#x3D; &#123;&#39;k1&#39;:[],&#39;k2&#39;:[]&#125;&quot;&quot;&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">li &#x3D; [11, 22, 33, 44, 55, 66, 77, 88, 99, 90]result &#x3D; &#123;&#39;k1&#39;: [], &#39;k2&#39;: []&#125;for num in li:    if num &gt; 66:        result[&#39;k1&#39;].append(num)    elif num &#x3D;&#x3D; 66:        pass    else:        result[&#39;k2&#39;].append(num)print(result)</code></pre></li><li><p>输出商品列表，用户输入序号，显示用户选中的商品</p><pre class="language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;商品列表：  goods &#x3D; [&#123;&quot;name&quot;: &quot;电脑&quot;, &quot;price&quot;: 1999&#125;,&#123;&quot;name&quot;: &quot;鼠标&quot;, &quot;price&quot;: 10&#125;,&#123;&quot;name&quot;: &quot;游艇&quot;, &quot;price&quot;: 20&#125;,&#123;&quot;name&quot;: &quot;美女&quot;, &quot;price&quot;: 998&#125;]要求:1：页面显示 序号 + 商品名称 + 商品价格，如：      1 电脑 1999       2 鼠标 10  ...2：用户输入选择的商品序号，然后打印商品名称及商品价格3：如果用户输入的商品序号有误，则提示输入有误，并重新输入。4：用户输入Q或者q，退出程序。&quot;&quot;&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 自己版本goods &#x3D; [    &#123;&quot;name&quot;: &quot;电脑&quot;, &quot;price&quot;: 1999&#125;,    &#123;&quot;name&quot;: &quot;鼠标&quot;, &quot;price&quot;: 10&#125;,    &#123;&quot;name&quot;: &quot;游艇&quot;, &quot;price&quot;: 20&#125;,    &#123;&quot;name&quot;: &quot;美女&quot;, &quot;price&quot;: 998&#125;]for index in range(len(goods)):    v &#x3D; goods[index].values()  # dict_values([&#39;电脑&#39;, 1999])    list_v &#x3D; list(v)    print(index+1, list_v[0], list_v[1])while True:    user_input &#x3D; input(&#39;please input a number,(Q&#x2F;q) to quit: &#39;)  # 1    if user_input.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    if not user_input.isdecimal():        print(&#39;input type error&#39;)    else:        target_index &#x3D; int(user_input) - 1        if target_index not in range(len(goods)):            print(&#39;out of range&#39;)                    else:            print(goods[target_index][&#39;name&#39;], goods[target_index][&#39;price&#39;])</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 老师版本goods &#x3D; [    &#123;&quot;name&quot;: &quot;电脑&quot;, &quot;price&quot;: 1999&#125;,    &#123;&quot;name&quot;: &quot;鼠标&quot;, &quot;price&quot;: 10&#125;,    &#123;&quot;name&quot;: &quot;游艇&quot;, &quot;price&quot;: 20&#125;,    &#123;&quot;name&quot;: &quot;美女&quot;, &quot;price&quot;: 998&#125;]for index in range(len(goods)):    print(index+1, goods[index][&#39;name&#39;], goods[index][&#39;price&#39;])while True:    user_input &#x3D; input(&#39;please input a number,(Q&#x2F;q) to quit: &#39;)  # 1    # 输入Q\q用户退出    if user_input.upper() &#x3D;&#x3D; &#39;Q&#39;:        break    # 输入非数字退出    if not user_input.isdecimal():        print(&#39;input type error&#39;)        break    # 超出范围退出    if int(user_input) not in range(1, len(goods)+1):        print(&#39;out of range&#39;)        break    target_index &#x3D; int(user_input) - 1    print(goods[target_index][&#39;name&#39;], goods[target_index][&#39;price&#39;])</code></pre></li></ol><h1 id="九-、总结和考试"><a href="#九-、总结和考试" class="headerlink" title="九 、总结和考试"></a>九 、总结和考试</h1><p>​课程目标：对第一模块 “Python基础” 阶段的知识点进行总结和考试，让学员更好的掌握此模块的相关知识。</p><p>课程概要：</p><ul><li>代码规范</li><li>知识补充</li><li>阶段总结（思维导图）</li><li>考试题</li></ul><h2 id="1-代码规范"><a href="#1-代码规范" class="headerlink" title="1. 代码规范"></a>1. 代码规范</h2><p>​程序员写代码是有规范的，不只是实现功能而已。</p><h3 id="1-1-名称"><a href="#1-1-名称" class="headerlink" title="1.1 名称"></a>1.1 名称</h3><p>在Python开发过程中会创建文件夹&#x2F;文件&#x2F;变量等，这些在命名有一些潜规则（编写代码时也要注意pep8规范）。</p><ul><li><p>文件夹，小写 &amp; 小写下划线连接，例如：<code>commands</code>、<code>data_utils</code>等。</p></li><li><p>文件，小写 &amp; 小写下划线连接，例如：<code>page.py</code>、<code>db_convert.py</code>等。</p></li><li><p>变量</p><ul><li>全局变量，大写 &amp; 大写下划线连接，例如：<code>NAME = &quot;武沛齐&quot;</code> 、<code>BASE_NAME = 18</code></li><li>局部变量，小写 &amp; 小写下划线连接，例如：<code>data = [11,22,33]</code>、<code>user_parent_id = 9</code>等。</li></ul></li></ul><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p>作为程序员，写代码注释是非常基础且有用的技能，方便以后对代码进行维护和理解。</p><ul><li><p>文件夹</p><img src="/2022/05/23/python-mo-kuai-yi-day2/image-20201122135126441.png" class="" title="image-20201122135126441"></li><li><p>文件注释</p><pre class="language-python" data-language="python"><code class="language-python">除此&quot;&quot;&quot;这个文件主要为项目提供工具和转换的功能，初次之外还有日志....例如：.........&quot;&quot;&quot;....</code></pre></li><li><p>代码注释</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;alex&quot;# 在名称后面添加一个大烧饼data &#x3D; name + &quot;dsb&quot; print(data)</code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;alex&quot;&quot;&quot;&quot;在名称后面添加一个大烧饼，内部的实现机制：1. xxx    2. xxx    3. xx&quot;&quot;&quot;data &#x3D; name + &quot;dsb&quot; print(data)</code></pre></li></ul><h3 id="1-3-todo"><a href="#1-3-todo" class="headerlink" title="1.3 todo"></a>1.3 todo</h3><p>基于注释可以实现todo注释的效果，例如：</p><img src="Python模块一day2/image-20201122112314543.png" alt="image-20201122112314543" style="zoom: 33%;float:left;" /><h3 id="1-4-条件嵌套"><a href="#1-4-条件嵌套" class="headerlink" title="1.4 条件嵌套"></a>1.4 条件嵌套</h3><p>以后写条件语句一定要想办法减少嵌套的层级（最好不要超过3层）。</p><img src="Python模块一day2/image-20201122112505721.png" alt="image-20201122112505721" style="zoom: 33%;float:left;" /><h3 id="1-5-简单逻辑先处理"><a href="#1-5-简单逻辑先处理" class="headerlink" title="1.5 简单逻辑先处理"></a>1.5 简单逻辑先处理</h3><p>示例1：</p><pre class="language-python" data-language="python"><code class="language-python">goods &#x3D; [    &#123;&quot;name&quot;: &quot;电脑&quot;, &quot;price&quot;: 1999&#125;,    &#123;&quot;name&quot;: &quot;鼠标&quot;, &quot;price&quot;: 10&#125;,    &#123;&quot;name&quot;: &quot;游艇&quot;, &quot;price&quot;: 20&#125;,    &#123;&quot;name&quot;: &quot;美女&quot;, &quot;price&quot;: 998&#125;]for index in range(len(goods)):    item &#x3D; goods[index]    print(index + 1, item[&#39;name&#39;], item[&#39;price&#39;])while True:    num &#x3D; input(&quot;请输入要选择的商品序号(Q&#x2F;q)：&quot;)  # &quot;1&quot;    if num.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    if num.isdecimal():        num &#x3D; int(num)        if 0 &lt; num &lt; 5:            target_index &#x3D; num - 1            choice_item &#x3D; goods[target_index]            print(choice_item[&quot;name&quot;], choice_item[&#39;price&#39;])        else:            print(&quot;序号范围选择错误&quot;)    else:        print(&quot;用户输入的序号格式错误&quot;)</code></pre><p>示例2：</p><pre class="language-python" data-language="python"><code class="language-python">goods &#x3D; [    &#123;&quot;name&quot;: &quot;电脑&quot;, &quot;price&quot;: 1999&#125;,    &#123;&quot;name&quot;: &quot;鼠标&quot;, &quot;price&quot;: 10&#125;,    &#123;&quot;name&quot;: &quot;游艇&quot;, &quot;price&quot;: 20&#125;,    &#123;&quot;name&quot;: &quot;美女&quot;, &quot;price&quot;: 998&#125;]for index in range(len(goods)):    item &#x3D; goods[index]    print(index + 1, item[&#39;name&#39;], item[&#39;price&#39;])while True:    num &#x3D; input(&quot;请输入要选择的商品序号(Q&#x2F;q)：&quot;)  # &quot;1&quot;    if num.upper() &#x3D;&#x3D; &quot;Q&quot;:        break    if not num.isdecimal():        print(&quot;用输入的格式错误&quot;)        break    num &#x3D; int(num)    if num &gt; 4 or num &lt; 0:        print(&quot;范围选择错误&quot;)        break    target_index &#x3D; num - 1    choice_item &#x3D; goods[target_index]    print(choice_item[&quot;name&quot;], choice_item[&#39;price&#39;])</code></pre><h3 id="1-6-循环"><a href="#1-6-循环" class="headerlink" title="1.6 循环"></a>1.6 循环</h3><p>尽量少循环多干事，提高代码效率。</p><pre class="language-python" data-language="python"><code class="language-python"># 效率更高，只循环了一次字典infokey_list &#x3D; []value_list &#x3D; []info &#x3D; &#123;&#39;k1&#39;: &#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;, &#39;k3&#39;: &#39;v3&#39;&#125;for key, value in info.items():    key_list.append(key)    value_list.append(value)</code></pre><pre class="language-python" data-language="python"><code class="language-python">info &#x3D; &#123;&#39;k1&#39;: &#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;, &#39;k3&#39;: &#39;v3&#39;&#125;key_list &#x3D; list(info.keys())value_list &#x3D; list(info.values())</code></pre><h3 id="1-7-变量和值"><a href="#1-7-变量和值" class="headerlink" title="1.7 变量和值"></a>1.7 变量和值</h3><pre class="language-python" data-language="python"><code class="language-python"># 推荐name &#x3D; &quot;武沛齐&quot;age &#x3D; 19</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 不推荐name&#x3D;&quot;武沛齐&quot;age&#x3D; 18</code></pre><p>可以基于Pycharm的格式化工具来实现自动处理。</p><p>python代码规范：PEP8规范。</p><h2 id="2-知识补充"><a href="#2-知识补充" class="headerlink" title="2.知识补充"></a>2.知识补充</h2><h3 id="2-1-pass"><a href="#2-1-pass" class="headerlink" title="2.1 pass"></a>2.1 pass</h3><p>​一般Python的代码块是基于 <code>:</code> 和<code>缩进</code>来实现，Python中规定代码块中必须要有代码才算完整，在没有代码的情况下为了<font color="#dd0000"><strong>保证语法的完整性</strong></font>可以用pass代替，例如：</p><pre class="language-python" data-language="python"><code class="language-python"># 其他编程语言if 提交&#123;    ...&#125;else&#123;    ....&#125;</code></pre><pre class="language-python" data-language="python"><code class="language-python">if 条件 :    passelse:    pass</code></pre><pre class="language-python" data-language="python"><code class="language-python">for i in range(xxx):    pass</code></pre><h3 id="2-2-is-比较"><a href="#2-2-is-比较" class="headerlink" title="2.2 is 比较"></a>2.2 is 比较</h3><p><code>is</code> 和 <code>==</code>的区别是什么？</p><ul><li><code>==</code>，用于比较两个值是否相等。</li><li>is，用于表示内存地址是否一致。</li></ul><pre class="language-python" data-language="python"><code class="language-python"># 示例1v1 &#x3D; []v2 &#x3D; []print( v1 &#x3D;&#x3D; v2 )  # True，两个值相当print( v1 is v2 )  # False，不属于同一块内存。</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 示例2v1 &#x3D; []v2 &#x3D; v1print( v1 &#x3D;&#x3D; v2 )  # True，两个值相当print( v1 is v2 )  # True，属于同一块内存。</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 示例3v1 &#x3D; Nonev2 &#x3D; Noneprint(v1 &#x3D;&#x3D; v2)  # True，两个值相当print(v1 is v2)  # True，属于同一块内存。</code></pre><h3 id="2-3-位运算"><a href="#2-3-位运算" class="headerlink" title="2.3 位运算"></a>2.3 位运算</h3><p>计算机底层本质上都是二进制，我们平时在计算机中做的很多操作底层都会转换为二进制的操作，位运算就是对二进制的操作。</p><ul><li><p><code>&amp;</code>，与（都为1）</p><pre class="language-python" data-language="python"><code class="language-python">a &#x3D; 60            # 60 &#x3D; 0011 1100 b &#x3D; 13            # 13 &#x3D; 0000 1101 c &#x3D; a &amp; b         # 12 &#x3D; 0000 1100</code></pre></li><li><p><code>|</code>，或（只要有一个为1）</p><pre class="language-python" data-language="python"><code class="language-python">a &#x3D; 60            # 60 &#x3D; 0011 1100 b &#x3D; 13            # 13 &#x3D; 0000 1101 c &#x3D; a | b         # 61 &#x3D; 0011 1101 </code></pre></li><li><p><code>^</code>，异或（值不同）</p><pre class="language-python" data-language="python"><code class="language-python">a &#x3D; 60            # 60 &#x3D; 0011 1100 b &#x3D; 13            # 13 &#x3D; 0000 1101 c &#x3D; a ^ b         # 49 &#x3D; 0011 0001 </code></pre></li><li><p><code>~</code>，取反</p><pre class="language-python" data-language="python"><code class="language-python">a &#x3D; 60            #  60 &#x3D; 0011 1100 c &#x3D; ~a;           # -61 &#x3D; 1100 0011</code></pre></li><li><p><code>&lt;&lt;</code>，左移动</p><pre class="language-python" data-language="python"><code class="language-python">a &#x3D; 60            #  60 &#x3D; 0011 1100c &#x3D; a &lt;&lt; 2;       # 240 &#x3D; 1111 0000</code></pre></li><li><p><code>&gt;&gt;</code>，右移动</p><pre class="language-python" data-language="python"><code class="language-python">a &#x3D; 60            # 60 &#x3D; 0011 1101 c &#x3D; a &gt;&gt; 2;       # 15 &#x3D; 0000 1111</code></pre></li></ul><p>平时在开发中，二进制的位运算几乎很好少使用，在计算机底层 或 网络协议底层用的会比较多，例如：</p><ul><li><p>计算  2**n</p><pre class="language-python" data-language="python"><code class="language-python">2**0    1 &lt;&lt; 0   1     12**1    1 &lt;&lt; 1   10    22**2    1 &lt;&lt; 2   100   42**3    1 &lt;&lt; 3   1000  8...</code></pre></li></ul><h4 id="面试题：计算一个数的一半"><a href="#面试题：计算一个数的一半" class="headerlink" title="面试题：计算一个数的一半"></a><font color="#dd0000"><strong>面试题：计算一个数的一半</strong></font></h4><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 10 &gt;&gt; 1 print(v1) # 值为5v2 &#x3D; 20 &gt;&gt; 1print(v2) # 值为 10</code></pre><ul><li><p>网络传输数据，文件太大还未传完（websocket源码为例）。</p><pre class="language-python" data-language="python"><code class="language-python">     第1个字节         第2个字节         ...  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len |    Extended payload length    ||I|S|S|S|  (4)  |A|     (7)     |             (16&#x2F;64)           ||N|V|V|V|       |S|             |   (if payload len&#x3D;&#x3D;126&#x2F;127)   || |1|2|3|       |K|             |                               |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +FIN位置是0，表示这是一部分数据，后续还有数据。FIN位置是1，表示这是最后数据，已发送完毕。</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 例如：接收到的第一个字节的值为245（11110101），让v的二进制和 1000 0000 做 &amp; 与运算。v &#x3D; 245   # 245 11110101          # 128 10000000                10000000    data &#x3D; v &amp; 128if data &#x3D;&#x3D; 0:    print(&quot;还有数据&quot;)else:    print(&quot;已完毕&quot;)</code></pre></li></ul><h2 id="3-阶段总结"><a href="#3-阶段总结" class="headerlink" title="3.阶段总结"></a>3.阶段总结</h2><p>可使用思维导图（ xmind 软件），对阶段知识点的内容进行梳理，将知识梗概和重点写出来，也便于以后的回顾和复习。</p><img src="/2022/05/23/python-mo-kuai-yi-day2/image-20201122122813525.png" class="" title="image-20201122122813525"><h2 id="4-考试题"><a href="#4-考试题" class="headerlink" title="4.考试题"></a>4.考试题</h2><p>考试题的目的是让大家对自己近期知识点学习练习 以及 自测，请大家务必【独立】完成（切勿翻看笔记 &amp; 切勿网上搜索 ）。</p><ul><li><p>第一步：自己独立完成（闭卷）</p></li><li><p>第二步：做完之后，翻看自己笔记去修改和更正。</p></li><li><p>第三步：觉自己做的没问题了，最后再去看考试题的参考答案和讲解。</p></li></ul><p>详情见附件《第一阶段考试题.md》文件。</p>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 第一阶段 </tag>
            
            <tag> python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块1--day1</title>
      <link href="/2022/05/20/python-mo-kuai-yi-day1/"/>
      <url>/2022/05/20/python-mo-kuai-yi-day1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h2><h3 id="（一）授课模式"><a href="#（一）授课模式" class="headerlink" title="（一）授课模式"></a>（一）授课模式</h3><img src="Python模块一day1/5524d8bea9b140b7ab911ca5c024a9b5.png" alt="img" style="zoom: 67%;" /><h3 id="（二）学习方法"><a href="#（二）学习方法" class="headerlink" title="（二）学习方法"></a>（二）学习方法</h3><h4 id="严格训练、反复练习、疲劳战"><a href="#严格训练、反复练习、疲劳战" class="headerlink" title="严格训练、反复练习、疲劳战"></a>严格训练、反复练习、疲劳战</h4><p>学生完成</p><h4 id="激发积极性、快乐学习、梦想飞扬"><a href="#激发积极性、快乐学习、梦想飞扬" class="headerlink" title="激发积极性、快乐学习、梦想飞扬"></a>激发积极性、快乐学习、梦想飞扬</h4><p>老师激发学生兴趣</p><h4 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h4><ul><li><p>随堂笔记</p></li><li><p><font color="#dd0000"> 对比完成</font>课堂练习和作业</p></li><li><p>阶段总结&amp;思维导图</p></li><li><p>错题本</p></li><li><p>单词本</p></li></ul><h3 id="（三）笔记"><a href="#（三）笔记" class="headerlink" title="（三）笔记"></a>（三）笔记</h3><h3 id="1、下载Typora"><a href="#1、下载Typora" class="headerlink" title="1、下载Typora"></a>1、下载Typora</h3><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20201011095314682-16577177175361.png" class=""><h3 id="2、切换至大纲视图"><a href="#2、切换至大纲视图" class="headerlink" title="2、切换至大纲视图"></a>2、切换至大纲视图</h3><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20220520192803560-16577177230502.png" class=""><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20220520192813266-16577177317553.png" class=""><h3 id="3、Markdown语法"><a href="#3、Markdown语法" class="headerlink" title="3、Markdown语法"></a>3、Markdown语法</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题(#)"></a>标题(#)</h4><ul><li><p><code># 一级标题</code></p></li><li><p>x def fib(max_count):    first &#x3D; 1    second &#x3D; 0    count &#x3D; 0    while count &lt; max_count:        next_value &#x3D; first + second        first &#x3D; second        second &#x3D; next_value        yield next_value        count +&#x3D; 1​​count &#x3D; input(“请输入要生成斐波那契数列的个数：”)count &#x3D; int(count)fib_generator &#x3D; fib(count)for num in fib_generator:    print(num)python</p></li><li><p><code>### 三级标题</code></p></li><li><p><code>共六级标题</code></p></li></ul><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表(- )"></a>无序列表(- )</h4><ul><li><p><code>- 内容</code></p></li><li><p><code>- 内容</code></p></li><li><p><code>- 内容</code></p></li></ul><h4 id="有序列表-1"><a href="#有序列表-1" class="headerlink" title="有序列表(1. )"></a>有序列表(1. )</h4><ul><li><code>1. 内容</code></li><li><code>2. 内容</code></li><li>​    <code>- 内容</code></li><li>​    <code>- 内容</code> </li><li><code>内容</code></li></ul><h4 id="引用-gt"><a href="#引用-gt" class="headerlink" title="引用(&gt; )"></a>引用(&gt; )</h4><blockquote><p><code> &gt; 计算机一门xx学科</code></p></blockquote><h4 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h4><pre class="language-python" data-language="python"><code class="language-python">&#96;&#96;&#96;Python内容&#96;&#96;&#96;</code></pre><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a><font color="#dd0000">图片</font></h4><pre class="language-python" data-language="python"><code class="language-python">  想要在文档中显示图片时，可以通过 &#96;![](图片路径)&#96;来展示，但这种编写方式比较麻烦，因为需要自己录入图片的路径，所以一般不会这么写入图片，而是选择直接 复制图片 或 截图 直接粘贴到文档中，Typora可以自动帮助我们生成图片格式。</code></pre><p>​为了将文档中的管理文档中的图片，防止因为删除导致图片在文档中丢失，所以一般会在Typora中设置成将文档中的图片都复制到制定目录。</p><p>​在Typora中找到设置页面，并按照图片先进行如下设置：</p><img src="Python模块一day1/image-20220520194108838.png" alt="image-20220520194108838" style="zoom:80%;" /><p>​那些接下来就可以直接将图片粘贴到文档中且Typora自动将图片保存至文档根目录的 assets 文件夹中。</p><img src="Python模块一day1/image-20220520194208916.png" alt="image-20220520194208916" style="zoom: 80%;" /><h2 id="二、计算机基础和环境搭建"><a href="#二、计算机基础和环境搭建" class="headerlink" title="二、计算机基础和环境搭建"></a>二、计算机基础和环境搭建</h2><p>​课程目标：了解计算机基础知识并完成Python的环境搭建</p><h3 id="（一）计算机基础"><a href="#（一）计算机基础" class="headerlink" title="（一）计算机基础"></a>（一）计算机基础</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>计算机的组成</p><pre class="language-none"><code class="language-none">计算机是由多个硬件组合而成，常见的硬件有：CPU、硬盘、内存、网卡、显示器、机箱、电源......</code></pre></li></ul><p>​<strong>注意事项：机械的将零件组合在一起，他们之间无法进行协作</strong></p><ul><li><p>操作系统</p><p>用于协调计算机的各个硬件，让硬件之间进行协调操作，已完成某个目标。</p><pre class="language-none"><code class="language-none">常见的操作系统分类- windows， 优点：生态牛逼、工具多；缺点：略慢、收费。[个人]- xp- win7- win10- ...- linux， 优点：资源占用少、免费（很多公式的服务器用linux）；缺点：工具少、告别游戏（不支持linux系统）[企业的服务器]- centos- ubantu- redhat- ...- mac， 优点：生态还行、工具差不多都有、用户体验和交互；缺点：不能玩游戏、</code></pre></li><li><p>软件（应用程序）</p><pre class="language-none"><code class="language-none">在安装完操作系统之后，我们会在自己的电脑上安装一些常用的电脑软件，例如：QQ，杀毒，微信...问题来了：这些软件是由谁开发的？是由各大公司的程序员开发的。以后的你肯定是写&#96;软件&#96;，可以把软件理解成为一大堆的代码（一篇文章）。</code></pre></li></ul><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20220520201008629.png" class=""><h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><p>​作文，是由小学生使用 汉语&#x2F;英语&#x2F;法语&#x2F;日语… 写出来一大堆的文字的集合。<font color="#dd0000">软件，是由程序员使用编程语言开发出来的一大堆代码的集合</font>。全球的编程语言有2500+多种，常见的编程语言：Java、C#、Python、PHP、C…</p><p>​本质上学习编程语言就是学习他的语法，根据语法再去编写相应的软件中的功能。</p><ul><li><p>Python语言中输出的语法规则</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;我是Alex的二大爷&quot;)</code></pre></li><li><p>Golang语言中的输出的语法规则</p><pre class="language-go" data-language="go"><code class="language-go">fmt.Println(&quot;我是Alex二大爷&quot;)</code></pre></li></ul><h4 id="编译器-x2F-解释器"><a href="#编译器-x2F-解释器" class="headerlink" title="编译器&#x2F;解释器"></a>编译器&#x2F;解释器</h4><p>​编译器&#x2F;解释器，就是一个<code>翻译官</code>，将代码翻译成计算机能够识别的命令。</p><pre class="language-none"><code class="language-none">A使用Python开发了一个软件 1000              B使用Golang开发了一个软件 2000       Python解释器                        Golang编译器                    操    作    系    统               CPU    硬盘    网卡    内存    电源 .....</code></pre><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20220520201406497.png" class=""><p>​<font color="#dd0000"><strong>为什么有的叫解释器？有的叫编译器？</strong></font></p><ul><li><font color="#dd0000">解释器，实时翻译。</font>拿到1000行代码之后，解释一句交给操作系统一句(Python、PHP、JavaScript、Ruby…一般称为<font color="#dd0000">解释型语言</font>)。</li><li><font color="#dd0000">编译器，全文翻译。</font>拿到1000行代码之后会将他编译成一个临时文件（计算机能够识别命令），再把文件交给操作系统去读取(C、C++、Go、Java…一般称为<font color="#dd0000">编译型语言</font>)。</li></ul><h3 id="（二）学习编程的本质"><a href="#（二）学习编程的本质" class="headerlink" title="（二）学习编程的本质"></a>（二）学习编程的本质</h3><ul><li>选择一门编程语言，在自己的电脑上安装此编程语言相关的编译器&#x2F;解释器。</li><li>学习编程语言的语法规则，根据语法规则 + 业务背景 设计并开发你的软件（代码集合）。</li><li>使用 编译器&#x2F;解释器 去运行自己写的代码。</li></ul><h3 id="（三）Python介绍"><a href="#（三）Python介绍" class="headerlink" title="（三）Python介绍"></a>（三）Python介绍</h3><h4 id="语言的分类"><a href="#语言的分类" class="headerlink" title="语言的分类"></a>语言的分类</h4><ul><li><p><code>翻译</code>的维度</p><ul><li>解释型语言，Python、Ruby….</li><li>编译型语言，C、C++、Golang</li></ul></li><li><p><code>高低</code>的维度</p><ul><li><p>低级编程语言，写出来的代码直接可以被计算机识别。</p><pre class="language-none"><code class="language-none">机器语言，101 001 00001 00010 001000100010001，机器码，交给计算机去执行。汇编语言，MOV INC ... ，指令，交给计算机去执行。</code></pre></li><li><p>高级编程语言，写出来的代码无法直接被计算机识别，但可以通过某中方式将其转换为计算机可以识别的语言。</p><ul><li>&#96;&#96;&#96;<br>C、C++、Java、Python、Ruby…，这类编程语言在编写代码时几乎是写英语作文。<br>交由相关编译器或解释器翻译成机器码，然后再交给计算机去执行。</li></ul><p><strong>注意：现在基本上都使用高级编程语言。</strong></p></li></ul></li></ul><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><blockquote><p>Python的创始人为吉多·范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。</p></blockquote><p>全球众多编程语言，为何Python可以脱颖而出成为业界炙手可热的编程语言？目前位居TIOBE排行榜第三名并且一直呈上升趋势。</p><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20220520203519432.png" class=""><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20220520203526151.png" class=""><p><strong>Python如此火爆的原因如下：</strong></p><ul><li><font color="#dd0000">语法简洁 &amp; 适合小白学习，</font>相比较于其他编程语言Python的学习成本非常低，甚至可以让其他行业的人快速掌握编程技能，通过编程提供工作效率，例如：Excel自动化办公、文件和文件夹的处理等。</li><li><font color="#dd0000">类库强大，</font>Python自诞生之初就任其自然生长，经过多年的发展，造就其在很多领域都是积累了很多方便的类库，自然也成为了运维自动化、数据分析、机器学习首选编程语言。</li><li><font color="#dd0000">开发效率极高，</font>结合Python语法精炼和类库齐全的特点，所以在使用Python进行开发时可以用更少的代码完成更多的功能，大大提升开发效率。例如：Python10行代码实现的功能，用其他语言可能需要100+行才能完成。</li></ul><h4 id="Python的解释器种类（了解）"><a href="#Python的解释器种类（了解）" class="headerlink" title="Python的解释器种类（了解）"></a>Python的解释器种类（了解）</h4><p>​由于Python太火了，所有就有很多的公司都开发了Python解释器（用来翻译python代码成为计算机能够识别的命令）。</p><ul><li><p>CPython【主流】，底层是由C语言开发出来的Python解释器。</p></li><li><p>Jython，是由Java语言开发出来的Python解释器，方便与让Python和Java代码做集成。</p></li><li><p>IronPython，是基于C#语言开发出来的Python解释器，方便与让Python和C#代码做集成。</p></li><li><p>RubyPython，…</p></li><li><p>PyPy，是对CPython的优化，他的执行效率提高了。引入编译器的功能，本质上将Python代码进行编译，再去执行编译后的代码。</p></li><li><p>…</p><p><strong>注意：常说的Python解释器默认指的就是CPython解释器。</strong></p></li></ul><p>​CPython的解释器主要有两大版本：</p><ul><li><p>2.x，目前最新的Python2.7.18。（2020后不再维护）</p><pre class="language-none"><code class="language-none">Being the last of the 2.x series, 2.7 received bugfix support until 2020. Support officially stopped January 1 2020, and 2.7.18 code freeze occurred on January 1 2020, but the final release occurred after that date.</code></pre></li><li><p>3.x，目前最新的3.9.0版本（授课）</p></li></ul><h3 id="（四）Python环境搭建"><a href="#（四）Python环境搭建" class="headerlink" title="（四）Python环境搭建"></a>（四）Python环境搭建</h3><ul><li>Python解释器，将程序员编写的python代码翻译成计算机能够识别的指令。<ul><li>主流CPython</li><li>3.9.0版本</li></ul></li><li>学习编程本质上的3件事<ul><li>安装 CPython 3.9.0版本解释器</li><li>学习Python语法并写代码</li><li>解释器去运行代码</li></ul></li></ul><h4 id="安装Python解释器（mac）"><a href="#安装Python解释器（mac）" class="headerlink" title="安装Python解释器（mac）"></a>安装Python解释器（mac）</h4><ul><li><p>去Python官网下载Python解释器（3.9.0版本）</p><pre class="language-none"><code class="language-none">https:&#x2F;&#x2F;www.python.org&#x2F;</code></pre></li><li><p>安装</p><pre class="language-none"><code class="language-none">默认Python解释器安装目录： &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9有bin目录下有一个 python3.9 文件，他就是Python解释器的启动文件。解释器路径：&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;python3.9 </code></pre></li><li><p>写一个简单的Python代码并且让解释器去运行。</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; input(&quot;请输入用户名:&quot;)print(&quot;欢迎使用NB系统：&quot;,name)</code></pre><p>将文件保存在：文稿&#x2F;hello.py【&#x2F;Users&#x2F;wupeiqi&#x2F;Documents&#x2F;hello.py】</p><p>接下来要让解释器去运行代码文件：</p><pre class="language-none"><code class="language-none">- 打开终端- 在终端输入：解释器 代码文件  &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;python3.9 &#x2F;Users&#x2F;wupeiqi&#x2F;Documents&#x2F;hello.py</code></pre></li><li><p>【补充】系统环境变量</p><pre class="language-none"><code class="language-none">- 假设你有30个Python文件要运行   &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;python3.9 &#x2F;Users&#x2F;wupeiqi&#x2F;Documents&#x2F;hello1.py   ...   &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;python3.9 &#x2F;Users&#x2F;wupeiqi&#x2F;Documents&#x2F;hello30.py- Python解释器的路径每次不用再写这么长。    - 将  &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin 添加到系统的环境变量中。    - 以后再使用Python解释器去运行python代码时，就可以这样（Python会自动将环境变量中的安装目录和Python可执行文件进行拼接）：     python3.9 &#x2F;Users&#x2F;wupeiqi&#x2F;Documents&#x2F;hello1.py     ...     python3.9 &#x2F;Users&#x2F;wupeiqi&#x2F;Documents&#x2F;hello2.py- 如何将 &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin 添加到系统的环境变量中 ？- 默认你不用添加，默认Python解释器在安装的过程中已经帮你添加了。- 自己手动想添加： - 打开用户目录的下的  .bash_profile 文件（.zprofile） - 在文件中写如下内容</code></pre><pre class="language-none"><code class="language-none"># Setting PATH for Python 3.9# The original version is saved in .zprofile.pysavePATH&#x3D;&quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin:$&#123;PATH&#125;&quot;export PATH</code></pre></li></ul><h4 id="安装Python解释器（win）"><a href="#安装Python解释器（win）" class="headerlink" title="安装Python解释器（win）"></a>安装Python解释器（win）</h4><ul><li><p>Python官网下载Python解释器</p><pre class="language-none"><code class="language-none">https:&#x2F;&#x2F;www.python.org&#x2F;downloads&#x2F;release&#x2F;python-390&#x2F;</code></pre></li><li><p>在自己电脑上进行安装</p><pre class="language-none"><code class="language-none">python解释器安装目录：C:\Python39python解释器的路径：C:\Python39\python.exe</code></pre></li><li><p>编写一个Python代码并交给Python解释器去运行</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; input(&quot;请输入用户名&quot;)print(&quot;欢迎使用NB系统&quot;,name)</code></pre><p>并将文件保存在：Y:\hello.py</p><p>怎么让解释器去运行写好的代码文件呢？</p><pre class="language-none"><code class="language-none">- 打开终端- 在终端输入：解释器路径 代码路径</code></pre></li><li><p>优化配置（让以后操作Python解释器去运行代码时候更加方便）</p><pre class="language-none"><code class="language-none">- 写了30个Python代码，想要使用解释器去运行。    C:\Python39\python.exe Y:\hello1.py    C:\Python39\python.exe Y:\hello2.py    ...    C:\Python39\python.exe Y:\hello10.py- 然你以后可以方便的去运行代码，不用再写Python解释器所在的路径。       只要你将 C:\Python39 路径添加到系统的环境变量中。以后你在终端就可以（Python会自动将环境变量中的安装目录和Python可执行文件进行拼接）：        python.exe Y:\hello1.py        - 如何将 C:\Python39 添加到环境变量呢？【默认在解释器安装的时已自动添加到环境变量了】此电脑\右键属性\高级系统保护\高级\环境变量\用户变量\PATH\新建\加入python解释器路径重新打开终端</code></pre></li></ul><h4 id="安装Pycharm编辑器（mac"><a href="#安装Pycharm编辑器（mac" class="headerlink" title="安装Pycharm编辑器（mac)"></a>安装Pycharm编辑器（mac)</h4><ol><li><p>帮助我们快速编写代码，用Pycharm可以大大的提高咱们写代码的效率。 +  用解释器去运行代码。</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;asdfasdf&quot;)</code></pre></li></ol><ul><li>下载Pycharm</li></ul><pre class="language-none"><code class="language-none">https:&#x2F;&#x2F;www.jetbrains.com&#x2F;pycharm&#x2F;</code></pre><ul><li><p>安装</p></li><li><p>快速使用，写代码+运行代码</p></li><li><p>破解Pycharm（专业版）</p></li></ul><h4 id="安装Pycharm编辑器（win"><a href="#安装Pycharm编辑器（win" class="headerlink" title="安装Pycharm编辑器（win)"></a>安装Pycharm编辑器（win)</h4><ul><li><p>下载Pycharm</p><pre class="language-none"><code class="language-none">https:&#x2F;&#x2F;www.jetbrains.com&#x2F;pycharm&#x2F;download&#x2F;other.html</code></pre></li><li><p>安装</p></li><li><p>快速使用：编写代码 + 运行代码</p></li><li><p>破解Pycharm（专业版）</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>了解硬件 &amp; 操作系统 &amp; 软件（应用系统）之间的关系。</li><li>了解常见的操作系统都有哪些。</li><li>了解编译器和解释器的区别和作用。</li><li>编程语言进行分类</li><li>了解Python解释器的种类</li><li>了解CPython解释器的版本</li><li>学会如何安装Python解释器。</li><li>了解什么环境变量的作用。</li><li>了解Python和Pycharm的区别。</li></ol><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol><li><p>简述硬件 &amp; 操作系统 &amp; 软件（应用系统）之间的关系。</p><pre class="language-none"><code class="language-none">- 硬件是组成计算机的物理物理基础- 操作系统将硬件集成起来，通过将用户指令转化为计算机能够识别的命令，使各硬件之间交互起来- 软件是一堆代码，需要在操作系统上运行</code></pre></li><li><p>列举常见的操作系统都有哪些。</p><pre class="language-none"><code class="language-none">- windos 操作系统- linux 操作系统- mac 操作系统</code></pre></li><li><p>简述编译器和解释器的区别和作用。</p><pre class="language-none"><code class="language-none">解释器：实时翻译，读一行运行一行编译器：全文翻译，读完所有代码，将其翻译成一个临时文件，将零时文件交给操作系统</code></pre></li><li><p>编程语言进行分类</p><pre class="language-none"><code class="language-none">- 按翻译类型- 解释型：Python、Ruby- 翻译型：C、C++- 按高低级- 高级语言：C、C++、Java、Python、Ruby- 低级语言：机器语言和汇编语言</code></pre></li><li><p>Python解释器的种类有哪些？</p><pre class="language-none"><code class="language-none">- CPython：底层由C语言开发出来的解释器- PYPY：Cpython的优化版本，将Python进行编译后在执行，提高了运行效率- Jpthon：底层由Java语言开发出来的解释器，方便Python和Java的集成- IronPython：底层由C#语言开发出来的解释器，方便Python和C#的集成- RubyPython：底层由Ruby语言开发出来的解释器，方便Python和Ruby的集成...</code></pre></li><li><p>CPython解释器的版本有哪些？你现在用的是哪个版本？</p><pre class="language-none"><code class="language-none">大版本- 2.X- 3.X自己使用版本（3.9.0）</code></pre></li><li><p>系统环境变量的作用是什么？</p><pre class="language-none"><code class="language-none">1、在终端执行Python命令时，需要输入完整的Python解释器路径\python3.9 + .py文件完整路径，将Python解释器安装路径加入环境变量后，可直接输入python3.9 + .py文件完整路径2、当调用Python模块和变量时，Python解释器会自动在系统变量中进行查找，找不到就会报错</code></pre></li><li><p>Python和Pycharm的区别是什么？</p><pre class="language-none"><code class="language-none">Python是解释器，将python代码转化为计算机可以识别的命令Pycharm是IDE集成开发环境，方便开发者对于Python的使用，提高写代码和运行代码的效率</code></pre></li></ol><h2 id="三、快速上手"><a href="#三、快速上手" class="headerlink" title="三、快速上手"></a>三、快速上手</h2><p>​课程目标：学习Python最基础的语法知识，可以用代码快速实现一些简单的功能。</p><p>​课程概要：</p><ul><li>初识编码（密码本）</li><li>编程初体验</li><li>输出</li><li>初识数据类型</li><li>变量</li><li>注释</li><li>输入</li><li>条件语句</li></ul><h3 id="（一）编码（密码本）"><a href="#（一）编码（密码本）" class="headerlink" title="（一）编码（密码本）"></a>（一）编码（密码本）</h3><p><strong>计算机中所有的数据本质上都是以0和1的组合来存储</strong>。</p><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20220521101214309.png" class=""><p>​在计算机中会将中文内容（通过编码）转换成 01010101010… ，最终存储到硬盘上。</p><pre class="language-none"><code class="language-none">武     -&gt;      01111111 00011010 010110110沛     -&gt;      01001111 10010000 001110100齐     -&gt;      11111111 00000000 010101010</code></pre><p>​在计算机中有很多种编码。</p><pre class="language-none"><code class="language-none">每种编码都有自己的一套密码本，都维护这自己的一套规则，如：    utf-8编码：        武     -&gt;      01111111 00011010 010110110        沛     -&gt;      01001111 10010000 001110100        齐     -&gt;      11111111 00000000 010101010    gbk编码：        武     -&gt;      11111111 00000010        沛     -&gt;      01001111 01111111        齐     -&gt;      00110011 10101010所以，使用的不同的编码保存文件时，硬盘的文件中存储的0&#x2F;1也是不同的。</code></pre><p><strong>注意事项：以某个编码的形式进行保存文件，以后就要以这种编码去打开这个文件。否则就会出现乱码。</strong></p><pre class="language-none"><code class="language-none">UTF-8编码去保存武沛齐：01111111 00011010 010110110 01001111 10010000 001110100 11111111 00000000 010101010GBK编码形式去打开：乱码</code></pre><h3 id="（二）编程初体验"><a href="#（二）编程初体验" class="headerlink" title="（二）编程初体验"></a>（二）编程初体验</h3><ul><li><p><strong>编码必须要保持：保存和打开一致，否则会乱码。</strong></p></li><li><p>默认Python解释器是以UTF-8编码的形式打开文件。如果想要修改Python的默认解释器编码，可以这样干：</p><pre class="language-python" data-language="python"><code class="language-python"># -*- coding:gbk -*-print(&quot;我是你二大爷&quot;)</code></pre></li><li><p><strong>建议：所有Python代码文件的都要以UTF-8编码保存和读取。</strong></p><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20220521101646801.png" class=""></li></ul><h3 id="（三）输出"><a href="#（三）输出" class="headerlink" title="（三）输出"></a>（三）输出</h3><p>​将结果或内容想要呈现给用户。</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;看着风景美如画&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">print(&quot;                                                            * *  &quot;)print(&quot;                                                         * * * *  &quot;)print(&quot;                                                      * * * * * *  &quot;)print(&quot;                                                   * * * * * * * *  &quot;)print(&quot;                                                * * * * * * * * * *  &quot;)print(&quot;                                             * * * * * * * * * * * *  &quot;)print(&quot;                                              * * * * * * * * * * * *  &quot;)print(&quot;                                               * * * * * * * * * * * *  &quot;)print(&quot;                                      * *       * * * * * * * * * * * *  &quot;)print(&quot;                                   * * * *       * * * * * * * * * * * *  &quot;)print(&quot;                                * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;                             * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;                          * * * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;                       * * * * * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;                        * * * * * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;                         * * * * * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;                * *       * * * * * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;             * * * *       * * * * * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;          * * * * * *       * * * * * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;       * * * * * * * *       * * * * * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;    * * * * * * * * * *       * * * * * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot; * * * * * * * * * * * *       * * * * * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;  * * * * * * * * * * * *       * * * * * * * * * * * *       * * * * * * * * * * * *  &quot;)print(&quot;   * * * * * * * * * * * *       * * * * * * * * * * * *       * * * * * * * * * * * *  &quot;)</code></pre><h4 id="关于输出："><a href="#关于输出：" class="headerlink" title="关于输出："></a>关于输出：</h4><ul><li><p>默认print在尾部会加换行符</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;看着风景美如画&quot;)print(&quot;本想吟诗增天下&quot;)输出：看着风景美如画本想吟诗增天下</code></pre></li><li><p>想要不换行，则可以这样干</p><pre class="language-none"><code class="language-none">print(&quot;看着风景美如画&quot;,end&#x3D;&quot;&quot;)print(&quot;本想吟诗增天下&quot;,end&#x3D;&quot;&quot;)输出：看着风景美如画本想吟诗增天下</code></pre><pre class="language-python" data-language="python"><code class="language-python">print(&quot;看着风景美如画&quot;,end&#x3D;&quot;,&quot;)print(&quot;本想吟诗增天下&quot;,end&#x3D;&quot;.&quot;)输出：看着风景美如画,本想吟诗增天下.</code></pre></li></ul><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><ol><li><p>使用print输出自己的姓名</p></li><li><p>使用print输出<br>春眠不觉晓，<br>出处闻啼鸟，<br>夜来风雨声，<br>花落知多少。</p></li><li><p>使用print输出<br>春眠不觉晓，出处闻啼鸟，夜来风雨声，花落知多少。</p></li></ol><h3 id="（四）初识数据类型"><a href="#（四）初识数据类型" class="headerlink" title="（四）初识数据类型"></a>（四）初识数据类型</h3><p>​刚上学时，老师教我们 数字 、拼音、汉字、真假判断 等，然后我们根据学到的内容写作文，老师来检查并打分。</p><p>​现在学编程，我教大家 int、str、bool 等，然后大家根据这些内容来写代码，写完代码交给Python解释器去运行。</p><h4 id="整型-int"><a href="#整型-int" class="headerlink" title="整型(int)"></a>整型(int)</h4><p>​整型（整数），其实就是以前数学课上讲的整数（不包含小数），在写代码时用于表示整数相关的东西，例如：年龄、存款、尺寸、手机号等。一般我们提到的：5、18、22、99、… 等整数 在Python中都称为是整型，且支持 <strong>加&#x2F;减&#x2F;乘&#x2F;除&#x2F;取余&#x2F;指数 等操作。</strong></p><h4 id="字符串（str）"><a href="#字符串（str）" class="headerlink" title="字符串（str）"></a>字符串（str）</h4><p>​字符串，其实就是我们生活中的文本信息。例如：姓名、地址、自我介绍等。<br>​字符串有一个特点，他必须由引号引起来，如：</p><h5 id="单行字符串"><a href="#单行字符串" class="headerlink" title="单行字符串"></a>单行字符串</h5><pre class="language-none"><code class="language-none">print(&quot;我是Alex&quot;)print(&#39;我是Alex&#39;)print(&#39;我是&quot;alex&#39;)print(&quot;中国北京昌平区&quot;)</code></pre><h5 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h5><pre class="language-none"><code class="language-none">print(&quot;&quot;&quot;中国北京昌平区sasasasasasasas&quot;&quot;&quot;)</code></pre><h5 id="对于字符串"><a href="#对于字符串" class="headerlink" title="对于字符串"></a>对于字符串</h5><ul><li><p>加，两个字符串可以通过加号拼接起来。</p><pre class="language-python" data-language="python"><code class="language-python">print( &quot;alex&quot; + &quot;是金角大王吧&quot; )</code></pre></li><li><p>乘，让整形和字符串进行相乘，以实现让字符串重复出现N次并拼接起来。</p><pre class="language-python" data-language="python"><code class="language-python">print(3 * &quot;我想吃饺子&quot;)</code></pre></li></ul><h3 id="布尔类型（bool）"><a href="#布尔类型（bool）" class="headerlink" title="布尔类型（bool）"></a>布尔类型（bool）</h3><p>​布尔类型中共有两个值：True &#x2F; False</p><pre class="language-python" data-language="python"><code class="language-python">print(1 &gt; 2)Falseprint(1 &#x3D;&#x3D; 1)True</code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; input(&quot;请输入你的用户名:&quot;)if name &#x3D;&#x3D; &quot;alex&quot;:    print(&quot;用户登录成功&quot;)else:    print(&quot;用户登录失败&quot;)</code></pre><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><pre class="language-python" data-language="python"><code class="language-python">1 &gt; 2 1 &#x3D;&#x3D; 3&quot;alex&quot; &#x3D;&#x3D; &quot;eric&quot;1 &#x3D;&#x3D; &quot;alex&quot;1 &gt; &quot;alex&quot;  是无法进行比较大小</code></pre><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>三句话搞定类型转换：</p><ul><li><p>其他所有类型转换为布尔类型时，除了 空字符串、0以为其他都是True。</p></li><li><p>字符串转整形时，只有那种 “988” 格式的字符串才可以转换为整形，其他都报错。</p></li><li><p>想要转换为那种类型，就用这类型的英文包裹一下就行。</p></li></ul><pre class="language-python" data-language="python"><code class="language-python">str(...)int(...)bool(...)</code></pre><h4 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h4><ol><li>计算整型50乘以10再除以5的商并使用print输出。</li><li>判断整型8是否大于10的结果并使用print输出。</li><li>计算整型30除以2得到的余数并使用print输出。</li><li>使用字符串乘法实现 把字符串”我爱我的祖国”创建三遍并拼接起来最终使用print输出。</li><li>判断 字符串”wupeiqi”和”alex”是否相等的结果并使用print输出。</li><li>判断 整型666和整型666是否相等的结果并使用print输出。</li><li>判断 字符串”666”和整型666是否相等的结果并使用print输出。</li><li>看代码写结果（禁止运行代码）：</li></ol><pre class="language-python" data-language="python"><code class="language-python">print( int(&quot;100&quot;)*3 )print( int(&quot;123&quot;) + int(&quot;88&quot;) )print( str(111) + str(222) )print( str(111)*3 )print( int(&quot;8&quot;) &gt; 7 )print( str(111) &#x3D;&#x3D; 111 )print( bool(-1) )print( bool(0) )print( bool(&quot;&quot;) )print( bool(&quot;你好&quot;) )print( True &#x3D;&#x3D; True)print( True &#x3D;&#x3D; False)print( bool(&quot;&quot;) &#x3D;&#x3D; bool(0) )</code></pre><p>​注意：类型转换不是改变原来值，实际在底层是新创建了一个值。例如有整数 6 ，然后使用 str(6) 转化了一下得到 “6”,实际上这个字符串”6”是依据整数6新创建的。</p><h3 id="（五）变量"><a href="#（五）变量" class="headerlink" title="（五）变量"></a>（五）变量</h3><p>​变量，其实就是我们生活中起别名和外号，让变量名指向某个值，格式为： 【变量名 &#x3D; 值】，以后可以通过变量名来操作其对应的值。</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;print(name) # 武沛齐</code></pre><pre class="language-python" data-language="python"><code class="language-python">age &#x3D; 18name &#x3D; &quot;alex&quot;flag &#x3D; 1 &gt; 18address &#x3D; &quot;北京昌平&quot; + &quot;沙河&quot;addr &#x3D; &quot;北京昌平&quot; + &quot;沙河&quot; + name   # &quot;北京昌平沙河alex&quot;print(addr)print(flag)</code></pre><pre class="language-python" data-language="python"><code class="language-python">age &#x3D; 18number &#x3D; 1 &#x3D;&#x3D; 2</code></pre><p><strong>注意：Python中等号的称谓： <code>age = 18</code> 给变量age赋值18</strong></p><h4 id="变量名的规范"><a href="#变量名的规范" class="headerlink" title="变量名的规范"></a>变量名的规范</h4><h5 id="三个规范（只要有一条不满足就会报错）："><a href="#三个规范（只要有一条不满足就会报错）：" class="headerlink" title="三个规范（只要有一条不满足就会报错）："></a>三个规范（只要有一条不满足就会报错）：</h5><ul><li><p>变量名只能由 字母、数字、下划线 组成。</p></li><li><p>不能以数字开头</p><pre class="language-none"><code class="language-none">9name &#x3D; &quot;alex&quot;</code></pre></li><li><p>不能用Python内置的关键字（pycharm中橙黄色字体的字）</p><pre class="language-none"><code class="language-none">def &#x3D; &quot;alex&quot;break &#x3D; 123</code></pre><p><em>[‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</em></p></li></ul><h5 id="两个建议："><a href="#两个建议：" class="headerlink" title="两个建议："></a>两个建议：</h5><ul><li><p>下划线连接命名（小写）</p><pre class="language-none"><code class="language-none">father_name &#x3D; &quot;wupeiqi&quot;brother_age &#x3D; 19</code></pre></li><li><p>见名知意</p><pre class="language-none"><code class="language-none">age &#x3D; 18color &#x3D; &quot;red&quot;current_user_name &#x3D; &quot;吉诺比利&quot;</code></pre></li></ul><h5 id="练习题：判断变量命名是否正确"><a href="#练习题：判断变量命名是否正确" class="headerlink" title="练习题：判断变量命名是否正确"></a>练习题：判断变量命名是否正确</h5><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;吉诺比利&quot;name0 &#x3D; &quot;帕克&quot;name_1 &#x3D; &quot;邓肯&quot;_coach &#x3D; &quot;波波维奇&quot;_ &#x3D; &quot;卡哇伊&quot;1_year &#x3D; &quot;1990&quot; # 错误year_1_ &#x3D; &quot;1990&quot;_1_year &#x3D; &quot;1990&quot;nba-team &#x3D; &quot;马刺&quot; # 错误new*name &#x3D; &quot;伦纳德&quot; # 错误</code></pre><h3 id="变量内存指向关系"><a href="#变量内存指向关系" class="headerlink" title="变量内存指向关系"></a>变量内存指向关系</h3><p>​通过学习上述变量知识让我们对变量了有了初步认识，接下来我们就要从稍稍高级一些的角度来学习变量，即：内存指向（在电脑的内存中是怎么存储的）。</p><h5 id="情景一"><a href="#情景一" class="headerlink" title="情景一"></a>情景一</h5><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;wupeiqi&quot;</code></pre><p>​在计算机的内存中创建一块区域保存字符串”wupeiqi”，name变量名则指向这块区域。</p><img src="Python模块一day1/image-20201011163312491.png" alt="image-20201011163312491" style="zoom:50%;" /><h5 id="情景二"><a href="#情景二" class="headerlink" title="情景二"></a>情景二</h5><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;wupeiqi&quot;name &#x3D; &quot;alex&quot;</code></pre><p>​在计算机的内存中创建一块区域保存字符串”wupeiqi”，name变量名则指向这块区域。然后又再内存中创建了一块域保存字符串”alex”，name变量名则指向”alex”所在的区域，不再指向”wupeiqi”所在区域（无人指向的数据会被标记为垃圾，由解释器自动化回收）</p><img src="Python模块一day1/image-20201011163344305.png" alt="image-20201011163344305" style="zoom:50%;" /><h5 id="情景三"><a href="#情景三" class="headerlink" title="情景三"></a>情景三</h5><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;wupeiqi&quot;new_name &#x3D; name</code></pre><p>​在计算机的内存中创建一块区域保存字符串”wupeiqi”，name变量名则指向这块区域。new_name变量名指向name变量，因为被指向的是变量名，所以自动会转指向到name变量代表的内存区域。</p><img src="Python模块一day1/image-20201011163427166.png" alt="image-20201011163427166" style="zoom:50%;" /><h5 id="情景四"><a href="#情景四" class="headerlink" title="情景四"></a>情景四</h5><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;wupeiqi&quot;new_name &#x3D; namename &#x3D; &quot;alex&quot;</code></pre><p>​在计算机的内存中创建一块区域保存字符串”wupeiqi”，name变量名则指向这块区域(灰色线)， 然后new_name指向name所指向的内存区域，最后又创建了一块区域存放”alex”，让name变量指向”alex”所在区域.</p><img src="Python模块一day1/image-20201011163503412.png" alt="image-20201011163503412" style="zoom:50%;" /><h5 id="情景五"><a href="#情景五" class="headerlink" title="情景五"></a>情景五</h5><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 18age &#x3D; str(num)</code></pre><p>​在计算机的内存中创建一块区域保存整型18，name变量名则指向这块区域。通过类型转换依据整型18再在内存中创建一个字符串”18”, age变量指向保存这个字符串的内存区域。</p><img src="Python模块一day1/image-20201011163528779.png" alt="image-20201011163528779" style="zoom:50%;" /><p>至此，关于变量的内存相关的说明已讲完，由于大家都是初学者，关于变量的内存管理目前只需了解以上知识点即可，更多关于内存管理、垃圾回收、驻留机制等问题在后面的课程中会讲解。</p><h5 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h5><ol><li><p>看代码结果</p><pre class="language-python" data-language="python"><code class="language-python">alex_length &#x3D; 3wupeiqi_length &#x3D; 18total &#x3D; alex_length + wupeiqi_lengthprint(total)  # 21</code></pre></li><li><p>按要求写代码</p><pre class="language-python" data-language="python"><code class="language-python"># 假设age为小明的年龄age &#x3D; 18# 问：已知小李比小明大3岁，计算小李年龄赋值给ming_age变量并输出。ming_age &#x3D; age + 3print(ming_age)# 问：已知大刘比小明和小李年龄的和还要大5岁，计算大刘的年龄赋值给liu_age变量并输入。liu_age &#x3D; age + ming_age + 5print(liu_age)</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">nickname &#x3D; &quot;一米八大高个&quot;username &#x3D; nicknameusername &#x3D; &quot;弟弟&quot;print(nickname)  # &quot;一米八大高个&quot;print(username)  # &quot;弟弟&quot;</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">nickname &#x3D; &quot;一米八大高个&quot;username &#x3D; nicknamenickname &#x3D; &quot;弟弟&quot;print(nickname)  # &quot;弟弟&quot;print(username)  # &quot;一米八大高个&quot;</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">nickname &#x3D; &quot;一米八大高个&quot;username &#x3D; &quot;&quot;text &#x3D; username + nicknameprint(text)  # &quot;一米八大高个&quot;</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">nickname &#x3D; &quot;一米八大高个&quot;username &#x3D; nicknamenickname &#x3D; &quot;弟弟&quot;text &#x3D; username + nicknameprint(text)  # &quot;一米八大高个弟弟&quot;</code></pre></li><li><p>看代码写结果</p><pre class="language-python" data-language="python"><code class="language-python">string_number &#x3D; &quot;20&quot;num &#x3D; int(string_number)data &#x3D; string_number * 3print(data) # &quot;202020&quot;value &#x3D; num * 3print(value) # 60</code></pre></li></ol><h3 id="（六）注释"><a href="#（六）注释" class="headerlink" title="（六）注释"></a>（六）注释</h3><p>​写代码时候，如果想要对某写内容进行注释处理，即：解释器忽略不会按照代码去运行。</p><ul><li><p>单行注释</p><pre class="language-python" data-language="python"><code class="language-python"># 声明一个name变量name &#x3D; &quot;alex&quot;age &#x3D; 19 # 这表示当前用户的年龄注意：快捷点 command + ?  、   control + ?</code></pre></li><li><p>多行注释</p><pre class="language-python" data-language="python"><code class="language-python"># 声明一个name变量# 声明一个name变量# 声明一个name变量name &#x3D; &quot;alex&quot;&quot;&quot;&quot;多行注释内容多行注释内容多行注释内容&quot;&quot;&quot;age &#x3D; 19</code></pre></li></ul><h3 id="（七）-输入"><a href="#（七）-输入" class="headerlink" title="（七） 输入"></a>（七） 输入</h3><p>​输入，可以实现程序和用户之间的交互。</p><pre class="language-python" data-language="python"><code class="language-python"># 1. 右边 input(&quot;请输入用户名：&quot;) 是让用户输入内容。# 2. 将用户输入的内容赋值给name变量。name &#x3D; input(&quot;请输入用户名：&quot;)if name &#x3D;&#x3D; &quot;alex&quot;:  print(&quot;登录成功&quot;)else:  print(&quot;登录失败&quot;)</code></pre><p><strong>特别注意：用户输入的任何内容本质上都是<font color="#dd0000">字符串</font>。</strong></p><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><ol><li><p>提示输入姓名，然后给姓名后面拼接一个“烧饼”，提示输入姓名，然后给姓名后面拼接一个“烧饼”，最终打印结果。</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; input(&quot;请输入用户名：&quot;)text &#x3D; name + &quot;烧饼&quot;print(text)</code></pre></li><li><p>提示输入 姓名&#x2F;位置&#x2F;行为，然后做拼接并打印：xx 在 xx 做 xx 。</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; input(&quot;请输入用户名：&quot;)address &#x3D; input(&quot;请输入位置：&quot;)action &#x3D; input(&quot;请输入行为：&quot;)text &#x3D; name + &quot;在&quot; + address + actionprint(text)</code></pre></li><li><p>提示输入两个数字，计算两个数的和。</p><pre class="language-python" data-language="python"><code class="language-python">number1 &#x3D; input(&quot;请输入一个数字：&quot;) # &quot;1&quot;number2 &#x3D; input(&quot;请输入一个数字：&quot;) # &quot;2&quot;value &#x3D; int(number1) + int(number2)print(value)</code></pre></li></ol><h3 id="（八）条件语句"><a href="#（八）条件语句" class="headerlink" title="（八）条件语句"></a>（八）条件语句</h3><pre class="language-python" data-language="python"><code class="language-python">if 条件 :    条件成立之后的代码...    条件成立之后的代码...    条件成立之后的代码...else:    条件不成立之后执行的代码...    条件不成立之后执行的代码...    条件不成立之后执行的代码...</code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; input(&quot;请输入用户名:&quot;)if name &#x3D;&#x3D; &quot;alex&quot;:  print(&quot;sb&quot;)else:  print(&quot;db&quot;)</code></pre><p><strong>提醒：统一缩进问题<font color="#dd0000">（都是使用四个空格 &#x3D; tab）</font>。</strong></p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; input(&quot;请输入用户名:&quot;)if name &#x3D;&#x3D; &quot;alex&quot;:    print(&quot;sb&quot;)   print(&quot;sb&quot;)else:    print(&quot;db&quot;)</code></pre><h4 id="基本条件语句"><a href="#基本条件语句" class="headerlink" title="基本条件语句"></a>基本条件语句</h4><ul><li><p>示例1</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;开始&quot;)if True:  print(&quot;123&quot;)else:  print(&quot;456&quot;)print(&quot;结束&quot;)# 输出结果开始123结束</code></pre></li><li><p>示例2</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;开始&quot;)if 5&#x3D;&#x3D;5:  print(&quot;123&quot;)else:  print(&quot;456&quot;)print(&quot;结束&quot;)</code></pre></li><li><p>示例3</p><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 19if num &gt; 10:print(&quot;num变量对应值大于10&quot;)else:print(&quot;num变量对应值不大于10&quot;)</code></pre></li><li><p>示例4</p><pre class="language-python" data-language="python"><code class="language-python">username &#x3D; &quot;wupeiqi&quot;password &#x3D; &quot;666&quot;if username &#x3D;&#x3D; &quot;wupeiqi&quot; and password &#x3D;&#x3D; &quot;666&quot;:print(&quot;恭喜你，登录成功&quot;)else:print(&quot;登录失败&quot;)</code></pre></li><li><p>示例5</p><pre class="language-python" data-language="python"><code class="language-python">username &#x3D; &quot;wupeiqi&quot;if username &#x3D;&#x3D; &quot;wupeiqi&quot; or username &#x3D;&#x3D; &quot;alex&quot;:print(&quot;VIP大会员用户&quot;)else:print(&quot;普通用户&quot;)</code></pre></li><li><p>示例6</p><pre class="language-python" data-language="python"><code class="language-python">number &#x3D; 19if number%2 &#x3D;&#x3D; 1:print(&quot;number是奇数&quot;)else:print(&quot;number是偶数&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">number &#x3D; 19data &#x3D; number%2 &#x3D;&#x3D; 1if data:print(&quot;number是奇数&quot;)else:print(&quot;number是偶数&quot;)</code></pre></li><li><p>示例7</p><pre class="language-python" data-language="python"><code class="language-python">if 条件:  成立</code></pre><pre class="language-python" data-language="python"><code class="language-python">print(&quot;开始&quot;)if 5 &#x3D;&#x3D; 5:  print(&quot;5等于5&quot;)print(&quot;结束&quot;)</code></pre></li></ul><p><strong>练习题</strong></p><ol><li><p>提示用户输入用户名和密码，用户名等于”wupeiqi”且密码等于”uuu”就输出登录成功；否则输出登录失败。</p><pre class="language-python" data-language="python"><code class="language-python">user_name &#x3D; input(&#39;please input your username: &#39;)user_pwd &#x3D; input(&#39;please input your password: &#39;)if user_name &#x3D;&#x3D; &#39;wupeiqi&#39; and user_pwd &#x3D;&#x3D; &#39;uuu&#39;:    print(&#39;login successful&#39;)else:    print(&#39;login failed&#39;)</code></pre></li><li><p>猜数字，提示用户输入一个数字，判断数字如果大于10，就输出猜错了；否则输出猜对了。</p><pre class="language-python" data-language="python"><code class="language-python">guess_number &#x3D; int(input(&#39;please guess a number: &#39;))if guess_number &gt; 10:    print(&#39;you are wrong&#39;)else:    print(&#39;you are right&#39;)</code></pre></li><li><p>提示用户输入一个数字，判断是否为偶数，是偶数则输出 偶偶偶数，否则输出 奇奇奇数。</p><pre class="language-python" data-language="python"><code class="language-python">input_number &#x3D; int(input(&#39;please input a number: &#39;))if (input_number % 2) &#x3D;&#x3D; 0:    print(&#39;your input is an even number&#39;)else:    print(&#39;your input is an odd number&#39;)</code></pre></li></ol><h4 id="多条件判断"><a href="#多条件判断" class="headerlink" title="多条件判断"></a>多条件判断</h4><pre class="language-python" data-language="python"><code class="language-python">if 条件A:  A成立，执行此缩进中的所有代码  ...elif 条件B:  B成立，执行此缩进中的所有代码  ...elif 条件C:  C成立，执行此缩进中的所有代码  ...else:  上述ABC都不成立。</code></pre><pre class="language-python" data-language="python"><code class="language-python">score &#x3D; input(&quot;请输入分数&quot;)data &#x3D; int(score)if data &gt; 90:  print(&quot;优&quot;)elif data &gt; 80:  print(&quot;良&quot;)elif data &gt; 70:  print(&quot;中&quot;)elif data &gt; 60:  print(&quot;差&quot;)else:  print(&quot;不及格&quot;)</code></pre><h4 id="条件嵌套"><a href="#条件嵌套" class="headerlink" title="条件嵌套"></a>条件嵌套</h4><pre class="language-python" data-language="python"><code class="language-python">if 条件A:    if 条件A1:        ...    else：       ...elif 条件B:    ...</code></pre><p><strong>模拟10086客服</strong></p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;欢迎致电10086，我们提供了如下服务： 1.话费相关；2.业务办理；3.人工服务&quot;)choice &#x3D; input(&quot;请选择服务序号&quot;)if choice &#x3D;&#x3D; &quot;1&quot;:    print(&quot;话费相关业务&quot;)    cost &#x3D; input(&quot;查询话费请按1;交话费请按2&quot;)    if cost &#x3D;&#x3D; &quot;1&quot;:        print(&quot;查询话费余额为100&quot;)    elif cost &#x3D;&#x3D; &quot;2&quot;:        print(&quot;交互费&quot;)    else:        print(&quot;输入错误&quot;)elif choice &#x3D;&#x3D; &quot;2&quot;:    print(&quot;业务办理&quot;)elif choice &#x3D;&#x3D; &quot;3&quot;:    print(&quot;人工服务&quot;)else:    print(&quot;序号输入错误&quot;)</code></pre><h3 id="今日作业"><a href="#今日作业" class="headerlink" title="今日作业"></a>今日作业</h3><ol><li><p>谈谈你了解的编码以及为什么会出现乱码的现象？</p><pre class="language-none"><code class="language-none">- 编码    编码就是一个密码本，存储这文字和计算机能够识别的二级制(0101)之间的映射关系- 乱码    文件保存时所使用的编码和打开文件所用的编码不一致，就会导致乱码文件中的内容出现丢失时也会产生乱码</code></pre></li><li><p>Python解释器默认编码是什么？如何修改？</p><pre class="language-python" data-language="python"><code class="language-python">- pycharm默认编码utf-8- 如何设置见图</code></pre><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20220521163345655.png" class=""></li><li><p>用print打印出下面内容：</p><pre class="language-none"><code class="language-none">⽂能提笔安天下,武能上⻢定乾坤.⼼存谋略何⼈胜,古今英雄唯是君。</code></pre><pre class="language-python" data-language="python"><code class="language-python">print(&#39;⽂能提笔安天下,&#39;)print(&#39;武能上⻢定乾坤.&#39;)print(&#39;⼼存谋略何⼈胜,&#39;)print(&#39;古今英雄唯是君。&#39;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; &#39;&#39;&#39;⽂能提笔安天下,武能上⻢定乾坤.⼼存谋略何⼈胜,古今英雄唯是君。&#39;&#39;&#39;print(text)</code></pre></li><li><p>变量名的命名规范和建议？</p><pre class="language-none"><code class="language-none">- 命名规范1. 只能由字母、数字和下划线组成2. 不能以数字开头3. 不能使用解释器保留关键字- 建议1. 使用小写字母并用下划线连接 例如：user_name2. 变量名能表征其涵义 例如：age &#x3D; int(18) 好于 a &#x3D; int(18)</code></pre></li><li><p>如下哪个变量名是正确的？</p><pre class="language-pythonn" data-language="pythonn"><code class="language-pythonn">name &#x3D; &#39;武沛齐&#39;  # 正确_ &#x3D; &#39;alex&#39;  # 正确_9 &#x3D; &quot;老男孩&quot;  # 正确9name &#x3D; &quot;宝浪&quot;oldboy(edu &#x3D; 666</code></pre></li><li><p>设定一个理想数字比如：66，让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了;只有等于66，显示猜测结果正确。</p><pre class="language-python" data-language="python"><code class="language-python">right_number &#x3D; 66guess_number &#x3D; int(input(&#39;please input a number: &#39;)).strip()if guess_number &gt; right_number:    print(&#39;too large&#39;)elif guess_number &lt; right_number:    print(&#39;too small&#39;)else:    print(&#39;you are correct&#39;)</code></pre></li><li><p>提示⽤户输入 “爸爸” ，判断⽤户输入的对不对。如果对, 提示真聪明, 如果不对, 提示你是傻逼么。</p><pre class="language-python" data-language="python"><code class="language-python">user_input &#x3D; input(&#39;please input &quot;爸爸&quot;: &#39;).strip()if user_input &#x3D;&#x3D; &#39;爸爸&#39;:    print(&#39;you are correct&#39;)else:    print(&#39;you are wrong&#39;)</code></pre></li><li><p>写程序，成绩有ABCDE5个等级，与分数的对应关系如下.要求用户输入0-100的数字后，你能正确打印他的对应成绩等级.</p><pre class="language-python" data-language="python"><code class="language-python">A    90-100B    80-89C    60-79D    40-59E    0-39</code></pre><pre class="language-python" data-language="python"><code class="language-python">score &#x3D; int(input(&#39;please input your score: &#39;).strip())if 90 &lt;&#x3D; score &lt;&#x3D; 100:    print(&#39;A&#39;)elif 80 &lt;&#x3D; score &lt; 90:    print(&#39;B&#39;)elif 60 &lt;&#x3D; score &lt; 80:    print(&#39;C&#39;)elif 40 &lt;&#x3D; score &lt; 60:    print(&#39;D&#39;)elif 0 &lt;&#x3D; score &lt; 40:    print(&#39;E&#39;)else:    print(&#39;out of range&#39;)</code></pre></li></ol><h2 id="四、python基础"><a href="#四、python基础" class="headerlink" title="四、python基础"></a>四、python基础</h2><p>课程目标：掌握Python基础中的必备语法知识。</p><p>课程概要：</p><ul><li>循环语句</li><li>字符串格式化</li><li>运算符（面试题）</li></ul><h3 id="1-循环语句"><a href="#1-循环语句" class="headerlink" title="1. 循环语句"></a>1. 循环语句</h3><ul><li><p>while循环</p><pre class="language-python" data-language="python"><code class="language-python">while 条件:    ...    ...    ...</code></pre></li><li><p>for循环（后期）</p></li></ul><h4 id="1-1-循环语句基本使用"><a href="#1-1-循环语句基本使用" class="headerlink" title="1.1 循环语句基本使用"></a>1.1 循环语句基本使用</h4><p>示例1：死循环</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;开始&quot;)while True:    print(&quot;Alex是个小都比&quot;)print(&quot;结束&quot;)# 输出：开始Alex是个小都比Alex是个小都比Alex是个小都比Alex是个小都比...</code></pre><p>示例2：</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;开始&quot;)flag &#x3D; Truewhile flag:print(&quot;滚滚黄河，滔滔长江。&quot;)flag &#x3D; Falseprint(&quot;结束&quot;)# 输出：开始滚滚黄河，滔滔长江。结束</code></pre><p>示例3：</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;开始&quot;)num &#x3D; 1while num &lt; 5:print(&quot;给我生命，给我力量。&quot;)num &#x3D; num + 1print(&quot;结束&quot;)# 输出：开始给我生命，给我力量。给我生命，给我力量。给我生命，给我力量。给我生命，给我力量。结束</code></pre><h4 id="练习题：重复3次输出我爱我的祖国。"><a href="#练习题：重复3次输出我爱我的祖国。" class="headerlink" title="练习题：重复3次输出我爱我的祖国。"></a>练习题：重复3次输出我爱我的祖国。</h4><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 0while num &lt; 3:print(&quot;我爱我的祖国&quot;)num &#x3D; num + 1# 输出：我爱我的祖国我爱我的祖国我爱我的祖国</code></pre><h4 id="1-2-综合小案例"><a href="#1-2-综合小案例" class="headerlink" title="1.2 综合小案例"></a>1.2 综合小案例</h4><pre class="language-python" data-language="python"><code class="language-python"># 请实现一个用户登录系统，如果密码错误则反复提示让用户重新输入，直到输入正确才停止。print(&quot;开始运行路飞系统&quot;)flag &#x3D; Truewhile flag:    user &#x3D; input(&quot;请输入用户名：&quot;)    pwd &#x3D; input(&quot;请输入密码：&quot;)    if user &#x3D;&#x3D; &quot;wupeiqi&quot; and pwd &#x3D;&#x3D; &quot;luffy&quot;:        print(&quot;登录成功&quot;)        flag &#x3D; False    else:        print(&quot;用户名或密码错误&quot;)print(&quot;系统结束&quot;)</code></pre><p><strong>练习题-补充代码实现猜数字</strong></p><ol><li><p>设定一个理想数字比如：66，一直提示让用户输入数字，如果比66大，则显示猜测的结果大了；如果比66小，则显示猜测的结果小了;只有输入等于66，显示猜测结果正确，然后退出循环。</p><pre class="language-python" data-language="python"><code class="language-python">right_number &#x3D; 66flag &#x3D; Trueprint(&#39;guess number program start&#39;)while flag:    guess_num &#x3D; int(input(&#39;please guess a number: &#39;))    if guess_num &#x3D;&#x3D; right_number:        print(&#39;congratulations on your guess&#39;)        flag &#x3D; False    elif guess_num &gt; right_number:        print(&#39;your guess is too large&#39;)    else:        print(&#39;your guess is too small&#39;)print(&#39;exit the program&#39;)</code></pre></li><li><p>使用循环输出1~100所有整数。</p><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 0while num &lt; 100:    num +&#x3D; 1    print(num)</code></pre></li><li><p>使用循环输出 1 2 3 4 5 6   8 9 10，即：10以内除7以外的整数。</p><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 0while num &lt; 10:    num +&#x3D; 1    if num &#x3D;&#x3D; 7:  # 当num &#x3D; 7时再对num+1后，再进行打印        num +&#x3D; 1    print(num)</code></pre><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 0while num &lt; 10:    num +&#x3D; 1    if num !&#x3D; 7:          print(num)</code></pre></li><li><p>输出 1~100 内的所有奇数。</p><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 0while num &lt; 100:    num +&#x3D; 1    if num % 2 &#x3D;&#x3D; 1:        print(num)</code></pre></li><li><p>输出 1~100 内的所有偶数。</p><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 0while num &lt; 100:    num +&#x3D; 1    if num % 2 &#x3D;&#x3D; 0:        print(num)</code></pre></li><li><p>求 1~100 的所有整数的和。</p><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 0sum_num &#x3D; 0while num &lt; 100:    num +&#x3D; 1    sum +&#x3D; numprint(sum_num)</code></pre></li><li><p>输出10 ~ 1 所有整数。</p><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 10while num &gt; 0:    print(num)    num -&#x3D; 1</code></pre></li><li><p>求1-100内1-2+3…的和</p><pre class="language-python" data-language="python"><code class="language-python">num &#x3D; 1sum_num &#x3D; 0while num &lt; 101:    if num % 2 &#x3D;&#x3D; 1:        sum_num +&#x3D; num    else:        sum_num -&#x3D; num    num +&#x3D; 1print(sum_num)</code></pre></li></ol><h4 id="1-3-break"><a href="#1-3-break" class="headerlink" title="1.3 break"></a>1.3 break</h4><p>​break，用于在while循环中帮你<font color="#dd0000">终止循环。</font>通过示例来更深入理解break的应用。</p><p>示例1：</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;开始&quot;)while True:print(&quot;红旗飘飘，军号响。&quot;)breakprint(&quot;剑已出鞘，雷鸣电闪。&quot;)print(&quot;从来都是狭路相逢勇者胜。&quot;)print(&quot;结束&quot;)</code></pre><p>示例2：</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;开始运行系统&quot;)while True:user &#x3D; input(&quot;请输入用户名：&quot;)pwd &#x3D;  input(&quot;请输入密码：&quot;)if user &#x3D;&#x3D; &#39;wupeiqi&#39; and pwd &#x3D; &quot;oldboy&quot;:print(&quot;登录成功&quot;)breakelse:print(&quot;用户名或密码错误，请重新登录&quot;)print(&quot;系统结束&quot;)# 输出开始运行系统&gt;&gt;&gt; 用户名&gt;&gt;&gt; 密码正确，登录成功系统结束不正确，一直循环输出</code></pre><p>​<strong>所以，以后写代码时候，想要<font color="#dd0000">结束循环可以通过两种方式实现了，即：条件判断 和 break关键字，两种在使用时无好坏之分，只要能实现功能就行。</font></strong></p><h4 id="1-4-continue"><a href="#1-4-continue" class="headerlink" title="1.4 continue"></a>1.4 continue</h4><p>​continue，在循环中用于 <font color="#dd0000">结束本次循环，开始下一次循环。</font></p><p>示例1：</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;开始&quot;)while True:print(&quot;红旗飘飘，军号响。&quot;)continueprint(&quot;剑已出鞘，雷鸣电闪。&quot;)print(&quot;从来都是狭路相逢勇者胜。&quot;)print(&quot;结束&quot;)# 输出开始红旗飘飘，军号响。红旗飘飘，军号响。红旗飘飘，军号响。红旗飘飘，军号响。...</code></pre><p>示例2：</p><pre class="language-python" data-language="python"><code class="language-python">print(&quot;开始&quot;)i &#x3D; 1while i &lt; 101:if i &#x3D;&#x3D; 7:i &#x3D; i + 1continueprint(i)i &#x3D; i + 1print(&quot;结束&quot;)# 输出开始1234568910...100结束</code></pre><p>​写在最后，对于break和continue都是放在循环语句中用于控制循环过程的，一旦遇到break就停止所有循环，一旦遇到continue就停止本次循环，开始下次循环。</p><p>​当然，通过如果没有了break和continue，我们用while条件的判断以及其他协助也能完成很多功能，有了break和continue可以在一定程度上简化我们的代码逻辑。</p><h4 id="1-5-while-x2F-for-else-while-x2F-for正常结束后打印提示语"><a href="#1-5-while-x2F-for-else-while-x2F-for正常结束后打印提示语" class="headerlink" title="1.5 while&#x2F;for else(while&#x2F;for正常结束后打印提示语)"></a>1.5 while&#x2F;for else(while&#x2F;for正常结束后打印提示语)</h4><p>​当while后的条件不成立时，else中的代码就会执行。</p><pre class="language-python" data-language="python"><code class="language-python">while False:  passelse:  print(123)</code></pre><pre class="language-python" data-language="python"><code class="language-python">num_list &#x3D; [1, 2, 3, 4]for item in num_list:    print(item)else:    print(&#39;all print down&#39;)</code></pre><p>​<font color="#dd0000"><strong>注意事项：当while, 被break打断后，不会执行else后的结果。</strong></font></p><h4 id="2-字符串格式化"><a href="#2-字符串格式化" class="headerlink" title="2.字符串格式化"></a>2.字符串格式化</h4><p>​字符串格式化，使用<font color="#dd0000">更便捷的形式实现字符串的拼接。</font></p><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1 %"></a>2.1 %</h4><h5 id="2-1-1-基本格式化操作"><a href="#2-1-1-基本格式化操作" class="headerlink" title="2.1.1 基本格式化操作"></a>2.1.1 基本格式化操作</h5><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;# %s占位符# text &#x3D; &quot;我叫%s，今年18岁&quot; %&quot;武沛齐&quot;text &#x3D; &quot;我叫%s，今年18岁&quot; %name</code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;武沛齐&quot;age &#x3D; 18# text &#x3D; &quot;我叫%s，今年%s岁&quot; %(&quot;武沛齐&quot;,18)text &#x3D; &quot;我叫%s，今年%d岁&quot; %(name,age)</code></pre><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; &quot;我叫%s，今年%d岁&quot;  # 模板data1 &#x3D; text %(&quot;武沛齐&quot;,20)data2 &#x3D; text %(&quot;alex&quot;,84)</code></pre><p><a href="https://www.cnblogs.com/wupeiqi/articles/5484747.html">各种百分号</a></p><pre class="language-python" data-language="python"><code class="language-python">message &#x3D; &quot;%(name)s你什么时候过来呀？%(user)s今天不在呀。&quot; % &#123;&quot;name&quot;: &quot;死鬼&quot;, &quot;user&quot;: &quot;李杰&quot;&#125;print(message)</code></pre><h5 id="2-1-2-百分比"><a href="#2-1-2-百分比" class="headerlink" title="2.1.2 百分比"></a>2.1.2 百分比</h5><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; &quot;%s，这个片我已经下载了90%%了，居然特么的断网了&quot; %&quot;兄弟&quot;print(text)# 输出：兄弟，这个片我已经下载了90%了，居然特么的断网了</code></pre><p><font color="#dd0000">一旦字符串格式化中存现百分比的显示，请一定要呀加 %% 以实现输出 %。</font></p><h4 id="2-2-format（推荐）"><a href="#2-2-format（推荐）" class="headerlink" title="2.2 format（推荐）"></a>2.2 format（推荐）</h4><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; &quot;我叫&#123;0&#125;，今年18岁&quot;.format(&quot;武沛齐&quot;)text &#x3D; &quot;我叫&#123;0&#125;，今年&#123;1&#125;岁&quot;.format(&quot;武沛齐&quot;,18)text &#x3D; &quot;我叫&#123;0&#125;，今年&#123;1&#125;岁，真实的姓名是&#123;0&#125;。&quot;.format(&quot;武沛齐&quot;,18)</code></pre><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; &quot;我叫&#123;&#125;，今年18岁&quot;.format(&quot;武沛齐&quot;)text &#x3D; &quot;我叫&#123;&#125;，今年&#123;&#125;岁&quot;.format(&quot;武沛齐&quot;,18)text &#x3D; &quot;我叫&#123;&#125;，今年&#123;&#125;岁，真实的姓名是&#123;&#125;。&quot;.format(&quot;武沛齐&quot;,18,&quot;武沛齐&quot;)</code></pre><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; &quot;我叫&#123;n1&#125;，今年18岁&quot;.format(n1&#x3D;&quot;武沛齐&quot;)text &#x3D; &quot;我叫&#123;n1&#125;，今年&#123;age&#125;岁&quot;.format(n1&#x3D;&quot;武沛齐&quot;,age&#x3D;18)text &#x3D; &quot;我叫&#123;n1&#125;，今年&#123;age&#125;岁，真实的姓名是&#123;n1&#125;。&quot;.format(n1&#x3D;&quot;武沛齐&quot;,age&#x3D;18)</code></pre><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; &quot;我叫&#123;0&#125;，今年&#123;1&#125;岁&quot;  # 模板data1 &#x3D; text.format(&quot;武沛齐&quot;,666)data2 &#x3D; text.format(&quot;alex&quot;,73)</code></pre><h4 id="2-3-f"><a href="#2-3-f" class="headerlink" title="2.3 f"></a>2.3 f</h4><p>​到Python3.6版本，更便捷，<font color="#dd0000">不支持Python3.6之前版本，包括Python2。</font></p><pre class="language-python" data-language="python"><code class="language-python">action &#x3D; &quot;跑步&quot;text &#x3D; f&quot;嫂子喜欢&#123;action&#125;，跑完之后满身大汗&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;喵喵&quot;age &#x3D; 19text &#x3D; f&quot;嫂子的名字叫&#123;name&#125;，今年&#123;age&#125;岁&quot;print(text)</code></pre><pre class="language-python" data-language="python"><code class="language-python">text &#x3D; f&quot;嫂子的名字叫喵喵，今年&#123;19 + 2&#125;岁&quot;print(text)</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 在Python3.8引入text &#x3D; f&quot;嫂子的名字叫喵喵，今年&#123;19 + 2&#x3D;&#125;岁&quot;print(text)# 输出嫂子的名字叫喵喵，今年19 + 2&#x3D;21岁</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 进制转换v1 &#x3D; f&quot;嫂子今年&#123;22&#125;岁&quot;print(v1)v2 &#x3D; f&quot;嫂子今年&#123;22:#b&#125;岁&quot;print(v2)v3 &#x3D; f&quot;嫂子今年&#123;22:#o&#125;岁&quot;print(v3)v4 &#x3D; f&quot;嫂子今年&#123;22:#x&#125;岁&quot;print(v4)# 输出嫂子今年22岁嫂子今年0b10110岁嫂子今年0o26岁嫂子今年0x16岁</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 理解name &#x3D; &quot;alex&quot;text &#x3D; f&quot;我是&#123; name.upper() &#125;，我爱大铁锤&quot;print(text)# 输出：我是ALEX，我爱大铁锤</code></pre><h3 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h3><p>​提到运算符，我想大家首先想到的就是加、减、乘、除之类， 本节要系统的跟大家来聊一聊，我们写代码时常见的运算符可以分为5种：</p><ul><li><p>算数运算符，例如：加减乘除</p><img src="Python模块一day1/image-20201011165419956.png" alt="image-20201011165419956"  /></li><li><p>比较运算符，例如：大于、小于</p><img src="Python模块一day1/image-20201011165434014.png" alt="image-20201011165434014"  /><p>注意：<font color="#dd0000">python3中不支持 <code>&lt;&gt;</code></font></p></li><li><p>赋值运算，例如：变量赋值</p><img src="Python模块一day1/image-20201011165501909.png" alt="image-20201011165501909"  /></li><li><p>成员运算，例如：是否包含</p><img src="Python模块一day1/image-20201011165515812.png" alt="image-20201011165515812"  /></li><li><p>逻辑运算，例如：且或非</p><img src="Python模块一day1/image-20201011165530169.png" alt="image-20201011165530169"  /></li></ul><h4 id="3-1-运算符优先级"><a href="#3-1-运算符优先级" class="headerlink" title="3.1 运算符优先级"></a>3.1 <font color="#dd0000">运算符优先级</font></h4><p>​运算符的优先级有很多，常见的没几个，<font color="#dd0000">推荐你记住3个即可：</font></p><ul><li><p><font color="#dd0000">算数优先级优先级 大于 比较运算符</font></p><pre class="language-python" data-language="python"><code class="language-python">if (2 + 10) &gt; 11:print(&quot;真&quot;)else:print(&quot;假&quot;)</code></pre></li><li><p><font color="#dd0000">比较运算符优先级 大于 逻辑运算符</font></p><pre class="language-python" data-language="python"><code class="language-python">if (1&gt;2) and (2&lt;10):print(&quot;成立&quot;)else:print(&quot;不成立&quot;)</code></pre></li><li><p><font color="#dd0000">逻辑运算符内部三个优先级 not &gt; and &gt; or</font></p><pre class="language-python" data-language="python"><code class="language-python">if ((not 1) and (1&gt;2)) or (3 &#x3D;&#x3D; 8):print(&quot;真&quot;)else:print(&quot;假&quot;)</code></pre></li></ul><p><font color="#dd0000"><strong>上述这3个优先级从高到低总结：<code>加减乘除 &gt; 比较 &gt; not and or </code>。绝招：加括号。</strong></font></p><h4 id="3-2-面试题"><a href="#3-2-面试题" class="headerlink" title="3.2 面试题"></a>3.2 面试题</h4><p><strong>一般情况下逻辑运算符两边都为布尔值–返回布尔值</strong></p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; name &#x3D;&#x3D; &quot;alex&quot; and pwd &#x3D;&#x3D; &quot;123&quot;# v1 &#x3D; True and Falseif name &#x3D;&#x3D; &quot;alex&quot; and pwd &#x3D;&#x3D; &quot;123&quot;:  pass</code></pre><p><font color="#dd0000"><strong>当逻辑运算符两边不为布尔值时–直接取值</strong></font></p><pre class="language-python" data-language="python"><code class="language-python"># 当逻辑运算符两边不为布尔值时v2 &#x3D; &quot;wupeiqi&quot; and &quot;alex&quot;# 第一步：将and前后的只转换为布尔值 True and True# 第二步：判断本次操作取决于谁？由于前面的是True，所以本次逻辑判断取决于后面的值。# 所以，后面的值等于多少最终结果就是多少。 v2 &#x3D; &quot;alex&quot;v3 &#x3D; &quot;&quot; and &quot;alex&quot;# 第一步：将and前后的只转换为布尔值 False and True# 第二步：判断本次操作取悦于谁？由于前面的是False，所以本次逻辑判断取决于前面的值。# 所以，前面的只等于多少最终结果就是多少。 v2 &#x3D; &quot;&quot;v4 &#x3D; 1 or 8 # 第一步：将and前后的只转换为布尔值 True or True# 第二步：判断本次操作取悦于谁？由于前面的是True，所以本次逻辑判断取决于前面的值。# v4 &#x3D; 1v5 &#x3D; 0 or 8 # 第一步：将and前后的只转换为布尔值 False or True# 第二步：判断本次操作取悦于谁？由于前面的是False，所以本次逻辑判断取决于后面的值。# v5 &#x3D; 8</code></pre><h3 id="练习题-3"><a href="#练习题-3" class="headerlink" title="练习题"></a>练习题</h3><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 1 or 2  # 1v2 &#x3D; -1 or 3  # -1v3 &#x3D; 0 or -1  # -1v4 &#x3D; 0 or 100  # 100v5 &#x3D; &quot;&quot; or 10  # 10v6 &#x3D; &quot;wupeiqi&quot; or &quot;&quot;  # &quot;wupeiqi&quot;v7 &#x3D; 0 or &quot;&quot;  # &quot;&quot;print(v1,v2,v3,v4,v5,v6,v7)# or，看第一个值，如果第一个值为真，结果就应该是第一个值，否则就结果就是第二个值。</code></pre><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 4 and 8  # 8v2 &#x3D; 0 and 6  # 0v3 &#x3D; -1 and 88  # 88v4 &#x3D; &quot;&quot; and 7  # &quot;&quot;v5 &#x3D; &quot;武沛齐&quot; and &quot;&quot;  # &quot;&quot;v6 &#x3D; &quot;&quot; and 0  # &quot;&quot;v7 &#x3D; 0 and &quot;中国&quot;  # 0print(v1,v2,v3,v4,v5,v6,v7)# and，看第一个值，如果第一个值真，结果就应该是第二个值，否则结果就是第一个值。</code></pre><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>​如果多个and 和or的情况，<font color="#dd0000">先计算and再计算or.</font></p><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; 0 or 4 and 3 or 7 or 9 and 6     0 or 3 or 7 or 9 and 6     0 or 3 or 7 or 6     3 or 7 or 6     3 or 6     3v2 &#x3D; 8 or 3 and 4 or 2 and 0 or 9 and 7 8    v3 &#x3D; 0 or 2 and 3 and 4 or 6 and 0 or 3 4</code></pre><p>​<font color="#dd0000">先计算not，在计算and，最后计算or.</font></p><pre class="language-python" data-language="python"><code class="language-python">v4 &#x3D; not 8 or 3 and 4 or 2 4</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>while循环语句</li><li>break和continue关键字的作用</li><li>三种字符串格式化的方式</li><li>基本运算符（逻辑运算符涉及的相关面试题）</li></ol><h3 id="今日作业-1"><a href="#今日作业-1" class="headerlink" title="今日作业"></a>今日作业</h3><ol><li><p>判断下列逻辑语句的True,False</p><pre class="language-python" data-language="python"><code class="language-python">1 &gt; 1 or 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6not 2 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6TF</code></pre></li><li><p>求出下列逻辑语句的值。</p><pre class="language-python" data-language="python"><code class="language-python">8 or 3 and 4 or 2 and 0 or 9 and 70 or 2 and 3 and 4 or 6 and 0 or 384</code></pre></li><li><p>下列结果是什么？</p><pre class="language-python" data-language="python"><code class="language-python">6 or 2 &gt; 1  # 63 or 2 &gt; 1  # 30 or 5 &lt; 4  # F5 &lt; 4 or 3  # 32 &gt; 1 or 6  # T3 and 2 &gt; 1  # T0 and 3 &gt; 1  # 02 &gt; 1 and 3  # 33 &gt; 1 and 0  # 03 &gt; 1 and 2 or 2 &lt; 3 and 3 and 4 or 3 &gt; 2  # 2</code></pre></li><li><p>实现用户登录系统，并且要支持连续三次输错之后直接退出，并且在每次输错误时显示剩余错误次数（提示：使⽤字符串格式化）。</p><pre class="language-python" data-language="python"><code class="language-python">user_name &#x3D; &#39;Alex&#39;pwd &#x3D; &#39;666&#39;times &#x3D; 3while times &gt; 0:    log_name &#x3D; input(&#39;please input your username: &#39;).strip()    log_pwd &#x3D; input(&#39;please input your password: &#39;).strip()    times -&#x3D; 1    if log_name &#x3D;&#x3D; user_name and log_pwd &#x3D;&#x3D; pwd:        print(&#39;login successful&#39;)        break    else:        if times &#x3D;&#x3D; 0:            break        print(f&#39;username or password incorrect! you have &#123;times&#125; times to login&#39;)</code></pre></li><li><p>猜年龄游戏<br>要求：允许用户最多尝试3次，3次都没猜对的话，就直接退出，如果猜对了，打印恭喜信息并退出。</p><pre class="language-python" data-language="python"><code class="language-python">true_age &#x3D; 66times &#x3D; 3while times &gt; 0:    guess_age &#x3D; int(input(&#39;please guess a age: &#39;).strip())    if guess_age &#x3D;&#x3D; true_age:        print(&#39;congratulations on your guess&#39;)        break    elif guess_age &gt; true_age:        print(&#39;you guess is too large!&#39;)    else:        print(&#39;you guess is too small!&#39;)    times -&#x3D; 1</code></pre></li><li><p>猜年龄游戏升级版<br>要求：允许用户最多尝试3次，每尝试3次后，如果还没猜对，就问用户是否还想继续玩，如果回答Y，就继续让其猜3次，以此往复，如果回答N，就退出程序，如何猜对了，就直接退出。</p><pre class="language-PYTHON" data-language="PYTHON"><code class="language-PYTHON"># 自己作业true_age &#x3D; 66flag &#x3D; Truewhile flag:    times &#x3D; 3    while times &gt; 0:        guess_age &#x3D; int(input(&#39;please guess a age: &#39;).strip())        times -&#x3D; 1        if guess_age &#x3D;&#x3D; true_age:            print(&#39;congratulations on your guess&#39;)            break        elif guess_age &gt; true_age:            print(&#39;you guess is too large!&#39;)        else:            print(&#39;you guess is too small!&#39;)        if times &#x3D;&#x3D; 0:            order &#x3D; input(&#39;input &quot;Y&quot; to continue: &#39;)            if order &#x3D;&#x3D; &#39;Y&#39;:                break            else:                flag &#x3D; False                break</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 老师讲解true_age &#x3D; 66count &#x3D; 3while count &gt; 0:    guess_age &#x3D; int(input(&#39;please guess a age: &#39;).strip())    count -&#x3D; 1    if guess_age &#x3D;&#x3D; true_age:        print(&#39;congratulations on your guess&#39;)        break    elif guess_age &gt; true_age:        print(&#39;you guess is too large!&#39;)    else:        print(&#39;you guess is too small!&#39;)    if count &#x3D;&#x3D; 0:        order &#x3D; input(&#39;input &quot;Y&quot; to continue: &#39;)        if order &#x3D;&#x3D; &#39;Y&#39;:            count &#x3D; 3  # 输入&#39;Y&#39;后重置count            continue        else:            break</code></pre></li></ol><h2 id="五、进制和编码"><a href="#五、进制和编码" class="headerlink" title="五、进制和编码"></a>五、进制和编码</h2><p>​课程目标：讲解计算机中一些必备的常识知识，让学员了解一些常见名词背后的含义（重在理解）。</p><p>课程概要：</p><ul><li>python代码的运行方式</li><li>进制</li><li>计算机中的单位</li><li>编码</li></ul><h3 id="1-Python代码运行方式"><a href="#1-Python代码运行方式" class="headerlink" title="1.Python代码运行方式"></a>1.Python代码运行方式</h3><ul><li><p>脚本式</p><pre class="language-python" data-language="python"><code class="language-python">python3 ~&#x2F;PycharmProjects&#x2F;day03&#x2F;6.作业题讲解.py</code></pre></li><li><p>交互式</p><pre class="language-python" data-language="python"><code class="language-python">python3</code></pre><img src="Python模块一day1/截屏2020-10-25 下午5.15.51.png" alt="截屏2020-10-25 下午5.15.51" style="zoom:50%;" /></li></ul><h3 id="2-进制"><a href="#2-进制" class="headerlink" title="2.进制"></a>2.进制</h3><p>计算机中底层所有的数据都是以 <code>010101</code>的形式存在（图片、文本、视频等）。</p><ul><li><p>二进制</p><pre class="language-python" data-language="python"><code class="language-python">0110</code></pre><p>![](Python模块一day1&#x2F;截屏2020-10-25 下午5.36.39.png)</p></li><li><p>八进制</p></li><li><p>十进制</p></li><li><p>十六进制</p></li></ul><img src="Python模块一day1/image-20201025174321969.png" alt="image-20201025174321969" style="zoom: 50%;" /><h4 id="2-1-进制转换"><a href="#2-1-进制转换" class="headerlink" title="2.1 进制转换"></a><font color="#dd0000">2.1 进制转换</font></h4><img src="Python模块一day1/image-20201025180124802.png" alt="image-20201025180124802" style="zoom:50%;" /><pre class="language-python" data-language="python"><code class="language-python">v1 &#x3D; bin(25) # 十进制转换为二进制，结果为字符串print(v1) # &quot;0b11001&quot;v2 &#x3D; oct(23) # 十进制转换为八进制print(v2) # &quot;0o27&quot;v3 &#x3D; hex(28) # 十进制转换为十六进制print(v3) # &quot;0x1c&quot;</code></pre><pre class="language-python" data-language="python"><code class="language-python">i1 &#x3D; int(&quot;0b11001&quot;,base&#x3D;2) # 25i2 &#x3D; int(&quot;0o27&quot;,base&#x3D;8) # 23 i3 &#x3D; int(&quot;0x1c&quot;,base&#x3D;16) # 28 </code></pre><h3 id="3-计算机中的单位"><a href="#3-计算机中的单位" class="headerlink" title="3. 计算机中的单位"></a>3. 计算机中的单位</h3><p>​由于计算机中本质上所有的东西以为二进制存储和操作的，为了方便对于二进制值大小的表示，所以就搞了一些单位。</p><ul><li><p>b（bit），位</p><pre class="language-none"><code class="language-none">1，1位10，2位111，3位1001，4位</code></pre></li><li><p>B（byte），字节</p><pre class="language-none"><code class="language-none">8位是一个字节。10010110，1个字节10010110 10010110，2个字节</code></pre></li><li><p>KB（kilobyte），千字节</p><pre class="language-none"><code class="language-none">1024个字节就是1个千字节。10010110 11010110  10010111 .. ，1KB1KB &#x3D; 1024B&#x3D; 1024 * 8 b</code></pre></li><li><p>M（Megabyte），兆</p><pre class="language-none"><code class="language-none">1024KB就是1M1M&#x3D; 1024KB &#x3D; 1024 * 1024 B &#x3D; 1024 * 1024 * 8 b</code></pre></li><li><p>G（Gigabyte），千兆</p><pre class="language-none"><code class="language-none">1024M就是1G1 G&#x3D;  1024 M&#x3D;  1024 *1024KB &#x3D;  1024 * 1024 * 1024 B &#x3D;  1024 * 1024 * 1024 * 8 b</code></pre></li><li><p>T（Terabyte），万亿字节</p><pre class="language-none"><code class="language-none">1024个G就是1T</code></pre></li><li><p>…其他更大单位 PB&#x2F;EB&#x2F;ZB&#x2F;YB&#x2F;BB&#x2F;NB&#x2F;DB 不再赘述。</p></li></ul><p><span style="color:red;">做个小练习</span>：</p><ul><li><p>假设1个汉字需要2个字节(2B&#x3D;16位来表示，如：1000101011001100)，那么1G流量可以通过网络传输多少汉字呢？（计算机传输本质上也是二进制）</p><pre class="language-python" data-language="python"><code class="language-python">1G &#x3D; 1024M &#x3D; 1024 * 1024KB &#x3D; 1024 * 1024 * 1024 B每个汉字需要2个字节表示1024 * 1024 * 1024&#x2F;2 &#x3D; ?  # 536870912.0</code></pre></li><li><p>假设1个汉字需要2个字节(2B&#x3D;16位来表示，如：1000101011001100)，那么500G硬盘可以存储多少个汉字？</p><pre class="language-python" data-language="python"><code class="language-python">500G &#x3D; 500 * 1024M &#x3D; 500 * 1024 * 1024KB &#x3D; 500 * 1024 * 1024 * 1024 B500 * 1024 * 1024 * 1024 &#x2F; 2 &#x3D; ?  # 268435456000.0</code></pre></li></ul><h3 id="4-编码"><a href="#4-编码" class="headerlink" title="4.编码"></a>4.编码</h3><p>​<font color="#dd0000">编码，文字和二进制之间的一个对照表。</font></p><h4 id="4-1-ascii编码"><a href="#4-1-ascii编码" class="headerlink" title="4.1 ascii编码"></a>4.1 ascii编码</h4><p>​ascii规定使用1个字节来表示<font color="#dd0000">字母与二进制</font>的对应关系。</p><pre class="language-none"><code class="language-none">0000000000000001    w00000010    B00000011    a...11111111</code></pre><p><strong>为什么是8位</strong></p><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20201026111741235.png" class=""><img src="/2022/05/20/python-mo-kuai-yi-day1/image-20201026111752410.png" class=""><pre class="language-python" data-language="python"><code class="language-python">2**8 &#x3D; 256</code></pre><h4 id="4-2-gb-2312编码"><a href="#4-2-gb-2312编码" class="headerlink" title="4.2 gb-2312编码"></a>4.2 gb-2312编码</h4><p>​gb-2312编码，由国家信息标准委员会制作（1980年）。gbk编码，对gb2312进行扩展，包含了中日韩等文字（1995年）。</p><p>​在与二进制做对应关系时，有如下逻辑：</p><ul><li>单字节表示，用一个字节表示对应关系（ASCII码的内容）。2**8 &#x3D; 256</li><li>双字节表示，用两个字节表示对应关系（汉字）。2**16 &#x3D; 65536种可能性。</li></ul><h4 id="4-3-unicode"><a href="#4-3-unicode" class="headerlink" title="4.3 unicode"></a>4.3 unicode</h4><p>​unicode（<a href="https://unicode-table.com/en/">对照表网址</a>）也被称为万国码，为全球的每个文字都分配了一个码位（二进制表示）。</p><ul><li><p>ucs2 ：用固定的2个字节去表示一个文字。</p><pre class="language-none"><code class="language-none">00000000 00000000     悟...2**16 &#x3D; 65535</code></pre></li><li><p>ucs4：用固定的4个字节去表示一个文字。</p><pre class="language-none"><code class="language-none">00000000 00000000 00000000 00000000  无...2**32 &#x3D; 4294967296</code></pre></li></ul><pre class="language-none"><code class="language-none">文字     十六进制            二进制  ȧ        0227           1000100111 ȧ        0227         00000010 00100111                       ucs2 不够两个字节前面补零 ȧ        0227         00000000 00000000 00000010 00100111     ucs4 不够四个字节前面补零  乔       4E54           100111001010100 乔       4E54         01001110 01010100                       ucs2 乔       4E54         00000000 00000000 01001110 01010100     ucs4  😆      1F606        11111011000000110 😆      1F606        00000000 00000001 11110110 00000110      ucs4</code></pre><p>​无论是ucs2和ucs4都有缺点：<font color="#dd0000">浪费空间？</font></p><pre class="language-python" data-language="python"><code class="language-python">文字     十六进制     二进制A        0041      01000001A        0041      00000000 01000001A        0041      00000000 00000000 00000000 01000001</code></pre><p>​unicode的应用：<font color="#dd0000">在文件存储和网络传输时，不会直接使用unicode，而在内存中会unicode。</font></p><h4 id="4-4-utf-8编码"><a href="#4-4-utf-8编码" class="headerlink" title="4.4 utf-8编码"></a>4.4 utf-8编码</h4><p>​包含所有文字和二进制的对应关系，全球应用最为广泛的一种编码（站在巨人的肩膀上功成名就）。<font color="#dd0000">本质上：utf-8是对unicode的压缩，用尽量少的二进制去与文字进行对应。</font></p><pre class="language-none"><code class="language-none">unicode码位范围            utf-8       0000 ~ 007F              用1个字节表示 0080 ~ 07FF              用2个字节表示 0800 ~ FFFF              用3个字节表示10000 ~ 10FFFF            用4个字节表示</code></pre><p>具体压缩的流程：</p><ul><li><p>第一步：选择转换模板</p><pre class="language-none"><code class="language-none">  码位范围（十六进制）                转换模板   0000 ~ 007F              0XXXXXXX   0080 ~ 07FF              110XXXXX 10XXXXXX   0800 ~ FFFF              1110XXXX 10XXXXXX 10XXXXXX  10000 ~ 10FFFF            11110XXX 10XXXXXX 10XXXXXX 10XXXXXX    例如：      &quot;B&quot;  对应的unicode码位为 0042，那么他应该选择的一个模板。      &quot;ǣ&quot;  对应的unicode码位为 01E3，则应该选择第二个模板。      &quot;武&quot; 对应的unicode码位为 6B66，则应该选择第三个模板。      &quot;沛&quot; 对应的unicode码位为 6C9B，则应该选择第三个模板。      &quot;齐&quot; 对应的unicode码位为 9F50，则应该选择第三个模板。       😆  对应的unicode码位为 1F606，则应该选择第四个模板。            注意：一般中文都使用第三个模板（3个字节），这也就是平时大家说中文在utf-8中会占3个字节的原因了。</code></pre></li><li><p>第二步：在模板中填入数据</p><pre class="language-none"><code class="language-none"># 文字  -&gt;  16进制编码号  -&gt;  二进制- &quot;武&quot;  -&gt;  6B66  -&gt;  110 101101 100110- 根据模板去套入数据1110XXXX 10XXXXXX 10XXXXXX1110XXXX 10XXXXXX 101001101110XXXX 10101101 1010011011100110 10101101 10100110在UTF-8编码中 ”武“  11100110 10101101 10100110</code></pre><p><strong>小练习</strong></p><pre class="language-python" data-language="python"><code class="language-python"># - 😆  -&gt;  1F606# - 根据模板去套入数据# 1. 将十六进制转为二进制bin_code &#x3D; bin(int(&#39;1F606&#39;, base&#x3D;16))print(bin_code)  # 0b11111011000000110# 2. 将结果套入模板&#39;&#39;&#39; - 1F606属于10000 ~ 10FFFF  使用第四个模板 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX - 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX  最后一个字节需要补6位 11111011000 000110 -&gt; 000110   11110XXX 10XXXXXX 10XXXXXX 10000110 - 11110XXX 10XXXXXX 10XXXXXX 10000110  倒数第二个字节需要补6位 11111 011000 000110 -&gt; 011000   11110XXX 10XXXXXX 10011000 10000110 - 11110XXX 10XXXXXX 10011000 10000110  倒数第三个字节需要补6位  11111 011000 000110 -&gt; 011111 位数不够补0   11110XXX 10011111 10011000 10000110 - 11110XXX 10XXXXXX 10011000 10000110  第一个字节需要补3位  11111 011000 000110 -&gt; 000 位数不够补0   11110000 10011111 10011000 10000110&#39;&#39;&#39;结果：11110000 10011111 10011000 10000110</code></pre></li></ul><h4 id="4-5-Python相关的编码"><a href="#4-5-Python相关的编码" class="headerlink" title="4.5 Python相关的编码"></a>4.5 Python相关的编码</h4><p><strong>字节（byte）</strong></p><pre class="language-none"><code class="language-none">字符串（str）        &quot;alex媳妇叫铁锤&quot;             unicode处理                 一般在内存字节（byte）      b&quot;alexfdsfdsdfskdfsd&quot;      utf-8编码 or gbk编码       一般用于文件或网络处理</code></pre><p><strong>字符串和字节的转化</strong></p><pre class="language-python" data-language="python"><code class="language-python"># 1.字符串转为字节v1 &#x3D; &quot;武&quot;v2 &#x3D; &quot;武&quot;.encode(&quot;utf-8&quot;)  # b&#39;\xe6\xad\xa6&#39; 三个字节v3 &#x3D; &quot;武&quot;.encode(&quot;gbk&quot;)  # b&#39;\xce\xe4&#39; 两个字节# 2.字节转为字符串v3 &#x3D; b&#39;\xe6\xad\xa6&#39;.decode(&#39;utf-8&#39;)  # &quot;武&quot;v4 &#x3D;  b&#39;\xce\xe4&#39;.decode(&#39;gbk&#39;)  # &quot;武&quot;</code></pre><p><strong>将一个字符串写入到一个文件中（字符串一般用在内存，要将其写入文件，需要将字符串转为字节码，一般使用”utf-8”编码）。</strong></p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;嫂子热的满身大汗&quot;data &#x3D; name.encode(&quot;utf-8&quot;)  # 将字符串转为utf-8字节码# 打开一个文件file_object &#x3D; open(&quot;log.txt&quot;,mode&#x3D;&quot;wb&quot;)# 在文件中写内容file_object.write(data)# 关闭文件file_object.close()</code></pre><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>​本章的知识点属于<font color="#dd0000">理解</font>为主，了解这些基础之后有利于后面知识点的学习，接下来对本节所有的知识点进行归纳总结：</p><ol><li><p>计算机上所有的东西最终都会转换成为二进制再去运行。</p></li><li><p>ascii编码、unicode字符集、utf-8编码本质上都是字符与二进制的关系。</p><ul><li>ascii，字符和二进制的对照表。</li><li>unicode，字符和二进制（码位）的对照表。</li><li>utf-8，对unicode字符集的码位<font color="#dd0000">进行压缩处理</font>，间接也维护了字符和二进制的对照表。</li></ul></li><li><p>ucs2和ucs4指的是使用多少个字节来表示unicode字符集的码位。</p></li><li><p>目前最广泛的编码为：utf-8，他可以表示所有的字符且存储或网络传输也不会浪费资源（对码位进行压缩了）。</p></li><li><p>二进制、八进制、十进制、十六进制其实就是进位的时机不同。</p><pre class="language-python" data-language="python"><code class="language-python">在Python中二进制、八进制和十六进制是以字符串进行表示，十进制是以整型进行表示</code></pre></li><li><p>基于Python实现二进制、八进制、十进制、十六进制之间的转换。</p><pre class="language-python" data-language="python"><code class="language-python">- 其它进制转为十进制- 二进制转十进制： int(&#39;0b...&#39;, base&#x3D;2)    - 八进制转十进制： int(&#39;0o...&#39;, base&#x3D;8)    - 十六进制转十进制： int(&#39;0x...&#39;, base&#x3D;16)- 十进制转其它进制    - 十进制转二进制： bin()    - 十进制转八进制： oct()    - 十进制转十六进制： hex()    </code></pre></li><li><p>一个字节8位</p></li><li><p>计算机中常见单位b&#x2F;B&#x2F;KB&#x2F;M&#x2F;G的关系。</p></li><li><p>汉字，用gbk编码需要用2个字节；用utf-8编码需要用3个字节。</p></li><li><p>基于Python实现将字符串转换为字节（utf-8编码）</p><pre class="language-python" data-language="python"><code class="language-python"># 字符串类型name &#x3D; &quot;武沛齐&quot;print(name) # 武沛齐# 字符串转换为字节类型data &#x3D; name.encode(&quot;utf-8&quot;)print(data) # b&#39;\xe6\xad\xa6\xe6\xb2\x9b\xe9\xbd\x90&#39;# 把字节转换为字符串old &#x3D; data.decode(&quot;utf-8&quot;)print(old)</code></pre></li><li><p>基于Python实现将字符串转换为字节（gbk编码）</p><pre class="language-python" data-language="python"><code class="language-python"># 字符串类型name &#x3D; &quot;武沛齐&quot;print(name) # 武沛齐# 字符串转换为字节类型data &#x3D; name.encode(&quot;gbk&quot;)# print(data) # b&#39;\xe6\xad\xa6\xe6\xb2\x9b\xe9\xbd\x90&#39;  utf8，中文3个字节print(data) # b&#39;\xce\xe4\xc5\xe6\xc6\xeb&#39;              gbk，中文2个字节# 把字节转换为字符串old &#x3D; data.decode(&quot;gbk&quot;)print(old)</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 路飞学院 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 第一阶段 </tag>
            
            <tag> python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day7-Web开发初探</title>
      <link href="/2022/05/19/python-ru-men-dao-jing-tong-7/"/>
      <url>/2022/05/19/python-ru-men-dao-jing-tong-7/</url>
      
        <content type="html"><![CDATA[<h3 id="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"><a href="#本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记" class="headerlink" title="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"></a>本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记</h3><h3 id="视频链接-Python零基础到精通7天速成"><a href="#视频链接-Python零基础到精通7天速成" class="headerlink" title="视频链接:Python零基础到精通7天速成"></a>视频链接:<a href="https://www.bilibili.com/video/BV1Gf4y1q7SG?share_source=copy_web">Python零基础到精通7天速成</a></h3><span id="more"></span><h1 id="一、Web开发介绍"><a href="#一、Web开发介绍" class="headerlink" title="一、Web开发介绍"></a>一、Web开发介绍</h1><p> &amp;emsp;我们看到的⽹⻚通过代码来实现的 ，这些代码由浏览器解释并渲染成你看到的丰富多彩的⻚⾯效果。这个浏览器就相当于Python的解释器，专⻔负责解释和执⾏(渲染）⽹⻚代码。<br> &amp;emsp;写⽹⻚的代码是专⻔的语⾔， 主要分为Hmtl \ CSS \ JavaScript, 被称为⽹⻚开发三剑客，分别作⽤如下：</p><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p> &amp;emsp;超⽂本标记语⾔（英语：HyperText Markup Language，简称：HTML）是⼀种⽤于创建⽹⻚的标准标记语⾔。<br> &amp;emsp;主要负责编写⻚⾯架构，有点像建房⼦时，造的⽑坯房。</p><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p> &amp;emsp;CSS (Cascading Style Sheets) ⽤于渲染HTML元素标签的样式。<br> &amp;emsp;让你的⽹⻚样式变的丰富多彩起来，可以改变字体、颜⾊、排列⽅式、背景颜⾊等<br> &amp;emsp;相当于给你的⽑坯房做装修</p><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p> &amp;emsp;周杰伦&#x3D; 周杰<br> &amp;emsp;⽹⻚脚本语⾔，可以让你的⽹⻚动起来，⽐如⼀张图⽚⿏标放上去⾃动变⼤、⼀个按钮⾃动变⾊、提交<br> &amp;emsp;表单时少填或填错了字段会提示报错等，都是JavaScript实现的。</p><div align=center><img src="https://img-blog.csdnimg.cn/e5561eb8cda4494d8a3a27ad6ae3fecc.png" width = 60%></div><p> &amp;emsp;以上3个 组件 是做⽹站开发都必须掌握的技能 ，我们接下来依次体验下~吧</p><h1 id="二、HTML"><a href="#二、HTML" class="headerlink" title="二、HTML"></a>二、HTML</h1><h2 id="（一）HTML简介"><a href="#（一）HTML简介" class="headerlink" title="（一）HTML简介"></a>（一）HTML简介</h2><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>路⻜学城<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>我的第⼀个标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>我的第⼀个段落。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><ul><li>&lt;!DOCTYPE html&gt; 声明为 HTML5 ⽂档</li><li>&lt;html&gt; 元素是 HTML ⻚⾯的根元素</li><li>&lt;head&gt; 标签⽤于定义⽂档的头部，它是所有头部元素的容器。 中的元素可以引⽤脚本、指示浏览器在哪⾥找到样式表、提供元信息等等。</li><li>&lt;meta&gt; 元素包含⽂档的元数据， 如定义⽹⻚编码格式为 utf-8、关键词啥的</li><li>&lt;title&gt; 元素⾥描述了⽂档的标题</li><li>&lt;body&gt; 元素包含了可⻅的⻚⾯内容</li><li>&lt;h1&gt; 元素定义⼀个⼤标题</li><li>&lt;p&gt; 元素定义⼀个段落</li></ul><p><font color="#dd0000"> 注：在浏览器的⻚⾯上使⽤键盘上的 F12 按键开启调试模式，就可以看到组成标签</font></p><h2 id="（二）什么是HTML"><a href="#（二）什么是HTML" class="headerlink" title="（二）什么是HTML"></a>（二）什么是HTML</h2><p> &amp;emsp;HTML 是⽤来描述⽹⻚的⼀种语⾔。</p><ul><li>HTML 指的是超⽂本标记语⾔: HyperText Markup Language</li><li>HTML 不是⼀种编程语⾔，⽽是⼀种标记语⾔</li><li>标记语⾔是⼀套标记标签 (markup tag)</li><li>HTML 使⽤标记标签来描述⽹⻚</li><li>HTML ⽂档包含了HTML 标签及⽂本内容</li><li>HTML⽂档也叫做 web ⻚⾯<h4 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h4> &amp;emsp;HTML 标记标签通常被称为 HTML 标签 (HTML tag)</li><li>HTML 标签是由尖括号包围的关键词，⽐如</li><li>HTML 标签通常是成对出现的，⽐如 <b> 和 </b> ,标签对中的第⼀个标签是开始标签，第⼆个标签是结束标签</li></ul><h2 id="（三）HTML⽹⻚结构"><a href="#（三）HTML⽹⻚结构" class="headerlink" title="（三）HTML⽹⻚结构"></a>（三）HTML⽹⻚结构</h2><p> &amp;emsp;下⾯是⼀个可视化的HTML⻚⾯结构</p><div align=center><img src="https://img-blog.csdnimg.cn/a1c12388aba84543a51ff77e8d509a71.png" width = 60%></div><font color="#dd0000"> 注： 只有 区域 (⽩⾊部分) 才会在浏览器中显示。</font><h1 id="三、HTML常⽤元素⼊⻔"><a href="#三、HTML常⽤元素⼊⻔" class="headerlink" title="三、HTML常⽤元素⼊⻔"></a>三、HTML常⽤元素⼊⻔</h1><h2 id="（一）HTML标题"><a href="#（一）HTML标题" class="headerlink" title="（一）HTML标题"></a>（一）HTML标题</h2><div align=center><img src="https://img-blog.csdnimg.cn/55c0190e16514b49871c158e35163586.png" width = 60%></div><h2 id="（二）段落"><a href="#（二）段落" class="headerlink" title="（二）段落"></a>（二）段落</h2><div align=center><img src="https://img-blog.csdnimg.cn/fa2fed5198bb438bbf9355b48ad95ab9.png" width = 60%></div><h2 id="（三）超链接"><a href="#（三）超链接" class="headerlink" title="（三）超链接"></a>（三）超链接</h2><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 传入属性target = _blank会打开一个新窗口 --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://www.luffycity.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这是⼀个链接使⽤了 href 属性<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><a href="https://www.luffycity.com">这是⼀个链接使⽤了 href 属性</a></p><h2 id="（四）显示图片"><a href="#（四）显示图片" class="headerlink" title="（四）显示图片"></a>（四）显示图片</h2><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>black_girl.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>600<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>500<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span></code></pre><div align=center><img src="https://img-blog.csdnimg.cn/cfa915e33c9d4d63ac2352824d6ed10e.png" width = 60%></div><h2 id="（五）HTML表格"><a href="#（五）HTML表格" class="headerlink" title="（五）HTML表格"></a>（五）HTML表格</h2><div align=center><img src="https://img-blog.csdnimg.cn/faeb53aeac62488cbdb8631d56b9ce8d.png" width = 60%></div><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>row 1, cell 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>row 1, cell 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>row 2, cell 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>row 2, cell 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span></code></pre><h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><table border="1" cellpadding="10"> <tr> <th>First Name</th> <th>Last Name</th> <th>Points</th> </tr> <tr> <td>Jill</td> <td>Smith</td> <td>50</td> </tr>  <tr> <td>Eve</td> <td>Jackson</td> <td>94</td> </tr>  <tr> <td>Jhon</td> <td>Doe</td> <td>80</td> </tr>  <tr> <td>Adam</td> <td>Jhonson</td> <td>67</td> </tr></table><h2 id="（六）列表"><a href="#（六）列表" class="headerlink" title="（六）列表"></a>（六）列表</h2><p> &amp;emsp;分为有序列表 和 ⽆序列表</p><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Coffee<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Tea<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Milk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span> <span class="token attr-name">start</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Coffee<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Tea<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Milk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span></code></pre><h4 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h4><ol> <li>Coffee</li> <li>Tea</li> <li>Milk</li></ol><ol start="50"> <li>Coffee</li> <li>Tea</li> <li>Milk</li></ol><h4 id="⽆序列表"><a href="#⽆序列表" class="headerlink" title="⽆序列表"></a>⽆序列表</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Coffee<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Tea<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Milk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre><h4 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h4><ul> <li>Coffee</li> <li>Tea</li> <li>Milk</li></ul><h4 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Coffee<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Tea <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Black tea<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Green tea<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Milk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre><h4 id="效果-4"><a href="#效果-4" class="headerlink" title="效果"></a>效果</h4><ul> <li>Coffee</li> <li>Tea <ul> <li>Black tea</li> <li>Green tea</li> </ul> </li> <li>Milk</li></ul><h2 id="（七）div区块元素"><a href="#（七）div区块元素" class="headerlink" title="（七）div区块元素"></a>（七）div区块元素</h2><h4 id="HTML区块元素"><a href="#HTML区块元素" class="headerlink" title="HTML区块元素"></a>HTML区块元素</h4><p> &amp;emsp;⼤多数 HTML 元素被定义为块级元素或内联元素。<br> &amp;emsp;块级元素在浏览器显示时，通常会以新⾏来开始（和结束）。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    ,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><div>    ,</div>]]></content>
      
      
      <categories>
          
          <category> Python零基础到精通7天速成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day6-用Python解决各种工作问题</title>
      <link href="/2022/05/14/python-ru-men-dao-jing-tong-6/"/>
      <url>/2022/05/14/python-ru-men-dao-jing-tong-6/</url>
      
        <content type="html"><![CDATA[<h3 id="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"><a href="#本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记" class="headerlink" title="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"></a>本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记</h3><h3 id="视频链接-Python零基础到精通7天速成"><a href="#视频链接-Python零基础到精通7天速成" class="headerlink" title="视频链接:Python零基础到精通7天速成"></a>视频链接:<a href="https://www.bilibili.com/video/BV1Gf4y1q7SG?share_source=copy_web">Python零基础到精通7天速成</a></h3><span id="more"></span><h1 id="一、模块和包"><a href="#一、模块和包" class="headerlink" title="一、模块和包"></a>一、模块和包</h1><h2 id="（一）什么是模块"><a href="#（一）什么是模块" class="headerlink" title="（一）什么是模块"></a>（一）什么是模块</h2><p> &amp;emsp;在计算机程序的开发过程中，随着程序代码越写越多，在⼀个⽂件⾥代码就会越来越⻓，越来越不容易维护。<br> &amp;emsp;<font color="#dd0000">为了编写可维护的代码</font>，我们把很多代码按功能分组，分别放到不同的⽂件⾥，这样，每个⽂件包含的代码就相对较少，很多编程语⾔都采⽤这种组织代码的⽅式。<font color="#dd0000">在Python中，⼀个.py⽂件就可以称之为⼀个模块（Module）</font></p><h4 id="使用模块有什么好处"><a href="#使用模块有什么好处" class="headerlink" title="使用模块有什么好处"></a>使用模块有什么好处</h4><p> &amp;emsp;最⼤的好处是<font color="#dd0000">⼤⼤提⾼了代码的可维护性</font>。其次，编写代码不必从零开始。<font color="#dd0000">当⼀个模块编写完毕，就可以被其他地⽅引⽤。</font>我们在编写程序的时候，也经常引⽤其他模块，包括Python内置的模块和来⾃第三⽅的模块。</p><p> &amp;emsp;<font color="#dd0000">使⽤模块还可以避免函数名和变量名冲突。</font> 每个模块有独⽴的命名空间，因此相同名字的函数和变量完全可以分别存在不同的模块中，所以，我们⾃⼰在编写模块时，不必考虑名字会与其他模块冲突</p><h4 id="模块的分类"><a href="#模块的分类" class="headerlink" title="模块的分类"></a>模块的分类</h4><p>1、内置标准模块（⼜称标准库）执⾏<font color="#dd0000">help(‘modules’)</font>查看所有python⾃带模块列表<br>2、第三⽅开源模块，可通过pip install 模块名联⽹安装<br>3、⾃定义模块</p><h4 id="模块调用"><a href="#模块调用" class="headerlink" title="模块调用"></a>模块调用</h4><pre class="language-python" data-language="python"><code class="language-python">import module_a #导⼊from module import xx # 导⼊某个模块下的某个⽅法 or ⼦模块from module.xx.xx import xx as rename #导⼊后⼀个⽅法后重命名from module.xx.xx import * #导⼊⼀个模块下的所有⽅法，不建议使⽤module_a.xxx #调⽤</code></pre><p>※ 注意：<font color="#dd0000">模块⼀旦被调⽤，即相当于执⾏了另外⼀个py⽂件⾥的代码</font></p><h2 id="（二）自定义模块"><a href="#（二）自定义模块" class="headerlink" title="（二）自定义模块"></a>（二）自定义模块</h2><p> &amp;emsp;这个最简单， 创建⼀个.py⽂件，就可以称之为模块，就可以在另外⼀个程序⾥导⼊</p><div align=center><img src="https://img-blog.csdnimg.cn/68ed3adc3b70448fb63a27a232db1868.png" width = 80%></div><h2 id="（六）模块查找路径"><a href="#（六）模块查找路径" class="headerlink" title="（六）模块查找路径"></a>（六）模块查找路径</h2><p> &amp;emsp;Python导入模块时会自动在系统环境变量中寻找需要导入的模块或包，如果找不到就会报错。</p><pre class="language-python" data-language="python"><code class="language-python">import sys# def sayhi():#     print(&#39;我是被调用的&#39;)# # print(&#39;哈哈哈哈&#39;)print(sys.path)# output:# [&#39;C:\\Users\\Geng\\Desktop\\我在b站学编程\\python\\day6&#39;, #  &#39;C:\\Users\\Geng\\Desktop\\我在b站学编程\\python&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\python39.zip&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\DLLs&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib&#39;, #  &#39;C:\\Users\\Geng\\anaconda3&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib\\site-packages&#39;, #  &#39;C:\\Program Files (x86)\\ArcGIS\\Desktop10.6\\bin&#39;, #  &#39;C:\\Program Files (x86)\\ArcGIS\\Desktop10.6\\ArcPy&#39;, #  &#39;C:\\Program Files (x86)\\ArcGIS\\Desktop10.6\\ArcToolBox\\Scripts&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib\\site-packages\\locket-0.2.1-py3.9.egg&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib\\site-packages\\win32&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib\\site-packages\\win32\\lib&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib\\site-packages\\Pythonwin&#39;]</code></pre><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><div align=center><img src="https://img-blog.csdnimg.cn/cd5052f2b00348f9a75a43e62528a000.png" width = 50%></div> &emsp;使用绝对导入的方法在day6课件下的import_test模块中导入my_first_mode模块。<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1、先获取到import_test模块的所有系统环境变量（sys.path()），发现不包括day6<br>2、将其绝对路径向上移动一层到day6后并添加到系统环境变量中</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="language-python" data-language="python"><code class="language-python">import sysimport osprint(sys.path)  # 打印文件的调用路径列表，发现my_first_mode所在的day6文件夹并不在调用列表中print(__file__)  # 打印当前模块绝对位置print(os.path.dirname(__file__))  # 打印当前位置的上一层（课件）print(os.path.dirname(os.path.dirname(__file__)))  # 打印当前位置的上二层（day6）base_path &#x3D; os.path.dirname(os.path.dirname(__file__))  # 因为my_first_mode在day6文件夹sys.path.append(base_path)import my_first_mode</code></pre><h2 id="（七）第三方开源模块"><a href="#（七）第三方开源模块" class="headerlink" title="（七）第三方开源模块"></a>（七）第三方开源模块</h2><p> &amp;emsp;<a href="https://pypi.org/">https://pypi.org/</a> 是python的开源模块库，截⽌2022年5.15⽇，已经收录了375,660个来⾃全世界python开发者贡献的模块,⼏乎涵盖了你想⽤python做的任何事情。 事实上每个python开发者，只要注册⼀个账号就可以往这个平台上传你⾃⼰的模块，这样全世界的开发者都可以容易的下载并使⽤你的模块。</p><h4 id="下载方法"><a href="#下载方法" class="headerlink" title="下载方法"></a>下载方法</h4><p>1、 直接在上⾯这个⻚⾯上点download,下载后，解压并进⼊⽬录，执⾏以下命令完成安装</p><pre class="language-python" data-language="python"><code class="language-python">编译源码python setup.py build 安装源码python setup.py install</code></pre><p>2、直接通过pip安装</p><pre class="language-python" data-language="python"><code class="language-python">pip3 install paramiko #paramiko 是模块名</code></pre><p>pip命令会⾃动下载模块包并完成安装。软件⼀般会被⾃动安装你python安装⽬录的这个⼦⽬录⾥</p><pre class="language-none"><code class="language-none">&#x2F;your_python_install_path&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;site-packages</code></pre><p> &amp;emsp;pip命令默认会连接在国外的python官⽅服务器下载，速度⽐较慢，你还可以使⽤国内的⾖瓣源，数据会定期同步国外官⽹，速度快好多</p><pre class="language-none"><code class="language-none">pip install -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; alex_sayhi --trusted-hostpypi.douban.com #alex_sayhi是模块名</code></pre><p>-i 后⾯跟的是⾖瓣源地址</p><pre class="language-—trusted-host" data-language="—trusted-host"><div class="caption"><span>```得加上，是通过⽹站https安全验证⽤的</span></div><code class="language-—trusted-host">## （三）什么是包 &amp;emsp;若你写的项⽬较复杂，有很多代码⽂件的话，为了⽅便管理，可以⽤包来管理。 &lt;font color&#x3D;&quot;#dd0000&quot;&gt;**⼀个包其实就是⼀个⽂件⽬录，**&lt;&#x2F;font&gt;你可以把属于同⼀个业务线的代码⽂件都放在同⼀个包⾥。#### 如何创建包 &amp;emsp;只需要&lt;font color&#x3D;&quot;#dd0000&quot;&gt;**在⽬录下创建⼀个空的 __init__.py ⽂件 ，**&lt;&#x2F;font&gt; 这个⽬录就变成了包。这个⽂件叫包的初始化⽂件，⼀般为空，当然也可以写东⻄，&lt;font color&#x3D;&quot;#dd0000&quot;&gt;**当你调⽤这个包下及其任意⼦包的的任意模块时， 这个 __init__.py ⽂件都会先执⾏。**&lt;&#x2F;font&gt;#### 示例以下有a、b 2个包，a2是a的⼦包，b2是b的⼦包&lt;div align&#x3D;center&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;3c9cda86f9a344789f214b6872685226.png&quot; width &#x3D; 50%&gt;&lt;&#x2F;div&gt;#### 若在a_module.py模块⾥导⼊b2_mod.py的话，怎么办？ &amp;emsp;a_module.py的⽂件路径为：&#96;&#96;&#96;pythonprint(__file__)# output: C:\Users\Geng\Desktop\我在b站学编程\python\day6\课件\a\a2\a_module.py</code></pre><p> &amp;emsp;想导⼊成功，直接写以下代码就可以</p><pre class="language-none"><code class="language-none">from day6.课件.b.b2 import b2_mod</code></pre><p> &amp;emsp;为何从day6开始？⽽不是从 python 或课件开始呢？<br> &amp;emsp;因为你的系统环境变量（sys.path()）列表⾥，已经添加了顶级包（python）的路径.<font color="#dd0000"><strong>pycharm会自动将该模块所在位置和该模块的顶级包加入sys.path</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">print(sys.path)# output: # [&#39;C:\\Users\\Geng\\Desktop\\我在b站学编程\\python\\day6\\课件\\a\\a2&#39;,#  &#39;C:\\Users\\Geng\\Desktop\\我在b站学编程\\python&#39;,  # 就是这个啦#  &#39;C:\\Users\\Geng\\anaconda3\\python39.zip&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\DLLs&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib&#39;, #  &#39;C:\\Users\\Geng\\anaconda3&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib\\site-packages&#39;,#  &#39;C:\\Program Files (x86)\\ArcGIS\\Desktop10.6\\bin&#39;, #  &#39;C:\\Program Files (x86)\\ArcGIS\\Desktop10.6\\ArcPy&#39;, #  &#39;C:\\Program Files (x86)\\ArcGIS\\Desktop10.6\\ArcToolBox\\Scripts&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib\\site-packages\\locket-0.2.1-py3.9.egg&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib\\site-packages\\win32&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib\\site-packages\\win32\\lib&#39;, #  &#39;C:\\Users\\Geng\\anaconda3\\lib\\site-packages\\Pythonwin&#39;]</code></pre><h1 id="二、常用模块-os-amp-sys"><a href="#二、常用模块-os-amp-sys" class="headerlink" title="二、常用模块-os&amp;sys"></a>二、常用模块-os&amp;sys</h1><h2 id="（一）系统调⽤OS模块"><a href="#（一）系统调⽤OS模块" class="headerlink" title="（一）系统调⽤OS模块"></a>（一）系统调⽤OS模块</h2><p> &amp;emsp;os 模块提供了很多允许你的程序与操作系统直接交互的功能</p><pre class="language-python" data-language="python"><code class="language-python">import os得到当前⼯作⽬录，即当前Python脚本⼯作的⽬录路径: os.getcwd()返回指定⽬录下的所有⽂件和⽬录名:os.listdir()函数⽤来删除⼀个⽂件:os.remove()删除多个⽬录：os.removedirs（r“c：\python”）检验给出的路径是否是⼀个⽂件：os.path.isfile()检验给出的路径是否是⼀个⽬录：os.path.isdir()判断是否是绝对路径：os.path.isabs()检验给出的路径是否真地存:os.path.exists()返回⼀个路径的⽬录名和⽂件名:os.path.split() e.gos.path.split(&#39;&#x2F;home&#x2F;swaroop&#x2F;byte&#x2F;code&#x2F;poem.txt&#39;) 结果：(&#39;&#x2F;home&#x2F;swaroop&#x2F;byte&#x2F;code&#39;, &#39;poem.txt&#39;)分离扩展名：os.path.splitext() e.g os.path.splitext(&#39;&#x2F;usr&#x2F;local&#x2F;test.py&#39;) 结果：(&#39;&#x2F;usr&#x2F;local&#x2F;test&#39;, &#39;.py&#39;)获取路径名：os.path.dirname()获得绝对路径: os.path.abspath()获取⽂件名：os.path.basename()运⾏shell命令: os.system()读取操作系统环境变量HOME的值:os.getenv(&quot;HOME&quot;)返回操作系统所有的环境变量： os.environ设置系统环境变量，仅程序运⾏时有效：os.environ.setdefault(&#39;HOME&#39;,&#39;&#x2F;home&#x2F;alex&#39;)给出当前平台使⽤的⾏终⽌符:os.linesep Windows使⽤&#39;\r\n&#39;，Linux and MAC使⽤&#39;\n&#39;指示你正在使⽤的平台：os.name 对于Windows，它是&#39;nt&#39;，⽽对于Linux&#x2F;Unix⽤户，它是&#39;posix&#39;重命名：os.rename（old， new）创建多级⽬录：os.makedirs（r“c：\python\test”）创建单个⽬录：os.mkdir（“test”）获取⽂件属性：os.stat（file）修改⽂件权限与时间戳：os.chmod（file）获取⽂件⼤⼩：os.path.getsize（filename）结合⽬录名与⽂件名：os.path.join(dir,filename)改变⼯作⽬录到dirname: os.chdir(dirname)获取当前终端的⼤⼩: os.get_terminal_size()杀死进程: os.kill(10884,signal.SIGKILL)</code></pre><h2 id="（二）sys模块"><a href="#（二）sys模块" class="headerlink" title="（二）sys模块"></a>（二）sys模块</h2><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><pre class="language-python" data-language="python"><code class="language-python">sys.path()  # 以列表形式返回系统环境变量sys.argv()  # 获取脚本参数</code></pre><h1 id="三、常用模块-time-amp-datetime"><a href="#三、常用模块-time-amp-datetime" class="headerlink" title="三、常用模块-time&amp;datetime"></a>三、常用模块-time&amp;datetime</h1><h2 id="（一）基本概念"><a href="#（一）基本概念" class="headerlink" title="（一）基本概念"></a>（一）基本概念</h2><p> &amp;emsp;在平常的代码中，我们常常需要与时间打交道。在Python中，与时间处理有关的模块就包括：time，datetime,calendar(很少⽤，不讲)，下⾯分别来介绍。</p><h4 id="写程序时对时间的处理可以归为以下3种："><a href="#写程序时对时间的处理可以归为以下3种：" class="headerlink" title="写程序时对时间的处理可以归为以下3种："></a>写程序时对时间的处理可以归为以下3种：</h4><p><strong>时间的显示</strong>，在屏幕显示、记录⽇志等 “2022-03-04”<br><strong>时间的转换</strong>，⽐如把字符串格式的⽇期转成Python中的⽇期类型<br><strong>时间的运算</strong>，计算两个⽇期间的差值等</p><h4 id="在Python中，通常有这⼏种⽅式来表示时间："><a href="#在Python中，通常有这⼏种⽅式来表示时间：" class="headerlink" title="在Python中，通常有这⼏种⽅式来表示时间："></a>在Python中，通常有这⼏种⽅式来表示时间：</h4><p><strong>1. 时间戳（timestamp）</strong>, 表示的是从1970年1⽉1⽇00:00:00开始按秒计算的偏移量，<font color="#dd0000"><strong>用于时间的计算。</strong></font>例⼦：1554864776.161901<br><strong>2. 格式化的时间字符串</strong>，⽐如“2020-10-03 17:54”<font color="#dd0000"><strong>用于时间的显示。</strong></font><br><strong>3. 时间对象：</strong>元组（struct_time）共九个元素，由于Python的time模块实现主要调⽤C库，所以各个平台可能有所不同，mac上：time.struct_time(tm_year&#x3D;2020, tm_mon&#x3D;4, tm_mday&#x3D;10, tm_hour&#x3D;2, tm_min&#x3D;53, tm_sec&#x3D;15, tm_wday&#x3D;2, tm_yday&#x3D;100, tm_isdst&#x3D;0)</p><pre class="language-python" data-language="python"><code class="language-python">索引（Index） 属性（Attribute） 值（Values）0 tm_year（年） ⽐如20111 tm_mon（⽉） 1 - 122 tm_mday（⽇） 1 - 313 tm_hour（时） 0 - 234 tm_min（分） 0 - 595 tm_sec（秒） 0 - 616 tm_wday（weekday） 0 - 6（0表示周⼀）7 tm_yday（⼀年中的第⼏天） 1 - 3668 tm_isdst（是否是夏令时） 默认为-1</code></pre><p><strong>UTC时间</strong><br> &amp;emsp;UTC（Coordinated Universal Time，世界协调时）亦即格林威治天⽂时间，世界标准时间。在中国为UTC+8，⼜称东8区。DST（Daylight Saving Time）即夏令时。</p><div align=center><img src="https://img-blog.csdnimg.cn/c4fba89d5c0e44ada45f43c4e18238c2.png" width = 80%></div><h2 id="（二）time模块的常⽤⽅法"><a href="#（二）time模块的常⽤⽅法" class="headerlink" title="（二）time模块的常⽤⽅法"></a>（二）time模块的常⽤⽅法</h2><pre class="language-python" data-language="python"><code class="language-python">import time# 1、计算机中的时间：时间戳time_stamp &#x3D; time.time()print(time_stamp)  # output：1652668353.8377407# 2、将时间戳和时间对象的转化# 时间戳转为时间对象time_struct &#x3D; time.localtime()  # 将时间戳转化为时间对象time_struct_zero &#x3D; time.gmtime()  # 将时间戳转化为零时区的时间对象print(time_struct)  # output：time.struct_time(tm_year&#x3D;2022, tm_mon&#x3D;5, tm_mday&#x3D;16, tm_hour&#x3D;10, tm_min&#x3D;25, tm_sec&#x3D;57, tm_wday&#x3D;0, tm_yday&#x3D;136, tm_isdst&#x3D;0)print(time_struct_zero)  # output：time.struct_time(tm_year&#x3D;2022, tm_mon&#x3D;5, tm_mday&#x3D;16, tm_hour&#x3D;2, tm_min&#x3D;25, tm_sec&#x3D;57, tm_wday&#x3D;0, tm_yday&#x3D;136, tm_isdst&#x3D;0)# 时间对象转为时间戳time_stamp1 &#x3D; time.mktime(time_struct)print(time_stamp1)  # output: 1652668353.0# 3、时间对象和时间字符串的转化# 时间对象转化为时间字符串time_str &#x3D; time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)print(time_str)  # 2022-05-16 10:34:15# 时间字符串转化为时间对象time_struct1 &#x3D; time.strptime(time_str, &#39;%Y-%m-%d %H:%M:%S&#39;)print(time_struct1)  # output:time.struct_time(tm_year&#x3D;2022, tm_mon&#x3D;5, tm_mday&#x3D;16, tm_hour&#x3D;10, tm_min&#x3D;34, tm_sec&#x3D;15, tm_wday&#x3D;0, tm_yday&#x3D;136, tm_isdst&#x3D;-1)# 4、sleeps_time &#x3D; time.time()print(s_time)  # output:1652670953.2851179time.sleep(3)e_time &#x3D; time.time()print(e_time)  # output：1652670956.2869053</code></pre><h4 id="字符串转时间格式对应表"><a href="#字符串转时间格式对应表" class="headerlink" title="字符串转时间格式对应表"></a>字符串转时间格式对应表</h4><div align=center><img src="https://img-blog.csdnimg.cn/ebc2d679d63440f8b9ca4c545323846d.png" width = 80%></div><div align=center><img src="https://img-blog.csdnimg.cn/d6aee8de24f6464eab702e73657bac77.png" width = 80%></div><h4 id="最后为了容易记住转换关系，看下图"><a href="#最后为了容易记住转换关系，看下图" class="headerlink" title="最后为了容易记住转换关系，看下图"></a>最后为了容易记住转换关系，看下图</h4><div align=center><img src="https://img-blog.csdnimg.cn/d88a02b06aad491e9dd115a22bfcd822.png" width = 80%></div><h2 id="（三）datetime模块"><a href="#（三）datetime模块" class="headerlink" title="（三）datetime模块"></a>（三）datetime模块</h2><p> &amp;emsp;相⽐于time模块，datetime模块的接⼝则更直观、更容易调⽤</p><h4 id="datetime模块定义了下⾯这⼏个类："><a href="#datetime模块定义了下⾯这⼏个类：" class="headerlink" title="datetime模块定义了下⾯这⼏个类："></a>datetime模块定义了下⾯这⼏个类：</h4><pre class="language-python" data-language="python"><code class="language-python">datetime.date： # 表示⽇期的类。常⽤的属性有year, month, daydatetime.time： # 表示时间的类。常⽤的属性有hour, minute, second, microseconddatetime.datetime： # 表示⽇期时间datetime.timedelta： # 表示时间间隔，即两个时间点之间的⻓度datetime.tzinfo： # 与时区有关的相关信息。（这⾥不详细充分讨论该类，感兴趣的童鞋可以参考python⼿册）</code></pre><h4 id="我们需要记住的⽅法仅以下⼏个："><a href="#我们需要记住的⽅法仅以下⼏个：" class="headerlink" title="我们需要记住的⽅法仅以下⼏个："></a>我们需要记住的⽅法仅以下⼏个：</h4><pre class="language-python" data-language="python"><code class="language-python">d&#x3D;datetime.datetime.now()  # 返回当前的datetime⽇期类型, d.timestamp(),d.today(),d.year,d.timetuple()等⽅法可以调⽤datetime.date.fromtimestamp(322222)  # 把⼀个时间戳转为datetime⽇期类型</code></pre><h4 id="时间运算"><a href="#时间运算" class="headerlink" title="时间运算"></a><font color="#dd0000">时间运算</font></h4><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; datetime.datetime.now()datetime.datetime(2017, 10, 1, 12, 53, 11, 821218)&gt;&gt;&gt; datetime.datetime.now() + datetime.timedelta(4) #当前时间 +4天datetime.datetime(2017, 10, 5, 12, 53, 35, 276589)&gt;&gt;&gt; datetime.datetime.now() + datetime.timedelta(hours&#x3D;4) #当前时间+4⼩时datetime.datetime(2017, 10, 1, 16, 53, 42, 876275)</code></pre><h4 id="时间替换"><a href="#时间替换" class="headerlink" title="时间替换"></a><font color="#dd0000">时间替换</font></h4><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; d.replace(year&#x3D;2999,month&#x3D;11,day&#x3D;30)datetime.date(2999, 11, 30)</code></pre><h1 id="四、常用模块-random"><a href="#四、常用模块-random" class="headerlink" title="四、常用模块-random"></a>四、常用模块-random</h1><p> &amp;emsp;程序中有很多地⽅需要⽤到随机字符，⽐如登录⽹站的随机验证码，通过random模块可以很容易⽣成随机字符串</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; random.randrange(1,10) #返回1-10之间的⼀个随机数，不包括10&gt;&gt;&gt; random.randint(1,10) #返回1-10之间的⼀个随机数，包括10&gt;&gt;&gt; random.randrange(0, 100, 2) #随机选取0到100间的偶数&gt;&gt;&gt; random.random() #返回⼀个随机浮点数&gt;&gt;&gt; random.choice(&#39;abce3#$@1&#39;) #返回⼀个给定数据集合中的随机字符&#39;#&#39;&gt;&gt;&gt; random.sample(&#39;abcdefghij&#39;,3) #从多个字符中选取特定数量的字符[&#39;a&#39;, &#39;d&#39;, &#39;b&#39;]#⽣成随机字符串&gt;&gt;&gt; import string&gt;&gt;&gt; &#39;&#39;.join(random.sample(string.ascii_lowercase + string.digits, 6))&#39;4fvda1&#39;#洗牌&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; random.shuffle(a)&gt;&gt;&gt; a[3, 0, 7, 2, 1, 6, 5, 8, 9, 4]</code></pre><h1 id="五、常用模块-json序列"><a href="#五、常用模块-json序列" class="headerlink" title="五、常用模块-json序列"></a>五、常用模块-json序列</h1><h2 id="（一）概念"><a href="#（一）概念" class="headerlink" title="（一）概念"></a>（一）概念</h2><p> &amp;emsp;JSON(JavaScriptObject Notation, JS 对象简谱) 是⼀种轻量级的数据交换格式。它采⽤完全独⽴于编程<br>语⾔的⽂本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语⾔。 易于⼈阅读和编写，同时也易于机器解析和⽣成，并有效地提升⽹络传输效率。</p><div align=center><img src="https://img-blog.csdnimg.cn/ca4b4eb7be0d4b6d98b0b08c4a6f384b.png" width = 80%></div> &emsp;Json的作⽤是⽤于不同语⾔接⼝间的数据交换，⽐如你把python的list、dict直接扔给javascript, 它是解析不了的。两个语⾔互相谁也不认识。Json就像是计算机界的英语 ，可以帮各个语⾔之间实现数据类型的相互转换。<div align=center><img src="https://img-blog.csdnimg.cn/ec2fd65decbe488dada8c667ce3e1673.png" width = 80%></div><div align=center><img src="https://img-blog.csdnimg.cn/01d31de8b16646778a1ab4ceaa56d76d.png" width = 80%></div><h4 id="JSON⽀持的数据类型"><a href="#JSON⽀持的数据类型" class="headerlink" title="JSON⽀持的数据类型"></a>JSON⽀持的数据类型</h4><p> &amp;emsp;Python中的字符串、数字、列表、字典、集合、布尔类型，都可以被序列化成JSON字符串，被其它任何编程语⾔解析</p><h4 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h4><p> &amp;emsp;序列化是指把内存⾥的数据类型转变成字符串，以使其能存储到硬盘或通过⽹络传输到远程，因为硬盘或⽹络传输时只能接受bytes</p><h4 id="为什么要序列化？"><a href="#为什么要序列化？" class="headerlink" title="为什么要序列化？"></a>为什么要序列化？</h4><p> &amp;emsp;你打游戏过程中，打累了，停下来，关掉游戏、想过2天再玩，2天之后，游戏⼜从你上次停⽌的地⽅继续运⾏，你上次游戏的进度肯定保存在硬盘上了，是以何种形式呢？游戏过程中产⽣的很多临时数据是不规律的，可能在你关掉游戏时正好有10个列表，3个嵌套字典的数据集合在内存⾥，需要存下来？你如何存？把列表变成⽂件⾥的多⾏多列形式？那嵌套字典呢？根本没法存。所以，若是有种办法可以直接把内存数据存到硬盘上，下次程序再启动，再从硬盘上读回来，还是原来的格式的话，那是极好的。</p><h4 id="⽤于序列化的两个模块"><a href="#⽤于序列化的两个模块" class="headerlink" title="⽤于序列化的两个模块"></a>⽤于序列化的两个模块</h4><p>1、json，⽤于字符串和python数据类型间进⾏转换<br>2、pickle，⽤于python特有的类型和 python的数据类型间进⾏转换</p><h4 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h4><p>模块提供了四个功能：dumps、dump、loads、load</p><pre class="language-python" data-language="python"><code class="language-python">import pickledata &#x3D; &#123;&#39;k1&#39;:123,&#39;k2&#39;:&#39;Hello&#39;&#125;# pickle.dumps 将数据通过特殊的形式转换位只有python语⾔认识的字符串p_str &#x3D; pickle.dumps(data) # 注意dumps会把数据变成bytes格式print(p_str)# pickle.dump 将数据通过特殊的形式转换位只有python语⾔认识的字符串，并写⼊⽂件with open(&#39;result.pk&#39;,&quot;wb&quot;) as fp: pickle.dump(data,fp)# pickle.load 从⽂件⾥加载f &#x3D; open(&quot;result.pk&quot;,&quot;rb&quot;)d &#x3D; pickle.load(f)print(d)</code></pre><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p>Json模块也提供了四个功能：dumps、dump、loads、load，⽤法跟pickle⼀致</p><pre class="language-python" data-language="python"><code class="language-python">import json# json.dumps 将数据通过特殊的形式转换位所有程序语⾔都认识的字符串j_str &#x3D; json.dumps(data) # 注意json dumps⽣成的是字符串，不是bytesprint(j_str)#dump⼊⽂件with open(&#39;result.json&#39;,&#39;w&#39;) as fp: json.dump(data,fp)#从⽂件⾥loadwith open(&quot;result.json&quot;) as f: d &#x3D; json.load(f) print(d)</code></pre><h4 id="json-vs-pickle"><a href="#json-vs-pickle" class="headerlink" title="json vs pickle:"></a>json vs pickle:</h4><p><strong>json</strong><br>优点：跨语⾔(不同语⾔间的数据传递可⽤json交接)、体积⼩<br>缺点：只能⽀持int\str\list\tuple\dict<br><strong>Pickle</strong><br>优点：专为python设计，⽀持python所有的数据类型<br>缺点：只能在python中使⽤，存储数据占空间⼤</p><h1 id="六、常用模块-excel处理"><a href="#六、常用模块-excel处理" class="headerlink" title="六、常用模块-excel处理"></a>六、常用模块-excel处理</h1><p> &amp;emsp;第3⽅开源模块,安装</p><pre class="language-python" data-language="python"><code class="language-python">pip install openpyxl</code></pre><h2 id="（一）打开⽂件"><a href="#（一）打开⽂件" class="headerlink" title="（一）打开⽂件"></a>（一）打开⽂件</h2><h4 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h4><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import Workbook# 实例化wb &#x3D; Workbook()# 获取当前active的sheetws &#x3D; wb.activeprint(sheet.title) # 打印sheet表名sheet.title &#x3D; &quot;salary luffy&quot; # 改sheet 名</code></pre><h4 id="2、打开已有⽂件"><a href="#2、打开已有⽂件" class="headerlink" title="2、打开已有⽂件"></a>2、打开已有⽂件</h4><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; from openpyxl import load_workbook&gt;&gt;&gt; wb2 &#x3D; load_workbook(&#39;⽂件名称.xlsx&#39;)</code></pre><h2 id="（二）增删改查"><a href="#（二）增删改查" class="headerlink" title="（二）增删改查"></a>（二）增删改查</h2><h4 id="1、写数据"><a href="#1、写数据" class="headerlink" title="1、写数据"></a>1、写数据</h4><pre class="language-python" data-language="python"><code class="language-python"># ⽅式⼀：数据可以直接分配到单元格中(可以输⼊公式)sheet[&quot;C5&quot;] &#x3D; &quot;Hello ⾦⻆⼤王&quot;sheet[&quot;C7&quot;] &#x3D; &quot;Hello ⾦⻆⼤王2&quot;# ⽅式⼆：可以附加⾏，从第⼀列开始附加(从最下⽅空⽩处，最左开始)(可以输⼊多⾏)sheet.append([1, 2, 3])# ⽅式三：Python 类型会被⾃动转换sheet[&#39;A3&#39;] &#x3D; datetime.datetime.now().strftime(&quot;%Y-%m-%d&quot;)</code></pre><h4 id="2、选择表"><a href="#2、选择表" class="headerlink" title="2、选择表"></a>2、选择表</h4><pre class="language-python" data-language="python"><code class="language-python"># sheet 名称可以作为 key 进⾏索引ws3 &#x3D; wb[&quot;New Title&quot;]ws4 &#x3D; wb.get_sheet_by_name(&quot;New Title&quot;)print(wb.get_sheet_names()) # 打印所有的sheetsheet &#x3D; wb.worksheets[0] # 获得第1个sheet</code></pre><h4 id="3、保存表"><a href="#3、保存表" class="headerlink" title="3、保存表"></a>3、保存表</h4><pre class="language-python" data-language="python"><code class="language-python">wb.save(&#39;⽂件名称.xlsx&#39;)</code></pre><h4 id="4、删除工作表"><a href="#4、删除工作表" class="headerlink" title="4、删除工作表"></a>4、删除工作表</h4><pre class="language-python" data-language="python"><code class="language-python"># ⽅式⼀wb.remove(sheet)# ⽅式⼆del wb[sheet]</code></pre><h2 id="（三）花式遍历表数据"><a href="#（三）花式遍历表数据" class="headerlink" title="（三）花式遍历表数据"></a>（三）花式遍历表数据</h2><h4 id="1、按行遍历"><a href="#1、按行遍历" class="headerlink" title="1、按行遍历"></a>1、按行遍历</h4><pre class="language-python" data-language="python"><code class="language-python">for row in sheet: # 循环获取表数据    for cell in row: # 循环获取每个单元格数据        print(cell.value, end&#x3D;&quot;,&quot;)    print()</code></pre><h4 id="2、按列遍历"><a href="#2、按列遍历" class="headerlink" title="2、按列遍历"></a>2、按列遍历</h4><pre class="language-python" data-language="python"><code class="language-python"># A1, A2, A3这样的顺序for column in sheet.columns:    for cell in column:        print(cell.value,end&#x3D;&quot;,&quot;)    print()</code></pre><h4 id="3、遍历指定⾏-amp-列"><a href="#3、遍历指定⾏-amp-列" class="headerlink" title="3、遍历指定⾏&amp;列"></a>3、遍历指定⾏&amp;列</h4><pre class="language-python" data-language="python"><code class="language-python"># 从第2⾏开始⾄第5⾏，每⾏打印5列for row in sheet.iter_rows(min_row&#x3D;2,max_row&#x3D;5,max_col&#x3D;5):    for cell in row:        print(cell.value,end&#x3D;&quot;,&quot;)    print()</code></pre><h4 id="4、遍历指定⼏列的数据-取得第2到第5列的数据"><a href="#4、遍历指定⼏列的数据-取得第2到第5列的数据" class="headerlink" title="4、遍历指定⼏列的数据-取得第2到第5列的数据"></a>4、遍历指定⼏列的数据-取得第2到第5列的数据</h4><pre class="language-python" data-language="python"><code class="language-python">for col in sheet.iter_cols(min_col&#x3D;2,max_col&#x3D;5,):    for i in col:        print(i.value,end&#x3D;&quot;,&quot;)    print()</code></pre><h2 id="（四）设置单元格样式"><a href="#（四）设置单元格样式" class="headerlink" title="（四）设置单元格样式"></a>（四）设置单元格样式</h2><h4 id="1、需导⼊的类"><a href="#1、需导⼊的类" class="headerlink" title="1、需导⼊的类"></a>1、需导⼊的类</h4><pre class="language-python" data-language="python"><code class="language-python">from openpyxl.styles import Font, colors, Alignment</code></pre><h4 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h4><p> &amp;emsp;下⾯的代码指定了等线24号，加粗斜体，字体颜⾊红⾊。直接使⽤cell的font属性，将Font对象赋值给它。</p><pre class="language-python" data-language="python"><code class="language-python">bold_itatic_24_font &#x3D; Font(name&#x3D;&#39;等线&#39;, size&#x3D;24, italic&#x3D;True, color&#x3D;colors.RED,bold&#x3D;True) # 声明样式sheet[&#39;A1&#39;].font &#x3D; bold_itatic_24_font # 给单元格设置样式</code></pre><h4 id="3、对齐方式"><a href="#3、对齐方式" class="headerlink" title="3、对齐方式"></a>3、对齐方式</h4><p> &amp;emsp;也是直接使⽤cell的属性aligment，这⾥指定垂直居中和⽔平居中。除了center，还可以使⽤right、left<br>等等参数。</p><pre class="language-python" data-language="python"><code class="language-python"># 设置B1中的数据垂直居中和⽔平居中sheet[&#39;B1&#39;].alignment &#x3D; Alignment(horizontal&#x3D;&#39;center&#39;, vertical&#x3D;&#39;center&#39;)</code></pre><h4 id="4、设置⾏⾼-amp-列宽"><a href="#4、设置⾏⾼-amp-列宽" class="headerlink" title="4、设置⾏⾼&amp;列宽"></a>4、设置⾏⾼&amp;列宽</h4><pre class="language-python" data-language="python"><code class="language-python"># 第2⾏⾏⾼sheet.row_dimensions[2].height &#x3D; 40# C列列宽sheet.column_dimensions[&#39;C&#39;].width &#x3D; 30</code></pre><h2 id="（五）小练习"><a href="#（五）小练习" class="headerlink" title="（五）小练习"></a>（五）小练习</h2><h4 id="练习数据-iris"><a href="#练习数据-iris" class="headerlink" title="练习数据-iris"></a>练习数据-iris</h4><pre class="language-none"><code class="language-none">序号,sepal_length(cm),sepal_width(cm),petal_length(cm),petal_width(cm),outcome0,5.1,3.5,1.4,0.2,o1,4.9,3,1.4,0.2,02,4.7,3.2,1.3,0.2,03,4.6,31,1.5,0.2,04,5,3.6,1.4,0.2,05,5.4,3.9,1.7,0.4,06,4.6,3.4,1.4,0.3,07,5,3.4,1.5,0.2,08,4.4,2.9,1.4,0.2,09,4.9,3.1,1.5,0.1,010,5.4,3.7,1.5,0.2,011,4.8,3.4,1.6,0.2,012,4.8,3,1.4,0.1,013,4.3,3,1.1,0.1,014,5.8,4,1.2,0.2,015,5.7,4.4,1.5,0.4,016,5.4,3.9,1.3,0.4,017,5.1,3.5,1.4,0.3,018,5.7,3.8,1.7,0.3,019,5.1,3.8,1.5,0.3,020,5.4,3.4,1.7,0.2,021,5.1,3.7,1.5,0.4,022,4.6,3.6,1,0.2,023,5.1,3.3,1.7,0.5,024,4.8,3.4,1.9,0.2,025,5,3,1.6,0.2,026,5,3.4,1.6,0.4,027,5.2,3.5,1.5,0.2,028,5.2,3.4,1.4,0.2,029,4.7,3.2,1.6,0.2,030,4.8,3.1,1.6,0.2,031,5.4,3.4,1.5,0.4,032,5.2,4.1,1.5,0.1,033,5.5,4.2,1.4,0.2,034,4.9,3.1,1.5,0.2,035,5,3.2,1.2,0.2,036,5.5,3.5,1.3,0.2,037,4.9,3.6,1.4,0.1,038,4.4,3,1.3,0.2,039,5.1,3.4,1.5,0.2,040,5,3.5,1.3,0.3,041,4.5,2.3,1.3,0.3,042,4.4,3.2,1.3,0.2,043,5,3.5,1.6,0.6,044,5.1,3.8,1.9,0.4,045,4.8,3,1.4,0.3,046,5.1,3.8,1.6,0.2,047,4.6,3.2,1.4,0.2,048,5.3,3.7,1.5,0.2,049,5,3.3,1.4,0.2,050,7,3.2,4.7,1.4,1</code></pre><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>1、创建iris.xlsx文件，导入上述数据<br>2、新增一行数据，516.43.24.51.51<br>3、将C5改为31,F2改为0<br>4、分别按行、按列遍历数据<br>5、获取第5行到第22行，C到E列的数据<br>6、将D9单元格字体设为新罗马24号，加粗斜体，字体颜⾊红⾊<br>7、将D9单元格指定垂直居中和⽔平居中</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import Workbookfrom openpyxl.styles import Font, colors, Alignment# 1、创建iris.xlsx文件，导入数据# file_iris &#x3D; open(&#39;iris&#39;, encoding&#x3D;&#39;utf-8&#39;)# for line in file_iris:wb &#x3D; Workbook()  # 实例化Workbooksheet &#x3D; wb.active  # 激活该sheetsheet.title &#x3D; &#39;iris&#39;  # 更改sheet名称# 写入数据file_iris &#x3D; open(&#39;iris&#39;, encoding&#x3D;&#39;utf-8&#39;)for line in file_iris:    sheet.append(line.strip().split(&#39;,&#39;))# 2、新增一行数据，516.43.24.51.51sheet.append([&#39;51&#39;, &#39;6.4&#39;, &#39;3.2&#39;, &#39;4.5&#39;, &#39;1.5&#39;, &#39;1&#39;])# 3、将C5改为3.1,F2改为0sheet[&#39;C5&#39;] &#x3D; &#39;3.1&#39;sheet[&#39;F2&#39;] &#x3D; &#39;0&#39;# 4、分别按行、按列遍历数据# 按行for row in sheet:    for cell in row:        print(cell.value, end&#x3D;&#39;,&#39;)    print()# 按列for col in sheet.columns:    for cell in col:        print(cell.value, end&#x3D;&#39;,&#39;)    print()# 5、获取第5行到第22行，C到E列的数据for row in sheet.iter_cols(min_row&#x3D;5, max_row&#x3D;22, min_col&#x3D;3, max_col&#x3D;5):    for cell in row:        print(cell.value, end&#x3D;&#39;,&#39;)    print()# 6、将D9单元格字体设为新罗马24号，加粗斜体，字体颜⾊红⾊my_style &#x3D; Font(name&#x3D;&#39;Times New Roman&#39;, size&#x3D;24, italic&#x3D;True, color&#x3D;colors.COLOR_INDEX[2],bold&#x3D;True)  # 声明样式sheet[&#39;D9&#39;].font &#x3D; my_style# 将D9单元格指定垂直居中和⽔平居中sheet[&#39;D9&#39;].alignment &#x3D; Alignment(horizontal&#x3D;&#39;center&#39;, vertical&#x3D;&#39;center&#39;)# 保存文件wb.save(&#39;iris.xlsx&#39;)</code></pre><h1 id="七、常用模块-邮件发送"><a href="#七、常用模块-邮件发送" class="headerlink" title="七、常用模块-邮件发送"></a>七、常用模块-邮件发送</h1><p> &amp;emsp;SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是⼀组⽤于由源地址到⽬的地址传送<br>邮件的规则，由它来控制信件的中转⽅式。</p><div align=center><img src="https://img-blog.csdnimg.cn/7376ab924d6c4cde93a5a37608acc310.png" width = 80%></div><h4 id="想实现发送邮件需经过以下⼏步："><a href="#想实现发送邮件需经过以下⼏步：" class="headerlink" title="想实现发送邮件需经过以下⼏步："></a>想实现发送邮件需经过以下⼏步：</h4><p>1、登录 邮件服务器<br>2、构造符合邮件协议规则要求的邮件内容 （email模块）<br>3、发送<br> &amp;emsp;Python对SMTP⽀持有smtplib 和 email 两个模块， email 负责构造邮件， smtplib 负责发送邮件,它对smtp协议进⾏了简单的封装。</p><h4 id="发送⼀封最简单的信语法如下："><a href="#发送⼀封最简单的信语法如下：" class="headerlink" title="发送⼀封最简单的信语法如下："></a>发送⼀封最简单的信语法如下：</h4><pre class="language-python" data-language="python"><code class="language-python">import smtplibfrom email.mime.text import MIMEText  # 构造邮件正文from email.header import Header  # 邮件头# 登录邮件服务器smtp_obj &#x3D; smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465)  # 发件⼈邮箱中的SMTP服务器，端⼝是25smtp_obj.login(&quot;xxxxxxxxxx@qq.com&quot;, &quot;bvidphbzxnsjjdch&quot;)  # 括号中对应的是发件⼈邮箱账号、邮箱密码# smtp_obj.set_debuglevel(1) # 显示调试信息# 设置邮件头信息msg &#x3D; MIMEText(&quot;xxxxxxxxxxx&quot;, &quot;plain&quot;, &quot;utf-8&quot;)  # plain表示文件内容为纯文本msg[&quot;From&quot;] &#x3D; Header(&quot;xxxxxxxx&quot;, &quot;utf-8&quot;)  # 发送者msg[&quot;To&quot;] &#x3D; Header(&quot;xxxxxx&quot;, &quot;utf-8&quot;)  # 接收者msg[&quot;Subject&quot;] &#x3D; Header(&quot;xxxxx&quot;, &quot;utf-8&quot;)  # 主题# 发送smtp_obj.sendmail(&quot;xxxxxxxxx@qq.com&quot;, [&quot;xxxxxxxxxx@qq.com&quot;], msg.as_string())  # 接受方可使用列表同时传入多个值</code></pre><p>※ 如何查看发送邮件服务器-以QQ邮箱为例：<br>1、点击设置-账户</p><div align=center><img src="https://img-blog.csdnimg.cn/a752685766854b2f8e18af011e4831a2.png" width = 80%></div>2、IMAP/SMTP服务-点击什么是 IMAP，它又是如何设置？<div align=center><img src="https://img-blog.csdnimg.cn/a403ea4074b8419ba563ee0992f064dd.png" width = 80%></div>3、进入页面<div align=center><img src="https://img-blog.csdnimg.cn/7ca6edb3f0b9412e81fea294e32d0eb9.png" width = 80%></div><p>※ 如何查看发送邮件服务器-以QQ邮箱为例：msg的[“From”]、[“To”]和[“Subject”]为邮件显示的发送者，接受者和主题，可以自定义smtp_obj.sendmail()中才传入发送方、接收方和内容。</p><div align=center><img src="https://img-blog.csdnimg.cn/3481f353c4a445a290d2eecfb41f8531.png" width = 80%></div><h4 id="发送HTML格式的邮件"><a href="#发送HTML格式的邮件" class="headerlink" title="发送HTML格式的邮件"></a>发送HTML格式的邮件</h4><p> &amp;emsp;只需要改⼀下 MIMEText() 第2个参数为 html 就可以</p><pre class="language-python" data-language="python"><code class="language-python"># 设置邮件头信息mail_body &#x3D; &#39;&#39;&#39; &lt;h5&gt;hello,⼩哥哥&lt;&#x2F;h5&gt; &lt;p&gt; 你好同学 &lt;ahref&#x3D;&quot;http:&#x2F;&#x2F;wx1.sinaimg.cn&#x2F;mw1024&#x2F;5ff6135fgy1gdnghz2vbsg205k09ob2d.gif&quot;&gt;这是我的照⽚&lt;&#x2F;a&gt;&lt;&#x2F;p&gt; &lt;&#x2F;p&gt;&#39;&#39;&#39;msg &#x3D; MIMEText(mail_body, &quot;html&quot;, &quot;utf-8&quot;)</code></pre><h4 id="在HTML⽂本中插⼊图⽚"><a href="#在HTML⽂本中插⼊图⽚" class="headerlink" title="在HTML⽂本中插⼊图⽚"></a>在HTML⽂本中插⼊图⽚</h4><pre class="language-python" data-language="python"><code class="language-python"># -*- coding:utf-8 -*-# created by Alex Li - 路⻜学城import smtplibfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.header import Header# 登录邮件服务器smtp_obj &#x3D; smtplib.SMTP_SSL(&quot;smtp.exmail.qq.com&quot;, 465) # 发件⼈邮箱中的SMTP服务器，端⼝是25smtp_obj.login(&quot;nami@luffycity.com&quot;, &quot;333dsfsf#$#&quot;) # 括号中对应的是发件⼈邮箱账号、邮箱密码smtp_obj.set_debuglevel(1) # 显示调试信息# 设置邮件头信息mail_body &#x3D; &#39;&#39;&#39;    &lt;h5&gt;hello,⼩哥哥&lt;&#x2F;h5&gt;    &lt;p&gt;    你好同学    &lt;p&gt;&lt;img src&#x3D;&quot;cid:image1&quot;&gt;&lt;&#x2F;p&gt;    &lt;&#x2F;p&gt;&#39;&#39;&#39;msg_root &#x3D; MIMEMultipart(&#39;related&#39;) # 允许添加附件、图⽚等msg_root[&quot;From&quot;] &#x3D; Header(&quot;来⾃娜美的问候&quot;,&quot;utf-8&quot;) # 发送者msg_root[&quot;To&quot;] &#x3D; Header(&quot;有缘⼈&quot;,&quot;utf-8&quot;) # 接收者msg_root[&quot;Subject&quot;] &#x3D; Header(&quot;娜美的信&quot;,&quot;utf-8&quot;) # 主题# 允许添加图⽚msgAlternative &#x3D; MIMEMultipart(&#39;alternative&#39;)msgAlternative.attach(MIMEText(mail_body, &#39;html&#39;, &#39;utf-8&#39;))msg_root.attach(msgAlternative) # 把邮件正⽂内容添加到msg_root⾥# 加载图⽚，fp &#x3D; open(&#39;girl.jpg&#39;, &#39;rb&#39;)msgImage &#x3D; MIMEImage(fp.read())fp.close()# 定义图⽚ ID，在 HTML ⽂本中引⽤msgImage.add_header(&#39;Content-ID&#39;, &#39;&lt;image1&gt;&#39;)msg_root.attach(msgImage) # 添加图⽚到msg_root对象⾥# 发送smtp_obj.sendmail(&quot;nami@luffycity.com&quot;, [&quot;alex@luffycity.com&quot;,&quot;317828332@qq.com&quot;], msg_root.as_string())</code></pre><h1 id="实战：给员工自动批量发工资条"><a href="#实战：给员工自动批量发工资条" class="headerlink" title="实战：给员工自动批量发工资条"></a>实战：给员工自动批量发工资条</h1><pre class="language-python" data-language="python"><code class="language-python">from openpyxl import load_workbookimport smtplibfrom email.mime.text import MIMEText  # 构造邮件正文from email.header import Header  # 邮件头# 1、登录邮件服务器smtp_obj &#x3D; smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465)  # 发件⼈邮箱中的SMTP服务器，端⼝是25smtp_obj.login(&quot;xxxxxxxx@qq.com&quot;, &quot;xxxxxxxxxxx&quot;)  # 括号中对应的是发件⼈邮箱账号、授权码# smtp_obj.set_debuglevel(1) # 显示调试信息# 2、构造邮件表格wb &#x3D; load_workbook(&#39;工资信息.xlsx&#39;, data_only&#x3D;True)  # 打开已有excel,data_only表示不转入公式sheet &#x3D; wb.active  # 激活当前sheetcount_col &#x3D; 0for row in sheet.iter_rows(max_row&#x3D;3):    print(count_col)    # 构造表头    if count_col &#x3D;&#x3D; 0:        table_head &#x3D; &#39;&lt;thead&gt;&#39;  # 表头用td        for cell in row:            table_head +&#x3D; f&#39;&lt;th&gt; &#123;cell.value&#125; &lt;&#x2F;th&gt;&#39;        table_head +&#x3D; &#39;&lt;&#x2F;thead&gt;&#39;        count_col +&#x3D; 1        # print(table_head)  # 显示拼接结果        continue  # 表头不发送    # 构造表格中其它行    else:        # print(row[2].value)        name &#x3D; row[2].value  # 将变量name储存用于文件头的收件人        email &#x3D; row[1].value  # 将变量email储存用于填写发送地址        table_row &#x3D; &#39;&lt;tbody&gt;&#39;        for cell in row:            table_row +&#x3D; f&#39;&lt;td&gt; &#123;cell.value&#125; &lt;&#x2F;td&gt;&#39;        table_row +&#x3D; &#39;&lt;&#x2F;tbody&gt;&#39;        # print(table_row)  # 显示拼接结果    # 3、构造邮件正文    msg &#x3D; f&#39;&#39;&#39;    &lt;h5&gt;这是你的工资：&lt;&#x2F;h5&gt;    &lt;table border&#x3D;&quot;1&quot;&gt;        &#123;table_head&#125;        &#123;table_row&#125;    &lt;&#x2F;table&gt;    &#39;&#39;&#39;    # 4、设置邮件头信息    msg &#x3D; MIMEText(msg, &quot;html&quot;, &quot;utf-8&quot;)  # plain表示文件内容为纯文本    msg[&quot;From&quot;] &#x3D; Header(&quot;耿天霸&quot;, &quot;utf-8&quot;)  # 发送者    msg[&quot;To&quot;] &#x3D; Header(f&quot;&#123;name&#125;&quot;, &quot;utf-8&quot;)  # 接收者    msg[&quot;Subject&quot;] &#x3D; Header(&quot;工资单&quot;, &quot;utf-8&quot;)  # 主题    # print(name)    # print(email)    # 5、发送    smtp_obj.sendmail(&quot;xxxxxxxx@qq.com&quot;, email, msg.as_string())    print(f&#39;&#123;name&#125;邮件已发送成功&#39;)    count_col +&#x3D; 1</code></pre><h1 id="实战：批量从1000号员工word简历中调取技能关键词"><a href="#实战：批量从1000号员工word简历中调取技能关键词" class="headerlink" title="实战：批量从1000号员工word简历中调取技能关键词"></a>实战：批量从1000号员工word简历中调取技能关键词</h1><pre class="language-python" data-language="python"><code class="language-python">import osimport docxdef get_ket_words(key_list, file_path):    &#39;&#39;&#39;    :param key_list: 需要调取的技能列表[&#39;Python&#39;, &#39;数据分析&#39;, &#39;英语六级&#39;]    :param file_path:  包含简历文件夹的绝对路径    :return: 返回包含所选关键词的word文档列表[&#39;xxx简历.docx&#39;, &#39;xx简历.docx&#39;]    &#39;&#39;&#39;    words_list &#x3D; []  # 获取路径下所有word文档    file_list &#x3D; os.listdir(file_path)    for file in file_list:        if file[-4:] &#x3D;&#x3D; &#39;docx&#39;:            words_list.append(file)    # print(words_list)    text_dic &#x3D; &#123;        # &#123;word文件路径: &#39;word文字内容&#39;&#125;    &#125;    for word in words_list:        word_name &#x3D; file_path+ &#39;\\&#39; + word        document &#x3D; docx.Document(word_name)        all_paragraphs &#x3D; document.paragraphs        word_text &#x3D; &#39;&#39;        for paragraph in all_paragraphs:            word_text +&#x3D; paragraph.text        text_dic[word_name] &#x3D; word_text    # print(text_dic)    out_list &#x3D; []    for text in text_dic:        for key in key_list:            if key in text_dic[text]:                out_list.append(text)    return out_listfile_path &#x3D; r&#39;C:\Users\Geng\Desktop\我在b站学编程\python\day6\简历&#39;out_list &#x3D; get_ket_words([&#39;Python&#39;, &#39;数据分析&#39;, &#39;英语六级&#39;], file_path)print(out_list)</code></pre><p>※ 目前只能实现纯文本word的读取</p><h1 id="作业：生成1000张名字不同的学员海报"><a href="#作业：生成1000张名字不同的学员海报" class="headerlink" title="作业：生成1000张名字不同的学员海报"></a>作业：生成1000张名字不同的学员海报</h1>]]></content>
      
      
      <categories>
          
          <category> Python零基础到精通7天速成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day5-函数编程</title>
      <link href="/2022/05/11/python-ru-men-dao-jing-tong-5/"/>
      <url>/2022/05/11/python-ru-men-dao-jing-tong-5/</url>
      
        <content type="html"><![CDATA[<h3 id="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"><a href="#本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记" class="headerlink" title="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"></a>本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记</h3><h3 id="视频链接-Python零基础到精通7天速成"><a href="#视频链接-Python零基础到精通7天速成" class="headerlink" title="视频链接:Python零基础到精通7天速成"></a>视频链接:<a href="https://www.bilibili.com/video/BV1Gf4y1q7SG?share_source=copy_web">Python零基础到精通7天速成</a></h3><span id="more"></span><h1 id="一、函数编程的作用"><a href="#一、函数编程的作用" class="headerlink" title="一、函数编程的作用"></a>一、函数编程的作用</h1><h2 id="（一）引子"><a href="#（一）引子" class="headerlink" title="（一）引子"></a>（一）引子</h2><p> &amp;emsp;你是⼀家公司的IT运维⼈员， 现在⽼板让你写⼀个监控程序<br>1、24⼩时全年⽆休的监控你们公司⽹站服务器的系统状况<br>2、当cpu＼memory＼disk等指标的使⽤量超过阀值时即发邮件报警</p><h4>你掏空了所有的知识量，写出了以下代码</h4><pre class="language-python" data-language="python"><code class="language-python">while True：    if cpu利⽤率 &gt; 90%:    #发送邮件提醒    连接邮箱服务器    发送邮件    关闭连接    if 硬盘使⽤空间 &gt; 90%:    #发送邮件提醒    连接邮箱服务器    发送邮件    关闭连接    if 内存占⽤ &gt; 80%:    #发送邮件提醒    连接邮箱服务器    发送邮件    关闭连接</code></pre><h4 id="此代码有以下问题"><a href="#此代码有以下问题" class="headerlink" title="此代码有以下问题"></a>此代码有以下问题</h4><p>1、代码重复过多，⼀个劲的copy and paste不符合⾼端程序员的⽓质<br>2、如果⽇后需要修改发邮件的这段代码，⽐如加⼊群发功能，那你就需要在所有⽤到这段代码的地⽅都修改⼀遍</p><h4 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h4><p> &amp;emsp;只需要把重复的代码提取出来，放在⼀个公共的地⽅，起个名字，以后<br>谁想⽤这段代码，就通过这个名字调⽤就⾏了，如下</p><pre class="language-python" data-language="python"><code class="language-python">def 发送邮件(内容) #发送邮件提醒 连接邮箱服务器 发送邮件 关闭连接while True：    if cpu利⽤率 &gt; 90%:    发送邮件(&#39;CPU报警&#39;)    if 硬盘使⽤空间 &gt; 90%:    发送邮件(&#39;硬盘报警&#39;)    if 内存占⽤ &gt; 80%:    发送邮件(&#39;内存报警&#39;)</code></pre><h1 id="二、语法定义-amp-特性"><a href="#二、语法定义-amp-特性" class="headerlink" title="二、语法定义&amp;特性"></a>二、语法定义&amp;特性</h1><h2 id="（一）函数是什么"><a href="#（一）函数是什么" class="headerlink" title="（一）函数是什么"></a>（一）函数是什么</h2><p> &amp;emsp;函数⼀词来源于数学，但编程中的「函数」概念，与数学中的函数是有很⼤不同的，具体区别，我们后⾯会讲，编程中的函数在英⽂中也有很多不同的叫法。在BASIC中叫做subroutine(⼦过程或⼦程序)，在C中只有function，在Java⾥⾯叫做method</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><p> &amp;emsp;<font color="#dd0000"><strong>函数是指将⼀组语句的集合通过⼀个名字(函数名)封装起来，要想执⾏这个函数，只需调⽤其函数名即可</strong></font></p><h4 id="特性"><a href="#特性" class="headerlink" title="特性:"></a>特性:</h4><p><font color="#dd0000"><strong>1. 减少重复代码<br>2. 使程序变的可扩展<br>3. 使程序变得易维护</strong></font></p><h2 id="（二）语法定义"><a href="#（二）语法定义" class="headerlink" title="（二）语法定义"></a>（二）语法定义</h2><pre class="language-python" data-language="python"><code class="language-python">def sayhi():#函数名    print(&quot;Hello, I&#39;m nobody!&quot;)sayhi() #调⽤函数# 可以带参数def calc(x,y):    res &#x3D; x**y    print(res) #函数执⾏结果calc(5,22)</code></pre><h1 id="三、各种参数"><a href="#三、各种参数" class="headerlink" title="三、各种参数"></a>三、各种参数</h1><h2 id="（一）形参和实参"><a href="#（一）形参和实参" class="headerlink" title="（一）形参和实参"></a>（一）形参和实参</h2><h4 id="形参–用于函数定义"><a href="#形参–用于函数定义" class="headerlink" title="形参–用于函数定义"></a>形参–用于函数定义</h4><p> &amp;emsp;只有在被调⽤时才分配内存单元，在调⽤结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效。函数调⽤结束返回主调⽤程序代码后则不能再使⽤该形参变量</p><h4 id="实参–用于函数调用"><a href="#实参–用于函数调用" class="headerlink" title="实参–用于函数调用"></a>实参–用于函数调用</h4><p> &amp;emsp;可以是变量、任意数据类型、表达式、函数等，⽆论实参是何种类型的量，在进⾏函数调⽤时，它们都必须有确定的值，以便把这些值传送给形参。因此应预先给实参赋值</p><div align=center><img src="https://img-blog.csdnimg.cn/0175ff49fe5841858cdf4722d3fa8e0d.png" width = 50%></div><h2 id="（二）默认参数–用于函数定义"><a href="#（二）默认参数–用于函数定义" class="headerlink" title="（二）默认参数–用于函数定义"></a>（二）默认参数–用于函数定义</h2><p>看如下代码</p><pre class="language-python" data-language="python"><code class="language-python">def stu_register(name,age,country,course): print(&quot;----注册学⽣信息------&quot;) print(&quot;姓名:&quot;,name) print(&quot;age:&quot;,age) print(&quot;国籍:&quot;,country) print(&quot;课程:&quot;,course)stu_register(&quot;王⼭炮&quot;,22,&quot;CN&quot;,&quot;python_devops&quot;)stu_register(&quot;张叫春&quot;,21,&quot;CN&quot;,&quot;linux&quot;)stu_register(&quot;刘⽼根&quot;,25,&quot;CN&quot;,&quot;linux&quot;)</code></pre><p> &amp;emsp;发现 country 这个参数 基本都 是”CN”, 就像我们在⽹站上注册⽤户，像国籍这种信息，你不填写，默认就会是 中国， 这就是通过默认参数实现的，把country变成默认参数⾮常简单</p><pre class="language-python" data-language="python"><code class="language-python">def stu_register(name,age,course,country&#x3D;&quot;CN&quot;):</code></pre><h4 id="那调⽤时"><a href="#那调⽤时" class="headerlink" title="那调⽤时"></a>那调⽤时</h4><pre class="language-python" data-language="python"><code class="language-python">stu_register(&quot;Mack&quot;,22,&quot;Python&quot;,&quot;US&quot;)</code></pre><p> &amp;emsp;你告诉我，第3个参数 python 到底应该给到country还是course呢？ ⽆论给哪个，都会出现歧义，所以<font color="#dd0000"><strong>Python语法⼲脆就让你把默认参数放最后， 解释器在处理函数时参数时，按优先级，位置参数&gt;默认参数</strong></font></p><h2 id="（三）关键字参数–用于函数调用"><a href="#（三）关键字参数–用于函数调用" class="headerlink" title="（三）关键字参数–用于函数调用"></a>（三）关键字参数–用于函数调用</h2><p> &amp;emsp;正常情况下，给函数传参数要按顺序，不想按顺序就可以⽤关键参数，只需指定参数名即可(指定了参数名的参数就叫关键参数)，<font color="#dd0000"><strong>但记住⼀个要求就是，关键参数必须放在位置参数(以位置顺序确定对应关系的参数)之后</strong></font></p><pre class="language-python" data-language="python"><code class="language-python">def stu_register(name, age, course&#x3D;&#39;PY&#39; ,country&#x3D;&#39;CN&#39;):    print(&quot;----注册学⽣信息------&quot;)    print(&quot;姓名:&quot;, name)    print(&quot;age:&quot;, age)    print(&quot;国籍:&quot;, country)    print(&quot;课程:&quot;, course)</code></pre><h4 id="调用时可以这样"><a href="#调用时可以这样" class="headerlink" title="调用时可以这样"></a>调用时可以这样</h4><pre class="language-python" data-language="python"><code class="language-python"># 输入玩位置参数后，再输入关键字参数关键字参数可以不按照定义顺序输入stu_register(&quot;王⼭炮&quot;,course&#x3D;&#39;PY&#39;, age&#x3D;22,country&#x3D;&#39;JP&#39; )</code></pre><h4 id="但不能这样"><a href="#但不能这样" class="headerlink" title="但不能这样"></a>但不能这样</h4><pre class="language-python" data-language="python"><code class="language-python"># corse关键字参数传在位置参数22之前stu_register(&quot;王⼭炮&quot;,course&#x3D;&#39;PY&#39;,22,country&#x3D;&#39;JP&#39; )</code></pre><h2 id="（四）非固定参数–用于函数调用"><a href="#（四）非固定参数–用于函数调用" class="headerlink" title="（四）非固定参数–用于函数调用"></a>（四）非固定参数–用于函数调用</h2><p> &amp;emsp;若你的函数在定义时不确定⽤户想传⼊多少个参数，就可以使⽤⾮固定参数</p><pre class="language-python" data-language="python"><code class="language-python">def stu_register(name,age,*args): # *args 会把多传⼊的参数变成⼀个元组形式    print(name,age,args)stu_register(&quot;Alex&quot;,22)#输出#Alex 22 () #后⾯这个()就是args,只是因为没传值,所以为空stu_register(&quot;Jack&quot;,32,&quot;CN&quot;,&quot;Python&quot;)#输出# Jack 32 (&#39;CN&#39;, &#39;Python&#39;)</code></pre><h4 id="还可以有⼀个-kwargs"><a href="#还可以有⼀个-kwargs" class="headerlink" title="还可以有⼀个 **kwargs"></a>还可以有⼀个 **kwargs</h4><pre class="language-python" data-language="python"><code class="language-python">def stu_register(name,age,*args,**kwargs): # **kwargs 会把多传⼊的参数变成⼀个dict形式    print(name,age,args,kwargs)stu_register(&quot;Alex&quot;,22)#输出#Alex 22 () &#123;&#125;#后⾯这个&#123;&#125;就是kwargs,只是因为没传值,所以为空stu_register(&quot;Jack&quot;,32,&quot;CN&quot;,&quot;Python&quot;,sex&#x3D;&quot;Male&quot;,province&#x3D;&quot;ShanDong&quot;)#输出# Jack 32 (&#39;CN&#39;, &#39;Python&#39;) &#123;&#39;province&#39;: &#39;ShanDong&#39;, &#39;sex&#39;: &#39;Male&#39;&#125;</code></pre><h2 id="（四）练习题"><a href="#（四）练习题" class="headerlink" title="（四）练习题"></a>（四）练习题</h2><p> &amp;emsp;根据下图所示，对print_info⾥的代码进⾏实现</p><div align=center><img src="https://img-blog.csdnimg.cn/6e3edba743d9473eb36f6714d78d7cac.png" width = 80%></div><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="language-python" data-language="python"><code class="language-python">def print_info(name, age, sex, hobby&#x3D;&#39;学习&#39;):    print(&#39;info&#39;.center(25, &#39;-&#39;))    print(f&#39;name: &#123;name&#125;&#39;)    print(f&#39;Age: &#123;age&#125;&#39;)    print(f&#39;Sex: &#123;sex&#125;&#39;)    print(f&#39;hobby: &#123;hobby&#125;&#39;)print_info(name&#x3D;&#39;Alex&#39;, age&#x3D;22, sex&#x3D;&#39;M&#39;)print_info(name&#x3D;&#39;Jack&#39;, age&#x3D;22, sex&#x3D;&#39;M&#39;, hobby&#x3D;&#39;运动&#39;)</code></pre><h1 id="四、函数返回值可以干啥"><a href="#四、函数返回值可以干啥" class="headerlink" title="四、函数返回值可以干啥"></a>四、函数返回值可以干啥</h1><p> &amp;emsp;函数外部的代码要想获取函数的执⾏结果，就可以在函数⾥⽤return语句把结果返回</p><pre class="language-python" data-language="python"><code class="language-python">def stu_register(name, age, course&#x3D;&#39;PY&#39; ,country&#x3D;&#39;CN&#39;):    print(&quot;----注册学⽣信息------&quot;)    print(&quot;姓名:&quot;, name)    print(&quot;age:&quot;, age)    print(&quot;国籍:&quot;, country)    print(&quot;课程:&quot;, course)    if age &gt; 22:    return False    else:    return True  # 1、返回执行结果，多个返回值使用元组进行封装                 # 2、程序执行，一遇到return，就代表函数的结束registriation_status &#x3D; stu_register(&quot;王⼭炮&quot;,22,course&#x3D;&quot;PY全栈开发&quot;,country&#x3D;&#39;JP&#39;)if registriation_status:    print(&quot;注册成功&quot;)else:    print(&quot;too old to be a student.&quot;)</code></pre><h1 id="五、局部变量-amp-全局变量"><a href="#五、局部变量-amp-全局变量" class="headerlink" title="五、局部变量&amp;全局变量"></a>五、局部变量&amp;全局变量</h1><h4 id="看如下代码"><a href="#看如下代码" class="headerlink" title="看如下代码"></a>看如下代码</h4><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;Alex Li&quot;def change_name(): name &#x3D; &quot;⾦⻆⼤王, ⼀个有Tesla的⾼级屌丝&quot; print(&quot;after change&quot;, name)change_name()print(&quot;在外⾯看看name改了么?&quot;,name)</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt;after change ⾦⻆⼤王,⼀个有Tesla的⾼级屌丝&gt;&gt;&gt;在外⾯看看name改了么? Alex Li</code></pre><p> &amp;emsp;为什么在函数内部改了name的值后， 在外⾯print()的时候却没有改呢？因为这两个name根本不是⼀回事<br><strong>※</strong>在函数中定义的变量称为局部变量，在程序的⼀开始定义的变量称为全局变量<br><strong>※</strong>全局变量作⽤域(即有效范围)是整个程序，局部变量作⽤域是定义该变量的函数<br><strong>※</strong>变量的查找顺序是<strong>局部变量&gt;全局变量</strong><br><strong>※</strong>当全局变量与局部变量同名时，在定义局部变量的函数内，局部变量起作⽤；在其它地⽅全局变量起作⽤。<br><strong>※</strong>在函数⾥是不能直接修改全局变量的</p><h4 id="就是想在函数⾥修改全局变量怎么办？"><a href="#就是想在函数⾥修改全局变量怎么办？" class="headerlink" title="就是想在函数⾥修改全局变量怎么办？"></a>就是想在函数⾥修改全局变量怎么办？</h4><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &quot;Alex Li&quot;def change_name():    global name #声明⼀个全局变量    name &#x3D; &quot;Alex ⼜名⾦⻆⼤王,爱⽣活、爱⾃由、爱姑娘&quot;    print(&quot;after change&quot;, name)change_name()print(&quot;在外⾯看看name改了么?&quot;, name)</code></pre><p> &amp;emsp; <strong>global name的作⽤就是要在函数⾥声明全局变量name ，意味着最上⾯的 name &#x3D; “Alex Li” 即使不写，程序最后⾯的print也可以打印name</strong><br> &amp;emsp;<font color="#dd0000">虽然可以改，但不建议⽤这个global语法，随着代码增多 ，会造成代码调试困难</font></p><h4 id="传递列表、字典产⽣的现象"><a href="#传递列表、字典产⽣的现象" class="headerlink" title="传递列表、字典产⽣的现象"></a>传递列表、字典产⽣的现象</h4><pre class="language-python" data-language="python"><code class="language-python">d &#x3D; &#123;&quot;name&quot;:&quot;Alex&quot;,&quot;age&quot;:26,&quot;hobbie&quot;:&quot;健身&quot;&#125;l &#x3D; [&quot;Rebeeca&quot;,&quot;Katrina&quot;,&quot;Rachel&quot;]def change_data(info,girls):    info[&quot;hobbie&quot;] &#x3D; &quot;学习&quot;    girls.append(&quot;XiaoYun&quot;)change_data(d,l)print(d,l)</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><pre class="language-python" data-language="python"><code class="language-python">&#123;‘name’: ‘Alex’, ‘age’: 26, ‘hobbie’: ‘学习’&#125;[‘Rebeeca’, ‘Katrina’, ‘Rachel’, ‘XiaoYun’]</code></pre><p> &amp;emsp;不是说不能在函数⾥改全局变量么，怎么改了呀？</p><p> &amp;emsp;字典，列表，集合等数据类型该数据类型本身（鱼缸）和里面的各元素（鱼），都是单独在内存中进行存放，鱼缸是一个地址，每条鱼有各自的地址</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; d &#x3D; &#123;&quot;name&quot;:&quot;Alex&quot;,&quot;age&quot;:26,&quot;hobbie&quot;:&quot;健身&quot;&#125;&gt;&gt;&gt; print(id(d))&gt;&gt;&gt; for k in d.keys():...     print(k,d[k])...     print(id(k), id(d[k]))...1714053591680name Alex1714015535408 1714053616240age 261714053616880 1714015333456hobbie ⼤保健1714053616752 1714053350192</code></pre><div align=center><img src="https://img-blog.csdnimg.cn/cdb48ad4dba84023901cb223e8a66807.png" width = 80%></div> &emsp;根据上图我们能看出， 程序只是把d这个dict的内存地址传给了change_data函数，把dict⽐作⻥缸，⾥⾯的k,v⽐作缸⾥装的⻥。现在只是把⻥缸丢给了函数，这个⻥缸本身你不能改，但是⾥⾯的⻥可以。相当于只是传了⼀个对这个d的引⽤关系给到函数的形参。这样是为了减少内存的浪费，因为如果这个dict⽐较⼤，传⼀次到函数⾥就要copy⼀份新的值的话，效率太低了。<h1 id="六、内置函数"><a href="#六、内置函数" class="headerlink" title="六、内置函数"></a>六、内置函数</h1><p> &amp;emsp;python解释器自带的函数</p><div align=center><img src="https://img-blog.csdnimg.cn/553be5a077b340b09de60538357d5c52.png" width = 80%></div>1. abs # 求绝对值2. all # 里面的元素全为真返回真3. any # 里面的元素任意为真返回真   <pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3]&gt;&gt;&gt; all(a)False&gt;&gt;&gt; any(a)True</code></pre><ol start="4"><li>ascii # 返回字符的ascii码<pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; ascii(&#39;中国&#39;)&quot;&#39;\\u4e2d\\u56fd&#39;&quot;</code></pre></li><li>bin # 返回整数的2进制格式</li><li>bool # 判断⼀个数据结构是True or False</li><li>bytearray # 把byte变成 bytearray, 可修改的数组</li><li>bytes # bytes(“中国”,”gbk”)</li><li>callable # 判断⼀个对象是否可调⽤</li><li>chr # 返回⼀个数字对应的ascii字符 ， ⽐如chr(90)返回ascii⾥的’Z’</li><li>classmethod # ⾯向对象时⽤，现在忽略</li><li>compile # py解释器⾃⼰⽤的东⻄，忽略</li><li>complex # 求复数，⼀般⼈⽤不到</li><li>copyright # 没⽤</li><li>credits # 没⽤</li><li>chr # 返回ascii码中对于编号的字符<pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; chr(97)&#39;a&#39;</code></pre></li><li>delattr # ⾯向对象时⽤，现在忽略</li><li>dict # ⽣成⼀个空dict</li><li>dir # 以列表的形式返回当前作用域所有变量名</li></ol><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; a &#x3D; &#39;name&#39;&gt;&gt;&gt; b &#x3D; 22&gt;&gt;&gt; print(dir())[&#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;a&#39;, &#39;b&#39;]</code></pre><ol start="19"><li>divmod #返回除法的商和余数 ，⽐如divmod(4,2)，结果(2, 0)</li><li>enumerate # 返回列表的索引和元素<pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; numbers &#x3D; list(range(10, 0, -1))&gt;&gt;&gt; for i, j in enumerate(numbers):...     print(i, j)...0 101 92 83 74 65 56 47 38 29 1</code></pre></li><li>eval # 可以把字符串形式的list,dict,set,tuple,再转换成其原有的数据类型。</li><li>exec # 把字符串格式的代码，进⾏解义并执⾏，⽐如exec(“print(‘hellworld’)”)，会解义⾥⾯的字符<br>串并执⾏</li><li>exit # 退出程序</li><li>filter # 对list、dict、set、tuple等可迭代对象进⾏过滤<pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; numbers &#x3D; list(range(10))&gt;&gt;&gt; for number in filter(lambda x: x &gt; 5, numbers):...     print(number)...6789</code></pre></li><li>float # 转成浮点</li><li>format # 没⽤</li><li>frozenset # 把⼀个集合变成不可修改的</li><li>getattr # ⾯向对象时⽤，现在忽略</li><li>globals # 打印全局作⽤域⾥的值</li><li>hasattr # ⾯向对象时⽤，现在忽略</li><li>hash # hash函数</li><li>help</li><li>hex # 返回⼀个10进制的16进制表示形式,hex(10) 返回’0xa’</li><li>id # 查看对象内存地址</li><li>input</li><li>int</li><li>isinstance # 判断⼀个数据结构的类型，⽐如判断a是不是fronzenset, isinstance(a,frozenset) 返<br>回 True or False</li><li>issubclass # ⾯向对象时⽤，现在忽略</li><li>iter # 把⼀个数据结构变成迭代器，讲了迭代器就明⽩了</li><li>len</li><li>list</li><li>locals # 以字典的形式返回当前作用域所有变量名和变量值<pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; a &#x3D; &#39;name&#39;&gt;&gt;&gt; b &#x3D; 22&gt;&gt;&gt; print(dir())&#123;&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: &#123;&#125;, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;a&#39;: &#39;name&#39;, &#39;b&#39;: 22&#125;</code></pre></li><li>map # 输入函数和可迭代的对象，返回可迭代对象基于函数的计算结果<pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; numbers &#x3D; list(range(10))&gt;&gt;&gt; for number in map(lambda x: x**2, numbers):...     print(number)0149162536496481</code></pre></li><li>max # 求最⼤值</li><li>memoryview # ⼀般⼈不⽤，忽略</li><li>min # 求最⼩值</li><li>next # ⽣成器会⽤到，现在忽略</li><li>object # ⾯向对象时⽤，现在忽略</li><li>oct # 返回10进制数的8进制表示</li><li>open</li><li>ord # 传入ascii码字符，返回对应的10进制数<pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; ord(&#39;a&#39;)97</code></pre></li><li>print</li><li>property # ⾯向对象时⽤，现在忽略</li><li>quit</li><li>range</li><li>repr # 没什么⽤</li><li>reversed # 可以把⼀个列表反转</li><li>round # 4舍5⼊保留任意位数小数<pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; # 保留两位小数&gt;&gt;&gt; round(3.1415, 2)3.14</code></pre></li><li>set</li><li>setattr # ⾯向对象时⽤，现在忽略</li><li>slice # 没⽤</li><li>sorted</li><li>staticmethod #⾯向对象时⽤，现在忽略</li><li>str # 转换为字符串</li><li>sum # 求和</li><li>super # ⾯向对象时⽤，现在忽略</li><li>tuple # 转换为元组</li><li>type # 查看数据类型</li><li>vars # 返回⼀个对象的属性，⾯向对象时就明⽩了</li><li>zip #可以把2个或多个列表拼成⼀个，<pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; a &#x3D; [1, 5, 10, 12, 22]&gt;&gt;&gt; b &#x3D; [&#39;苹果&#39;, &#39;香蕉&#39;, &#39;梨&#39;]&gt;&gt;&gt; print(list(zip(a, b)))  # 返回的结果为一个对象，此处用list()进行打印[(1, &#39;苹果&#39;), (5, &#39;香蕉&#39;), (10, &#39;梨&#39;)]</code></pre><h1 id="七、学籍注册小程序"><a href="#七、学籍注册小程序" class="headerlink" title="七、学籍注册小程序"></a>七、学籍注册小程序</h1><h2 id="（一）需求"><a href="#（一）需求" class="headerlink" title="（一）需求"></a>（一）需求</h2></li><li>要求⽤户输⼊姓名、年龄、⼿机号、身份证号、所选课程，然后为学员完成注册</li><li>⼿机号、身份证号唯⼀</li><li>可选的课程只能从Python、Linux、⽹络安全、前端、数据分析这⼏⻔⾥选</li><li>学员信息存⼊⽂件<h2 id="（二）代码"><a href="#（二）代码" class="headerlink" title="（二）代码"></a>（二）代码</h2><pre class="language-python" data-language="python"><code class="language-python"># 提前创建&#39;student_data.db&#39;文件db_file &#x3D; &#39;student_data.db&#39;def register_api():    student_info &#x3D; []    # 接收用户名    user_name &#x3D; input(&#39;please input your name: &#39;).strip()    # 接收用户年龄    user_age &#x3D; input(&#39;please input your age: &#39;).strip()    # 接收用户手机号    user_phone &#x3D; input(&#39;please input your phone number: &#39;).strip()    if user_phone in phone_list:        exit(&#39;your phone number is registered&#39;)    # 接收用户身份证    user_id &#x3D; input(&#39;please input your ID number: &#39;).strip()    if user_id in id_list:        exit(&#39;your id number is registered&#39;)    # 接收用户所选课程    course_list &#x3D; [&#39;Python&#39;, &#39;Linux&#39;, &#39;⽹络安全&#39;, &#39;前端&#39;, &#39;数据分析&#39;]    print(&#39;我们开设的课程有：&#39;)    for i in range(len(course_list)):        print(f&#39;&#123;i&#125;: &#123;course_list[i]&#125;&#39;)    course_index &#x3D; input(f&#39;please input a number to choice a course: &#39;)    if int(course_index) in range(len(course_list)):        user_course &#x3D; course_list[int(course_index)]    else:        exit(&#39;choice number out of range&#39;)    student_info.append(user_name)    student_info.append(user_age)    student_info.append(user_phone)    student_info.append(user_id)    student_info.append(user_course)    print(&#39;恭喜你完成注册&#39;.center(50, &#39;-&#39;))    return student_infodef info_save(filename, student_list):    file &#x3D; open(filename, mode&#x3D;&#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;)    for info in student_list:        file.write(info + &#39; &#39;)    file.write(&#39;\n&#39;)    file.close()# 取出所有手机号和身份证号def get_data(filename):    phone_list &#x3D; []    id_list &#x3D; []    file &#x3D; open(filename, encoding&#x3D;&#39;utf-8&#39;)    for line in file:        student_list &#x3D; line.strip().split(&#39; &#39;)        phone_list.append(student_list[2])        id_list.append(student_list[3])    return phone_list, id_listwhile True:    user_input &#x3D; input(&#39;按下任意键进行学籍注册，如果退出请按e:&#39;)    if user_input &#x3D;&#x3D; &#39;e&#39;:        exit()    else:        phone_list, id_list &#x3D; get_data(db_file)        student_list &#x3D; register_api()        info_save(db_file, student_list)</code></pre><h1 id="八、扎金花棋牌游戏"><a href="#八、扎金花棋牌游戏" class="headerlink" title="八、扎金花棋牌游戏"></a>八、扎金花棋牌游戏</h1><h2 id="（一）需求-1"><a href="#（一）需求-1" class="headerlink" title="（一）需求"></a>（一）需求</h2>1、允许用户一次性输入多名玩家姓名，不限个数，然后为每个玩家随机产生三张牌<br>2、你只有一副扑克牌，确保发出去的每张牌不重样<br>3、牌需要有黑桃，红桃，方片，梅花之分</li></ol><h4 id="最终输出"><a href="#最终输出" class="headerlink" title="最终输出"></a>最终输出</h4><pre class="language-python" data-language="python"><code class="language-python">&#123;&#39;Alex&#39;: [[&#39;红桃&#39;, 7], [&#39;梅花&#39;, 5], [&#39;梅花&#39;, K]], &#39;Jack&#39;: [[&#39;梅花&#39;, 5], [&#39;红桃&#39;, 5], [&#39;黑桃&#39;, 8]]&#125;</code></pre><h2 id="（二）代码-1"><a href="#（二）代码-1" class="headerlink" title="（二）代码"></a>（二）代码</h2><pre class="language-python" data-language="python"><code class="language-python">import stringimport random# 传入序号和图案生成一副扑克牌def create_cards(pattern_list, serial_list):    &quot;&quot;&quot;    :param pattern_list: [&#39;黑桃&#39;, &#39;红桃&#39;, &#39;梅花&#39;, &#39;方片&#39;]    :param serial_list: [1, 2, ..., K, A]    :return:包含所有卡牌的列表    &quot;&quot;&quot;    cards_list &#x3D; []    for serial in serial_list:        for pattern in pattern_list:            card &#x3D; []            card.append(pattern)            card.append(serial)            cards_list.append(card)    return cards_listserial_list &#x3D; list(string.digits[1:] + &#39;JQKA&#39;)all_cards &#x3D; create_cards([&#39;黑桃&#39;, &#39;红桃&#39;, &#39;梅花&#39;, &#39;方片&#39;], serial_list)def play_cards(player_list):    player_dic &#x3D; &#123;&#125;    &quot;&quot;&quot;    :param player: [&#39;Alex&#39;, &#39;Jack&#39;, ...]  输入列表，包含每个玩家的姓名    :return: &#123;&#39;Alex&#39;: [[&#39;红桃&#39;, 7], [&#39;梅花&#39;, 5], [&#39;梅花&#39;, K]], &#39;Jack&#39;: [[&#39;梅花&#39;, 5], [&#39;红桃&#39;, 5], [&#39;黑桃&#39;, 8]]。。。&#125;    &quot;&quot;&quot;    for player in player_list:        get_cards &#x3D; random.sample(all_cards, 3)        for get_card in get_cards:            all_cards.remove(get_card)        player_dic[player] &#x3D; list(get_cards)    return player_dicresult &#x3D; play_cards([&#39;Alex&#39;, &#39;Jack&#39;, &#39;GY&#39;, &#39;LT&#39;])print(result)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python零基础到精通7天速成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day4-用Python批量处理文件</title>
      <link href="/2022/05/08/python-ru-men-dao-jing-tong-4/"/>
      <url>/2022/05/08/python-ru-men-dao-jing-tong-4/</url>
      
        <content type="html"><![CDATA[<h3 id="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"><a href="#本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记" class="headerlink" title="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"></a>本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记</h3><h3 id="视频链接-Python零基础到精通7天速成"><a href="#视频链接-Python零基础到精通7天速成" class="headerlink" title="视频链接:Python零基础到精通7天速成"></a>视频链接:<a href="https://www.bilibili.com/video/BV1Gf4y1q7SG?share_source=copy_web">Python零基础到精通7天速成</a></h3><span id="more"></span><h1 id="一、文件操作"><a href="#一、文件操作" class="headerlink" title="一、文件操作"></a>一、文件操作</h1><h2 id="（一）文件操作流程"><a href="#（一）文件操作流程" class="headerlink" title="（一）文件操作流程"></a>（一）文件操作流程</h2><h4 id="用word操作一个文件的流程如下"><a href="#用word操作一个文件的流程如下" class="headerlink" title="用word操作一个文件的流程如下:"></a>用word操作一个文件的流程如下:</h4><p>1．找到文件，双击打开<br>2. 读或修改<br>3．保存&amp;关闭</p><h4 id="用pythqn操作文件也差不多"><a href="#用pythqn操作文件也差不多" class="headerlink" title="用pythqn操作文件也差不多:"></a>用pythqn操作文件也差不多:</h4><pre class="language-python" data-language="python"><code class="language-python">f &#x3D; open(&#39;filename&#39;)  # 打开文件f.write(&#39;我是野生程序员&#39;)  # 写操作f.read()  # 读操作f.close()  # 保持并关闭</code></pre><p> &amp;emsp;不过有一点跟人肉操作word文档不同，就是word文档只要打开了，就即可以读、又可以修改。但Python只能以读、创建、追加3种模式中的任意一种打开文件，不能即写又读。</p><h4 id="文件打开模式-文本模式"><a href="#文件打开模式-文本模式" class="headerlink" title="文件打开模式(文本模式)"></a>文件打开模式(文本模式)</h4><p>1、r只读模式<br>2、w创建模式，若文件已存在，则覆盖旧文件<br>3、a追加模式，新数据会写到文件末尾</p><h2 id="（二）创建、只读、追加"><a href="#（二）创建、只读、追加" class="headerlink" title="（二）创建、只读、追加"></a>（二）创建、只读、追加</h2><h4 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h4><pre class="language-python" data-language="python"><code class="language-python"># 以写入模式打开file &#x3D; open(&#39;name_list&#39;, mode&#x3D;&#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;)  # ctrl+左键点击open，可以查看函数参数列表  # ctrl+左键点击open，可以查看函数参数列表file.write(&#39;张三\n&#39;)file.write(&#39;李四\n&#39;)file.write(&#39;王五\n&#39;)file.encoding(&#39;UTF-8&#39;)file.close()</code></pre><h4 id="2、只读"><a href="#2、只读" class="headerlink" title="2、只读"></a>2、只读</h4><pre class="language-python" data-language="python"><code class="language-python"># 以只读模式打开file &#x3D; open(&#39;name_list&#39;, mode&#x3D;&#39;r&#39;)  print(file.read())print(&#39;--------------------------&#39;)file &#x3D; open(&#39;name_list&#39;, mode&#x3D;&#39;r&#39;)  # read后光标会移到文本最后一行，需要重新打开文本才能在此readprint(file.readline())</code></pre><h4 id="3、追加"><a href="#3、追加" class="headerlink" title="3、追加"></a>3、追加</h4><pre class="language-python" data-language="python"><code class="language-python"># 以追加模式打开file &#x3D; open(&#39;name_list&#39;, mode&#x3D;&#39;a&#39;)file.write(&#39;耿天霸\n&#39;)file.close()</code></pre><h4 id="4、其它功能"><a href="#4、其它功能" class="headerlink" title="4、其它功能"></a>4、其它功能</h4><pre class="language-python" data-language="python"><code class="language-python">def seek (self, *args,**kwargs ) : &#39;&#39;&#39; 把操作文件的光标移到指定位置*注意seek的长度是按字节算的，字符编码存每个字符所占的字节长度不一样。如&quot;路飞学城”用gbk存是2个字节一个字，用utf-8就是3个字节，因此以gbk打开时, seek（4）就把光标切换到了“飞”和“学”两个字中间。&#39;&#39;&#39;def tell(self, *args,* *kwargs ) : # 返回当前文件操作光标位置def flush( self, *args,**kwargs ) : # 把文件从内存buffer里强制刷新到硬盘&#39;&#39;&#39;正常情况下write命令将数据导入到内存的缓存（buffer）中，当缓存满了再一并写入内存，但当断电时内存中数据（包括buffer）会丢失（因为还没写入硬盘），因此通过flush命令可以不用将数据导入到buffer而直接写入硬盘（应用于不能丢失的重要数据）&#39;&#39;&#39;# 示例file &#x3D; open(&#39;name_list&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;)file.seek(3)print(file.readline())  # output:三file &#x3D; open(&#39;name_list2&#39;, mode&#x3D;&#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;)file.write(&#39;王二\n&#39;)print(file.tell())file.write(&#39;张三\n&#39;)print(file.tell())file.write(&#39;李四\n&#39;)print(file.tell())file.seek(8)file.write(&#39;王五&#39;)file.close()  # output:# 王二# 王五# 李四# 不输入flie.flush 运行write后没有任何结果&gt;&gt;&gt; flie &#x3D; open(&#39;file_flush&#39;, &#39;w&#39;, encoding &#x3D; &#39;utf-8&#39;)&gt;&gt;&gt; flie.write(&#39;张三\n&#39;)3&gt;&gt;&gt; flie.write(&#39;李四\n&#39;)3&gt;&gt;&gt; flie.flush()  &#39;&#39;&#39;output: 张三        李四&#39;&#39;&#39;</code></pre><h2 id="（三）遍历文件"><a href="#（三）遍历文件" class="headerlink" title="（三）遍历文件"></a>（三）遍历文件</h2><h4 id="1、数据源"><a href="#1、数据源" class="headerlink" title="1、数据源"></a>1、数据源</h4><pre class="language-python" data-language="python"><code class="language-python">1． 马纤羽  深圳  173  50  137442345232.  乔亦菲  广州  172  52  158234235253． 罗梦竹  北京  175  49  186234234214． 刘诺涵  北京  170  48  186234237655． 岳妮妮  深圳  177  54  188353245536． 贺婉置  深圳  174  52  189334344527． 叶梓    上海  171  49  18042432324</code></pre><h4 id="2、任务"><a href="#2、任务" class="headerlink" title="2、任务"></a>2、任务</h4><p> &amp;emsp;遍历文件并找出身高大于170，体重低于50的人</p><h4 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h4><pre class="language-python" data-language="python"><code class="language-python"># 以追加模式打开file &#x3D; open(&#39;data_sourse&#39;, encoding&#x3D;&#39;utf-8&#39;)  # encoding参数，告诉python源文件的编码格式，否则python会用GBK进行解码，并报错！！！# 以列表打印出源文件，每一行为一个元素，# print(file.readlines())  # 可以看到：元素的末尾都有换行符，当文件中出现多的换行符元素是，在遍历是会报错# 循环每一行for row in file.readlines():    # print(row, end&#x3D;&#39;&#39;)  # 每一行自带换行符，使用不需要print()再在结尾加换行符    row_list &#x3D; row.split()  # 将字符串row存成列表row_list，分隔符使用空格    # print(row_list)    height &#x3D; int(row_list[3])    weight &#x3D; int(row_list[4])    if height &gt;&#x3D; 170 and weight &lt;&#x3D; 50:        print(row, end&#x3D;&#39;&#39;)</code></pre><h2 id="（四）2进制模式"><a href="#（四）2进制模式" class="headerlink" title="（四）2进制模式"></a>（四）2进制模式</h2><h4 id="1、如何处理图⽚、视频⽂件呢？"><a href="#1、如何处理图⽚、视频⽂件呢？" class="headerlink" title="1、如何处理图⽚、视频⽂件呢？"></a>1、如何处理图⽚、视频⽂件呢？</h4><p> &amp;emsp;图⽚、视频，是有⾃⼰特殊的编码的，⽽⾮什么unicode\utf-8这样的⽂本编码 。 所以要操作这样的⽂件 ，你⽤utf-8什么的去解，会报错。</p><h4 id="2、可以⽤2进制模式打开⽂件"><a href="#2、可以⽤2进制模式打开⽂件" class="headerlink" title="2、可以⽤2进制模式打开⽂件"></a>2、可以⽤2进制模式打开⽂件</h4><p>（1）<strong>rb</strong> 2进制只读模式<br>（2）<strong>wb</strong> 2进制创建模式，若⽂件已存在，则覆盖旧⽂件<br>（3）<strong>ab</strong> 2进制追加模式，新数据会写到⽂件末尾</p><h4 id="3、代码实例"><a href="#3、代码实例" class="headerlink" title="3、代码实例"></a>3、代码实例</h4><h4 id="（1）读取二进制文件"><a href="#（1）读取二进制文件" class="headerlink" title="（1）读取二进制文件"></a>（1）读取二进制文件</h4><pre class="language-python" data-language="python"><code class="language-python">file_png &#x3D; open(&#39;aa.png&#39;, &#39;rb&#39;)for line in file_png.readlines():    print(line)# output为16进制格式表示打开成功：b&quot;\x00\x00\x00\rIHDR\x00\x00\x01\xe1\x00\x00\x01#\x08\x02\x00\x00\x00\x8a\x08.\xe6...# 采用16进制进行显示相较于2进制010101方便人类阅读</code></pre><h4 id="（2）写入二进制文件"><a href="#（2）写入二进制文件" class="headerlink" title="（2）写入二进制文件"></a>（2）写入二进制文件</h4><pre class="language-python" data-language="python"><code class="language-python">file &#x3D; open(&#39;wb_file&#39;, &#39;wb&#39;)# file.write(&#39;哈哈&#39;)  # 直接写入文本会报错file.write(&#39;哈哈&#39;.encode(&#39;utf-8&#39;))  # 将&#39;哈哈&#39;解码为字节码，可以进行写入</code></pre><h2 id="（五）混合模式"><a href="#（五）混合模式" class="headerlink" title="（五）混合模式"></a>（五）混合模式</h2><h4 id="文件的三种混合模式"><a href="#文件的三种混合模式" class="headerlink" title="文件的三种混合模式"></a>文件的三种混合模式</h4><h4 id="w-写读"><a href="#w-写读" class="headerlink" title="w+ 写读"></a>w+ 写读</h4><p>  &amp;emsp;这个功能基本没什么意义，它会创建⼀个新⽂件 ，写⼀段内容，可以再把写的内容读出来，没什么卵⽤</p><h4 id="r-读写"><a href="#r-读写" class="headerlink" title="r+ 读写"></a>r+ 读写</h4><p> &amp;emsp;能读能写,但都是写在⽂件最后，跟追加⼀样</p><h4 id="a-追加读"><a href="#a-追加读" class="headerlink" title="a+ 追加读"></a>a+ 追加读</h4><p> &amp;emsp;⽂件⼀打开时光标会在⽂件尾部,写的数据全会是追加的形式</p><p> &amp;emsp;尝试直接以r+模式打开⽂件，默认会把新增的内容追加到⽂件最后⾯。但我想要的是修改中间的内容 ，怎么办？ 为什么会把内容添加到尾部呢？(最新测试r+会从头覆盖，测试代码如下)</p><div align=center><img src="https://img-blog.csdnimg.cn/d76ac748b33d4e518d77feb4245ed806.png" width = 60%></div><h2 id="（六）文件修改"><a href="#（六）文件修改" class="headerlink" title="（六）文件修改"></a>（六）文件修改</h2><h4 id="问：为什么原有数据会被覆盖呢？"><a href="#问：为什么原有数据会被覆盖呢？" class="headerlink" title="问：为什么原有数据会被覆盖呢？"></a>问：为什么原有数据会被覆盖呢？</h4><p> &amp;emsp;这是硬盘的存储原理导致的，当你把⽂件存到硬盘上，就在硬盘上划了⼀块空间，存数据，等你下次打开这个⽂件 ，seek到⼀个位置，每改⼀个字，就是把原来的覆盖掉，如果要插⼊，是不可能的，因为后⾯的数据在硬盘上不会整体向后移。所以就出现 当前这个情况 ，你想插⼊，却变成了会把旧内容覆盖掉。</p><h4 id="问：但是⼈家word-vim-都可以修改⽂件呀，你这不能修改算个什么玩意？"><a href="#问：但是⼈家word-vim-都可以修改⽂件呀，你这不能修改算个什么玩意？" class="headerlink" title="问：但是⼈家word, vim 都可以修改⽂件呀，你这不能修改算个什么玩意？"></a>问：但是⼈家word, vim 都可以修改⽂件呀，你这不能修改算个什么玩意？</h4><p> &amp;emsp;我并没说就不能修改了，你想修改当然可以，就是不要在硬盘上修改，把内容全部读到内存⾥，数据在内存⾥可以随便增删改查，修改之后，把内容再全部写回硬盘，把原来的数据全部覆盖掉。vim word等各种⽂本编辑器都是这么⼲的。</p><h4 id="问：但是⽂件如果特别⼤，⽐如5个GB-读到内存，就⼀下⼦吃掉了5GB内存，好费资源呀，有没有更好的办法呢？"><a href="#问：但是⽂件如果特别⼤，⽐如5个GB-读到内存，就⼀下⼦吃掉了5GB内存，好费资源呀，有没有更好的办法呢？" class="headerlink" title="问：但是⽂件如果特别⼤，⽐如5个GB,读到内存，就⼀下⼦吃掉了5GB内存，好费资源呀，有没有更好的办法呢？"></a>问：但是⽂件如果特别⼤，⽐如5个GB,读到内存，就⼀下⼦吃掉了5GB内存，好费资源呀，有没有更好的办法呢？</h4><p> &amp;emsp;如果不想占内存，只能⽤另外⼀种办法啦，就是边读边改，什么意思？ 不是不能改么？是不能改原⽂件 ，但你可以打开旧⽂件 的同时，⽣成⼀个新⽂件呀，边从旧的⾥⾯⼀⾏⾏的读，边往新的⼀⾏⾏写，遇到需要修改就改了再写到新⽂件，这样，在内存⾥⼀直只存⼀⾏内容。就不占内存了。 但这样也有⼀个缺点，就是虽然不占内存 ，但是占硬盘，每次修改，都要⽣成⼀份新⽂件，虽然改完后，可以把旧的覆盖掉，但在改的过程中，还是有2份数据的。</p><h4 id="问：还有更好的⽅式么"><a href="#问：还有更好的⽅式么" class="headerlink" title="问：还有更好的⽅式么?"></a>问：还有更好的⽅式么?</h4><p> &amp;emsp;有完没完？ 没了。</p><h4 id="文件修改实例"><a href="#文件修改实例" class="headerlink" title="文件修改实例"></a>文件修改实例</h4><h4 id="1、stock-data文件"><a href="#1、stock-data文件" class="headerlink" title="1、stock_data文件"></a>1、stock_data文件</h4><pre class="language-python" data-language="python"><code class="language-python">股票代码,股票名称,当前价,涨跌额,涨跌幅,年初⾄今,成交量,成交额,换⼿率,市盈率(TTM),股息率,市值SH601778,N晶科,6.29,+1.92,+43.94%,+43.94%,259.66万,1625.52万,0.44%,22.32,-,173.95亿SH688566,吉⻉尔,52.66,+6.96,+15.23%,+122.29%,1626.58万,8.09亿,42.29%,89.34,-,98.44亿SH688268,华特⽓体,88.80,+11.72,+15.20%,+102.51%,622.60万,5.13亿,22.87%,150.47,-,106.56亿SH600734,实达集团,2.60,+0.24,+10.17%,-61.71%,1340.27万,3391.14万,2.58%,亏损,0.00%,16.18亿</code></pre><h4 id="2、修改代码"><a href="#2、修改代码" class="headerlink" title="2、修改代码"></a>2、修改代码</h4><pre class="language-python" data-language="python"><code class="language-python"># 1、将数据导入内存file &#x3D; open(&#39;stock_data&#39;, mode&#x3D;&#39;r+&#39;, encoding&#x3D;&#39;utf-8&#39;)data &#x3D; file.read()  # 使用read方法new_data &#x3D; data.replace(&#39;吉⻉尔&#39;, &#39;路飞学城&#39;)print(new_data)# 2、删除硬盘数据file.seek(0)  # 将光标移动到文件最开始file.truncate()  # 截断：将光标后的数据全部删除# 3、写入新数据file.write(new_data)file.close()# 运行后stock_data的&#39;吉⻉尔&#39;,将改为&#39;路飞学城&#39;</code></pre><h1 id="二、练习–全局文件检索替换"><a href="#二、练习–全局文件检索替换" class="headerlink" title="二、练习–全局文件检索替换"></a>二、练习–全局文件检索替换</h1><p> &amp;emsp;写⼀个脚本，允许⽤户按以下⽅式执⾏时，即可以对指定⽂件内容进⾏全局替换，且替换完毕后打印替换了多少处内容。</p><pre class="language-python" data-language="python"><code class="language-python">def file_replace(file_name, old_str, new_str):    # 1、将数据导入内存    file &#x3D; open(file_name, mode&#x3D;&#39;r+&#39;, encoding&#x3D;&#39;utf-8&#39;)    data &#x3D; file.read()    new_data &#x3D; data.replace(old_str, new_str)    # 2、删除硬盘数据    file.seek(0)  # 将光标移动到文件最开始    file.truncate()  # 截断：将光标后的数据全部删除    # 3、写入新数据    file.write(new_data)    file.close()    print(f&#39;成功替换字符&#123;old_str&#125;到&#123;new_str&#125;，共计&#123;data.count(old_str)&#125;处&#39;)file_replace(&#39;stock_data&#39;, &#39;亿&#39;, &#39;万万&#39;)</code></pre><h1 id="三、练习–用户登陆认证程序"><a href="#三、练习–用户登陆认证程序" class="headerlink" title="三、练习–用户登陆认证程序"></a>三、练习–用户登陆认证程序</h1><h2 id="（一）要求"><a href="#（一）要求" class="headerlink" title="（一）要求"></a>（一）要求</h2><p>1、要求⽤户输⼊帐号密码进⾏登陆<br>2、⽤户账号信息保存在⽂件内<br>3、⽤户密码输⼊错误三次后锁定⽤户，下次再登录，检测到是这个被锁定的⽤户，则依然不允许其它登录，提示已被锁</p><h4 id="用户数据"><a href="#用户数据" class="headerlink" title="用户数据"></a>用户数据</h4><pre class="language-none"><code class="language-none">耿天霸 111111 unlock童天霸 222222 unlock武天霸 333333 unlock霸天霸 444444 unlock张天霸 555555 unlock</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="language-python" data-language="python"><code class="language-python"># 1、导入用户数据user_info &#x3D; open(&#39;users&#39;, encoding&#x3D;&#39;utf-8&#39;)# 2、将数据转化成字典，key为用户名，value为一个字典，包含&#123;用户名：，密码：，状态：&#125;info_dic &#x3D; &#123;    # &#39;耿天霸&#39;：&#123;&#39;password&#39;: &#39;111111&#39;, &#39;state&#39;: &#39;unlock&#39;&#125;,    # &#39;xxx&#39;:&#123;&#39;password&#39;:&#39;xxxxxx&#39;, &#39;state&#39;: &#39;xxxxx&#39;&#125;&#125;# 遍历每一行for line in user_info:    user &#x3D; line.strip().split()  # 先用strip()去掉空格，再用split()将逗号分开    print(user)    info_dic[user[0]] &#x3D; &#123;        &#39;password&#39;: user[1],        &#39;state&#39;: user[2]    &#125;# print(info_dic)# 4、登录小程序while True:    log_name &#x3D; input(&#39;please input your username: &#39;).strip()  # strip方法防止用户输入空格导致判断错误    # 如果用户名在用户信息中    if log_name in info_dic.keys():        # 如果用户名被被锁定：直接退出并输入提示语        if info_dic[log_name][&#39;state&#39;] &#x3D;&#x3D; &#39;locked&#39;:            print(&#39;you account is looked&#39;)            continue        else:            times &#x3D; 0            # 可以输入三次密码            while times &lt; 3:                log_password &#x3D; input(&#39;please input your password: &#39;).strip()                # 如果密码正确：退出并打印提示                if log_password &#x3D;&#x3D; info_dic[log_name][&#39;password&#39;]:                    exit(&#39;welcome, you are logged in&#39;)                # 如果密码不正确：打印提示                else:                    print(f&#39;your password is incorrect, you have &#123;2 - times&#125; times left&#39;)                    # 如果密码错误三次：锁定账户，打印提示；并按照原格式保存会数据库                    if times &#x3D;&#x3D; 2:                        info_dic[log_name][&#39;state&#39;] &#x3D; &#39;locked&#39;                        print(&#39;your account is locked&#39;)                        # 字典转回txt                        user_info1 &#x3D; open(&#39;users&#39;, mode&#x3D;&#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;)                        for k in info_dic:                            user_info1.write(k + &#39; &#39; + info_dic[k][&#39;password&#39;] + &#39; &#39; + info_dic[k][&#39;state&#39;] + &#39;\n&#39;)                        user_info1.close()  # 源文件中的耿天霸状态也会被锁定                times +&#x3D; 1    else:        print(&#39;username not registered&#39;)        continue</code></pre><h1 id="四、综合实战–股票查询程序"><a href="#四、综合实战–股票查询程序" class="headerlink" title="四、综合实战–股票查询程序"></a>四、综合实战–股票查询程序</h1><h4 id="（一）数据源"><a href="#（一）数据源" class="headerlink" title="（一）数据源"></a>（一）数据源</h4><div align=center><img src="https://img-blog.csdnimg.cn/42d0acb9f49b4172bd756c8301768e97.png" width = 100%></div><h4 id="数据源stock-data-txt"><a href="#数据源stock-data-txt" class="headerlink" title="数据源stock_data.txt"></a>数据源stock_data.txt</h4><pre class="language-python" data-language="python"><code class="language-python">股票代码,股票名称,当前价,涨跌额,涨跌幅,年初⾄今,成交量,成交额,换⼿率,市盈率(TTM),股息率,市值SH601778,N晶科,6.29,+1.92,+43.94%,+43.94%,259.66万,1625.52万,0.44%,22.32,-,173.95亿SH688566,吉⻉尔,52.66,+6.96,+15.23%,+122.29%,1626.58万,8.09亿,42.29%,89.34,-,98.44亿SH688268,华特⽓体,88.80,+11.72,+15.20%,+102.51%,622.60万,5.13亿,22.87%,150.47,-,106.56亿SH600734,实达集团,2.60,+0.24,+10.17%,-61.71%,1340.27万,3391.14万,2.58%,亏损,0.00%,16.18亿SH900957,凌云B股,0.36,+0.033,+10.09%,-35.25%,119.15万,42.10万,0.65%,44.65,0.00%,1.26亿SZ000584,哈⼯智能,6.01,+0.55,+10.07%,-4.15%,2610.86万,1.53亿,4.36%,199.33,0.26%,36.86亿SH600599,熊猫⾦控,6.78,+0.62,+10.06%,-35.55%,599.64万,3900.23万,3.61%,亏损,0.00%,11.25亿SH600520,⽂⼀科技,8.21,+0.75,+10.05%,-24.05%,552.34万,4464.69万,3.49%,亏损,0.00%,13.01亿SH603682,锦和商业,11.73,+1.07,+10.04%,+48.29%,2746.63万,3.15亿,29.06%,29.62,-,55.42亿SZ300831,派瑞股份,12.27,+1.12,+10.04%,+208.29%,25.38万,311.41万,0.32%,60.59,-,39.26亿SH900939,汇丽B,0.504,+0.046,+10.04%,-23.52%,123.86万,61.86万,1.41%,52.80,0.00%,9147.60万SH600880,博瑞传播,4.39,+0.40,+10.03%,+10.03%,1117.75万,4816.57万,1.02%,95.87,0.50%,48.00亿SZ000609,中迪投资,7.68,+0.70,+10.03%,+39.64%,2663.08万,2.00亿,9.12%,58.84,0.00%,22.98亿SZ300328,宜安科技,15.80,+1.44,+10.03%,+7.19%,432.45万,6832.68万,0.95%,64.80,0.51%,72.72亿SZ002988,豪美新材,17.33,+1.58,+10.03%,+58.41%,3.50万,60.68万,0.06%,24.42,-,40.34亿SZ000615,京汉股份,4.61,+0.42,+10.02%,+4.06%,518.09万,2388.41万,0.69%,亏损,0.00%,36.06亿SZ300443,⾦雷股份,18.33,+1.67,+10.02%,+32.74%,987.25万,1.75亿,6.19%,18.78,1.08%,43.64亿SH600506,⾹梨股份,11.42,+1.04,+10.02%,+11.96%,1039.48万,1.18亿,7.04%,亏损,0.00%,16.87亿SZ300505,川⾦诺,15.61,+1.42,+10.01%,-11.26%,493.54万,7555.40万,6.03%,26.70,0.85%,20.40亿SZ300830,⾦现代,14.95,+1.36,+10.01%,+239.77%,63.66万,951.76万,0.74%,70.76,0.00%,64.30亿SH603630,拉芳家化,17.26,+1.57,+10.01%,+27.85%,949.49万,1.60亿,4.19%,209.44,0.83%,39.13亿SZ002655,共达电声,11.43,+1.04,+10.01%,-14.64%,1683.51万,1.88亿,4.68%,166.69,0.00%,41.15亿SZ300460,惠伦晶体,16.59,+1.51,+10.01%,+0.97%,430.28万,6974.52万,2.56%,亏损,0.00%,27.92亿SH603929,亚翔集成,20.33,+1.85,+10.01%,+33.40%,1373.66万,2.76亿,6.44%,84.29,1.25%,43.38亿SH603392,万泰⽣物,35.97,+3.27,+10.00%,+311.09%,6.92万,248.91万,0.16%,65.24,-,155.97亿SZ000788,北⼤医药,6.82,+0.62,+10.00%,+2.40%,832.44万,5583.87万,1.40%,89.69,0.32%,40.65亿SH601609,⾦⽥铜业,10.89,+0.99,+10.00%,+66.26%,4027.64万,4.28亿,16.64%,32.38,0.32%,158.66亿SZ000403,双林⽣物,52.48,+4.77,+10.00%,+62.48%,171.75万,9013.54万,0.63%,88.80,0.23%,143.05亿SZ300832,新产业,72.80,+6.62,+10.00%,+131.92%,10.73万,780.85万,0.26%,40.20,0.62%,299.64亿SZ002985,北摩⾼科,92.58,+8.42,+10.00%,+310.92%,2422.97万,21.55亿,64.54%,60.48,1.08%,139.02亿SH603348,⽂灿股份,18.06,+1.64,+9.99%,-25.15%,357.86万,6328.87万,4.39%,89.39,0.89%,41.83亿SH603900,莱绅通灵,8.92,+0.81,+9.99%,-5.61%,1364.10万,1.15亿,4.01%,43.78,5.06%,30.37亿SH603042,华脉科技,17.85,+1.62,+9.98%,+17.05%,491.44万,8705.99万,4.86%,128.50,0.31%,24.28亿SZ300260,新莱应材,19.83,+1.80,+9.98%,+68.48%,1800.45万,3.48亿,14.16%,65.15,0.73%,40.04亿SZ000557,⻄部创业,3.42,+0.31,+9.97%,-0.87%,2751.17万,9408.89万,1.89%,79.39,0.00%,49.88亿SZ300716,国⽴科技,9.94,+0.90,+9.96%,-4.24%,142.25万,1413.92万,1.50%,亏损,0.29%,15.91亿SZ002449,国星光电,11.92,+1.08,+9.96%,-6.80%,5185.52万,6.03亿,8.53%,21.51,2.73%,73.72亿SZ002397,梦洁股份,8.50,+0.77,+9.96%,+73.47%,810.06万,6885.51万,1.67%,110.68,2.35%,64.95亿SZ002662,京威股份,4.09,+0.37,+9.95%,+54.92%,8588.12万,3.40亿,5.89%,亏损,0.00%,61.35亿SZ002297,博云新材,6.30,+0.57,+9.95%,-1.87%,2852.27万,1.74亿,6.07%,亏损,0.00%,29.69亿SZ300351,永贵电器,8.62,+0.78,+9.95%,-2.16%,1443.26万,1.23亿,5.89%,亏损,0.00%,33.07亿SH600834,申通地铁,7.63,+0.69,+9.94%,+5.68%,223.20万,1703.02万,0.47%,74.74,0.56%,36.42亿SZ000616,海航投资,3.10,+0.28,+9.93%,+27.57%,5002.95万,1.51亿,3.50%,133.28,0.00%,44.34亿SH600662,强⽣控股,5.54,+0.50,+9.92%,+22.03%,254.89万,1412.07万,0.24%,亏损,0.72%,58.36亿SZ300223,北京君正,107.20,+8.92,+9.08%,+23.01%,930.81万,9.86亿,7.34%,314.71,0.00%,216.28亿SZ002978,安宁股份,35.46,+2.95,+9.07%,+29.09%,1181.96万,4.11亿,29.10%,25.11,-,142.31亿SZ002084,海鸥住⼯,7.09,+0.54,+8.24%,+9.24%,1647.83万,1.16亿,3.36%,33.83,0.00%,35.60亿SH688012,中微公司,229.00,+17.30,+8.17%,+147.84%,448.32万,10.05亿,8.72%,607.21,-,1224.83亿SZ002049,紫光国微,74.04,+5.54,+8.09%,+45.63%,4459.03万,32.57亿,7.35%,85.03,0.10%,449.29亿SH600329,中新药业,14.83,+1.10,+8.01%,+7.00%,1159.16万,1.68亿,2.05%,18.90,2.16%,114.61亿SZ002204,⼤连᯿⼯,5.71,+0.41,+7.74%,+77.88%,1.73亿,9.35亿,8.97%,213.83,0.55%,110.28亿SH688088,虹软科技,84.16,+5.96,+7.62%,+78.12%,290.59万,2.43亿,7.22%,148.96,-,341.69亿SZ300398,⻜凯材料,21.33,+1.50,+7.56%,+42.68%,2676.82万,5.65亿,6.21%,47.18,0.00%,110.41亿SZ300298,三诺⽣物,21.93,+1.53,+7.50%,+48.45%,832.56万,1.80亿,1.89%,46.66,1.44%,123.97亿SH603236,移远通信,235.40,+16.09,+7.34%,+61.34%,96.10万,2.22亿,4.31%,151.64,0.22%,209.93亿SZ002074,国轩⾼科,26.93,+1.79,+7.12%,+85.09%,3628.58万,9.54亿,3.60%,亏损,0.00%,304.25亿SZ000710,⻉瑞基因,51.27,+3.37,+7.04%,+40.08%,411.57万,2.09亿,2.91%,63.69,0.00%,181.81亿SZ300624,万兴科技,95.86,+6.28,+7.01%,+51.92%,374.27万,3.54亿,7.52%,84.07,0.38%,77.91亿SZ300002,神州泰岳,6.42,+0.41,+6.82%,+96.93%,9118.57万,5.66亿,5.59%,亏损,0.00%,126.10亿SH603012,创⼒集团,7.30,+0.46,+6.73%,-18.16%,2648.28万,1.92亿,4.16%,15.57,1.01%,46.47亿SZ300144,宋城演艺,31.70,+1.98,+6.66%,+2.56%,980.92万,3.08亿,0.82%,45.22,0.66%,460.77亿SZ300724,捷佳伟创,67.58,+4.18,+6.59%,+78.36%,223.02万,1.48亿,1.31%,57.75,0.28%,216.70亿SZ200706,瓦轴B,2.27,+0.14,+6.57%,-21.99%,25.88万,57.83万,0.16%,亏损,0.00%,9.18亿SH603693,江苏新能,12.10,+0.74,+6.51%,+18.86%,2377.38万,2.87亿,12.32%,19.47,1.32%,74.78亿SZ200468,宁通信B,1.82,+0.11,+6.43%,-26.32%,53.22万,96.40万,0.53%,亏损,0.00%,3.89亿SH600426,华鲁恒升,18.11,+1.09,+6.40%,-8.86%,1369.76万,2.46亿,0.85%,13.16,2.05%,294.59亿SH900953,凯⻢B,0.334,+0.020,+6.37%,-30.13%,186.93万,63.29万,0.78%,236.41,0.00%,2.14亿SH600703,三安光电,25.15,+1.50,+6.34%,+36.98%,1.08亿,26.73亿,2.65%,95.77,0.42%,1025.72亿SZ300118,东⽅⽇升,12.75,+0.74,+6.16%,-7.94%,3686.23万,4.68亿,5.29%,13.57,1.63%,114.92亿SZ300418,昆仑万维,22.25,+1.29,+6.15%,+32.84%,3641.22万,8.00亿,4.03%,18.07,0.12%,257.36亿SH900929,锦旅B股,1.214,+0.070,+6.12%,-25.52%,36.05万,43.02万,0.55%,19.81,0.00%,1.61亿SZ300496,中科创达,60.79,+3.49,+6.09%,+34.99%,1062.96万,6.40亿,3.75%,96.33,0.22%,244.69亿SH600818,中路股份,12.36,+0.71,+6.09%,+3.69%,921.26万,1.15亿,3.87%,亏损,0.00%,39.73亿SZ300644,南京聚隆,35.19,+2.01,+6.06%,+18.64%,872.06万,3.12亿,21.10%,79.62,0.55%,22.53亿SZ300729,乐歌股份,24.18,+1.38,+6.05%,+3.50%,204.82万,4889.15万,8.14%,31.62,1.31%,21.09亿SZ300767,震安科技,108.58,+6.16,+6.01%,+79.44%,146.41万,1.57亿,3.19%,92.38,0.21%,86.86亿SH603179,DR新泉股,19.30,+1.08,+5.93%,+35.50%,147.38万,2833.24万,0.65%,35.11,2.25%,56.76亿SH603626,科森科技,11.27,+0.63,+5.92%,+8.47%,466.11万,5187.87万,1.01%,亏损,0.00%,53.30亿SZ300019,硅宝科技,9.50,+0.53,+5.91%,-6.13%,423.46万,3943.10万,1.55%,24.58,1.65%,31.40亿SZ002756,永兴材料,16.18,+0.90,+5.89%,-7.34%,247.83万,3910.01万,1.34%,18.38,2.98%,58.21亿SZ002498,汉缆股份,6.11,+0.34,+5.89%,+102.99%,2.01亿,12.04亿,6.05%,43.98,0.62%,202.93亿SZ002980,华盛昌,62.41,+3.46,+5.87%,+319.14%,969.65万,5.99亿,29.09%,51.97,-,83.21亿SZ002371,北⽅华创,176.88,+9.80,+5.87%,+101.00%,1006.35万,17.45亿,2.20%,276.58,0.04%,875.76亿SZ300139,晓程科技,8.71,+0.48,+5.83%,+0.23%,4423.87万,3.82亿,20.11%,亏损,0.00%,23.84亿SZ000636,⻛华⾼科,24.51,+1.33,+5.74%,+64.61%,5605.61万,13.61亿,6.26%,71.71,0.00%,219.42亿SZ000564,供销⼤集,4.06,+0.22,+5.73%,+69.87%,2.98亿,11.89亿,14.86%,亏损,0.00%,244.52亿SZ002612,朗姿股份,7.84,+0.42,+5.66%,-19.34%,540.71万,4191.22万,2.31%,1224.17,4.23%,34.69亿SH600176,中国巨⽯,9.39,+0.50,+5.62%,-13.85%,3256.19万,3.02亿,0.93%,16.97,2.14%,328.87亿SH603313,梦百合,24.10,+1.28,+5.61%,+14.16%,356.10万,8446.14万,1.05%,21.72,0.00%,82.23亿SZ300279,和晶科技,5.49,+0.29,+5.58%,-8.50%,2328.20万,1.31亿,5.33%,亏损,0.00%,24.65亿</code></pre><h2 id="（二）需求"><a href="#（二）需求" class="headerlink" title="（二）需求"></a>（二）需求</h2><p>1、程序启动后，给⽤户提供查询接⼝，允许⽤户᯿复查股票⾏情信息(⽤到循环)<br>2、允许⽤户通过模糊查询股票名，⽐如输⼊“啤酒”, 就把所有股票名称中包含“啤酒”的信息打印出来<br>3、允许按股票价格、涨跌幅、换⼿率这⼏列来筛选信息，⽐如输⼊“价格&gt;50”则把价格⼤于50的股票都打印，输⼊“市盈率&lt;50“，则把市盈率⼩于50的股票都打印，不⽤判断等于<br> &amp;emsp;<strong>思路提示：加载⽂件内容到内存，转成dict or list结构，然后对dict or list 进⾏查询等操作。 这样以后就不⽤每查⼀次就要打开⼀次⽂件了，效率会⾼。</strong></p><h4 id="程序启动后执⾏效果参考："><a href="#程序启动后执⾏效果参考：" class="headerlink" title="程序启动后执⾏效果参考："></a>程序启动后执⾏效果参考：</h4><pre class="language-python" data-language="python"><code class="language-python">股票查询接⼝&gt;&gt;:换⼿率&gt;25[&#39;序号&#39;, &#39;代码&#39;, &#39;名称&#39;, &#39;最新价&#39;, &#39;涨跌幅&#39;, &#39;涨跌额&#39;, &#39;成交量(⼿)&#39;, &#39;成交额&#39;, &#39;振幅&#39;,&#39;最⾼&#39;, &#39;最低&#39;, &#39;今开&#39;, &#39;昨收&#39;, &#39;量⽐&#39;, &#39;换⼿率&#39;, &#39;市盈率&#39;, &#39;市净率&#39;][&#39;18&#39;, &#39;603697&#39;, &#39;有友⻝品&#39;, &#39;22.73&#39;, &#39;10.02%&#39;, &#39;2.07&#39;, &#39;34.93万&#39;, &#39;7.68亿&#39;,&#39;8.23%&#39;, &#39;22.73&#39;, &#39;21.03&#39;, &#39;21.17&#39;, &#39;20.66&#39;, &#39;1.4&#39;, &#39;43.94%&#39;, &#39;38.1&#39;, &#39;4.66&#39;][&#39;23&#39;, &#39;603956&#39;, &#39;威派格&#39;, &#39;22.52&#39;, &#39;10.01%&#39;, &#39;2.05&#39;, &#39;18.33万&#39;, &#39;4.01亿&#39;,&#39;10.60%&#39;, &#39;22.52&#39;, &#39;20.35&#39;, &#39;20.35&#39;, &#39;20.47&#39;, &#39;2.16&#39;, &#39;43.02%&#39;, &#39;-&#39;, &#39;9.82&#39;][&#39;36&#39;, &#39;300748&#39;, &#39;⾦⼒永磁&#39;, &#39;59.7&#39;, &#39;10.01%&#39;, &#39;5.43&#39;, &#39;11.02万&#39;, &#39;6.38亿&#39;,&#39;6.98%&#39;, &#39;59.7&#39;, &#39;55.91&#39;, &#39;56.88&#39;, &#39;54.27&#39;, &#39;0.9&#39;, &#39;26.49%&#39;, &#39;234.09&#39;,&#39;23.54&#39;][&#39;37&#39;, &#39;300767&#39;, &#39;震安科技&#39;, &#39;41.13&#39;, &#39;10.00%&#39;, &#39;3.74&#39;, &#39;6.22万&#39;, &#39;2.49亿&#39;,&#39;10.32%&#39;, &#39;41.13&#39;, &#39;37.27&#39;, &#39;37.48&#39;, &#39;37.39&#39;, &#39;3.86&#39;, &#39;31.11%&#39;, &#39;43.32&#39;,&#39;3.68&#39;][&#39;38&#39;, &#39;603045&#39;, &#39;福达合⾦&#39;, &#39;32&#39;, &#39;10.00%&#39;, &#39;2.91&#39;, &#39;17.06万&#39;, &#39;5.31亿&#39;,&#39;9.87%&#39;, &#39;32&#39;, &#39;29.13&#39;, &#39;29.13&#39;, &#39;29.09&#39;, &#39;1.39&#39;, &#39;25.17%&#39;, &#39;52.74&#39;, &#39;4.02&#39;][&#39;39&#39;, &#39;2952&#39;, &#39;亚世光电&#39;, &#39;58.98&#39;, &#39;10.00%&#39;, &#39;5.36&#39;, &#39;4.18万&#39;, &#39;2.41亿&#39;,&#39;7.42%&#39;, &#39;58.98&#39;, &#39;55&#39;, &#39;55.91&#39;, &#39;53.62&#39;, &#39;3.04&#39;, &#39;27.44%&#39;, &#39;53.09&#39;, &#39;5.51&#39;]找到6条股票查询接⼝&gt;&gt;:最新价&lt;5[&#39;序号&#39;, &#39;代码&#39;, &#39;名称&#39;, &#39;最新价&#39;, &#39;涨跌幅&#39;, &#39;涨跌额&#39;, &#39;成交量(⼿)&#39;, &#39;成交额&#39;, &#39;振幅&#39;,&#39;最⾼&#39;, &#39;最低&#39;, &#39;今开&#39;, &#39;昨收&#39;, &#39;量⽐&#39;, &#39;换⼿率&#39;, &#39;市盈率&#39;, &#39;市净率&#39;][&#39;2&#39;, &#39;2676&#39;, &#39;顺威股份&#39;, &#39;3.69&#39;, &#39;10.15%&#39;, &#39;0.34&#39;, &#39;15.23万&#39;, &#39;5516万&#39;,&#39;9.55%&#39;, &#39;3.69&#39;, &#39;3.37&#39;, &#39;3.37&#39;, &#39;3.35&#39;, &#39;1.16&#39;, &#39;2.11%&#39;, &#39;-&#39;, &#39;2.58&#39;][&#39;3&#39;, &#39;601619&#39;, &#39;嘉泽新能&#39;, &#39;4.91&#39;, &#39;10.09%&#39;, &#39;0.45&#39;, &#39;16.55万&#39;, &#39;8006万&#39;,&#39;8.52%&#39;, &#39;4.91&#39;, &#39;4.53&#39;, &#39;4.54&#39;, &#39;4.46&#39;, &#39;1.82&#39;, &#39;3.28%&#39;, &#39;52.26&#39;, &#39;3.64&#39;]找到2条股票查询接⼝&gt;&gt;:⻝品[&#39;18&#39;, &#39;603697&#39;, &#39;有友⻝品&#39;, &#39;22.73&#39;, &#39;10.02%&#39;, &#39;2.07&#39;, &#39;34.93万&#39;, &#39;7.68亿&#39;,&#39;8.23%&#39;, &#39;22.73&#39;, &#39;21.03&#39;, &#39;21.17&#39;, &#39;20.66&#39;, &#39;1.4&#39;, &#39;43.94%&#39;, &#39;38.1&#39;, &#39;4.66&#39;]找到1条股票查询接⼝&gt;&gt;:能源[&#39;9&#39;, &#39;2828&#39;, &#39;⻉肯能源&#39;, &#39;14.25&#39;, &#39;10.04%&#39;, &#39;1.3&#39;, &#39;17.83万&#39;, &#39;2.52亿&#39;,&#39;4.71%&#39;, &#39;14.25&#39;, &#39;13.64&#39;, &#39;13.8&#39;, &#39;12.95&#39;, &#39;3.45&#39;, &#39;18.03%&#39;, &#39;-&#39;, &#39;3.08&#39;]找到1条股票查询接⼝&gt;&gt;:科技[&#39;12&#39;, &#39;2866&#39;, &#39;传艺科技&#39;, &#39;13.81&#39;, &#39;10.04%&#39;, &#39;1.26&#39;, &#39;13.59万&#39;, &#39;1.83亿&#39;,&#39;9.72%&#39;, &#39;13.81&#39;, &#39;12.59&#39;, &#39;12.61&#39;, &#39;12.55&#39;, &#39;2.63&#39;, &#39;16.86%&#39;, &#39;33.37&#39;,&#39;3.43&#39;][&#39;19&#39;, &#39;300777&#39;, &#39;中简科技&#39;, &#39;24.92&#39;, &#39;10.02%&#39;, &#39;2.27&#39;, &#39;5952&#39;, &#39;1483万&#39;,&#39;0.00%&#39;, &#39;24.92&#39;, &#39;24.92&#39;, &#39;24.92&#39;, &#39;22.65&#39;, &#39;3.45&#39;, &#39;1.49%&#39;, &#39;102.24&#39;,&#39;11.49&#39;][&#39;21&#39;, &#39;300245&#39;, &#39;天玑科技&#39;, &#39;11.53&#39;, &#39;10.02%&#39;, &#39;1.05&#39;, &#39;26.86万&#39;, &#39;3.05亿&#39;,&#39;9.64%&#39;, &#39;11.53&#39;, &#39;10.52&#39;, &#39;10.52&#39;, &#39;10.48&#39;, &#39;1.06&#39;, &#39;10.35%&#39;, &#39;127.47&#39;,&#39;2.57&#39;][&#39;26&#39;, &#39;300391&#39;, &#39;康跃科技&#39;, &#39;7.8&#39;, &#39;10.01%&#39;, &#39;0.71&#39;, &#39;3.9万&#39;, &#39;3027万&#39;,&#39;10.01%&#39;, &#39;7.8&#39;, &#39;7.09&#39;, &#39;7.09&#39;, &#39;7.09&#39;, &#39;0.75&#39;, &#39;1.94%&#39;, &#39;27.35&#39;, &#39;1.89&#39;][&#39;37&#39;, &#39;300767&#39;, &#39;震安科技&#39;, &#39;41.13&#39;, &#39;10.00%&#39;, &#39;3.74&#39;, &#39;6.22万&#39;, &#39;2.49亿&#39;,&#39;10.32%&#39;, &#39;41.13&#39;, &#39;37.27&#39;, &#39;37.48&#39;, &#39;37.39&#39;, &#39;3.86&#39;, &#39;31.11%&#39;, &#39;43.32&#39;,&#39;3.68&#39;][&#39;40&#39;, &#39;603327&#39;, &#39;福蓉科技&#39;, &#39;21.56&#39;, &#39;10.00%&#39;, &#39;1.96&#39;, &#39;3586&#39;, &#39;773.1万&#39;,&#39;0.00%&#39;, &#39;21.56&#39;, &#39;21.56&#39;, &#39;21.56&#39;, &#39;19.6&#39;, &#39;2.81&#39;, &#39;0.70%&#39;, &#39;31.97&#39;, &#39;8.05&#39;]找到6条</code></pre><h2 id="（三）代码"><a href="#（三）代码" class="headerlink" title="（三）代码"></a>（三）代码</h2><pre class="language-python" data-language="python"><code class="language-python"># 1、导入用户数据user_info &#x3D; open(&#39;stock_data&#39;, encoding&#x3D;&#39;utf-8&#39;)# 2、将数据转化成字典，key为用户名，value为一个字典，包含&#123;股票代码：，名称：，当前价：...&#125;info_dic &#x3D; &#123;    # &#39;SH601778&#39;：&#123;&#39;股票名称&#39;: &#39;N晶科&#39;, &#39;当前价&#39;: &#39;6.29&#39;, &#39;涨跌幅&#39;: &#39;+1.92&#39;... &#125;,    # &#39;SHxxxxxx&#39;:&#123;&#39;股票名称&#39;: &#39;xxx&#39;, &#39;当前价&#39;: &#39;x.xx&#39;, &#39;涨跌幅&#39;: &#39;xxxxx&#39;... &#125;&#125;# 遍历每一行for line in user_info:    # print(line)    stock &#x3D; line.strip().split(&#39;,&#39;)  # 先用strip()去掉回车（&#39;\n&#39;），再用split()按逗号进行分割    # print(stock)    # print(len(stock))    info_dic[stock[0]] &#x3D; &#123;        &#39;股票名称&#39;: stock[1],        &#39;当前价&#39;: stock[2],        &#39;涨跌额&#39;: stock[3],        &#39;涨跌幅&#39;: stock[4],        &#39;年初⾄今&#39;: stock[5],        &#39;成交量&#39;: stock[6],        &#39;成交额&#39;: stock[7],        &#39;换⼿率&#39;: stock[8],        &#39;市盈率(TTM)&#39;: stock[9],        &#39;股息率&#39;: stock[10],        &#39;市值&#39;: stock[11],    &#125;# print(info_dic)# 删除第一行del info_dic[&#39;股票代码&#39;]count &#x3D; 0while True:    user_input &#x3D; input(&#39;股票查询接口&gt;&gt;：&#39;)    # 输入e以退出程序    if user_input &#x3D;&#x3D; &#39;e&#39;:        exit(&#39;bye!&#39;)    # 解决查询问题    for stock in info_dic:        # 如果查询股票信息则直接打印，支持模糊查询        # print(info_dic[stock][&#39;股票名称&#39;])        if user_input in info_dic[stock][&#39;股票名称&#39;]:            print(info_dic[stock])            count +&#x3D; 1           print(f&#39;共找到&#123;count&#125;条记录&#39;)</code></pre><p>※ 目前只完成字符串查询问题，未完成含有表达式的查询</p>]]></content>
      
      
      <categories>
          
          <category> Python零基础到精通7天速成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day3-顺丰快递分拣小程序</title>
      <link href="/2022/05/05/python-ru-men-dao-jing-tong-3/"/>
      <url>/2022/05/05/python-ru-men-dao-jing-tong-3/</url>
      
        <content type="html"><![CDATA[<h3 id="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"><a href="#本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记" class="headerlink" title="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"></a>本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记</h3><h3 id="视频链接-Python零基础到精通7天速成"><a href="#视频链接-Python零基础到精通7天速成" class="headerlink" title="视频链接:Python零基础到精通7天速成"></a>视频链接:<a href="https://www.bilibili.com/video/BV1Gf4y1q7SG?share_source=copy_web">Python零基础到精通7天速成</a></h3><span id="more"></span><h1 id="一、数据类型–又见字符串"><a href="#一、数据类型–又见字符串" class="headerlink" title="一、数据类型–又见字符串"></a>一、数据类型–又见字符串</h1><p> &amp;emsp;是一个<font color="#dd0000">有序</font>的字符集合，用于在计算机里存储和表示文本信息</p><h2 id="（一）字符串的特性"><a href="#（一）字符串的特性" class="headerlink" title="（一）字符串的特性"></a>（一）字符串的特性</h2><p>1、<font color="#dd0000">有序</font><br> &amp;emsp;按照从左到右的顺序定义字符集合，下标从0开始顺序访问</p><div align=center><img src="https://img-blog.csdnimg.cn/38d03244ba3d4ca5a83c81c878ff3e70.png" width = 50%></div><p>2、可以进行切片操作</p><pre class="language-python" data-language="python"><code class="language-python">s &#x3D; &#39;hello world&#39;print(s[5:])</code></pre><p>3、<font color="#dd0000">不可变</font><br> &amp;emsp;不能像列表一样修改其中某个元素，所有对字符串的修改操作，相当于生成了一份新的数据。</p><h2 id="（二）字符串的常用操作"><a href="#（二）字符串的常用操作" class="headerlink" title="（二）字符串的常用操作"></a>（二）字符串的常用操作</h2><div align=center><img src="https://img-blog.csdnimg.cn/f652a42d71324ac7a7e9c3a0ef068b85.png" width = 60%></div>※ <font color="#dd0000">以上所有方法均可通过heip()方法进行查看。</font><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &#39;Geng tian ba&#39;print(name.center(50, &#39;-&#39;))  # output:-----------------------Gengtianba------------------------print(name.count(&#39;a&#39;, 0, -2))  # output:1  从G开始统计到n有多少各aprint(name.endswith(&#39;ba&#39;))  # output:Trueprint(name.startswith(&#39;geng&#39;))  # output:Falseprint(name.find(&#39;tian&#39;))  # output:5  没有就返回-1print(name.isdigit())  # output:False  判断字符串是否是数字类型的如‘34’print(&#39;-&#39;.j oin(&#39;ashahs&#39;))  # output:a-s-h-a-h-s .前面为连接符print(name.replace(&#39;n&#39;, &#39;N&#39;, 1))  # output:GeNg tian ba 将n还成N，后面的1表示只换一个print(name.split(&#39;n&#39;))  # output:[&#39;Ge&#39;, &#39;g tia&#39;, &#39; ba&#39;] 传入参数表示用什么对字符串进行分割，默认值为空格</code></pre><h1 id="二、数据类型–又见列表"><a href="#二、数据类型–又见列表" class="headerlink" title="二、数据类型–又见列表"></a>二、数据类型–又见列表</h1><p> &amp;emsp;[]内以逗号分隔，按照索引，存放各种数据类型，每个位置代表一个元素。</p><h2 id="（一）列表的特点"><a href="#（一）列表的特点" class="headerlink" title="（一）列表的特点"></a>（一）列表的特点</h2><p>1、可存放多个值<br>2、<font color="#dd0000">有序</font></p><div align=center><img src="https://img-blog.csdnimg.cn/011093bebe594b8d8ff5c9ab8e4c2d7c.png" width = 50%></div>3、<font color="#dd0000">可变</font> &emsp;可修改指定索引的对应值<h2 id="（二）列表的常用操作"><a href="#（二）列表的常用操作" class="headerlink" title="（二）列表的常用操作"></a>（二）列表的常用操作</h2><h3 id="1、列表的增加操作"><a href="#1、列表的增加操作" class="headerlink" title="1、列表的增加操作"></a>1、列表的增加操作</h3><p>（1）追加</p><pre class="language-python" data-language="python"><code class="language-python">names &#x3D; [&#39;耿天霸&#39;, &#39;童天霸&#39;, &#39;武天霸&#39;]                      names.append(&#39;霸天霸&#39;)                                print(names)  # output:[&#39;耿天霸&#39;, &#39;童天霸&#39;, &#39;武天霸&#39;, &#39;霸天霸&#39;]                            </code></pre><p>（2）插入</p><pre class="language-python" data-language="python"><code class="language-python">names.insert(-2, &#39;张天霸&#39;)  # insert()方法可以直接插入列表                                         print(names)  # output[&#39;耿天霸&#39;, &#39;童天霸&#39;, &#39;武天霸&#39;, &#39;霸天霸&#39;, &#39;张天霸&#39;]                           </code></pre><p>（3）合并</p><pre class="language-python" data-language="python"><code class="language-python">new_names &#x3D; [&#39;皮天霸&#39;, &#39;陈天霸&#39;]                                              names.extend(new_names)                                                 print(names)  #output:[&#39;耿天霸&#39;, &#39;童天霸&#39;, &#39;张天霸&#39;, &#39;武天霸&#39;, &#39;霸天霸&#39;, &#39;皮天霸&#39;, &#39;陈天霸&#39;]                            </code></pre><h3 id="2、列表的删除"><a href="#2、列表的删除" class="headerlink" title="2、列表的删除"></a>2、列表的删除</h3><p>（1）直接删</p><pre class="language-python" data-language="python"><code class="language-python">names &#x3D; [&#39;耿天霸&#39;, &#39;童天霸&#39;]del(names[1])print(names)  # output: [&#39;耿天霸&#39;]                       </code></pre><p>（2）根据位置删，默认删除最后一个元素，并返回被删除的值</p><pre class="language-python" data-language="python"><code class="language-python">names &#x3D; [&#39;耿天霸&#39;, &#39;童天霸&#39;, &#39;张天霸&#39;, &#39;武天霸&#39;]         names.pop(-2)                                print(names)  # output: [&#39;耿天霸&#39;, &#39;童天霸&#39;, &#39;武天霸&#39;]names.pop()                                  print(names)  # output: [&#39;耿天霸&#39;, &#39;童天霸&#39;]                                    </code></pre><p>（3）根据值删除</p><pre class="language-python" data-language="python"><code class="language-python">names &#x3D; [&#39;耿天霸&#39;, &#39;童天霸&#39;, &#39;张天霸&#39;, &#39;武天霸&#39;]           names.remove(&#39;耿天霸&#39;)  # 删除遇到的第一个值                            print(names)  # output: [&#39;童天霸&#39;, &#39;张天霸&#39;, &#39;武天霸&#39;]                                  </code></pre><p>（4）清空</p><pre class="language-python" data-language="python"><code class="language-python">names &#x3D; [&#39;耿天霸&#39;, &#39;童天霸&#39;, &#39;张天霸&#39;, &#39;武天霸&#39;]names.clear()                       print(names)  # output: []                                </code></pre><h3 id="3、列表的修改操作"><a href="#3、列表的修改操作" class="headerlink" title="3、列表的修改操作"></a>3、列表的修改操作</h3><pre class="language-python" data-language="python"><code class="language-python">names &#x3D; [&#39;耿天霸&#39;, &#39;童天霸&#39;, &#39;张天霸&#39;, &#39;武天霸&#39;, &#39;皮天霸&#39;]         names[1] &#x3D; &#39;陈天霸&#39;                                    names[-2] &#x3D; &#39;皮天霸&#39;                                   print(names)  # output: [&#39;耿天霸&#39;, &#39;陈天霸&#39;, &#39;张天霸&#39;, &#39;皮天霸&#39;]                            </code></pre><h3 id="4、列表的查操作"><a href="#4、列表的查操作" class="headerlink" title="4、列表的查操作"></a>4、列表的查操作</h3><p> &amp;emsp;在不知道元素在列表哪个位置的情况下，如何修改     </p><pre class="language-python" data-language="python"><code class="language-python">names &#x3D; [&#39;耿天霸&#39;, &#39;陈天霸&#39;, &#39;张天霸&#39;, &#39;皮天霸&#39;, &#39;皮天霸&#39;]               # 1、判断元素是否在列表                                             print(&#39;陈天霸&#39; in names)   # output:TURE                     # 2、获取元素位置                                                print(names.index(&#39;陈天霸&#39;))   # output:1                    # 3、对元素进行修改                                               names[1] &#x3D; &#39;天霸&#39;                                           print(names)  # output:[&#39;耿天霸&#39;, &#39;天霸&#39;, &#39;张天霸&#39;, &#39;皮天霸&#39;, &#39;皮天霸&#39;]    </code></pre><h3 id="5、列表的切片"><a href="#5、列表的切片" class="headerlink" title="5、列表的切片"></a>5、列表的切片</h3><pre class="language-python" data-language="python"><code class="language-python">names[start: end: step]  # 注意是左闭右开中间用冒号隔开不是逗号&gt;&gt;&gt; names &#x3D; [&#39;耿天霸&#39;, &#39;天霸&#39;, &#39;张天霸&#39;, &#39;皮天霸&#39;, &#39;皮天霸&#39;]&gt;&gt;&gt; names[::2][&#39;耿天霸&#39;, &#39;张天霸&#39;, &#39;皮天霸&#39;]</code></pre><h3 id="6、排序和反转"><a href="#6、排序和反转" class="headerlink" title="6、排序和反转"></a>6、排序和反转</h3><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; numbers &#x3D; [3, 4, 2, 6, 1, 5]&gt;&gt;&gt; numbers.sort()&gt;&gt;&gt; numbers[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; numbers.reverse()&gt;&gt;&gt; numbers[6, 5, 4, 3, 2, 1]</code></pre><h3 id="7、列表的遍历"><a href="#7、列表的遍历" class="headerlink" title="7、列表的遍历"></a>7、列表的遍历</h3><pre class="language-python" data-language="python"><code class="language-python">for i in enumerate(names):...     print(i)...(0, &#39;耿天霸&#39;)(1, &#39;天霸&#39;)(2, &#39;张天霸&#39;)(3, &#39;皮天霸&#39;)(4, &#39;皮天霸&#39;)</code></pre><h2 id="（三）列表练习题–班级分组小程序"><a href="#（三）列表练习题–班级分组小程序" class="headerlink" title="（三）列表练习题–班级分组小程序"></a>（三）列表练习题–班级分组小程序</h2><p>1、需求<br> &amp;emsp;假设班上有55名同学，每个人的姓名和考试成绩存在大列表里，格式如下：</p><div align=center><img src="https://img-blog.csdnimg.cn/31d3b608291f4812864288be31b36cb6.png" width = 50%></div> &emsp;要求按考试成绩高低，将学院分成5组，全存在一个新的大列表里，5组分别是90-100, 80-89, 70-79, 60-69, 0-59最终的数据格式如下：<div align=center><img src="https://img-blog.csdnimg.cn/173dc2869edc4f079b8179b1654897e9.png" width = 50%></div>2、代码<pre class="language-python" data-language="python"><code class="language-python">stu_list &#x3D; [[&quot;梦琪&quot;,100],[&quot;忆柳&quot;,55],[&quot;之桃&quot;,88],[&quot;慕青&quot;,59],[&quot;问兰&quot;,60],[&quot;尔岚&quot;,41],[&quot;元香&quot;,64],[&quot;初夏&quot;,75],[&quot;沛菡&quot;,51],\                         [&quot;傲珊&quot;,49],[&quot;曼文&quot;,40],[&quot;乐菱&quot;,41],[&quot;痴珊&quot;,92],[&quot;恨玉&quot;,92],[&quot;惜文&quot;,67],[&quot;香寒&quot;,82],[&quot;新柔&quot;,71],[&quot;语蓉&quot;,45],\                          [&quot;海安&quot;,64],[&quot;夜蓉&quot;,52],[&quot;涵柏&quot;,54],[&quot;水桃&quot;,42],[&quot;醉蓝&quot;,58],[&quot;春儿&quot;,57],[&quot;语琴&quot;,60],[&quot;从彤&quot;,74],[&quot;傲晴&quot;,66],\                          [&quot;语兰&quot;,71],[&quot;又菱&quot;,88],[&quot;碧彤&quot;,75],[&quot;元霜&quot;,50],[&quot;怜梦&quot;,73],[&quot;紫寒&quot;,86],[&quot;妙彤&quot;,97],[&quot;曼易&quot;,64],[&quot;南莲&quot;,88],\                          [&quot;紫翠&quot;,41],[&quot;雨寒&quot;,85],[&quot;易烟&quot;,94],[&quot;如萱&quot;,99],[&quot;若南&quot;,41],[&quot;寻真&quot;,47],[&quot;晓亦&quot;,65],[&quot;向珊&quot;,57],[&quot;慕灵&quot;,76],\                          [&quot;以蕊&quot;,74],[&quot;寻雁&quot;,66],[&quot;映易&quot;,43],[&quot;雪柳&quot;,63],[&quot;孤岚&quot;,40],[&quot;笑霜&quot;,97],[&quot;海云&quot;,92],[&quot;凝天&quot;,50],[&quot;沛珊&quot;,98],\                          [&quot;寒云&quot;,52],[&quot;冰旋&quot;,50],[&quot;宛儿&quot;,71],[&quot;绿真&quot;,77],[&quot;盼儿&quot;,53],[&quot;晓霜&quot;,79],[&quot;碧凡&quot;,72],[&quot;夏菡&quot;,89],[&quot;曼香&quot;,42],\                          [&quot;若烟&quot;,85],[&quot;半梦&quot;,93],[&quot;雅绿&quot;,98],[&quot;冰蓝&quot;,91],[&quot;灵槐&quot;,82],[&quot;平安&quot;,73],[&quot;书翠&quot;,90],[&quot;翠风&quot;,65],[&quot;香巧&quot;,100],\                         [&quot;代云&quot;,45],[&quot;梦曼&quot;,94],[&quot;幼翠&quot;,51],[&quot;友巧&quot;,62],[&quot;听寒&quot;,87],[&quot;梦柏&quot;,60],[&quot;醉易&quot;,99],[&quot;访旋&quot;,51],[&quot;亦玉&quot;,86],\                          [&quot;凌萱&quot;,83],[&quot;访卉&quot;,64],[&quot;怀亦&quot;,56],[&quot;笑蓝&quot;,63],[&quot;春翠&quot;,85],[&quot;靖柏&quot;,85],[&quot;夜蕾&quot;,90],[&quot;冰夏&quot;,47],[&quot;杀毒&quot;,88],\                          [&quot;阿加&quot;,92],[&quot;奥莱&quot;,33],[&quot;欧阳&quot;,56],[&quot;那谁&quot;,89],[&quot;安塞&quot;,91],[&quot;市内&quot;,35],[&quot;暗示&quot;,80],[&quot;维护&quot;,45],[&quot;呼吸科&quot;,66],\                         [&quot;迪迦&quot;,23]]                                                                                                                                                                                                                    new_list &#x3D; [                                                                                                             [],                                                                                                                  [],                                                                                                                  [],                                                                                                                  [],                                                                                                                  []]  # 创建一个五个分组的空列表                                                                                                                                                                                                                   for student in stu_list:                                                                                                 if student[1] &gt; 89:  # 如果学生成绩大于89                                                                                        new_list[0].append(student)   # 放入第一个空列表                                                                         elif student[1] &gt; 79:  # 如果学生成绩大于79                                                                                      new_list[1].append(student)   # 放入第二个空列表                                                                         elif student[1] &gt; 69:  # 如果学生成绩大于69                                                                                      new_list[2].append(student)   # 放入第三个空列表                                                                         elif student[1] &gt; 59:  # 如果学生成绩大于59                                                                                      new_list[3].append(student)   # 放入第四个空列表                                                                         else:   # 如果学生成绩小于等于60                                                                                                   new_list[4].append(student)   # 放入第五个空列表                                                                                                                                                                                          for group in new_list:                                                                                                   print(group) </code></pre><h1 id="三、数据类型dict"><a href="#三、数据类型dict" class="headerlink" title="三、数据类型dict"></a>三、数据类型dict</h1><h2 id="（一）引子"><a href="#（一）引子" class="headerlink" title="（一）引子"></a>（一）引子</h2><p> &amp;emsp;使用列表存储每个员工的名字、年龄、职务、工资<br>70-79, 60-69, 0-59最终的数据格式如下：</p><div align=center><img src="https://img-blog.csdnimg.cn/31c67ddb6346464ba1c5fac3fe0c4df6.png" width = 50%></div> &emsp;如果想要拿到佩奇的工资，需要做以下操作<pre class="language-python" data-language="python"><code class="language-python">staff_list &#x3D; [                     [&#39;Alex&#39;, 23, &#39;CEO&#39;, 66000],    [&#39;黑姑娘&#39;, 24, &#39;行政&#39;, 4000],       [&#39;佩奇&#39;, 26, &#39;讲师&#39;, 40000],       # [&#39;xxx&#39;, xx, &#39;xx&#39;, xxx]       # [&#39;xxx&#39;, xx, &#39;xx&#39;, xxx]       # [&#39;xxx&#39;, xx, &#39;xx&#39;, xxx]   ]                              for staff in staff_list:           if staff[0] &#x3D;&#x3D; &#39;佩奇&#39;:               print(staff[-1])        break  # 找到后直接结束 </code></pre><p> &amp;emsp;需要写三行代码，麻烦；需要遍历列表直到找到目标，时间消耗高</p><h2 id="（二）定义"><a href="#（二）定义" class="headerlink" title="（二）定义"></a>（二）定义</h2><p><strong>{key1:value1, key2:value2}</strong></p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; staff_dic &#x3D; &#123;...     &#39;Alex&#39;: [23, &#39;CEO&#39;, 66000],...     &#39;黑姑娘&#39;: [24, &#39;行政&#39;, 4000],...     &#39;佩奇&#39;: [26, &#39;讲师&#39;, 40000]... &#125;&gt;&gt;&gt; staff_dic[&#39;佩奇&#39;][26, &#39;讲师&#39;, 40000]&gt;&gt;&gt;  </code></pre><h2 id="（三）特性"><a href="#（三）特性" class="headerlink" title="（三）特性"></a>（三）特性</h2><p>1、key: value结构<br>2、<font color="#dd0000">key必须为不可变数据类型（除列表字典外）、必须唯一</font><br>3、可存放任意多个value、可修改、不唯一<br>4、<font color="#dd0000">无序</font>通过key而不是索引号进行取值<br>5、查询速度快，且不受dict大小影响（学完hash后讲原因）</p><h2 id="（四）增加修改操作"><a href="#（四）增加修改操作" class="headerlink" title="（四）增加修改操作"></a>（四）增加修改操作</h2><pre class="language-python" data-language="python"><code class="language-python">staff_dic &#x3D; &#123;                          &#39;Alex&#39;: [23, &#39;CEO&#39;, 66000],        &#39;黑姑娘&#39;: [24, &#39;行政&#39;, 4000],           &#39;佩奇&#39;: [26, &#39;讲师&#39;, 40000]        &#125;                                  staff_dic[&#39;耿天霸&#39;] &#x3D; [24, &#39;学生&#39;, 1500]  # 当字典中已有该key值时，会对该key对应的value进行修改</code></pre><h2 id="（五）删除操作"><a href="#（五）删除操作" class="headerlink" title="（五）删除操作"></a>（五）删除操作</h2><pre class="language-python" data-language="python"><code class="language-python">staff_dic.pop(&#39;Alex&#39;)  # 删除指定keydel staff_dic[&#39;Alex&#39;]  # 删除指定key，同pop()staff_doc.clear()  # 清空字典</code></pre><h2 id="（六）查找操作"><a href="#（六）查找操作" class="headerlink" title="（六）查找操作"></a>（六）查找操作</h2><pre class="language-python" data-language="python"><code class="language-python">staff_dic.keys()  # 以列表形式返回所有keystaff_dic.values()  # 以列表形式返回所有valuestaff_dic.items()  # 以列表形式返回所有字典，每个字典用元组封装staff_dic.get(&#39;key&#39;)  # 返回对应key的value值，没有返回None </code></pre><p>※字典不支持同时查多个值，一次只能查一个值；字典不支持通过value查找key，只能通过key查value</p><h2 id="（七）循环"><a href="#（七）循环" class="headerlink" title="（七）循环"></a>（七）循环</h2><pre class="language-python" data-language="python"><code class="language-python">for k in staff_dic.keys():  # 遍历所有keyfor v in staff_dic.values():  # 遍历所有valuefor k,v in staff_dic.items():    print(k, v)  # 遍历所有key和value# 官方推荐取法for k in staff_dic:  # 遍历所有keyfor k in staff_dic:    print(staff_dic[k])  # 遍历所有value for k in staff_dic():  # 遍历所有值    print(k, staff_dic[k])  </code></pre><h2 id="（八）求长度"><a href="#（八）求长度" class="headerlink" title="（八）求长度"></a>（八）求长度</h2><pre class="language-python" data-language="python"><code class="language-python">len(staff_dic)  </code></pre><h2 id="（九）嵌套"><a href="#（九）嵌套" class="headerlink" title="（九）嵌套"></a>（九）嵌套</h2><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; dic &#x3D; &#123;&#125;&gt;&gt;&gt; dic[&#39;耿天霸&#39;] &#x3D; &#123;&#39;age&#39;: 25,&#39;salary&#39;:1500&#125;&gt;&gt;&gt; dic[&#39;耿天霸&#39;][&#39;age&#39;]25  </code></pre><h1 id="四、集合"><a href="#四、集合" class="headerlink" title="四、集合"></a>四、集合</h1><p> &amp;emsp;数学中的集合概念，并主要进行交集、并集、补集和交叉补集运算</p><pre class="language-python" data-language="python"><code class="language-python"># 无序且不重复five_man &#x3D; set()# 交集set.intersection() # 并集set.union()# 补集set.difference()# 交叉补集set.symmetric_difference()</code></pre><h1 id="五、字符编码"><a href="#五、字符编码" class="headerlink" title="五、字符编码"></a>五、字符编码</h1><p> &amp;emsp;通过字符编码，建立数字和文字的关系，达到用电流进行编码</p><h2 id="（一）从二进制到英文字母"><a href="#（一）从二进制到英文字母" class="headerlink" title="（一）从二进制到英文字母"></a>（一）从二进制到英文字母</h2><p>1、二进制<br> &amp;emsp;通过二进制建立电流和十进制的关系</p><p>2、<font color="#dd0000">ASCII码</font></p><div align=center>&emsp;&emsp;通过ASCII码建立十进制和英文和符号的关系<img src="https://img-blog.csdnimg.cn/eb871791c5df43859b67da75a2f27be8.png" width = 100%></div><font color="#dd0000">&emsp;&emsp;这张表就是计算机显示各种文字和符号的基石</font>，ASCII（American Standard Code for Information Interchange）码，是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其它西欧语言。<div align=center><img src="https://img-blog.csdnimg.cn/4fca00f3cc714dc8a97c381b29575b9e.png" width = 100%></div><p>3、验证<br> &amp;emsp;通过ord()方法获取对应字符的十进制ASCII编码</p><pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; ord(&#39;0&#39;)  # 返回48对应0的十进制ASCII编码48</code></pre><p>4、问题</p><div align=center><img src="https://img-blog.csdnimg.cn/5fef903ebd9743fe8da370d75027d88d.png" width = 100%></div> &emsp;由于ASCII码是255个字符，对应的二进制位数是8，因此使用8位作为一个字符的长度，不够前方用0填充<h2 id="（二）计算机容量单位"><a href="#（二）计算机容量单位" class="headerlink" title="（二）计算机容量单位"></a>（二）计算机容量单位</h2><p>比特（bit）：一个二级制位，<font color="#dd0000">计算机中最小的表示单位</font><br>字节（bytes）：8个bit组成一个字节，<font color="#dd0000">计算机中最小的存储单位</font><br>1KB &#x3D; 1024B<br>1MB &#x3D; 1024KB<br>1GB &#x3D; 1024MB<br>1TB &#x3D; 1024GB<br>1PB &#x3D; 1024TB<br>1EB &#x3D; 1024PB<br>1ZB &#x3D; 1024EB<br>1YB &#x3D; 1024ZB</p><h2 id="（三）计算机怎么识别中文"><a href="#（三）计算机怎么识别中文" class="headerlink" title="（三）计算机怎么识别中文"></a>（三）计算机怎么识别中文</h2><p> &amp;emsp;我国1980年设计的中文编码表，一共存储了6763个汉字，使用两个字节进行存储，长成下面这样。</p><div align=center><img src="https://img-blog.csdnimg.cn/dba244cc3a5042d0b674e67cd83e988a.png" width = 100%></div> &emsp;这个表格比较大，像上面的一块块的文字区域有72个，这导致通过一个字节是没办法表示一个汉字的(因为一个字节最多允许256个字符变种，你现在6千多个，只能2个字节啦，2**16=65535个变种)。有了gb2312，我们就能愉快的写中文啦。 &emsp;但我们写字竟然会出现中英混杂的情况，比如“我是路飞学城，我的英文名叫Luffycity."，这种你怎么办?这就要求你必须在GB2312里同时支持英文，但是还不能是2个字节表示一个英文字母。人家ASCII用一个字符，你用2个，那一个2mb大小的英文文档只要一改编码，就立刻变成4mb,太坑爹，中国人你有钱也不能这么造呀。所以中国砖家们又通过神奇手段兼容了ASSCII,即遇到中文用2个字节，遇到英文直接用ASCII的编码。怎么做到的呢? &emsp;如何区别连在一起的2个字节是代表2个英文字母，还是一个中文汉字呢?中国人如此聪明，决定，<font color="#dd0000">如果2个字节连在一起，且每个字节的第1位(也就是相当于128的那个2进制位)如果是1，就代表这是个中文，</font>这个首位是128的字节被称为高字节。也就是2个高孛节连在一起，必然就是一个中文。你怎么如此笃定?因为0-127已经表示了英文的绝大部分字符，128-255是ASCII的扩展表，表示的都是极特殊的字符，一般没什么用。所以中国人就直接拿来用了。 &emsp;自1980年发布GB2312之后，中文一直用着没啥问题，随着个人电脑进入千家万户，有人发现，自己的名字竟然打印不出来，因为起的太生僻了。 &emsp;于是1995年，砖家们又升级了gb2312,加入更多字符，连什么藏语、维吾尔语、日语、韩语、蒙古语什么的统统都包含进去了，国家统一亚洲的野心从这些基础工作中就可见一斑哈。这个编码叫GBK，一直到现在，我们的windows电脑中文版本的编码就是<font color="#dd0000">GBK</font>.<h2 id="（四）编码的战国时代"><a href="#（四）编码的战国时代" class="headerlink" title="（四）编码的战国时代"></a>（四）编码的战国时代</h2><p> &amp;emsp;中国人在搞自己编码的同时，世界上其它非英语国家也得用电脑呀，于是都搞出了自己的编码，你可以想得到的是，全世界有上百种语言，日本把日文编到<strong>Shift_JIS</strong>里，韩国把韩文编到<strong>Euc-kr</strong>里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。之前你从玩个日本游戏，往自己电脑上一装,就显示乱码了。</p><h4>解决方式：</h4><p> &amp;emsp;这么乱极大了阻碍了不同国家的信息传递，于是联合国出面，发誓要解决这个混乱局面。因此,<strong>Unicode</strong>应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode 2-4字节已经收录<strong>136690</strong>个字符，并还在一直不断扩张中…。Unicode标准也在不断发展，但<strong>最常用的是用2个字节表示一个字符</strong>(如果要用到非常<strong>偏僻的字符，就需要4个字节</strong>)。现代操作系统和大多数编程语言都直接支持Unicode。</p><h4>Unicode的优势：</h4>1．支持全球所有语言2.可以跟各种语言的编码自由转换，也就是说，即使你gbk编码的文字，想转成unicode很容易。<p> &amp;emsp;为何unicode可以跟其它语言互相转换呢?因为有跟所有语言都有对应关系，这样做的好处是可以让那些已经用gbk或其它编码写好的软件容易的转成unicode编码，<font color="#dd0000"><strong>利于unicode的推广</strong></font>。下图就是unicode跟中文编码的对应关系</p><div align=center><img src="https://img-blog.csdnimg.cn/ab9f91d4a2324609b459cf4cde99921a.png" width = 100%></div><h2 id="（五）UTF-8编码："><a href="#（五）UTF-8编码：" class="headerlink" title="（五）UTF-8编码："></a>（五）UTF-8编码：</h2><p> &amp;emsp;新的问题又出现了:如果统-成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编 码需要多一倍的存储空间，由于计算机的内存比较大，并且字符串在内容中表示时也不会特别大，所以内存可以使用unicode来处理，但是存储和网络传输时一般数据都会非常多，那么增加一倍将是无法容忍的! ! !<br> &amp;emsp;为了解决存储和网络传输的问题，出现了Unicode Transformation Format,学术名UTF, 即:对unicode字符进行转换，以便于在存储和网络传输时可以节省空间!</p><h4>●UTF-8：</h4> 使用1、2、3、4个字节表示所有字符;优先使用1个字节、无法满足则使增加一个字节，最多4个字节。英文占1个字节、欧洲语系占2个、东亚占3个，其它及特殊字符占4个。<h4>●UTF-16:</h4> 使用2、4个字节表示所有字符;优先使用2个字节，否则使用4个字节表示。<h4>●UTF-32:</h4>使用4个字节表示所有字符。<p><font color="#dd0000"><strong>总结: UTF是为unicode编码设计的一种在存储和传输时节省空间的编码方案。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间</strong></font></p><div align=center><img src="https://img-blog.csdnimg.cn/7021815f69534e4d95e31e5d85f0a20c.png" width = 100%></div> &emsp;从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际 上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 &emsp;搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式:1、在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。2、用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。<div align=center><img src="https://img-blog.csdnimg.cn/bc8c412498d048de8830eb609cb9b4fb.png" width = 50%></div><h2 id="（六）常用编码一览表"><a href="#（六）常用编码一览表" class="headerlink" title="（六）常用编码一览表"></a>（六）常用编码一览表</h2><div align=center><img src="https://img-blog.csdnimg.cn/63e3a997f2de48c680b54a288af2427e.png" width = 100%></div><h2 id="（七）Py2-VS-Py3编码"><a href="#（七）Py2-VS-Py3编码" class="headerlink" title="（七）Py2 VS Py3编码"></a>（七）Py2 VS Py3编码</h2><p> &amp;emsp;python生下来的时候（1989年）还没有unicode&amp;utf-8,所以龟叔选用的默认编码只能是ASCI, -直到py2.7,用的还是ASCI,导致Py默认只支持英文想支持其它语言，必须单独配置。<br> &amp;emsp;到了Py3推出后,终于把默认编码改成了unicode,同时文件存储编码变成了utf-8，意味着，不用任何声明，你就可以写各种语言文字在你的Python程序里。从此，程序们手牵手过上了快乐的生活。</p><h1 id="六、十六进制"><a href="#六、十六进制" class="headerlink" title="六、十六进制"></a>六、十六进制</h1><h2 id="（一）概念"><a href="#（一）概念" class="headerlink" title="（一）概念"></a>（一）概念</h2><p> &amp;emsp;16进制，英文名称Hexadecimal(简写Hex)，在数学中是一种逢16进1的进位制。一般用数字0到9和字母A到F（或a<del>f ）表示，其中:A</del>F表示10~15，这些称作十六进制数字，比如十进制13用16进制表示是D,28用16进制是1C。</p><div align=center><img src="https://img-blog.csdnimg.cn/971bb0638c084bac8c9fa0ede3206462.png" width = 100%></div><h2 id="（二）应用"><a href="#（二）应用" class="headerlink" title="（二）应用"></a>（二）应用</h2><p> &amp;emsp;16进制在计算机领域应用普遍，常见的有htm\css的颜色表、mac地址、字符编码等都用16进制来表示</p><h1 id="七、快递分拣小程序"><a href="#七、快递分拣小程序" class="headerlink" title="七、快递分拣小程序"></a>七、快递分拣小程序</h1><h2 id="（一）需求"><a href="#（一）需求" class="headerlink" title="（一）需求"></a>（一）需求</h2><p> &amp;emsp;将数据源里的快递信息进行分拣，最终生成的数据格式如下:</p><div align=center><img src="https://img-blog.csdnimg.cn/c5c8b9c2541e4bd8ac8061e19d69a320.png" width = 80%></div><h2 id="（二）数据源"><a href="#（二）数据源" class="headerlink" title="（二）数据源"></a>（二）数据源</h2><pre class="language-python" data-language="python"><code class="language-python"></code></pre><p>​<br>​<br>​                                                                                                                     </p>]]></content>
      
      
      <categories>
          
          <category> Python零基础到精通7天速成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day2-开发年会抽奖小程序</title>
      <link href="/2022/05/03/python-ru-men-dao-jing-tong-2/"/>
      <url>/2022/05/03/python-ru-men-dao-jing-tong-2/</url>
      
        <content type="html"><![CDATA[<h3 id="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"><a href="#本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记" class="headerlink" title="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"></a>本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记</h3><h3 id="视频链接-Python零基础到精通7天速成"><a href="#视频链接-Python零基础到精通7天速成" class="headerlink" title="视频链接:Python零基础到精通7天速成"></a>视频链接:<a href="https://www.bilibili.com/video/BV1Gf4y1q7SG?share_source=copy_web">Python零基础到精通7天速成</a></h3><span id="more"></span><h1 id="一、for循环"><a href="#一、for循环" class="headerlink" title="一、for循环"></a>一、for循环</h1><h2 id="（一）多次猜年龄"><a href="#（一）多次猜年龄" class="headerlink" title="（一）多次猜年龄"></a>（一）多次猜年龄</h2><pre class="language-python" data-language="python"><code class="language-python">true_age &#x3D; 48for i in range(3):        guess_age &#x3D; int(input(&#39;please guess a number: &#39;))    if guess_age &gt; true_age:        print(&#39;猜的太大了&#39;)    elif guess_age &lt; true_age:        print(&#39;猜的太小了&#39;)    else:        # 只要猜对就退出程序，并打印提示语句        exit(&#39;恭喜你，猜对了&#39;)</code></pre><h2 id="（二）打印0-100的奇偶数"><a href="#（二）打印0-100的奇偶数" class="headerlink" title="（二）打印0-100的奇偶数"></a>（二）打印0-100的奇偶数</h2><pre class="language-python" data-language="python"><code class="language-python">for i in range(101):    if i%2 &#x3D;&#x3D; 0:  # 说明i是偶数        print(f&#39;&#123;i&#125; is even&#39;)    else:        print(f&#39;&#123;i&#125; is odd&#39;)</code></pre><h2 id="（三）打印门牌号"><a href="#（三）打印门牌号" class="headerlink" title="（三）打印门牌号"></a>（三）打印门牌号</h2><pre class="language-python" data-language="python"><code class="language-python"># 一共5层，每层9个房间，打印出房间号格式如L2-203(2楼3号房)for floor in range (1, 6):    for room in range(1, 10):        print(f&#39;L&#123;floor&#125;-&#123;floor&#125;0&#123;room&#125;&#39;)</code></pre><h2 id="（四）打印下方图形"><a href="#（四）打印下方图形" class="headerlink" title="（四）打印下方图形"></a>（四）打印下方图形</h2><div align=center><img src="https://img-blog.csdnimg.cn/b7a57af6ed454d219eb4e8353ed19bc9.png" width = 10%></div><pre class="language-python" data-language="python"><code class="language-python">for i in range(10):    if i &lt;&#x3D;5:        print(i*&quot;*&quot;)    else:        print((10-i)*&quot;*&quot;)</code></pre><h1 id="二、break和continue"><a href="#二、break和continue" class="headerlink" title="二、break和continue"></a>二、break和continue</h1><p><font color="#dd0000">用于控制循环流程，只能在循环中使用</font></p><h2 id="（一）break"><a href="#（一）break" class="headerlink" title="（一）break"></a>（一）break</h2><p> &amp;emsp;<font color="#dd0000">当程序遇到break，就会结束当前循环</font>（如果是多层嵌套循环，只结束当前循环）</p><pre class="language-python" data-language="python"><code class="language-python"># 一共5层，每层9个房间，当遇到房间404时，不再打印4层房间号for floor in range (1, 6):    for room in range(1, 10):        if floor&#x3D;&#x3D;4 and room&#x3D;&#x3D;4:            break        print(f&#39;L&#123;floor&#125;-&#123;floor&#125;0&#123;room&#125;&#39;)</code></pre><h2 id="（二）continue"><a href="#（二）continue" class="headerlink" title="（二）continue"></a>（二）continue</h2><p> &amp;emsp;<font color="#dd0000">当程序遇到continue，就会结束本次循环，直接进入下一次循环</font></p><pre class="language-python" data-language="python"><code class="language-python"># 一共5层，每层9个房间，当遇到第三层时不打印房间号其它层都打印for floor in range (1, 6):    if floor &#x3D;&#x3D; 3:        continue    for room in range(1, 10):        print(f&#39;L&#123;floor&#125;-&#123;floor&#125;0&#123;room&#125;&#39;)</code></pre><h1 id="三、while"><a href="#三、while" class="headerlink" title="三、while"></a>三、while</h1><p><font color="#dd0000">&amp;emsp;&amp;emsp;与for循环不一样的是，while循环的次数可以是不定的，只要条件满足就可以一直循环下去。<br></font></p><pre class="language-python" data-language="python"><code class="language-python"># while版猜年龄，当猜到的年龄和真实年龄不符时，继续猜提示，猜到时退出。true_age &#x3D; 48guess_age &#x3D; 0while guess_age !&#x3D; true_age:    guess_age &#x3D; int(input(&#39;please guess a number: &#39;))    if guess_age &gt; true_age:        print(&#39;猜的太大了&#39;)    elif guess_age &lt; true_age:        print(&#39;猜的太小了&#39;)    else:        print(&#39;恭喜你，猜对了&#39;)        break</code></pre><h1 id="四、打印九九乘法表"><a href="#四、打印九九乘法表" class="headerlink" title="四、打印九九乘法表"></a>四、打印九九乘法表</h1><div align=center><img src="https://img-blog.csdnimg.cn/cc75c013d07b42c0a36608ec8ab288e0.png" width = 80%></div><pre class="language-python" data-language="python"><code class="language-python">for i in range(1, 10):    for j in range(1,i+1):        print(f&#39;&#123;i&#125;*&#123;j&#125;&#x3D;&#123;i*j&#125;&#39;, end&#x3D;&#39; &#39;)    print()  # 每执行一次大循环，进行换行</code></pre><h1 id="五、京牌摇号小程序"><a href="#五、京牌摇号小程序" class="headerlink" title="五、京牌摇号小程序"></a>五、京牌摇号小程序</h1><h2 id="（一）需求："><a href="#（一）需求：" class="headerlink" title="（一）需求："></a>（一）需求：</h2><p>1、允许用户最多选三次<br>2、每次放出20个车牌供用户选择<br>3、京[A-Z]-[xxxxx]，可以是字母和数字的组合</p><h2 id="（二）思路"><a href="#（二）思路" class="headerlink" title="（二）思路"></a>（二）思路</h2><p>1、车牌由两个部分组成，第一部分京+A-Z的随机数；第二部分五位字母和数字组合随机数<br>2、随机数的实现<br>（1）random模块</p><pre class="language-python" data-language="python"><code class="language-python">import randomrandom.choice(&#39;abcdefg&#39;)  # 参数也可以是一个列表s &#x3D; &#39;abcdefghijk&#39;random.sample(s, 3)  # 从数据源s中随机选三个值random.randint(1, 100)  # 打印一个1到100的随机数 </code></pre><p>（2）string模块</p><pre class="language-python" data-language="python"><code class="language-python">import stringstring.digits  #打印数字string.ascii_letters  # 大写字母加小写字母string.ascii_uppercase  # 大写字母string.ascii_lowercase  # 小写字母string.punctuation  # 打印特殊字符 </code></pre><p>（3）join方法</p><pre class="language-python" data-language="python"><code class="language-python">引号内为链接符，join接受列表，列表元素必须全部为字符串&#39;--&#39;.join([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;,&#39;1&#39;,&#39;2&#39;])</code></pre><h2 id="（三）代码"><a href="#（三）代码" class="headerlink" title="（三）代码"></a>（三）代码</h2><pre class="language-python" data-language="python"><code class="language-python">import randomimport stringtimes &#x3D; 0while times &lt; 3:    times +&#x3D; 1    license_plates &#x3D; []    for i in range(20):        area &#x3D; random.choice(string.ascii_uppercase)  # 选择A-Z其中一个作为地区        part1 &#x3D; &#39;京&#39; + area + &#39;-&#39;  # 拼接车牌第一部分        num_str &#x3D; string.digits + string.ascii_uppercase  # 车牌第二部分在A-Z和0-9数字中选择        part2 &#x3D; &#39;&#39;.join(random.sample(num_str, 5))  # 拼接车牌第二部分        license_plates.append(part1 + part2)  # 拼接整个车牌    print(license_plates)    choice &#x3D; input(f&#39;please choice a license_plate  in the list \    and you hanv 3 chance to choice a number: you have &#123;3 - times&#125; times left： &#39;)    print(str.center(&#39;&#39;, 80, &#39;~&#39;))    if choice in license_plates:        exit(f&#39;your license_plates is &#123;choice&#125;&#39;)</code></pre><h1 id="六、综合联系–年会抽奖小程序"><a href="#六、综合联系–年会抽奖小程序" class="headerlink" title="六、综合联系–年会抽奖小程序"></a>六、综合联系–年会抽奖小程序</h1><h2 id="（一）需求"><a href="#（一）需求" class="headerlink" title="（一）需求"></a>（一）需求</h2><p> &amp;emsp;张三科技公司有300个员工，开年会抽奖，奖项如下:<br>一等奖 3名：泰国五日游<br>二等奖 6名：iPhone手机<br>三等奖 30名：羽毛球拍一副</p><h2 id="（二）规则"><a href="#（二）规则" class="headerlink" title="（二）规则"></a>（二）规则</h2><p>1、共抽三次，第一次抽三等奖，第二次抽二等奖，第三次抽一等奖<br>2、每个员工限中奖一次</p><h2 id="（三）代码-1"><a href="#（三）代码-1" class="headerlink" title="（三）代码"></a>（三）代码</h2><pre class="language-python" data-language="python"><code class="language-python">import randomemployees &#x3D; [employee for employee in range(300)]  # 一共300名员工winners_each_round &#x3D; [30, 6, 3]  # 抽3轮每轮中奖人数times &#x3D; 0def choice_winner(participants, number_of_winners):  # 定义函数，实现抽奖并移除中奖人员    winners &#x3D; random.sample(participants, number_of_winners)    print(f&#39;中&#123;times+1&#125;等奖人员编号为：&#123;winners&#125;&#39;)    for winner in winners:        participants.remove(winner)while times &lt; len(winners_each_round):  # 进行抽奖,一共抽三轮    choice_winner(employees, winners_each_round[times])    times +&#x3D; 1</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python零基础到精通7天速成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算R脚本</title>
      <link href="/2022/05/01/ji-suan-r-jiao-ben/"/>
      <url>/2022/05/01/ji-suan-r-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h2 id="一、计算公式"><a href="#一、计算公式" class="headerlink" title="一、计算公式"></a>一、计算公式</h2><div align=center><img src="https://img-blog.csdnimg.cn/74d684baa75a48028a052f83ff4ffd60.png" width = 80%></div><h2 id="二、数据源"><a href="#二、数据源" class="headerlink" title="二、数据源"></a>二、数据源</h2><h3 id="amp-emsp-国家地球系统科学数据中心-http-www-geodata-cn"><a href="#amp-emsp-国家地球系统科学数据中心-http-www-geodata-cn" class="headerlink" title="&amp;emsp;国家地球系统科学数据中心(http://www.geodata.cn/)"></a>&amp;emsp;国家地球系统科学数据中心(<a href="http://www.geodata.cn/">http://www.geodata.cn/</a>)</h3><img src="/2022/05/01/ji-suan-r-jiao-ben/d2bf59b83f59438d87a7b283e11a8a09.png" class="" title="img"><p><font color="#dd0000">※该数据为.nc格式，需要转换成tif格式</font></p><h2 id="三、数据输出"><a href="#三、数据输出" class="headerlink" title="三、数据输出"></a>三、数据输出</h2><h3 id="1、年降雨总量栅格数据"><a href="#1、年降雨总量栅格数据" class="headerlink" title="1、年降雨总量栅格数据"></a>1、年降雨总量栅格数据</h3><h3 id="2、各月降雨侵蚀因子R"><a href="#2、各月降雨侵蚀因子R" class="headerlink" title="2、各月降雨侵蚀因子R"></a>2、各月降雨侵蚀因子R</h3><h3 id="3、年总降雨量侵蚀因子R"><a href="#3、年总降雨量侵蚀因子R" class="headerlink" title="3、年总降雨量侵蚀因子R"></a>3、年总降雨量侵蚀因子R</h3><h2 id="四、操作过程"><a href="#四、操作过程" class="headerlink" title="四、操作过程"></a>四、操作过程</h2><h3 id="1、将12各月的降雨量栅格数据输入文件夹"><a href="#1、将12各月的降雨量栅格数据输入文件夹" class="headerlink" title="1、将12各月的降雨量栅格数据输入文件夹"></a>1、将12各月的降雨量栅格数据输入文件夹</h3><h3 id="2、更改文件工作环境，运行脚本"><a href="#2、更改文件工作环境，运行脚本" class="headerlink" title="2、更改文件工作环境，运行脚本"></a>2、更改文件工作环境，运行脚本</h3><h2 id="五、Python2源码"><a href="#五、Python2源码" class="headerlink" title="五、Python2源码"></a>五、Python2源码</h2><pre class="language-python" data-language="python"><code class="language-python"># coding&#x3D;utf-8  ##Python2不支持中文# 导入模块import arcpyfrom arcpy.sa import *# 设置工作环境arcpy.env.workspace &#x3D; &quot;C:&#x2F;Users&#x2F;Geng&#x2F;Desktop&#x2F;test&#x2F;&quot;# 创建变量rasters &#x3D; arcpy.ListRasters(&quot;*&quot;, &quot;tif&quot;)  # 将工作空间中所有.tif栅格文件存入raster变量sum_pre &#x3D; 0  # 初始化年降雨量r_month &#x3D; []  # 创建空列表存储12各月的降雨量侵蚀因子rr_year &#x3D; 0  # 初始化年降雨量侵蚀因子# 计算年总降水量for raster in rasters:    print raster    sum_pre +&#x3D; Raster(raster)# 编辑公式通过降雨量计算降雨侵蚀因子rdef calculation_r(pre_mon, pre_year):    # 该公式计算出的降雨侵蚀因子有异常值(Nodata)    r_month_with_nodata &#x3D; 17.02 * (1.735 * Power(10, (1.5 * Log10(Power(pre_mon, 2)&#x2F;pre_year) - 0.8188)))    return Con(pre_mon &#x3D;&#x3D; 0, 0, r_month_with_nodata)  # 处理异常值(将Nodata 赋值为0)# 根据12个月的r，计算该年的rfor raster in rasters:    r_month.append(calculation_r(Raster(raster), sum_pre))    r_year +&#x3D; r_month[-1]    # 输出每月r    r_month[-1].save(arcpy.env.workspace + &quot;&#x2F;r_%s.tif&quot; %raster)# 输出结果r_year.save(arcpy.env.workspace + &quot;&#x2F;r_year.tif&quot;)  # 输出年尺度rsum_pre.save(arcpy.env.workspace + &quot;&#x2F;pre_year.tif&quot;)  # 输出年尺度pre</code></pre>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day1-Python新手小白上路</title>
      <link href="/2022/04/22/python-ru-men-dao-jing-tong-1/"/>
      <url>/2022/04/22/python-ru-men-dao-jing-tong-1/</url>
      
        <content type="html"><![CDATA[<h3 id="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"><a href="#本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记" class="headerlink" title="本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记"></a>本文章为金角大王Alex《Python零基础到精通7天速成》视频笔记</h3><h3 id="视频链接-Python零基础到精通7天速成"><a href="#视频链接-Python零基础到精通7天速成" class="headerlink" title="视频链接:Python零基础到精通7天速成"></a>视频链接:<a href="https://www.bilibili.com/video/BV1Gf4y1q7SG?share_source=copy_web">Python零基础到精通7天速成</a></h3><span id="more"></span><h1 id="一、Python语言简介"><a href="#一、Python语言简介" class="headerlink" title="一、Python语言简介"></a>一、Python语言简介</h1><h2 id="1、Python的优势领域"><a href="#1、Python的优势领域" class="headerlink" title="1、Python的优势领域"></a>1、Python的优势领域</h2><img src="/2022/04/22/python-ru-men-dao-jing-tong-1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16.png" class="" title="在这里插入图片描述"><h2 id="2、Python的排名"><a href="#2、Python的排名" class="headerlink" title="2、Python的排名"></a>2、Python的排名</h2><p><a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a></p><h1 id="二、安装Python解释器"><a href="#二、安装Python解释器" class="headerlink" title="二、安装Python解释器"></a>二、安装Python解释器</h1><h2 id="一-为什么要安装Python解释器"><a href="#一-为什么要安装Python解释器" class="headerlink" title="(一)为什么要安装Python解释器"></a>(一)为什么要安装Python解释器</h2><div align=center><img src="https://img-blog.csdnimg.cn/bab3384778a54f1fbe8de609cdc756f0.png??" width = 65%></div><h2 id="（二）python解释器安装"><a href="#（二）python解释器安装" class="headerlink" title="（二）python解释器安装"></a>（二）python解释器安装</h2><p>1、官网安装<a href="https://www.python.org/">https://www.python.org/</a><br>（1）将Python添加到系统变量中，如不添加只能在安装Python的目录下才能调出Python解释器<br>（2）安装好后在cmd命令行输入Python，即可进入Python交互式环境，输入exit()退出<br>2、写下第一行代码<br> &amp;emsp;书写Python代码可以通过两种方式，一致是在Python交互器直接写，一种是写到文件里并保存为.py文件<br>（1）交互器直接写</p><img src="/2022/04/22/python-ru-men-dao-jing-tong-1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_19,color_FFFFFF,t_70,g_se,x_16.png" class="" title="在这里插入图片描述"><p>（2）写到文件里</p><img src="/2022/04/22/python-ru-men-dao-jing-tong-1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16-16547800411713.png" class="" title="在这里插入图片描述"><p>（3）写下第一行代码</p><pre class="language-python" data-language="python"><code class="language-python">print(&#39;Hello world!&#39;)</code></pre><p>（4）执行<br>a、交互器执行：命令行输入Python版本 + 空格 + 完整路径的.py文件（<font color="#dd0000">或直接将.py文件拖入</font>）<br>b、编程软件执行：找对对应的.py文件，run<br>※Python的后缀.py作用是供编程人员识别文件类型，不加任何后缀或加入其它后缀（如：.jpeg,.md）Python解释器都会按照Python语法对文件内容进行解析，对不符合Python语法的代码进行报错。</p><h1 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h1><h2 id="（一）快速扫盲CPU、内存、硬盘关系"><a href="#（一）快速扫盲CPU、内存、硬盘关系" class="headerlink" title="（一）快速扫盲CPU、内存、硬盘关系"></a>（一）快速扫盲CPU、内存、硬盘关系</h2><img src="/2022/04/22/python-ru-men-dao-jing-tong-1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16-16547800505065.png" class="" title="在这里插入图片描述"><p>1、硬盘负责永久性存储数据，为CPU提供计算的数据源，并保存计算结果。<br>2、但硬盘速度太慢，而CPU的处理速度很快，对于CPU而言硬盘读写数据时间消耗过大。<br>3、将一部分数据先读到内存，CPU只和内存进行通信，以解决CPU和硬盘速度的冲突。<br>4、举例：<br> &amp;emsp;当对一个很大的word文档进行操作时，刚打开时会很慢（内存从硬盘读取数据），打开后进行处理时反应很快（CPU和内存进行交互），保存时又会很慢（内存将数据存入硬盘）。</p><h2 id="（二）变量"><a href="#（二）变量" class="headerlink" title="（二）变量"></a>（二）变量</h2><h3 id="1、什么是变量"><a href="#1、什么是变量" class="headerlink" title="1、什么是变量"></a>1、什么是变量</h3><p> &amp;emsp;内存是一个仓库，变量就是仓库中<strong>存放程序运行数据的容器</strong>。</p><div align=center><img src="https://img-blog.csdnimg.cn/61aefc3170814ad08463dbfa78a68ad3.png?" width = 65%></div><center><font color="#dd0000">变量名=货物编号</font></center><center><font color="#dd0000">变量值=货物</font></center><center><font color="#dd0000">内存地址=一个个货架</font></center>举例： &emsp;变量名是衣服的编号，可以叫A区、B区，变量值就是衣服本身，通过货物编号（变量名）可以调用衣服（变量值），衣服的物理位置在具体某个货架（内存地址）上。<h3 id="2、变量的使用规则"><a href="#2、变量的使用规则" class="headerlink" title="2、变量的使用规则"></a>2、变量的使用规则</h3><p> &amp;emsp;先定义，在调用</p><h3 id="3、变量的命名规则"><a href="#3、变量的命名规则" class="headerlink" title="3、变量的命名规则"></a>3、<font color="#dd0000">变量的命名规则</font></h3><p>（1）在程序全局都会用到的变量，尽量定义在文件开头。<br>（2）变量名<strong>只能是字母、数字、下划线的组合，且不能以数字开头</strong>，其它形式均不合法。<br>（3）Python占用的关键字不建议声明为变量[‘and’,’as’,’assert’,’break’,’class’,’continue’,’def’,’del’,’elif’,’except’,’exec’,’finally’,’for’,’form’,’gloabl’,’if’,’import’,’in’,’is’,’lambda’,’not’,’or’,’pass’,’print’,’raise’,’return’,’try’,’while’,’with’,’yield’]</p><h3 id="4、常用变量名定义规范"><a href="#4、常用变量名定义规范" class="headerlink" title="4、常用变量名定义规范"></a>4、常用变量名定义规范</h3><p>（1）驼峰体(c,c#):每个单词首字母大写</p><pre class="language-python" data-language="python"><code class="language-python">AgeOfOldBoy&#x3D; 56NumberOfStudents &#x3D; 80</code></pre><p>（2）<br><font color="#dd0000">下划线(Python):每个单词下划线隔开</font></p><pre class="language-python" data-language="python"><code class="language-python">age_of_old_boy&#x3D; 56number_of_students &#x3D; 80</code></pre><p>（3）<font color="#dd0000">定义变量不好的方式</font><br>a. 用拼音、中文做变量名<br>b. 变量名过长<br>c. 不能让人通过名字就看出来什么意思<br>d. 首字母大写，是用来定义类名的</p><h3 id="5、变量的修改和删除"><a href="#5、变量的修改和删除" class="headerlink" title="5、变量的修改和删除"></a>5、变量的修改和删除</h3><p>修改：重新赋值，<font color="#dd0000">将货物编号（变量名）揭下来，贴到新的货物（变量）上。原来的货物（变量）还在仓库（内存）中，只是不能根据原来的货物编号（变量名）找到它。Python解释器对定期对没有货物编号（变量名）的货物（变量）进行删除</font><br>删除：del+空格+变量名，<font color="#dd0000">将货物编号（变量名）删除，原来的货物（变量）还在仓库（内存）中，只是不能根据原来的货物编号（变量名）找到它。Python解释器对定期对没有货物编号（变量名）的货物（变量）进行删除</font><br>※</p><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; &#39;GengTianBa&#39;name_new &#x3D; namename &#x3D; &#39;Gengyu&#39;print(name)print(name_new)输出：&#39;GengTianBa&#39;&#39;Gengyu&#39;</code></pre><p>name_new &#x3D; name:<font color="#dd0000">将新货物编号（name_new）指向原来货物编号（name）下的货物（’GengTianBa’），而不是指向原来的货物编号（name）。</font></p><h1 id="四、数据类型初始"><a href="#四、数据类型初始" class="headerlink" title="四、数据类型初始"></a>四、数据类型初始</h1><p>目前学习：整型、浮点、字符串、布尔、列表<br>往后学习：元组、字典、集合<br>使用type()查看</p><h2 id="（一）整型（int）"><a href="#（一）整型（int）" class="headerlink" title="（一）整型（int）"></a>（一）整型（int）</h2><p> &amp;emsp;就是整数</p><h2 id="（二）浮点型（float）"><a href="#（二）浮点型（float）" class="headerlink" title="（二）浮点型（float）"></a>（二）浮点型（float）</h2><p> &amp;emsp;就是小数</p><h2 id="（三）字符串（str）"><a href="#（三）字符串（str）" class="headerlink" title="（三）字符串（str）"></a>（三）<font color="#dd0000">字符串（str）</font></h2><p>1、字符串的定义<br> &amp;emsp;Python中加了引号的都会被认为是字符串<br>（1）单引号和双引号没有任何区别，只考虑单双引号的配合使用</p><pre class="language-python" data-language="python"><code class="language-python">msg &#x3D; &quot;my name is GY, I&#39;m 25 years old&quot;</code></pre><p>（2）多行字符串必须用多引号<br>2、<font color="#dd0000">字符串的方法</font><br>输入<code>str.＋table健</code>进行查看</p><div align=center><img src="https://img-blog.csdnimg.cn/988cac4caf72489eb738f82e429801e0.png" width = 80%></div>3、字符串拼接 &emsp;数字可以进行加减乘除运算，字符串只能进行“相加”和“相乘”。其中相加是字符串和字符串进行，相乘是字符串和数字进行。<h2 id="（四）布尔（bool）"><a href="#（四）布尔（bool）" class="headerlink" title="（四）布尔（bool）"></a>（四）布尔（bool）</h2><p> &amp;emsp;就两个值，一个True（真），一个False（假），主要用作逻辑判断。</p><h2 id="（五）列表（list）"><a href="#（五）列表（list）" class="headerlink" title="（五）列表（list）"></a>（五）列表（list）</h2><p> &amp;emsp;如果要把全班的人名在内存里存下来很简单，但不方便取（字符串切割，很麻烦），此时比较适合用列表。<br>列表通过索引标记元素位置。</p><pre class="language-python" data-language="python"><code class="language-python">names &#x3D; [&quot;Alex&quot;, &quot;Jack&quot;, &quot;Rain&quot;, &quot;Rachel&quot;, &quot;Mack&quot;]names[0]</code></pre><div align=center><img src="https://img-blog.csdnimg.cn/1691d6a1b580403c9ae61ae2b39a94e7.png" width = 100%></div>1、列表增加元素（1） insert():插入到任意位置<div align=center><img src="https://img-blog.csdnimg.cn/02dc9403f1b94815a1c4fa4a50faa5a0.png" width = 80%></div><p>（2）append():追加到列表尾部</p><div align=center><img src="https://img-blog.csdnimg.cn/a75589abc7e04a7f8abf96f297046564.png" width = 80%></div><p>2、列表元素的删除<br>（1） pop():删除任意位置元素</p><div align=center><img src="https://img-blog.csdnimg.cn/e0df74ed2fb547a4880b88a5ba991bd7.png" width = 80%></div><p>（2） remove():根据元素值删除（只删除第一个）</p><div align=center><img src="https://img-blog.csdnimg.cn/e8d8814d7d4f4651ba433806fd41e596.png" width = 80%></div><p>※del方法可以删除变量、列表元素、列表、字符串等所有东西。</p><p>3、列表元素的修改<br>根据下标找到元素重新赋值即可</p><div align=center><img src="https://img-blog.csdnimg.cn/ffd78f833a5c46ae864b755d16bf6016.png" width = 80%></div><p>4、判断列表中是否有某个元素</p><div align=center><img src="https://img-blog.csdnimg.cn/c96919d2d53e4e6ab44d9524d917bfc6.png" width = 80%></div><p>※先学习列表中的简单知识进行了解，后续在深入学习。</p><h1 id="五、运算符"><a href="#五、运算符" class="headerlink" title="五、运算符"></a>五、运算符</h1><p>目前学习：算数运算、比较运算、逻辑运算、赋值运算和成员运算<br>往后学习：算法运算和位运算</p><h2 id="（一）算数运算符"><a href="#（一）算数运算符" class="headerlink" title="（一）算数运算符"></a>（一）算数运算符</h2><p>以下假设变量：<strong>a&#x3D;10, b&#x3D;20</strong></p><div align=center><img src="https://img-blog.csdnimg.cn/475761c9066142c3bece7e0d11f7c235.png" width = 80%></div><h2 id="（二）比较运算符"><a href="#（二）比较运算符" class="headerlink" title="（二）比较运算符"></a>（二）比较运算符</h2><p>以下假设变量：<strong>a&#x3D;10, b&#x3D;20</strong></p><div align=center><img src="https://img-blog.csdnimg.cn/4ef9b3c2447043be9bc3e8d8e4cd3d6c.png" width = 80%></div>※<>在Python2中可以使用，Python3不支持。<h2 id="（三）赋值运算"><a href="#（三）赋值运算" class="headerlink" title="（三）赋值运算"></a>（三）赋值运算</h2><p>以下假设变量：<strong>a&#x3D;10, b&#x3D;20</strong></p><div align=center><img src="https://img-blog.csdnimg.cn/73f1fd9725e240e7b890748d59b22f4f.png" width = 80%></div><h2 id="（四）逻辑运算"><a href="#（四）逻辑运算" class="headerlink" title="（四）逻辑运算"></a>（四）逻辑运算</h2><p>以下假设变量：<strong>a&#x3D;10, b&#x3D;20</strong></p><div align=center><img src="https://img-blog.csdnimg.cn/4561d7d7270141bc91a6915767d8f720.png" width = 80%></div>※<font color="#dd0000">出现多个逻辑运算时，加上括号加强代码可读性</font><h2 id="（五）逻辑运算"><a href="#（五）逻辑运算" class="headerlink" title="（五）逻辑运算"></a>（五）逻辑运算</h2><div align=center><img src="https://img-blog.csdnimg.cn/be915ecf202643a2a60d2b49133824ef.png" width = 80%></div>※<font color="#dd0000">可以用来测试字符串、列表、元组、字典和集合，<strong>但不能测试数字类型</strong></font><h1 id="六、代码编辑器"><a href="#六、代码编辑器" class="headerlink" title="六、代码编辑器"></a>六、代码编辑器</h1><h2 id="（一）、安装Pycharm"><a href="#（一）、安装Pycharm" class="headerlink" title="（一）、安装Pycharm"></a>（一）、安装Pycharm</h2><p><a href="https://www.jetbrains.com/pycharm/download">https://www.jetbrains.com/pycharm/download</a></p><h2 id="（二）、创建项目"><a href="#（二）、创建项目" class="headerlink" title="（二）、创建项目"></a>（二）、创建项目</h2><div align=center><img src="https://img-blog.csdnimg.cn/bed3698df8984491b1c517405c97d5c7.png" width = 70%></div><h2 id="（三）、运行代码"><a href="#（三）、运行代码" class="headerlink" title="（三）、运行代码"></a>（三）、运行代码</h2><div align=center><img src="https://img-blog.csdnimg.cn/9250785ae9f64e56a8ae951553d3dda0.png" width = 70%></div><h2 id="（四）、命令终端"><a href="#（四）、命令终端" class="headerlink" title="（四）、命令终端"></a>（四）、命令终端</h2><div align=center><img src="https://img-blog.csdnimg.cn/2b5bc858b9ec47839837cf59788f2a3a.png" width = 70%></div><h2 id="（五）、代码调试"><a href="#（五）、代码调试" class="headerlink" title="（五）、代码调试"></a>（五）、代码调试</h2><div align=center><img src="https://img-blog.csdnimg.cn/ecd31ab243aa47d78eaba557ee6ab8ea.png" width = 70%></div><h2 id="（六）、一些快捷键"><a href="#（六）、一些快捷键" class="headerlink" title="（六）、一些快捷键"></a>（六）、一些快捷键</h2><p>1、ctrl+d 直接复制粘贴一行<br>2、ctrl+？选中要注释的多行代码，进行多行注释</p><h1 id="七、小练习"><a href="#七、小练习" class="headerlink" title="七、小练习"></a>七、小练习</h1><h2 id="（一）读取用户输入"><a href="#（一）读取用户输入" class="headerlink" title="（一）读取用户输入"></a>（一）读取用户输入</h2><pre class="language-python" data-language="python"><code class="language-python">name &#x3D; input(&quot;please input your username: &quot;)age &#x3D; input(&quot;please input your age: &quot;)job &#x3D; input(&quot;please input your job: &quot;)hobby &#x3D; input(&quot;please input your hobby: &quot;)</code></pre><p>※ input的输出值为str</p><h2 id="（二）格式化打印"><a href="#（二）格式化打印" class="headerlink" title="（二）格式化打印"></a>（二）格式化打印</h2><p> &amp;emsp;通过以上信息打印出好看的个人信息卡</p><pre class="language-python" data-language="python"><code class="language-python">msg &#x3D; f&#39;&#39;&#39;-----------info of &#123;name&#125;---------Name: &#123;name&#125;Age: &#123;age&#125;job: &#123;job&#125;hobby: &#123;hobby&#125;----------------end----------------&#39;&#39;&#39; print(msg)</code></pre><p>※ 在字符串前加f，然后用花括号将需要打印的变量括起来</p><h2 id="（三）流程控制"><a href="#（三）流程控制" class="headerlink" title="（三）流程控制"></a>（三）流程控制</h2><h3 id="1、缩进"><a href="#1、缩进" class="headerlink" title="1、缩进"></a>1、缩进</h3><p>（1）顶级代码必须顶行写，即如果一行代码的执行不依赖于任何条件，那它不能进行任何缩进。<br>（2）同一级别的代码缩进必须一致。<br>（3）官方建议缩进用四个空格。</p><h3 id="2、单分支"><a href="#2、单分支" class="headerlink" title="2、单分支"></a>2、单分支</h3><pre class="language-python" data-language="python"><code class="language-python">salary &#x3D; 8000if salary &lt; 10000:    print(&#39;你赚的太少了&#39;)</code></pre><h3 id="3、双分支"><a href="#3、双分支" class="headerlink" title="3、双分支"></a>3、双分支</h3><pre class="language-python" data-language="python"><code class="language-python">salary &#x3D; 12000if salary &lt; 10000:    print(&#39;你赚的太少了&#39;)else:    print(&#39;你的工资还可以&#39;)</code></pre><h3 id="4、多分支"><a href="#4、多分支" class="headerlink" title="4、多分支"></a>4、多分支</h3><pre class="language-python" data-language="python"><code class="language-python">true_age &#x3D; 48guess_age &#x3D; int(input(&#39;please guess a number: &#39;))if guess_age &gt; true_age:    print(&#39;猜的太大了&#39;)elif guess_age &lt; true_age:    print(&#39;猜的太小了&#39;)else:    print(&#39;恭喜你，猜对了&#39;)</code></pre><h2 id="（四）作业"><a href="#（四）作业" class="headerlink" title="（四）作业"></a>（四）作业</h2><div align=center><img src="https://img-blog.csdnimg.cn/b3f1383e1997474f96536ce94db4192f.png" width = 70%></div><pre class="language-python" data-language="python"><code class="language-python">score &#x3D; int(input(&quot;please input your score: &quot;))if score &gt; 89:    print(&#39;A&#39;)elif score &gt; 79:    print(&#39;B&#39;)elif score &gt; 59:    print(&#39;C&#39;)elif score &gt; 39 :    print(&#39;D&#39;)else:    print(&#39;E&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python零基础到精通7天速成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1HTML</title>
      <link href="/2022/03/07/web-qian-duan-bi-ji/"/>
      <url>/2022/03/07/web-qian-duan-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="黑马pink老师前端学习路线"><a href="#黑马pink老师前端学习路线" class="headerlink" title="黑马pink老师前端学习路线"></a>黑马pink老师前端学习路线</h2><p><img src="https://img-blog.csdnimg.cn/20210604162042916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70"></p><h2 id="一、HTML简介"><a href="#一、HTML简介" class="headerlink" title="一、HTML简介"></a>一、HTML简介</h2><h3 id="（一）基本概念"><a href="#（一）基本概念" class="headerlink" title="（一）基本概念"></a>（一）基本概念</h3><h4 id="1、网站"><a href="#1、网站" class="headerlink" title="1、网站"></a>1、网站</h4><p> &amp;emsp;是指因特尔网上根据一定规则，使用HTML等制作的用于展示特定内容相关的<strong>网页集合</strong>。</p><h4 id="2、网页"><a href="#2、网页" class="headerlink" title="2、网页"></a>2、网页</h4><p> &amp;emsp;是网站中的一页，通常是HTML格式的文件，它要通过浏览器来阅读。</p><h4 id="3、HTML"><a href="#3、HTML" class="headerlink" title="3、HTML"></a>3、<font color="#dd0000">HTML</font></h4><p> &amp;emsp;<strong>超文本标记语言（Hyper Text Markup Language）</strong>，它是用来描述网页的一种语言。HTML不是编程语言，而是一种<strong>标记语言（markup language）</strong>。即一套标记标签（markup tag）。</p><h4 id="4、超文本含义"><a href="#4、超文本含义" class="headerlink" title="4、超文本含义"></a>4、超文本含义</h4><p>（1）它可以加入图片、声音、动画、多媒体等内容，<strong>超越了文本的限制</strong>。<br>（2）它可以从一个文件跳转到另一个文件，与世界各地主机的文件链接，<strong>超级链接文本</strong>。</p><h3 id="（二）浏览器"><a href="#（二）浏览器" class="headerlink" title="（二）浏览器"></a>（二）浏览器</h3><p> &amp;emsp;网页是通过浏览器来展示的，关于浏览器我们需要掌握以下两点。</p><h4 id="1、常用的浏览器"><a href="#1、常用的浏览器" class="headerlink" title="1、常用的浏览器"></a>1、常用的浏览器</h4><p> &amp;emsp;<strong>浏览器</strong>是网页显示和运行的平台，常用的浏览器包括<strong>IE</strong>、<strong>火狐（Firefox）</strong>、<strong>谷歌（Chrome）</strong>、<strong>苹果（Safari）</strong>和<strong>Opera</strong>等。称为五大浏览器。<br>谷歌浏览器市场占有率最高</p><h4 id="2、浏览器内核"><a href="#2、浏览器内核" class="headerlink" title="2、浏览器内核"></a>2、浏览器内核</h4><p> &amp;emsp;浏览器内核（<strong>渲染引擎</strong>）：复制读取网页内容，整理讯息，计算网页的显示方式并显示网页。<br><img src="https://img-blog.csdnimg.cn/20210604171911440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70"></p><h3 id="（三）Web标准"><a href="#（三）Web标准" class="headerlink" title="（三）Web标准"></a>（三）Web标准</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p> &amp;emsp;Web标准是由W3C（万维网联盟）组织和其它标椎化组织制定的一系列标准的集合。</p><h4 id="2、遵循Web标准的优点"><a href="#2、遵循Web标准的优点" class="headerlink" title="2、遵循Web标准的优点"></a>2、遵循Web标准的优点</h4><p> &amp;emsp;浏览器不同，它们显示页面和排版稍有区别<br>遵循Web标准有以下优点<br>（1）让Web的发展前景更广阔。<br>（2）内容能被更广阔的设备访问。<br>（3）更容易被搜索引擎搜索。<br>（4）降低网站流量费用。<br>（5）使网站更易于维护。<br>（6）提高网页浏览速度。</p><h4 id="3、web标准的构成"><a href="#3、web标准的构成" class="headerlink" title="3、web标准的构成"></a>3、<font color="#dd0000">web标准的构成</font></h4><p><img src="https://img-blog.csdnimg.cn/20210604174144904.png"><br> &amp;emsp;Web 标准提出的最佳方案：<strong>结构、表现、行为分离</strong>。结构写到HTML文件中、表现写到CSS文件中、行为写到JavaScript中。<br><img src="https://img-blog.csdnimg.cn/20210604174611968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="（四）HTML语法规范"><a href="#（四）HTML语法规范" class="headerlink" title="（四）HTML语法规范"></a>（四）<font color="#dd0000">HTML语法规范</font></h3><p> &amp;emsp;1、所有标签由<strong>尖括号</strong>加<strong>关键词</strong>组成，如<code>&lt;html &gt;</code>。<br> &amp;emsp;2、大部分情况下标签成对出现。如<code>&lt;html&gt;&lt;/html&gt;</code>,其中<code>&lt;html&gt;</code>为开始标签，<code>&lt;/html&gt;</code>为结束标签，多一个<code>/</code>。双标签关系分为<strong>包含关系</strong>和<strong>并列关系</strong>。<br><img src="https://img-blog.csdnimg.cn/20210605093707770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="包含关系和并列关系"></p><h3 id="（五）HTML基本结构标签"><a href="#（五）HTML基本结构标签" class="headerlink" title="（五）HTML基本结构标签"></a>（五）<font color="#dd0000">HTML基本结构标签</font></h3><p><img src="https://img-blog.csdnimg.cn/20210605094456108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="基本结构标签"><br><img src="https://img-blog.csdnimg.cn/20210605094606933.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="（六）开发工具"><a href="#（六）开发工具" class="headerlink" title="（六）开发工具"></a>（六）开发工具</h3><p> &amp;emsp;使用记事本写.html文件有诸多不便，使用VSCode进行.html的编写。<br> &amp;emsp;VSCode中安转以下插件，<strong>输入英文感叹号</strong>出现HTML基本结构，编辑title和body后，右键选择Open in Default Browser 打开网页。<br><img src="https://img-blog.csdnimg.cn/20210605104736885.png" alt="中文插件"></p><p><img src="https://img-blog.csdnimg.cn/20210605104753697.png" alt="用浏览器打开VSCode插件"></p><h2 id="二、HTML常用标签"><a href="#二、HTML常用标签" class="headerlink" title="二、HTML常用标签"></a>二、<font color="#dd0000">HTML常用标签</font></h2><h3 id="（一）语义标签"><a href="#（一）语义标签" class="headerlink" title="（一）语义标签"></a>（一）语义标签</h3><p> &amp;emsp;标签的含义，用来干嘛的。根据标签的语义，在合适的地方给一个合理的标签，能让页面的结构更清晰。<br><img src="https://img-blog.csdnimg.cn/20210607161008669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="（二）标题标签"><a href="#（二）标题标签" class="headerlink" title="（二）标题标签"></a>（二）标题标签</h3><p> &amp;emsp;<code>&lt;h1&gt;-&lt;h6&gt;</code>，表示一级-六级标签，重要性递减。h为head的缩写，是<strong>双标签</strong>如：<code>&lt;h1&gt;  &lt;/h1&gt;</code>。加了标题的文字会加粗，字号也会变大，并且独占一行。</p><h4 id="1、基础语法"><a href="#1、基础语法" class="headerlink" title="1、基础语法"></a>1、基础语法</h4><pre class="language-none"><code class="language-none">&lt;h1&gt;我是一级标题&lt;&#x2F;h1&gt;&lt;h2&gt;我是二级标题&lt;&#x2F;h2&gt;</code></pre><h4 id="2、练习"><a href="#2、练习" class="headerlink" title="2、练习"></a>2、练习</h4><p><img src="https://img-blog.csdnimg.cn/20210607162414928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210607162435446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="（三）段落和换行标签"><a href="#（三）段落和换行标签" class="headerlink" title="（三）段落和换行标签"></a>（三）<font color="#dd0000">段落和换行标签</font></h3><h4 id="1、段落标签"><a href="#1、段落标签" class="headerlink" title="1、段落标签"></a>1、段落标签</h4><p> &amp;emsp;把文字分为不同的段落，p为paragraph 段落缩写。文本在一个段落中，会根据浏览器的大小自动换行，<strong>段落和段落之间保有空隙</strong>。<br>（1）基础语法</p><pre class="language-none"><code class="language-none">&lt;p&gt;我是一个段落标签&lt;&#x2F;p&gt;</code></pre><p>（2）示例<br><img src="https://img-blog.csdnimg.cn/20210607164257591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210607164309955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2、换行标签"><a href="#2、换行标签" class="headerlink" title="2、换行标签"></a>2、换行标签</h4><p> &amp;emsp;强制换行，br为break 换行缩写。 <code>&lt;br /&gt;</code>是一个单标签，<code>&lt;br /&gt;</code>和<code>&lt;p&gt;</code>的区别，段落标签不同段落间有间距，换行标签没有间距只是换行。<br>（1）基础语法</p><pre class="language-none"><code class="language-none">我是&lt;br &#x2F;&gt;一个换行标签</code></pre><h4 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h4><p><img src="https://img-blog.csdnimg.cn/20210609150648796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021060915072253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="（四）文本格式标签"><a href="#（四）文本格式标签" class="headerlink" title="（四）文本格式标签"></a>（四）文本格式标签</h3><p> &amp;emsp;突出重要性，在网页中为文字添加粗体、斜体或下划线等效果，使文字以特殊方式显示。</p><h4 id="1、基础语法-1"><a href="#1、基础语法-1" class="headerlink" title="1、基础语法"></a>1、基础语法</h4><p><img src="https://img-blog.csdnimg.cn/20210607172308823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h4><p><img src="https://img-blog.csdnimg.cn/20210609150526972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210609150606976.png" alt="在这里插入图片描述"></p><h3 id="（五）div和span标签"><a href="#（五）div和span标签" class="headerlink" title="（五）div和span标签"></a>（五）div和span标签</h3><p> &amp;emsp;就是盒子用来装内容，div是division的缩写，表示分割、分区；span意为跨度、跨距。<code>&lt;div&gt;</code>标签用来布局，但<strong>一行只能放一个</strong><code>&lt;div&gt;</code>（大盒子）。<code>&lt;span&gt;</code>标签用来布局，但**一行可以放多个<code>&lt;span&gt;</code>**（小盒子）。</p><h4 id="1、基础语法-2"><a href="#1、基础语法-2" class="headerlink" title="1、基础语法"></a>1、基础语法</h4><pre class="language-none"><code class="language-none">&lt;div&gt;我是一个div标签，我一个人单独占一行&lt;&#x2F;div&gt;    &lt;span&gt;百度&lt;&#x2F;span&gt;    &lt;span&gt;新浪&lt;&#x2F;span&gt;    &lt;span&gt;搜狐&lt;&#x2F;span&gt;</code></pre><h4 id="2、示例-1"><a href="#2、示例-1" class="headerlink" title="2、示例"></a>2、示例</h4><p><img src="https://img-blog.csdnimg.cn/20210609152409401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210609152605370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NjQwMjYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="（六）图像标签"><a href="#（六）图像标签" class="headerlink" title="（六）图像标签"></a>（六）<font color="#dd0000">图像标签</font></h3><h4 id="1、基础语法-3"><a href="#1、基础语法-3" class="headerlink" title="1、基础语法"></a>1、基础语法</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--单标签img（image） --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>图像URL<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  </code></pre><h4 id="2、标签属性"><a href="#2、标签属性" class="headerlink" title="2、标签属性"></a>2、标签属性</h4><p><img src="https://img-blog.csdnimg.cn/8c8862a958ca41c18951b4f34b37426f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>（1）图像标签可以有多个属性，但必须写在标签名img后面。<br>（2）属性之间不分先后顺序，标签名和属性、属性和属性之间用<font color="#dd0000">空格</font>隔开。<br>（3）属性值采取键值对的格式，及key&#x3D;”value”（属性 &#x3D; “属性值”）</p><h4 id="3、示例-1"><a href="#3、示例-1" class="headerlink" title="3、示例"></a>3、示例</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>图像标签的使用：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img.JPG<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>alt：替换文本，当图像加载不出来时，提示用户图片信息<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img1.JPG<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>这是我的桌面</span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>title：提示文本，当鼠标放在图片上时，出现的图片信息<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img.JPG<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>这是我的桌面<span class="token punctuation">"</span></span>  <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>桌面照片<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>width:给图像设置宽度<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img.JPG<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>这是我的桌面<span class="token punctuation">"</span></span>  <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>桌面照片<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>500<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>height:给图像设置高度<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img.JPG<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>这是我的桌面<span class="token punctuation">"</span></span>  <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>桌面照片<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100 <span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>border:给图像设置边框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img.JPG<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>这是我的桌面<span class="token punctuation">"</span></span>  <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>桌面照片<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>500<span class="token punctuation">"</span></span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>15<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h4 id="4、绝对路径和相对路径"><a href="#4、绝对路径和相对路径" class="headerlink" title="4、绝对路径和相对路径"></a>4、<font color="#dd0000">绝对路径和相对路径</font></h4><p>（1）目录文件夹和根目录<br> &amp;emsp;目录文件夹就是指普通的文件夹，打开目录文件夹的第一层就是根目录。<br>（2）<font color="#dd0000">绝对路径</font><br> &amp;emsp;指目录下的绝对位置，通常指<strong>从盘符开始的路径或完整的网络路径</strong>（”D:\web\img”或”<a href="http://www.&quot;)./">http://www.&quot;)。</a><br>（3）<font color="#dd0000">相对路径</font><br> &amp;emsp;以引用文件所在位置为参考，建立出的目录路径，简单来说就是<strong>图片相对于HTML文件的位置</strong>。<br><img src="https://img-blog.csdnimg.cn/896c674fa9ad412aa06b01c3fc476875.png" alt="在这里插入图片描述"></p><h3 id="（七）超链接标签"><a href="#（七）超链接标签" class="headerlink" title="（七）超链接标签"></a>（七）超链接标签</h3><p> &amp;emsp;用于定义超连接，作用是从一个页面链接到另一个页面。</p><h4 id="1、基础语法-4"><a href="#1、基础语法-4" class="headerlink" title="1、基础语法"></a>1、基础语法</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--双标签&lt;a>（anchor） --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>跳转目标<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>文字或图像<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><h4 id="2、标签属性-1"><a href="#2、标签属性-1" class="headerlink" title="2、标签属性"></a>2、标签属性</h4><p><img src="https://img-blog.csdnimg.cn/231ced72cfbf4eb5980921c1d31bf960.png" alt="在这里插入图片描述"></p><h4 id="3、超链接类型"><a href="#3、超链接类型" class="headerlink" title="3、超链接类型"></a>3、超链接类型</h4><p>（1）外部链接：必须以http:&#x2F;&#x2F;开头<br>（2）内部链接：网站内部页面之间的相互链接，直接链接内部网站的名称即可。<br>（3）空连接：<code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code>用于站位。<br>（4）下载链接：herf里面地址是一个文件（.exe）或者压缩包(.zip)，会下载这个文件。<br>（5）网页元素链接：在网页中的各种网页元素，如文本、图像、表格、音频、视频都可以添加超链接。<br>（6）锚点链接：当点击锚点链接，可以快速的定位到页面中的某个位置。在链接文本中的href属性中，设置属性值为#名字的形式，如<code>&lt;a herf=&quot;#two&quot;&gt;</code>第2集<code>&lt;/a&gt;</code>。找到目标位置标签，里面添加一个id属性，如<code>&lt;h3 id=&quot;two&quot;&gt;</code>第2集介绍<code>&lt;/h3&gt;</code></p><h4 id="4、示例"><a href="#4、示例" class="headerlink" title="4、示例"></a>4、示例</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>1.外部链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.baidu.com<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>百度<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://itcast.cn<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>传智播客<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>2.内部链接：网站内部各个网页之间的相互链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gongsijianjie.html<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>公司简介<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>3.空链接：没有确定链接目标<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>公司地址<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>4.下载链接：当链接目标为文件（.exe）或者压缩包(.zip)时，直接对其进行下载<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img.zip<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>下载链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>5.网页元素链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.qq.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img.JPG<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="（八）表格标签"><a href="#（八）表格标签" class="headerlink" title="（八）表格标签"></a>（八）<font color="#dd0000">表格标签</font></h3><p> &amp;emsp;<strong>用于显示和展示数据</strong>，因为它可以提高数据可读性（表格不是用来布局页面的而是用来展示数据的）。</p><h4 id="1、基础语法-5"><a href="#1、基础语法-5" class="headerlink" title="1、基础语法"></a>1、基础语法</h4><p>（1）表格标签<br><code>&lt;table&gt;&lt;/table&gt;</code>用于定义<strong>表格标签</strong>。<br>（2）表格结构标签<br>表格可能很长，为了更好的表示表格语义，可以将表格划分成表格头部和表格主体两大部分。<br>（3）表头标签<br><code>&lt;th&gt;&lt;/th&gt;</code>(table head);表头单元格位于表格的第一行或者第一列，表头单元格里面的文本内容会<strong>加粗并居住</strong>。<br>（4）行标签<br><code>&lt;tr&gt;&lt;/tr&gt;</code>用于定义表格中的<strong>行</strong>，必须嵌套在<code>&lt;table&gt;&lt;/table&gt;</code>标签中。<br>（5）单元格标签<br><code>&lt;td&gt;&lt;/td&gt;</code>(table data)用于定义表格中的<strong>单元格</strong>，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中。</p><h4 id="2、标签属性-2"><a href="#2、标签属性-2" class="headerlink" title="2、标签属性"></a>2、标签属性</h4><p> &amp;emsp;表格属性开发中不常用，后面通过CSS来设置（目的：记住这些英语单词后面CSS会用）。<br><img src="https://img-blog.csdnimg.cn/4b6f0feeac99428590b600c16ff001ab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="3、表格合并"><a href="#3、表格合并" class="headerlink" title="3、表格合并"></a>3、表格合并</h4><p>单元格合并三部曲<br>（1）确定跨行（rowspan）还是跨列（colspan）。<br>（2）找到目标单元（跨行指上方单元格，跨列指左侧单元格）格并确定合并单元格数量，如<td colspan="2"></td>。<br>（3）删除多余单元格</p><h4 id="4、示例-1"><a href="#4、示例-1" class="headerlink" title="4、示例"></a>4、示例</h4><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">cellpadding</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">cellspacing</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>500<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thead</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 第一行为表头标签 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>排名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>关键词<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>趋势<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>今日搜索<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>最近七日<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>相关链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thead</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tbody</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>鬼吹灯<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 图像标签为向下（向上）箭头的图像 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>images/down.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>345<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>贴吧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>百科<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>盗墓笔记<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>images/down.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>675324<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>贴吧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>百科<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>西游记<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>images/up.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>212<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>贴吧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>百科<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>东游记<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>images/up.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>23<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>75645<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>贴吧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>百科<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>甄嬛传<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>images/down.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">rowspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>631324<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>贴吧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>百科<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>水浒传<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>images/up.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>6724<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>贴吧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>百科<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>三国演义<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>images/up.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>13<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>7324<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>贴吧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>百科<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tbody</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="九-列表标签"><a href="#九-列表标签" class="headerlink" title="(九)列表标签"></a>(九)<font color="#dd0000">列表标签</font></h2><p> &amp;emsp;表格用于展示数据，列表用于<strong>布局页面</strong>，使得页面整齐有序。<br><img src="https://img-blog.csdnimg.cn/ec2f5d7ec31845a78af915730d013a0d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="1、无序列表"><a href="#1、无序列表" class="headerlink" title="1、无序列表"></a>1、<font color="#dd0000">无序列表</font></h3><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>列表项1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>列表项2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre><p>（1）无序列表的各个列表项没有级别之分，是<strong>并列关系</strong>。<br>（2）<code>&lt;ul&gt;&lt;/ul&gt;</code>标签中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，不能放其它标签（如段落标签<code>&lt;p&gt;&lt;/p&gt;</code>）或者文字。<br>（3）<code>&lt;li&gt;&lt;/li&gt;</code>是一个容器，可以容纳所有元素。<br>（4）无序列表带有自己的样式属性，通常使用CSS进行设置。</p><h3 id="2、有序列表"><a href="#2、有序列表" class="headerlink" title="2、有序列表"></a>2、有序列表</h3><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>列表项1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>列表项2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span></code></pre><h3 id="3、自定义列表"><a href="#3、自定义列表" class="headerlink" title="3、自定义列表"></a>3、<font color="#dd0000">自定义列表</font></h3><p> &amp;emsp;常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>名词1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>名词1解释1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>名词1解释2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span></code></pre><p>（1）<code>&lt;dl&gt;&lt;/dl&gt;</code>里面只能包含<code>&lt;dt&gt;&lt;/dt&gt;</code>和<code>&lt;dd&gt;&lt;/dd&gt;</code>。<br>（2）<code>&lt;dt&gt;&lt;/dt&gt;</code>和<code>&lt;dd&gt;&lt;/dd&gt;</code>没有个数限制，但通常是一个<code>&lt;dt&gt;&lt;/dt&gt;</code>对应多个<code>&lt;dd&gt;&lt;/dd&gt;</code>。<br>（3）<code>&lt;dt&gt;&lt;/dt&gt;</code>和<code>&lt;dd&gt;&lt;/dd&gt;</code>是<strong>并列关系，不是包含关系</strong>。</p><h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><p><img src="https://img-blog.csdnimg.cn/47f717883d3947cf8886c8c2ef38082f.png" alt="在这里插入图片描述"><br><strong>（1）学会什么时候用无序什么时候用自定义。</strong><br><strong>自定义：一个小标题加多个围绕说明</strong><br><img src="https://img-blog.csdnimg.cn/9cec6b04ce4243b2ae1af5b4874e0ee4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>无序：排列整齐、没有顺序。</strong><br><img src="https://img-blog.csdnimg.cn/82ac531af11c4376a3f79f09e9c82395.png" alt="在这里插入图片描述"><br><strong>（2）学完CSS后，完成对列表的布局。</strong></p><h3 id="（十）表单标签"><a href="#（十）表单标签" class="headerlink" title="（十）表单标签"></a>（十）<font color="#dd0000">表单标签</font></h3><p> &amp;emsp;表单用于<strong>收集用户信息</strong>，由表单域、表单控件和提示信息组成。</p><h4 id="1、表单域"><a href="#1、表单域" class="headerlink" title="1、表单域"></a>1、表单域</h4><p> &amp;emsp;<strong>一个包含表单元素的区域</strong>。<code>&lt;form&gt;&lt;/form&gt;</code>标签定义表单域，以<strong>实现用户信息的收集和传递，会把范围内的表单元素信息提交给服务器</strong>。<br>(1)基础语法</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url地址<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>提交方法<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>表单域名称<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>各种表单元素控件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre><p>（2）标签属性<br><img src="https://img-blog.csdnimg.cn/f9872812bc52491a8b4aa1ddafa33220.png" alt="在这里插入图片描述"><br>（3）实例代码</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>demo.php<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>基础班不用表单域提交数据，只需要写上form标签即可。掌握以下两点。<br>a、在写表单元素之前，应该有一个表单域把他们进行包含。<br>b、表单域就是<code>&lt;form&gt;&lt;/form&gt;</code></p><h4 id="2、表单控件（表单元素）"><a href="#2、表单控件（表单元素）" class="headerlink" title="2、表单控件（表单元素）"></a>2、表单控件（表单元素）</h4><p> &amp;emsp;在表单域中可以定义各种表单元素，这些表单元素就是允许用户在表单中输入或者选择的内容控件。</p><h5 id="（1）input输入表单元素"><a href="#（1）input输入表单元素" class="headerlink" title="（1）input输入表单元素"></a>（1）input输入表单元素</h5><p> &amp;emsp;用于收集用户信息<br>a、基础语法</p><pre class="language-markup" data-language="markup"><code class="language-markup">\<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>※ <code>&lt;input /&gt;</code>为单标签<br>※ type属性设置不同的属性值用来指定不同的元素类型（文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）</p><p><img src="https://img-blog.csdnimg.cn/5c73ef75bcb349fda46fcf67dad0a6bc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>b、标签属性</p><p><img src="https://img-blog.csdnimg.cn/658fd3395d2b466b93b1a435ce77645e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>※name和value是每个表单元素都有的值，主要给后台人员使用。<br>※name表单元素的名字，<strong>单选按钮和复选框都要有相同的name值</strong>。<br>※checked属性主要针对<strong>单选按钮和复选框</strong>，主要作用是一打开网页，就可以默认选择某个表单元素。<br>※maxlength是用户可以在表单元素输入的最大字符数，一般较少使用（一般使用正则表达式进行限定）。<br>c、实例代码</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>input 表单元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- text 文本框 用户可以输入任何文字 --></span>        用户：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入用户名<span class="token punctuation">"</span></span> <span class="token attr-name">maxlength</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>        <span class="token comment">&lt;!-- password 密码框 用户看不见输入的密码 --></span>        密码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>        <span class="token comment">&lt;!-- radio 单选按钮 可以实现多选 --></span>        <span class="token comment">&lt;!-- name 表单元素的名字 单选按钮必须有相同的name才能实现多选一 --></span>        <span class="token comment">&lt;!-- 单选按钮和复选框可以设置checked属性，一打开网页默认选中这个按钮 --></span>        性别：男 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>男<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checked<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        女 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>女<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>         <span class="token comment">&lt;!-- checkbox 复选框 可以实现多选 --></span>        爱好：吃饭 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>吃饭<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            睡觉 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>睡觉<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            打豆豆 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>打豆豆<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checked<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>d、lable标签<br> &amp;emsp;为<code>&lt;input /&gt;</code>元素定义标签，用于绑定一个表单元素，当点击<code>&lt;lable&gt;&lt;/lable&gt;</code>标签内的文本时，浏览器会自动将鼠标移动到对应的表单元素上，用来<strong>增强用户体验</strong>。<br>※实例代码</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>用户：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入用户名<span class="token punctuation">"</span></span> <span class="token attr-name">maxlength</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><h5 id="（2）select下拉表单元素"><a href="#（2）select下拉表单元素" class="headerlink" title="（2）select下拉表单元素"></a>（2）select下拉表单元素</h5><p> &amp;emsp;在页面中。<strong>如果有多个选项让用户选择，并且想要节约页面空间</strong>时使用<code>&lt;select&gt;&lt;/select&gt;</code>标签，定义下拉菜单。<br>a、基础语法</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>选项1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>选项2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>选项3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p>※<code>&lt;select&gt;&lt;/select&gt;</code>中至少包含一对<code>&lt;option&gt;&lt;/option&gt;</code><br>※<code>&lt;option&gt;&lt;/option&gt;</code>中可以定义selected属性，默认选中项。<br>b、实例代码</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>select 下拉表单<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>        籍贯：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">selected</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selected<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>四川<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>河南<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>陕西<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>重庆<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>江西<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h5 id="（3）textarea文本域元素"><a href="#（3）textarea文本域元素" class="headerlink" title="（3）textarea文本域元素"></a>（3）textarea文本域元素</h5><p> &amp;emsp;当用户输入内容较多时，不使用文本框表单，而是用<code>&lt;textarea&gt;&lt;/textarea&gt;</code>标签，以<strong>定义多行文本的输入</strong>。<br>a、基础语法</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">rows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span> <span class="token attr-name">cols</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>文本内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">></span></span></code></pre><p>b、标签属性<br>cols&#x3D;”每行中的字符数”<br>rows&#x3D;”显示的行数”<br><strong>实际开发中不会使用都是通过CSS来设置</strong>。<br>c、实例代码</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>textarea 文本域<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>        今日反馈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">cols</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span> <span class="token attr-name">rows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>pink老师，我知道这个留言反馈是使用textarea来做的<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>### 3、总结（1）学习了三大表单元素input输入表单元素、select下拉表单元素、textarea文本域表单元素。（2）这三组表单元素都应该包含在form表单域中，并且有name属性。```xml<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>总结<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入用户名<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>        籍贯：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jiguan<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">selected</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selected<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>四川<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>陕西<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>        个人简介：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gerenjianjie<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>（3）有三个名字特别相似的标签<br>a、表单域<code>&lt;form&gt;&lt;/form&gt;</code>提交区域内表单文件给后台服务器。<br>b、文件域file是<code>&lt;input /&gt;</code>标签属性值，用于上传文件。<br>c、文本域<code>&lt;textarea&gt;&lt;/textarea&gt;</code><br>（4）当前阶段不需要提交表单元素，只负责表单元素的外观形态。</p>]]></content>
      
      
      <categories>
          
          <category> 黑马pink老师前端视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络整理（三）</title>
      <link href="/2021/12/18/ji-suan-ji-wang-luo-zheng-li-san/"/>
      <url>/2021/12/18/ji-suan-ji-wang-luo-zheng-li-san/</url>
      
        <content type="html"><![CDATA[<h2 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、思维导图</h2><ul><li>第三章 数据链路层<ul><li>3.1 数据链路层概述<ul><li>点对点信道的数据链路</li><li>使用广播信道的数据链路</li></ul></li><li>3.2 封装成帧<ul><li>封装成帧</li><li>透明传输</li><li>最大传输单元</li></ul></li><li>3.3 差错监测<ul><li>概念</li><li>奇偶校验</li><li>循环冗余校验CRC</li></ul></li><li>3.4 可靠传输<ul><li>概念</li><li>传输差错</li><li>实现机制<ul><li>停止-等待协议</li><li>回到N帧协议</li><li>选择重传协议</li></ul></li></ul></li><li>3.5 碰撞监测<ul><li>点对点协议</li><li>媒体接入控制<ul><li>基本概念</li><li>静态划分信道<ul><li>频分多址</li><li>时分多址</li><li>码分多址</li></ul></li><li>动态划分信道<ul><li>受控接入<ul><li>集中控制</li><li>分散控制</li></ul></li><li>随机接入</li></ul></li></ul></li></ul></li><li>3.6 编址问题<ul><li>MAC地址</li><li>IP地址</li><li>ARP协议</li></ul></li><li>3.7 以太网交换机<ul><li>集线器与交换机的区别</li><li>以太网交换机自学习和发送帧的过程</li><li>生成树协议STP</li></ul></li><li>3.8 虚拟局域网VLAN<ul><li>概念</li><li>实现<h1 id="二、重点"><a href="#二、重点" class="headerlink" title="二、重点"></a>二、重点</h1><h1 id="三、参考文献"><a href="#三、参考文献" class="headerlink" title="三、参考文献"></a>三、参考文献</h1><a href="https://www.bilibili.com/video/BV1c4411d7jb?share_source=copy_web">b站湖科大教书匠计算机网络视频</a></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络整理（二）</title>
      <link href="/2021/12/16/ji-suan-ji-wang-luo-zheng-li-er/"/>
      <url>/2021/12/16/ji-suan-ji-wang-luo-zheng-li-er/</url>
      
        <content type="html"><![CDATA[<h2 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、思维导图</h2><ul><li>第二章 物理层<ul><li><p>2.1 基本概念</p><ul><li>物理层所要解决的问题（重要）</li><li>物理层协议的主要任务（重要）<ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>过程特性</li></ul></li></ul></li><li><p>2.2 传播媒体</p><ul><li>导引型传输媒体<ul><li>同轴电缆</li><li>双绞线（重要）</li><li>光纤（重要）</li><li>电力线</li></ul></li><li>非导引型传输媒体<ul><li>无线电波</li><li>微波（重要）</li><li>红外线</li><li>可见光</li></ul></li><li>无线电频谱管理机构<ul><li>中国</li><li>美国</li><li>ISM</li></ul></li></ul></li><li><p>2.3 传播方式</p><ul><li>串行传输和并行传输（重要）</li><li>同步传输和异步传输（重要）</li><li>单工、半双工和全双工</li></ul></li><li><p>2.4 编码和调整</p><ul><li>数据通信中的常用术语<ul><li>消息</li><li>数据</li><li>信号（基带信号）<ul><li>数字基带信号</li><li>模拟基带信号</li></ul></li></ul></li><li>编码（重要）<ul><li>将数字信号转换为另一种数字信号在数字信道中传播</li><li>将模拟信号转换为数字信号在数字信道中传播</li><li>常见的编码方式<ul><li>不归零编码</li><li>归零编码</li><li>曼彻斯特编码和差分曼彻斯特编码</li></ul></li></ul></li><li>调制（重要）<ul><li>将数字信号转化为模拟信号在模拟信道中传播</li><li>将模拟信号转化为另一模拟信号在模拟信道中传播</li><li>基本调制</li><li>混合调制</li></ul></li><li>码元（重要）</li></ul></li><li><p>2.5 信道的极限容量（重要）</p><ul><li><p>造成信号失真的因素</p><ul><li>码元传输速率</li><li>信号传输距离</li><li>噪声干扰</li><li>传播媒体质量</li></ul></li><li><p>奈氏准则</p></li><li><p>香农公式</p></li><li><p>奈氏准则和香农公式的作用</p></li></ul></li></ul></li></ul><h2 id="二、重点"><a href="#二、重点" class="headerlink" title="二、重点"></a>二、重点</h2><h3 id="（一）物理层所要解决的问题"><a href="#（一）物理层所要解决的问题" class="headerlink" title="（一）物理层所要解决的问题"></a>（一）物理层所要解决的问题</h3><pre><code>    物理层考虑的是怎样才能在连接各种计算机的**传输媒体上传输数据比特流**。    它为数据链路层**屏蔽了各种传输媒体的差异**，使数据链路层只需要考虑如何完成本层协议和服务，而不必考虑网络具体的传输媒体是什么。</code></pre><h3 id="（二）物理层协议的主要任务"><a href="#（二）物理层协议的主要任务" class="headerlink" title="（二）物理层协议的主要任务"></a>（二）物理层协议的主要任务</h3><h4 id="1、机械特性"><a href="#1、机械特性" class="headerlink" title="1、机械特性"></a>1、机械特性</h4><pre><code>    指定接口所用**接线器形状和尺寸**、**引脚数目和排列**、**固定**和**锁定**装置。</code></pre><h4 id="2、电气特性"><a href="#2、电气特性" class="headerlink" title="2、电气特性"></a>2、电气特性</h4><pre><code>    指明在接口电缆出现的各条线上出现的**电压范围**。</code></pre><h4 id="3、功能特性"><a href="#3、功能特性" class="headerlink" title="3、功能特性"></a>3、功能特性</h4><pre><code>    指定某条线上的**某一电平的电压表示何种意义**。</code></pre><h4 id="4、过程特性"><a href="#4、过程特性" class="headerlink" title="4、过程特性"></a>4、过程特性</h4><pre><code>    指明对于不同功能的各种可能**事件的出现顺序**。</code></pre><h3 id="（三）传播媒体"><a href="#（三）传播媒体" class="headerlink" title="（三）传播媒体"></a>（三）传播媒体</h3><h4 id="1、双绞线绞和的目的"><a href="#1、双绞线绞和的目的" class="headerlink" title="1、双绞线绞和的目的"></a>1、双绞线绞和的目的</h4><p>（1）抵御部分来自<strong>外界</strong>的<strong>电磁干扰</strong>。<br>（2）减少<strong>相邻导线</strong>的<strong>电磁干扰</strong>。</p><h4 id="2、光在光纤中传播的原理"><a href="#2、光在光纤中传播的原理" class="headerlink" title="2、光在光纤中传播的原理"></a>2、光在光纤中传播的原理</h4><pre><code>    纤芯：非常透明的石英玻璃拉成细丝（直径8~100um）。    包层：折射率比纤芯低的玻璃封套（直径125um）。    发送端：发光二极管、半导体激光器作为光源。    接收端：光电二极管、激光检波器检测光脉冲。    光纤：当光从高折射率的媒体射向低折射率的媒体时，折射角将大于入射角，因此只要入射角足够大时，就会发生全反射，即光遇到包层时就会反射回纤芯，光也就沿着光纤传输下去。    多模光纤：只要入射角大于某一临街角度，就可产生全反射。也就可以存在许多条不同入射角的</code></pre><p>光线，在一条光纤中传输。由于色散，多模光纤存在脉冲展宽的问题，只适合近距离传输（建筑物<br>内）。<br>        单模光纤：光在纤芯中一直向前传播而不发生全反射。没有脉冲展宽问题，适合长距离传输，成<br>本高、对光源要求高。</p><h3 id="（四）串行传输和并行传输"><a href="#（四）串行传输和并行传输" class="headerlink" title="（四）串行传输和并行传输"></a>（四）串行传输和并行传输</h3><p>1、串行传输<br>        <strong>比特一个接一个</strong>的在<strong>一根传输线</strong>上传输，适合<strong>远距离</strong>传输，<strong>计算机网络</strong>采用这种传输。<br>2、并行传输<br>        多个比特同时在多根传输线上传输，成本高。应用于计算机内部的数据传输。（例如：CPU和内存之间通过总线进行传输）</p><h3 id="（五）同步传输和异步传输"><a href="#（五）同步传输和异步传输" class="headerlink" title="（五）同步传输和异步传输"></a>（五）同步传输和异步传输</h3><p>1、同步传输<br>        <strong>比特</strong>一个接一个传输，中间<strong>没有间隔</strong>，各比特<strong>持续时长相等</strong>，要保证收发双方<strong>时钟同步</strong>。主要方法有。<br>（1）外同步：在收发双发之间<strong>增加</strong>一条单独的<strong>时钟信号线</strong>。<br>（2）内同步：发送方将<strong>时钟信号编码到数据</strong>中一起发送。<br>2、异步传输<br>        以<strong>字节为</strong>单位进行传输，字节间<strong>间隔不固定</strong>，但字节内每个<strong>比特持续时间相同</strong>（<strong>字节异步，比特同步</strong>）。为此需要给每个字节<strong>添加起始位和结束位</strong>，方便接收端接受。</p><h3 id="（六）编码"><a href="#（六）编码" class="headerlink" title="（六）编码"></a>（六）编码</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>（1）将数据信号转换为另一种数据信号，在数字信道上传输。<br>例如：因特网曼切斯特编码、4B&#x2F;8B、8B&#x2F;10B。<br>（2）将模拟信号转换为数字信号，在数字信道中传输。<br>例如：对音频信号进行编码的脉码调制（PCM, Pulse Code Modulation）。</p><h4 id="2、几种常见的编码"><a href="#2、几种常见的编码" class="headerlink" title="2、几种常见的编码"></a>2、几种常见的编码</h4><p>（1）不归零编码</p><img src="/2021/12/16/ji-suan-ji-wang-luo-zheng-li-er/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16.png" class="" title="在这里插入图片描述"><p>（2）归零编码</p><img src="/2021/12/16/ji-suan-ji-wang-luo-zheng-li-er/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16-16547789511995.png" class="" title="在这里插入图片描述"><p>（3)曼切斯特编码和差分曼切斯特编码</p><img src="/2021/12/16/ji-suan-ji-wang-luo-zheng-li-er/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16-16547789584237.png" class="" title="在这里插入图片描述"><h3 id="（七）调制"><a href="#（七）调制" class="headerlink" title="（七）调制"></a>（七）调制</h3><h4 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h4><p>（1）将数字信号转换成模拟信号，在模拟信道中传输。<br>例如：WiFi采用补码检控、直接序列扩频、正交频分复用等技术。<br>（2）将模拟信号转换为另一种模拟信号，在模拟信道中传输。<br>例如：语音信号加载到模拟的载波信号中进行传输。</p><h4 id="2、基本调制"><a href="#2、基本调制" class="headerlink" title="2、基本调制"></a>2、基本调制</h4><img src="/2021/12/16/ji-suan-ji-wang-luo-zheng-li-er/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16-16547789663299-165477896787511.png" class="" title="在这里插入图片描述"><h4 id="3、混合调制"><a href="#3、混合调制" class="headerlink" title="3、混合调制"></a>3、混合调制</h4><img src="/2021/12/16/ji-suan-ji-wang-luo-zheng-li-er/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16-165477897220412.png" class="" title="在这里插入图片描述"><h3 id="（八）码元"><a href="#（八）码元" class="headerlink" title="（八）码元"></a>（八）码元</h3><p> &amp;emsp;在使用时间域的波型表示数字信号时，代表<strong>不同离散数值的基本波型</strong>。</p><h3 id="（九）造成信号失真的原因"><a href="#（九）造成信号失真的原因" class="headerlink" title="（九）造成信号失真的原因"></a>（九）造成信号失真的原因</h3><p>1、码元传输速率<br>2、信号传输距离<br>3、噪声干扰<br>4、传输媒体质量</p><h3 id="（十）奈氏准则"><a href="#（十）奈氏准则" class="headerlink" title="（十）奈氏准则"></a>（十）奈氏准则</h3><img src="/2021/12/16/ji-suan-ji-wang-luo-zheng-li-er/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16-165477897722114.png" class="" title="在这里插入图片描述"><h3 id="（十一）香农公式"><a href="#（十一）香农公式" class="headerlink" title="（十一）香农公式"></a>（十一）香农公式</h3><img src="/2021/12/16/ji-suan-ji-wang-luo-zheng-li-er/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16-165477898075916.png" class="" title="在这里插入图片描述"><h3 id="（十二）奈氏准则和香农公式的意义"><a href="#（十二）奈氏准则和香农公式的意义" class="headerlink" title="（十二）奈氏准则和香农公式的意义"></a>（十二）奈氏准则和香农公式的意义</h3><p>1、在信道<strong>带宽一定</strong>的前提现，根据奈氏准则和香农公式，想要提高<strong>信息传输的效率</strong>，就必须采用<strong>多元制</strong>（更好的调整方法），和努力<strong>提高</strong>信道中的<strong>信噪比</strong>。<br>2、自从香农公式发表后，各种新的<strong>信号处理和调制方式</strong>就不断出现，目的就是为了接近<strong>香农公式给出的信道传输速率的极限</strong>。</p><h2 id="三、参考文献"><a href="#三、参考文献" class="headerlink" title="三、参考文献"></a>三、参考文献</h2><ol><li><a href="https://www.bilibili.com/video/BV1c4411d7jb?share_source=copy_web">b站湖科大教书匠计算机网络视频</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络整理（一）</title>
      <link href="/2021/12/16/ji-suan-ji-wang-luo-zheng-li-yi/"/>
      <url>/2021/12/16/ji-suan-ji-wang-luo-zheng-li-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、重点"><a href="#一、重点" class="headerlink" title="一、重点"></a>一、重点</h2><h3 id="（一）网络、互联网、因特网的概念"><a href="#（一）网络、互联网、因特网的概念" class="headerlink" title="（一）网络、互联网、因特网的概念"></a>（一）网络、互联网、因特网的概念</h3><p>1、网络（Network）<br>        由若干<font color="#dd0000">结点（Node）</font>和连接这些结点的<font color="#dd0000">链路（Link）</font>组成。<br>2、互联网（internet）<br>        多个网络可以通过路由器互连起来，形成一个覆盖范围更大的网络，及互联网，因此互联网是<font color="#dd0000">网络的网络</font>。<br>3、因特网（Internet）<br>        是世界上<font color="#dd0000">最大的互连网络</font>（用户数以亿计，互连的网络数以百万计）。</p><h3 id="（二）分组交换"><a href="#（二）分组交换" class="headerlink" title="（二）分组交换"></a>（二）分组交换</h3><p>​将报文分成若干个<font color="#dd0000">等长的报文段</font>，然后将各数据添加首部（包含重要的控件信息），构成分组。<font color="#dd0000">节点交换机（路由器）</font>对分组进行存储转发，分组从源主机到目的主机可走不同的路径。</p><h3 id="（三）计算机网络的分类"><a href="#（三）计算机网络的分类" class="headerlink" title="（三）计算机网络的分类"></a>（三）计算机网络的分类</h3><h4 id="1、按交换技术"><a href="#1、按交换技术" class="headerlink" title="1、按交换技术"></a>1、按交换技术</h4><p>电路交换网、报文交换网、分组交换网</p><h4 id="2、按使用者"><a href="#2、按使用者" class="headerlink" title="2、按使用者"></a>2、按使用者</h4><p>公用网、专用网</p><h4 id="3、安传输介质"><a href="#3、安传输介质" class="headerlink" title="3、安传输介质"></a>3、安传输介质</h4><p>有线网、无线网</p><h4 id="4、按覆盖范围"><a href="#4、按覆盖范围" class="headerlink" title="4、按覆盖范围"></a>4、按覆盖范围</h4><p>广域网（WAN）、城域网(MAN)、局域网(LAN)、个域网(PAN)</p><h4 id="5、按拓扑结构"><a href="#5、按拓扑结构" class="headerlink" title="5、按拓扑结构"></a>5、按拓扑结构</h4><p>总线型网络、星型网络、环形网络、网状网络</p><h3 id="（四）带宽"><a href="#（四）带宽" class="headerlink" title="（四）带宽"></a>（四）带宽</h3><pre><code>    用来表示网络通信线路所能传送数据的能力，也就是&lt;font color=&quot;#dd0000&quot;&gt;最高数据率&lt;/font&gt;。</code></pre><h3 id="（五）时延"><a href="#（五）时延" class="headerlink" title="（五）时延"></a>（五）时延</h3><h4 id="1、发送时延"><a href="#1、发送时延" class="headerlink" title="1、发送时延"></a>1、发送时延</h4><pre><code>    分组长度（b）/发送速率（b/s）</code></pre><h4 id="2、传播时延"><a href="#2、传播时延" class="headerlink" title="2、传播时延"></a>2、传播时延</h4><pre><code>    信道长度（m）/电磁波传播速率（m/s）    电磁波传播速率：</code></pre><p>自由空间：3*$10^8$m&#x2F;s<br>铜线：2.3*$10^8$m&#x2F;s<br>光纤：2*$10^8$m&#x2F;s</p><h4 id="3、处理时延"><a href="#3、处理时延" class="headerlink" title="3、处理时延"></a>3、处理时延</h4><pre><code>    不方便计算，忽略。</code></pre><h3 id="（六）利用率"><a href="#（六）利用率" class="headerlink" title="（六）利用率"></a>（六）利用率</h3><img src="/2021/12/16/ji-suan-ji-wang-luo-zheng-li-yi/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IC_5aSp6Zy4,size_20,color_FFFFFF,t_70,g_se,x_16.png" class=""><h3 id="（七）分层的必要性"><a href="#（七）分层的必要性" class="headerlink" title="（七）分层的必要性"></a>（七）分层的必要性</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><pre><code>    计算机网络是非常复杂的系统,“分层”可以将&lt;font color=&quot;#dd0000&quot;&gt;庞大而复杂&lt;/font&gt;的问题，转化成若干&lt;font color=&quot;#dd0000&quot;&gt;弱小的局部问题&lt;/font&gt;。</code></pre><h4 id="2、以五层原理体系结构为例，说明分层的必要性"><a href="#2、以五层原理体系结构为例，说明分层的必要性" class="headerlink" title="2、以五层原理体系结构为例，说明分层的必要性"></a>2、以五层原理体系结构为例，说明分层的必要性</h4><p>物理层：解决使用<font color="#dd0000">何种信号传输比特</font>的问题。<br>数据链路层：解决<font color="#dd0000">分组在一个网络（或一段链路）</font>上的传输问题。<br>网络层：解决<font color="#dd0000">分组在多个网络</font>间传输（路由）的问题。<br>运输层：解决<font color="#dd0000">进程之间基于网络的通信</font>问题。<br>应用层：解决<font color="#dd0000">应用进程间的交互来实现特定网络应用</font>的问题。</p><h3 id="（八）常见的计算机网络体系结构"><a href="#（八）常见的计算机网络体系结构" class="headerlink" title="（八）常见的计算机网络体系结构"></a>（八）常见的计算机网络体系结构</h3><h4 id="1、osi七层体系结构"><a href="#1、osi七层体系结构" class="headerlink" title="1、osi七层体系结构"></a>1、osi七层体系结构</h4><pre><code>    法律上的国际标准：物理层、数据链路层、网络层、传输层、对话层、表示层、应用层。</code></pre><h4 id="2、TCP-x2F-IP的四层体系结构"><a href="#2、TCP-x2F-IP的四层体系结构" class="headerlink" title="2、TCP&#x2F;IP的四层体系结构"></a>2、TCP&#x2F;IP的四层体系结构</h4><pre><code>    实际上的国际标准：网络接口层、网际层、传输层、应用层。</code></pre><h4 id="3、五层协议的原理体系结构"><a href="#3、五层协议的原理体系结构" class="headerlink" title="3、五层协议的原理体系结构"></a>3、五层协议的原理体系结构</h4><pre><code>    便于教学：物理层、数据链路层、网络层、传输层、应用层。</code></pre><h3 id="（九）分层思想举例"><a href="#（九）分层思想举例" class="headerlink" title="（九）分层思想举例"></a>（九）分层思想举例</h3><pre><code>    通过浏览器进程与Web服务器进程的交互实例，演示分组逐层封装和解封的过程视频（P9）。</code></pre><h3 id="（十）专用术语"><a href="#（十）专用术语" class="headerlink" title="（十）专用术语"></a>（十）专用术语</h3><h4 id="1、实体"><a href="#1、实体" class="headerlink" title="1、实体"></a>1、实体</h4><pre><code>    实体是指任何可&lt;font color=&quot;#dd0000&quot;&gt;发送或接受信息的硬件或软件&lt;/font&gt;进程。    &lt;font color=&quot;#dd0000&quot;&gt;对等实体&lt;/font&gt;是指通信双方相同层次中的实体。</code></pre><h4 id="2、协议"><a href="#2、协议" class="headerlink" title="2、协议"></a>2、协议</h4><p>（1）概念<br>        <font color="#dd0000">协议</font>是指控制两个对等实体进行逻辑通信的规则的集合。<br>（2）<font color="#dd0000">协议的三要</font>素是语法、语义、同步。<br>        <font color="#dd0000">语法</font>定义所交换信息的格式。例如：ip数据报的格式<br>        <font color="#dd0000">语义</font>定义通信双方所要完成的操作。例如：主机发送HTTP的GET请求给Web服务器，Web服务器收到后执行相应的操作，然后给主机发回HTTP响应。<br>        <font color="#dd0000">同步</font>定义通信双方的时序关系。例如：TCP的“三报文握手”建立连接的过程。<br>（3）<font color="#dd0000">协议数据单元</font><br>        对等层次之间传输的数据包成为该层的协议数据单元PDU。<br>        应用层：报文（message）<br>        运输层：TCP报文段（segment）或UDP用户数据报（datagram）<br>        网络层：分组（packet）或IP数据报<br>        数据链路层：帧（frame）<br>        物理层：比特流（bit stram）</p><h4 id="3、服务"><a href="#3、服务" class="headerlink" title="3、服务"></a>3、服务</h4><p>（1）概念<br>        在协议的控制下，两个对等实体之间的逻辑通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下一层所提供的服务。<font color="#dd0000">协议是水平的，服务是垂直</font>的。实体看得见相邻下层提供的服务，但并不知道实现该服务的具体协议。也就是说下面的协议对上面的实体是<font color="#dd0000">“透明”</font>的。<br>（2）<font color="#dd0000">服务访问点</font>是指在同一系统中，<font color="#dd0000">相邻两个实体交换信息的逻辑接口</font>，用于区分不同的服务类型。<br>        数据链路层的服务访问点为帧的“类型”字段。<br>        网络层的服务访问点为IP数据报首部中的“协议字段”。<br>        运输层的服务访问点为“窗口号”。<br>(3)<font color="#dd0000">服务原语</font>是指上层使用下层所提供的服务必须通过与下层交换的一些命令。<br>(4)<font color="#dd0000">服务数据单元</font>SDU是指统一系统内，层与层之间交换的数据包。多个SDU可以合成为一个PDU；一个SUP也可以划分为多个PDU。</p><h2 id="二、参考文献"><a href="#二、参考文献" class="headerlink" title="二、参考文献"></a>二、参考文献</h2><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?share_source=copy_web">b站湖科大教书匠计算机网络视频</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pycharm设置</title>
      <link href="/2021/05/21/pycharm-she-zhi/"/>
      <url>/2021/05/21/pycharm-she-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、字体随鼠标调整"><a href="#一、字体随鼠标调整" class="headerlink" title="一、字体随鼠标调整"></a>一、字体随鼠标调整</h2><ul><li><p>设置，搜索mouse</p></li><li><p>General里勾选Change front size with Ctrl+Mouse Wheel in：</p><img src="/2021/05/21/pycharm-she-zhi/image-20220521150603124.png" class="" title="image-20220521150603124"></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pycharm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
